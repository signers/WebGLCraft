require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{"jquery":[function(require,module,exports){
module.exports=require('ogZtPt');
},{}],"ogZtPt":[function(require,module,exports){
(function(global){(function browserifyShim(module, define, browserify_shim__define__module__export__) {
/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!memory;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( window.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.style.width = "2px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = marginDiv = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
		vb = "visibility:hidden;border:0;";
		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
		html = "<div " + style + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Figure out if the W3C box model works as expected
		div.innerHTML = "";
		div.style.width = div.style.paddingLeft = "1px";
		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
		}

		div.style.cssText = ptlm + vb;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		body.removeChild( container );
		div  = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, attr, name,
			data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var self = jQuery( this ),
					args = [ parts[0], value ];

				self.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;

					// See #9699 for explanation of this approach (setting first, then removal)
					jQuery.attr( elem, name, "" );
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( rboolean.test( name ) && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Determine handlers that should run if there are delegated events
		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
				selMatch = {};
				matches = [];
				jqcur[0] = cur;
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];
					sel = handleObj.selector;

					if ( selMatch[ sel ] === undefined ) {
						selMatch[ sel ] = (
							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
						);
					}
					if ( selMatch[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, matches: matches });
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						// If form was submitted by the user, bubble the event up the tree
						if ( this.parentNode && !event.isTrigger ) {
							jQuery.event.simulate( "submit", this.parentNode, event, true );
						}
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on.call( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					doneName = match[0];
					parent = elem.parentNode;
	
					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent[ expando ] = doneName;
					}
					
					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( 
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ? 
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret === null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight,
		i = 0,
		len = which.length;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i++ ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i++ ) {
			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
			}
		}
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			for ( p in prop ) {

				// property name normalization
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Adds width/height step functions
// Do not set anything below 0
jQuery.each([ "width", "height" ], function( i, prop ) {
	jQuery.fx.step[ prop ] = function( fx ) {
		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
	};
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if ( !elem ) {
				return null;
			}

			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

		// Set the scroll offset
		return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i ? val : jQuery( win ).scrollLeft(),
					 i ? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ],
				body = elem.document.body;
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNumeric( ret ) ? ret : orig;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

; browserify_shim__define__module__export__(typeof $ != "undefined" ? $ : window.$);

}).call(global, undefined, undefined, function defineExport(ex) { module.exports = ex; });

})(window)
},{}],"jquery-hotkeys":[function(require,module,exports){
module.exports=require('PDAayf');
},{}],"PDAayf":[function(require,module,exports){
(function(global){(function browserifyShim(module, define) {

; global.$ = require("jquery");
/*
 * jQuery Hotkeys Plugin
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Based upon the plugin by Tzury Bar Yochay:
 * https://github.com/tzuryby/jquery.hotkeys
 *
 * Original idea by:
 * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/
*/

(function(jQuery){

	jQuery.hotkeys = {
		version: "0.8",

		specialKeys: {
			8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause",
			20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home",
			37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del",
			96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7",
			104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111 : "/",
			112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8",
			120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 191: "/", 224: "meta"
		},

		shiftNums: {
			"`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&",
			"8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<",
			".": ">",  "/": "?",  "\\": "|"
		}
	};

	function keyHandler( handleObj ) {

                var stopEvent = function(evt) {
                    evt.cancelBubble=true;
                    evt.returnValue=false;
                    evt.keyCode=0;
                    return false;
                }

		// Only care when a possible input has been specified
		if ( typeof handleObj.data !== "string" ) {
			return;
		}

		var origHandler = handleObj.handler,
			keys = handleObj.data.toLowerCase().split(" ");

		handleObj.handler = function( event ) {
			// Don't fire in text-accepting inputs that we didn't directly bind to
			if ( this !== event.target && (/textarea|select/i.test( event.target.nodeName ) ||
				 event.target.type === "text") ) {
				return;
			}

			// Keypress represents characters, not special keys
			var special = event.type !== "keypress" && jQuery.hotkeys.specialKeys[ event.which ],
				character = String.fromCharCode( event.which ).toLowerCase(),
				key, modif = "", possible = {};

			// check combinations (alt|ctrl|shift+anything)
			if ( event.altKey && special !== "alt" ) {
				modif += "alt+";
			}

			if ( event.ctrlKey && special !== "ctrl" ) {
				modif += "ctrl+";
			}

			// TODO: Need to make sure this works consistently across platforms
			if ( event.metaKey && !event.ctrlKey && special !== "meta" ) {
				modif += "meta+";
			}

			if ( event.shiftKey && special !== "shift" ) {
				modif += "shift+";
			}

			if ( special ) {
				possible[ modif + special ] = true;

			} else {
				possible[ modif + character ] = true;
				possible[ modif + jQuery.hotkeys.shiftNums[ character ] ] = true;

				// "$" can be triggered as "Shift+4" or "Shift+$" or just "$"
				if ( modif === "shift+" ) {
					possible[ jQuery.hotkeys.shiftNums[ character ] ] = true;
				}
			}

			for ( var i = 0, l = keys.length; i < l; i++ ) {
				if ( possible[ keys[i] ] ) {
					var ret = origHandler.apply( this, arguments );
                                        stopEvent(event);
                                        return ret;
				}
			}
                        stopEvent(event);

		};
	}

	jQuery.each([ "keydown", "keyup", "keypress" ], function() {
		jQuery.event.special[ this ] = {add: keyHandler};
	});

})( jQuery );

}).call(global, module, undefined);

})(window)
},{"jquery":"jquery"}],"jquery-mousewheel":[function(require,module,exports){
module.exports=require('+244S/');
},{}],"+244S/":[function(require,module,exports){
(function(global){(function browserifyShim(module, define) {

; global.$ = require("jquery");
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 *
 * Requires: 1.2.2+
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

if ($.event.fixHooks) {
    for ( var i=types.length; i; ) {
        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;
    }
}

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },

    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },

    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";

    // Old school scrollwheel delta
    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }

    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;

    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }

    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }

    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);

    return ($.event.dispatch || $.event.handle).apply(this, args);
}

})(jQuery);

}).call(global, module, undefined);

})(window)
},{"jquery":"jquery"}],"detector":[function(require,module,exports){
module.exports=require('Bbc2K4');
},{}],"Bbc2K4":[function(require,module,exports){
(function(global){(function browserifyShim(module, define, browserify_shim__define__module__export__) {
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

Detector = {

	canvas : !! window.CanvasRenderingContext2D,
	webgl : ( function () { try { return !! window.WebGLRenderingContext && !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); } catch( e ) { return false; } } )(),
	workers : !! window.Worker,
	fileapi : window.File && window.FileReader && window.FileList && window.Blob,

	getWebGLErrorMessage : function () {

		var domElement = document.createElement( 'div' );

		domElement.style.fontFamily = 'monospace';
		domElement.style.fontSize = '13px';
		domElement.style.textAlign = 'center';
		domElement.style.background = '#eee';
		domElement.style.color = '#000';
		domElement.style.padding = '1em';
		domElement.style.width = '475px';
		domElement.style.margin = '5em auto 0';

		if ( ! this.webgl ) {

			domElement.innerHTML = window.WebGLRenderingContext ? [
				'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br />',
				'Find out how to get it <a href="http://get.webgl.org/">here</a>.'
			].join( '\n' ) : [
				'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br/>',
				'Find out how to get it <a href="http://get.webgl.org/">here</a>.'
			].join( '\n' );

		}

		return domElement;

	},

	addGetWebGLMessage : function ( parameters ) {

		var parent, id, domElement;

		parameters = parameters || {};

		parent = parameters.parent !== undefined ? parameters.parent : document.body;
		id = parameters.id !== undefined ? parameters.id : 'oldie';

		domElement = Detector.getWebGLErrorMessage();
		domElement.id = id;

		parent.appendChild( domElement );

	}

};

; browserify_shim__define__module__export__(typeof Detector != "undefined" ? Detector : window.Detector);

}).call(global, undefined, undefined, function defineExport(ex) { module.exports = ex; });

})(window)
},{}],"improved-noise":[function(require,module,exports){
module.exports=require('uBOzs+');
},{}],"uBOzs+":[function(require,module,exports){
(function(global){(function browserifyShim(module, define, browserify_shim__define__module__export__) {
// http://mrl.nyu.edu/~perlin/noise/

var ImprovedNoise = function () {

	var p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,
		 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,
		 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,
		 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,
		 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,
		 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,
		 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,
		 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,
		 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,
		 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

	for (var i=0; i < 256 ; i++) {

		p[256+i] = p[i];

	}

	function fade(t) {

		return t * t * t * (t * (t * 6 - 15) + 10);

	}

	function lerp(t, a, b) {

		return a + t * (b - a);

	}

	function grad(hash, x, y, z) {

		var h = hash & 15;
		var u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;
		return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);

	}

	return {

		noise: function (x, y, z) {

			var floorX = ~~x, floorY = ~~y, floorZ = ~~z;

			var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;

			x -= floorX;
			y -= floorY;
			z -= floorZ;

			var xMinus1 = x -1, yMinus1 = y - 1, zMinus1 = z - 1;

			var u = fade(x), v = fade(y), w = fade(z);

			var A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z, B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;

			return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), 
							grad(p[BA], xMinus1, y, z)),
						lerp(u, grad(p[AB], x, yMinus1, z),
							grad(p[BB], xMinus1, yMinus1, z))),
					lerp(v, lerp(u, grad(p[AA+1], x, y, zMinus1),
							grad(p[BA+1], xMinus1, y, z-1)),
						lerp(u, grad(p[AB+1], x, yMinus1, zMinus1),
							grad(p[BB+1], xMinus1, yMinus1, zMinus1))));

		}
	}
}

; browserify_shim__define__module__export__(typeof ImprovedNoise != "undefined" ? ImprovedNoise : window.ImprovedNoise);

}).call(global, undefined, undefined, function defineExport(ex) { module.exports = ex; });

})(window)
},{}],"three":[function(require,module,exports){
module.exports=require('EtP0tC');
},{}],"EtP0tC":[function(require,module,exports){
(function(global){(function browserifyShim(module, define, browserify_shim__define__module__export__) {
// Three.js r46 - http://github.com/mrdoob/three.js
/**
 * @author mr.doob / http://mrdoob.com/
 */

var THREE = THREE || {};

if ( ! self.Int32Array ) {

	self.Int32Array = Array;
	self.Float32Array = Array;

}
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype.start = function () {

	this.startTime = Date.now();
	this.oldTime = this.startTime;

	this.running = true;

};

THREE.Clock.prototype.stop = function () {

	this.getElapsedTime();

	this.running = false;

};

THREE.Clock.prototype.getElapsedTime = function () {

	this.elapsedTime += this.getDelta();

	return this.elapsedTime;

};


THREE.Clock.prototype.getDelta = function () {

	var diff = 0;

	if ( this.autoStart && ! this.running ) {

		this.start();

	}

	if ( this.running ) {

		var newTime = Date.now();
		diff = 0.001 * ( newTime - this.oldTime );
		this.oldTime = newTime;

		this.elapsedTime += diff;

	}

	return diff;

};/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Color = function ( hex ) {

	if ( hex !== undefined ) this.setHex( hex );
	return this;

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSV: function ( h, s, v ) {

		// based on MochiKit implementation by Bob Ippolito
		// h,s,v ranges are < 0.0 - 1.0 >

		var i, f, p, q, t;

		if ( v === 0 ) {

			this.r = this.g = this.b = 0;

		} else {

			i = Math.floor( h * 6 );
			f = ( h * 6 ) - i;
			p = v * ( 1 - s );
			q = v * ( 1 - ( s * f ) );
			t = v * ( 1 - ( s * ( 1 - f ) ) );

			switch ( i ) {

				case 1: this.r = q; this.g = v; this.b = p; break;
				case 2: this.r = p; this.g = v; this.b = t; break;
				case 3: this.r = p; this.g = q; this.b = v; break;
				case 4: this.r = t; this.g = p; this.b = v; break;
				case 5: this.r = v; this.g = p; this.b = q; break;
				case 6: // fall through
				case 0: this.r = v; this.g = t; this.b = p; break;

			}

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	getHex: function () {

		return ~~ ( this.r * 255 ) << 16 ^ ~~ ( this.g * 255 ) << 8 ^ ~~ ( this.b * 255 );

	},

	getContextStyle: function () {

		return 'rgb(' + Math.floor( this.r * 255 ) + ',' + Math.floor( this.g * 255 ) + ',' + Math.floor( this.b * 255 ) + ')';

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	},


	add: function ( v1, v2 ) {

		this.x = v1.x + v2.x;
		this.y = v1.y + v2.y;

		return this;

	},

	addSelf: function ( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	sub: function ( v1, v2 ) {

		this.x = v1.x - v2.x;
		this.y = v1.y - v2.y;

		return this;

	},

	subSelf: function ( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divideScalar: function ( s ) {

		if ( s ) {

			this.x /= s;
			this.y /= s;

		} else {

			this.set( 0, 0 );

		}

		return this;

	},


	negate: function() {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.lengthSq() );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},


	setLength: function ( l ) {

		return this.normalize().multiplyScalar( l );

	},

	equals: function( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};


THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	},


	add: function ( v1, v2 ) {

		this.x = v1.x + v2.x;
		this.y = v1.y + v2.y;
		this.z = v1.z + v2.z;

		return this;

	},

	addSelf: function ( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	sub: function ( v1, v2 ) {

		this.x = v1.x - v2.x;
		this.y = v1.y - v2.y;
		this.z = v1.z - v2.z;

		return this;

	},

	subSelf: function ( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	multiply: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	multiplySelf: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;
		this.z *= s;

		return this;

	},

	divideSelf: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( s ) {

		if ( s ) {

			this.x /= s;
			this.y /= s;
			this.z /= s;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},


	negate: function() {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.lengthSq() );

	},

	lengthManhattan: function () {

		// correct version
		// return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		return this.x + this.y + this.z;

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		return this.normalize().multiplyScalar( l );

	},


	cross: function ( a, b ) {

		this.x = a.y * b.z - a.z * b.y;
		this.y = a.z * b.x - a.x * b.z;
		this.z = a.x * b.y - a.y * b.x;

		return this;

	},

	crossSelf: function ( v ) {

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},


	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		return new THREE.Vector3().sub( this, v ).lengthSq();

	},


	setPositionFromMatrix: function ( m ) {

		this.x = m.n14;
		this.y = m.n24;
		this.z = m.n34;

	},

	setRotationFromMatrix: function ( m ) {

		var cosY = Math.cos( this.y );

		this.y = Math.asin( m.n13 );

		if ( Math.abs( cosY ) > 0.00001 ) {

			this.x = Math.atan2( - m.n23 / cosY, m.n33 / cosY );
			this.z = Math.atan2( - m.n12 / cosY, m.n11 / cosY );

		} else {

			this.x = 0;
			this.z = Math.atan2( m.n21, m.n22 );

		}

	},

	isZero: function () {

		return ( this.lengthSq() < 0.0001 /* almostZero */ );

	}

};
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	},


	add: function ( v1, v2 ) {

		this.x = v1.x + v2.x;
		this.y = v1.y + v2.y;
		this.z = v1.z + v2.z;
		this.w = v1.w + v2.w;

		return this;

	},

	addSelf: function ( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	sub: function ( v1, v2 ) {

		this.x = v1.x - v2.x;
		this.y = v1.y - v2.y;
		this.z = v1.z - v2.z;
		this.w = v1.w - v2.w;

		return this;

	},

	subSelf: function ( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;
		this.z *= s;
		this.w *= s;

		return this;

	},

	divideScalar: function ( s ) {

		if ( s ) {

			this.x /= s;
			this.y /= s;
			this.z /= s;
			this.w /= s;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},


	negate: function() {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.dot( this );

	},

	length: function () {

		return Math.sqrt( this.lengthSq() );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		return this.normalize().multiplyScalar( l );

	},


	lerpSelf: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = origin || new THREE.Vector3();
	this.direction = direction || new THREE.Vector3();

	this.intersectScene = function ( scene ) {

		return this.intersectObjects( scene.children );

	};

	this.intersectObjects = function ( objects ) {

		var i, l, object,
		intersects = [];

		for ( i = 0, l = objects.length; i < l; i ++ ) {

			Array.prototype.push.apply( intersects, this.intersectObject( objects[ i ] ) );

		}

		intersects.sort( function ( a, b ) { return a.distance - b.distance; } );

		return intersects;

	};

	var a = new THREE.Vector3();
	var b = new THREE.Vector3();
	var c = new THREE.Vector3();
	var d = new THREE.Vector3();

	var origin = new THREE.Vector3();
	var direction = new THREE.Vector3();
	var vector = new THREE.Vector3();
	var normal = new THREE.Vector3();
	var intersectPoint = new THREE.Vector3()

	this.intersectObject = function ( object ) {

		var intersect, intersects = [];

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			Array.prototype.push.apply( intersects, this.intersectObject( object.children[ i ] ) );

		}

		if ( object instanceof THREE.Particle ) {

			var distance = distanceFromIntersection( this.origin, this.direction, object.matrixWorld.getPosition() );

			if ( distance === null || distance > object.scale.x ) {

				return [];

			}

			intersect = {

				distance: distance,
				point: object.position,
				face: null,
				object: object

			};

			intersects.push( intersect );

		} else if ( object instanceof THREE.Mesh ) {

			// Checking boundingSphere

			var distance = distanceFromIntersection( this.origin, this.direction, object.matrixWorld.getPosition() );

			if ( distance === null || distance > object.geometry.boundingSphere.radius * Math.max( object.scale.x, Math.max( object.scale.y, object.scale.z ) ) ) {

				return intersects;

			}

			// Checking faces

			var f, fl, face, dot, scalar,
			geometry = object.geometry,
			vertices = geometry.vertices,
			objMatrix;

			object.matrixRotationWorld.extractRotation( object.matrixWorld );

			for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				face = geometry.faces[ f ];

				origin.copy( this.origin );
				direction.copy( this.direction );

				objMatrix = object.matrixWorld;

				// check if face.centroid is behind the origin

				vector = objMatrix.multiplyVector3( vector.copy( face.centroid ) ).subSelf( origin );
				dot = vector.dot( direction );

				if ( dot <= 0 ) continue;

				//

				a = objMatrix.multiplyVector3( a.copy( vertices[ face.a ].position ) );
				b = objMatrix.multiplyVector3( b.copy( vertices[ face.b ].position ) );
				c = objMatrix.multiplyVector3( c.copy( vertices[ face.c ].position ) );
				d = face instanceof THREE.Face4 ? objMatrix.multiplyVector3( d.copy( vertices[ face.d ].position ) ) : null;

				normal = object.matrixRotationWorld.multiplyVector3( normal.copy( face.normal ) );
				dot = direction.dot( normal );

				if ( object.doubleSided || ( object.flipSided ? dot > 0 : dot < 0 ) ) { // Math.abs( dot ) > 0.0001

					scalar = normal.dot( vector.sub( a, origin ) ) / dot;
					intersectPoint.add( origin, direction.multiplyScalar( scalar ) );

					if ( face instanceof THREE.Face3 ) {

						if ( pointInFace3( intersectPoint, a, b, c ) ) {

							intersect = {

								distance: origin.distanceTo( intersectPoint ),
								point: intersectPoint.clone(),
								face: face,
								object: object

							};

							intersects.push( intersect );

						}

					} else if ( face instanceof THREE.Face4 ) {

						if ( pointInFace3( intersectPoint, a, b, d ) || pointInFace3( intersectPoint, b, c, d ) ) {

							intersect = {

								distance: origin.distanceTo( intersectPoint ),
								point: intersectPoint.clone(),
								face: face,
								object: object

							};

							intersects.push( intersect );

						}

					}

				}

			}

		}

		return intersects;

	}

	var v0 = new THREE.Vector3(), v1 = new THREE.Vector3(), v2 = new THREE.Vector3();
	var dot, intersect, distance;

	function distanceFromIntersection( origin, direction, position ) {

		v0.sub( position, origin );
		dot = v0.dot( direction );

		if ( dot <= 0 ) return null; // check if position behind origin.

		intersect = v1.add( origin, v2.copy( direction ).multiplyScalar( dot ) );
		distance = position.distanceTo( intersect );

		return distance;

	}

	// http://www.blackpawn.com/texts/pointinpoly/default.html

	var dot00, dot01, dot02, dot11, dot12, invDenom, u, v;

	function pointInFace3( p, a, b, c ) {

		v0.sub( c, a );
		v1.sub( b, a );
		v2.sub( p, a );

		dot00 = v0.dot( v0 );
		dot01 = v0.dot( v1 );
		dot02 = v0.dot( v2 );
		dot11 = v1.dot( v1 );
		dot12 = v1.dot( v2 );

		invDenom = 1 / ( dot00 * dot11 - dot01 * dot01 );
		u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		return ( u >= 0 ) && ( v >= 0 ) && ( u + v < 1 );

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Rectangle = function () {

	var _left, _top, _right, _bottom,
	_width, _height, _isEmpty = true;

	function resize() {

		_width = _right - _left;
		_height = _bottom - _top;

	}

	this.getX = function () {

		return _left;

	};

	this.getY = function () {

		return _top;

	};

	this.getWidth = function () {

		return _width;

	};

	this.getHeight = function () {

		return _height;

	};

	this.getLeft = function() {

		return _left;

	};

	this.getTop = function() {

		return _top;

	};

	this.getRight = function() {

		return _right;

	};

	this.getBottom = function() {

		return _bottom;

	};

	this.set = function ( left, top, right, bottom ) {

		_isEmpty = false;

		_left = left; _top = top;
		_right = right; _bottom = bottom;

		resize();

	};

	this.addPoint = function ( x, y ) {

		if ( _isEmpty ) {

			_isEmpty = false;
			_left = x; _top = y;
			_right = x; _bottom = y;

			resize();

		} else {

			_left = _left < x ? _left : x; // Math.min( _left, x );
			_top = _top < y ? _top : y; // Math.min( _top, y );
			_right = _right > x ? _right : x; // Math.max( _right, x );
			_bottom = _bottom > y ? _bottom : y; // Math.max( _bottom, y );

			resize();
		}

	};

	this.add3Points = function ( x1, y1, x2, y2, x3, y3 ) {

		if (_isEmpty) {

			_isEmpty = false;
			_left = x1 < x2 ? ( x1 < x3 ? x1 : x3 ) : ( x2 < x3 ? x2 : x3 );
			_top = y1 < y2 ? ( y1 < y3 ? y1 : y3 ) : ( y2 < y3 ? y2 : y3 );
			_right = x1 > x2 ? ( x1 > x3 ? x1 : x3 ) : ( x2 > x3 ? x2 : x3 );
			_bottom = y1 > y2 ? ( y1 > y3 ? y1 : y3 ) : ( y2 > y3 ? y2 : y3 );

			resize();

		} else {

			_left = x1 < x2 ? ( x1 < x3 ? ( x1 < _left ? x1 : _left ) : ( x3 < _left ? x3 : _left ) ) : ( x2 < x3 ? ( x2 < _left ? x2 : _left ) : ( x3 < _left ? x3 : _left ) );
			_top = y1 < y2 ? ( y1 < y3 ? ( y1 < _top ? y1 : _top ) : ( y3 < _top ? y3 : _top ) ) : ( y2 < y3 ? ( y2 < _top ? y2 : _top ) : ( y3 < _top ? y3 : _top ) );
			_right = x1 > x2 ? ( x1 > x3 ? ( x1 > _right ? x1 : _right ) : ( x3 > _right ? x3 : _right ) ) : ( x2 > x3 ? ( x2 > _right ? x2 : _right ) : ( x3 > _right ? x3 : _right ) );
			_bottom = y1 > y2 ? ( y1 > y3 ? ( y1 > _bottom ? y1 : _bottom ) : ( y3 > _bottom ? y3 : _bottom ) ) : ( y2 > y3 ? ( y2 > _bottom ? y2 : _bottom ) : ( y3 > _bottom ? y3 : _bottom ) );

			resize();

		};

	};

	this.addRectangle = function ( r ) {

		if ( _isEmpty ) {

			_isEmpty = false;
			_left = r.getLeft(); _top = r.getTop();
			_right = r.getRight(); _bottom = r.getBottom();

			resize();

		} else {

			_left = _left < r.getLeft() ? _left : r.getLeft(); // Math.min(_left, r.getLeft() );
			_top = _top < r.getTop() ? _top : r.getTop(); // Math.min(_top, r.getTop() );
			_right = _right > r.getRight() ? _right : r.getRight(); // Math.max(_right, r.getRight() );
			_bottom = _bottom > r.getBottom() ? _bottom : r.getBottom(); // Math.max(_bottom, r.getBottom() );

			resize();

		}

	};

	this.inflate = function ( v ) {

		_left -= v; _top -= v;
		_right += v; _bottom += v;

		resize();

	};

	this.minSelf = function ( r ) {

		_left = _left > r.getLeft() ? _left : r.getLeft(); // Math.max( _left, r.getLeft() );
		_top = _top > r.getTop() ? _top : r.getTop(); // Math.max( _top, r.getTop() );
		_right = _right < r.getRight() ? _right : r.getRight(); // Math.min( _right, r.getRight() );
		_bottom = _bottom < r.getBottom() ? _bottom : r.getBottom(); // Math.min( _bottom, r.getBottom() );

		resize();

	};

	this.intersects = function ( r ) {

		return Math.min( _right, r.getRight() ) - Math.max( _left, r.getLeft() ) >= 0 &&
		        Math.min( _bottom, r.getBottom() ) - Math.max( _top, r.getTop() ) >= 0;

	};

	this.empty = function () {

		_isEmpty = true;

		_left = 0; _top = 0;
		_right = 0; _bottom = 0;

		resize();

	};

	this.isEmpty = function () {

		return _isEmpty;

	};

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Math = {

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	mapLinear: function( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// Get 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function() {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	}

};
THREE.Matrix3 = function () {

	this.m = [];

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	transpose: function () {

		var tmp, m = this.m;

		tmp = m[1]; m[1] = m[3]; m[3] = tmp;
		tmp = m[2]; m[2] = m[6]; m[6] = tmp;
		tmp = m[5]; m[5] = m[7]; m[7] = tmp;

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.m;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 */

THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

	this.set(

		( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0, n14 || 0,
		n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0, n24 || 0,
		n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1, n34 || 0,
		n41 || 0, n42 || 0, n43 || 0, ( n44 !== undefined ) ? n44 : 1

	);

	this.flat = new Array( 16 );
	this.m33 = new THREE.Matrix3();

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		this.n11 = n11; this.n12 = n12; this.n13 = n13; this.n14 = n14;
		this.n21 = n21; this.n22 = n22; this.n23 = n23; this.n24 = n24;
		this.n31 = n31; this.n32 = n32; this.n33 = n33; this.n34 = n34;
		this.n41 = n41; this.n42 = n42; this.n43 = n43; this.n44 = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.set(

			m.n11, m.n12, m.n13, m.n14,
			m.n21, m.n22, m.n23, m.n24,
			m.n31, m.n32, m.n33, m.n34,
			m.n41, m.n42, m.n43, m.n44

		);

		return this;

	},

	lookAt: function ( eye, center, up ) {

		var x = THREE.Matrix4.__v1, y = THREE.Matrix4.__v2, z = THREE.Matrix4.__v3;

		z.sub( eye, center ).normalize();

		if ( z.length() === 0 ) {

			z.z = 1;

		}

		x.cross( up, z ).normalize();

		if ( x.length() === 0 ) {

			z.x += 0.0001;
			x.cross( up, z ).normalize();

		}

		y.cross( z, x ).normalize();


		this.n11 = x.x; this.n12 = y.x; this.n13 = z.x;
		this.n21 = x.y; this.n22 = y.y; this.n23 = z.y;
		this.n31 = x.z; this.n32 = y.z; this.n33 = z.z;

		return this;

	},

	multiply: function ( a, b ) {

		var a11 = a.n11, a12 = a.n12, a13 = a.n13, a14 = a.n14,
		a21 = a.n21, a22 = a.n22, a23 = a.n23, a24 = a.n24,
		a31 = a.n31, a32 = a.n32, a33 = a.n33, a34 = a.n34,
		a41 = a.n41, a42 = a.n42, a43 = a.n43, a44 = a.n44,

		b11 = b.n11, b12 = b.n12, b13 = b.n13, b14 = b.n14,
		b21 = b.n21, b22 = b.n22, b23 = b.n23, b24 = b.n24,
		b31 = b.n31, b32 = b.n32, b33 = b.n33, b34 = b.n34,
		b41 = b.n41, b42 = b.n42, b43 = b.n43, b44 = b.n44;

		this.n11 = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		this.n12 = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		this.n13 = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		this.n14 = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		this.n21 = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		this.n22 = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		this.n23 = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		this.n24 = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		this.n31 = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		this.n32 = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		this.n33 = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		this.n34 = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		this.n41 = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		this.n42 = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		this.n43 = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		this.n44 = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplySelf: function ( m ) {

		return this.multiply( this, m );

	},

	multiplyToArray: function ( a, b, r ) {

		this.multiply( a, b );

		r[ 0 ] = this.n11; r[ 1 ] = this.n21; r[ 2 ] = this.n31; r[ 3 ] = this.n41;
		r[ 4 ] = this.n12; r[ 5 ] = this.n22; r[ 6 ] = this.n32; r[ 7 ] = this.n42;
		r[ 8 ]  = this.n13; r[ 9 ]  = this.n23; r[ 10 ] = this.n33; r[ 11 ] = this.n43;
		r[ 12 ] = this.n14; r[ 13 ] = this.n24; r[ 14 ] = this.n34; r[ 15 ] = this.n44;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.n11 *= s; this.n12 *= s; this.n13 *= s; this.n14 *= s;
		this.n21 *= s; this.n22 *= s; this.n23 *= s; this.n24 *= s;
		this.n31 *= s; this.n32 *= s; this.n33 *= s; this.n34 *= s;
		this.n41 *= s; this.n42 *= s; this.n43 *= s; this.n44 *= s;

		return this;

	},

	multiplyVector3: function ( v ) {

		var vx = v.x, vy = v.y, vz = v.z,
		d = 1 / ( this.n41 * vx + this.n42 * vy + this.n43 * vz + this.n44 );

		v.x = ( this.n11 * vx + this.n12 * vy + this.n13 * vz + this.n14 ) * d;
		v.y = ( this.n21 * vx + this.n22 * vy + this.n23 * vz + this.n24 ) * d;
		v.z = ( this.n31 * vx + this.n32 * vy + this.n33 * vz + this.n34 ) * d;

		return v;

	},

	multiplyVector4: function ( v ) {

		var vx = v.x, vy = v.y, vz = v.z, vw = v.w;

		v.x = this.n11 * vx + this.n12 * vy + this.n13 * vz + this.n14 * vw;
		v.y = this.n21 * vx + this.n22 * vy + this.n23 * vz + this.n24 * vw;
		v.z = this.n31 * vx + this.n32 * vy + this.n33 * vz + this.n34 * vw;
		v.w = this.n41 * vx + this.n42 * vy + this.n43 * vz + this.n44 * vw;

		return v;

	},

	rotateAxis: function ( v ) {

		var vx = v.x, vy = v.y, vz = v.z;

		v.x = vx * this.n11 + vy * this.n12 + vz * this.n13;
		v.y = vx * this.n21 + vy * this.n22 + vz * this.n23;
		v.z = vx * this.n31 + vy * this.n32 + vz * this.n33;

		v.normalize();

		return v;

	},

	crossVector: function ( a ) {

		var v = new THREE.Vector4();

		v.x = this.n11 * a.x + this.n12 * a.y + this.n13 * a.z + this.n14 * a.w;
		v.y = this.n21 * a.x + this.n22 * a.y + this.n23 * a.z + this.n24 * a.w;
		v.z = this.n31 * a.x + this.n32 * a.y + this.n33 * a.z + this.n34 * a.w;

		v.w = ( a.w ) ? this.n41 * a.x + this.n42 * a.y + this.n43 * a.z + this.n44 * a.w : 1;

		return v;

	},

	determinant: function () {

		var n11 = this.n11, n12 = this.n12, n13 = this.n13, n14 = this.n14,
		n21 = this.n21, n22 = this.n22, n23 = this.n23, n24 = this.n24,
		n31 = this.n31, n32 = this.n32, n33 = this.n33, n34 = this.n34,
		n41 = this.n41, n42 = this.n42, n43 = this.n43, n44 = this.n44;

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
		return (
			n14 * n23 * n32 * n41-
			n13 * n24 * n32 * n41-
			n14 * n22 * n33 * n41+
			n12 * n24 * n33 * n41+

			n13 * n22 * n34 * n41-
			n12 * n23 * n34 * n41-
			n14 * n23 * n31 * n42+
			n13 * n24 * n31 * n42+

			n14 * n21 * n33 * n42-
			n11 * n24 * n33 * n42-
			n13 * n21 * n34 * n42+
			n11 * n23 * n34 * n42+

			n14 * n22 * n31 * n43-
			n12 * n24 * n31 * n43-
			n14 * n21 * n32 * n43+
			n11 * n24 * n32 * n43+

			n12 * n21 * n34 * n43-
			n11 * n22 * n34 * n43-
			n13 * n22 * n31 * n44+
			n12 * n23 * n31 * n44+

			n13 * n21 * n32 * n44-
			n11 * n23 * n32 * n44-
			n12 * n21 * n33 * n44+
			n11 * n22 * n33 * n44
		);

	},

	transpose: function () {

		var tmp;

		tmp = this.n21; this.n21 = this.n12; this.n12 = tmp;
		tmp = this.n31; this.n31 = this.n13; this.n13 = tmp;
		tmp = this.n32; this.n32 = this.n23; this.n23 = tmp;

		tmp = this.n41; this.n41 = this.n14; this.n14 = tmp;
		tmp = this.n42; this.n42 = this.n24; this.n24 = tmp;
		tmp = this.n43; this.n43 = this.n34; this.n43 = tmp;

		return this;

	},

	clone: function () {

		var m = new THREE.Matrix4();

		m.n11 = this.n11; m.n12 = this.n12; m.n13 = this.n13; m.n14 = this.n14;
		m.n21 = this.n21; m.n22 = this.n22; m.n23 = this.n23; m.n24 = this.n24;
		m.n31 = this.n31; m.n32 = this.n32; m.n33 = this.n33; m.n34 = this.n34;
		m.n41 = this.n41; m.n42 = this.n42; m.n43 = this.n43; m.n44 = this.n44;

		return m;

	},

	flatten: function () {

		this.flat[ 0 ] = this.n11; this.flat[ 1 ] = this.n21; this.flat[ 2 ] = this.n31; this.flat[ 3 ] = this.n41;
		this.flat[ 4 ] = this.n12; this.flat[ 5 ] = this.n22; this.flat[ 6 ] = this.n32; this.flat[ 7 ] = this.n42;
		this.flat[ 8 ]  = this.n13; this.flat[ 9 ]  = this.n23; this.flat[ 10 ] = this.n33; this.flat[ 11 ] = this.n43;
		this.flat[ 12 ] = this.n14; this.flat[ 13 ] = this.n24; this.flat[ 14 ] = this.n34; this.flat[ 15 ] = this.n44;

		return this.flat;

	},

	flattenToArray: function ( flat ) {

		flat[ 0 ] = this.n11; flat[ 1 ] = this.n21; flat[ 2 ] = this.n31; flat[ 3 ] = this.n41;
		flat[ 4 ] = this.n12; flat[ 5 ] = this.n22; flat[ 6 ] = this.n32; flat[ 7 ] = this.n42;
		flat[ 8 ]  = this.n13; flat[ 9 ]  = this.n23; flat[ 10 ] = this.n33; flat[ 11 ] = this.n43;
		flat[ 12 ] = this.n14; flat[ 13 ] = this.n24; flat[ 14 ] = this.n34; flat[ 15 ] = this.n44;

		return flat;

	},

	flattenToArrayOffset: function( flat, offset ) {

		flat[ offset ] = this.n11;
		flat[ offset + 1 ] = this.n21;
		flat[ offset + 2 ] = this.n31;
		flat[ offset + 3 ] = this.n41;

		flat[ offset + 4 ] = this.n12;
		flat[ offset + 5 ] = this.n22;
		flat[ offset + 6 ] = this.n32;
		flat[ offset + 7 ] = this.n42;

		flat[ offset + 8 ]  = this.n13;
		flat[ offset + 9 ]  = this.n23;
		flat[ offset + 10 ] = this.n33;
		flat[ offset + 11 ] = this.n43;

		flat[ offset + 12 ] = this.n14;
		flat[ offset + 13 ] = this.n24;
		flat[ offset + 14 ] = this.n34;
		flat[ offset + 15 ] = this.n44;

		return flat;

	},

	setTranslation: function( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	setScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	setRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, -s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	setRotationY: function( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			-s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	setRotationZ: function( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, -s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	setRotationAxis: function( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle ),
		s = Math.sin( angle ),
		t = 1 - c,
		x = axis.x, y = axis.y, z = axis.z,
		tx = t * x, ty = t * y;

		this.set(

		 	tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	setPosition: function ( v ) {

		this.n14 = v.x;
		this.n24 = v.y;
		this.n34 = v.z;

		return this;

	},

	getPosition: function () {

		return THREE.Matrix4.__v1.set( this.n14, this.n24, this.n34 );

	},

	getColumnX: function () {

		return THREE.Matrix4.__v1.set( this.n11, this.n21, this.n31 );

	},

	getColumnY: function () {

		return THREE.Matrix4.__v1.set( this.n12, this.n22, this.n32 );

	},

	getColumnZ: function() {

		return THREE.Matrix4.__v1.set( this.n13, this.n23, this.n33 );

	},

	getInverse: function ( m ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm

		var n11 = m.n11, n12 = m.n12, n13 = m.n13, n14 = m.n14,
		n21 = m.n21, n22 = m.n22, n23 = m.n23, n24 = m.n24,
		n31 = m.n31, n32 = m.n32, n33 = m.n33, n34 = m.n34,
		n41 = m.n41, n42 = m.n42, n43 = m.n43, n44 = m.n44;

		this.n11 = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
		this.n12 = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
		this.n13 = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
		this.n14 = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
		this.n21 = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
		this.n22 = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
		this.n23 = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
		this.n24 = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
		this.n31 = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
		this.n32 = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
		this.n33 = n13*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
		this.n34 = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
		this.n41 = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
		this.n42 = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
		this.n43 = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
		this.n44 = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;
		this.multiplyScalar( 1 / m.determinant() );

		return this;

	},

	setRotationFromEuler: function( v, order ) {

		var x = v.x, y = v.y, z = v.z,
		a = Math.cos( x ), b = Math.sin( x ),
		c = Math.cos( y ), d = Math.sin( y ),
		e = Math.cos( z ), f = Math.sin( z );

		switch ( order ) {

			case 'YXZ':

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				this.n11 = ce + df * b;
				this.n12 = de * b - cf;
				this.n13 = a * d;

				this.n21 = a * f;
				this.n22 = a * e;
				this.n23 = - b;

				this.n31 = cf * b - de;
				this.n32 = df + ce * b;
				this.n33 = a * c;
				break;

			case 'ZXY':

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				this.n11 = ce - df * b;
				this.n12 = - a * f;
				this.n13 = de + cf * b;

				this.n21 = cf + de * b;
				this.n22 = a * e;
				this.n23 = df - ce * b;

				this.n31 = - a * d;
				this.n32 = b;
				this.n33 = a * c;
				break;

			case 'ZYX':

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				this.n11 = c * e;
				this.n12 = be * d - af;
				this.n13 = ae * d + bf;

				this.n21 = c * f;
				this.n22 = bf * d + ae;
				this.n23 = af * d - be;

				this.n31 = - d;
				this.n32 = b * c;
				this.n33 = a * c;
				break;

			case 'YZX':

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				this.n11 = c * e;
				this.n12 = bd - ac * f;
				this.n13 = bc * f + ad;

				this.n21 = f;
				this.n22 = a * e;
				this.n23 = - b * e;

				this.n31 = - d * e;
				this.n32 = ad * f + bc;
				this.n33 = ac - bd * f;
				break;

			case 'XZY':

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				this.n11 = c * e;
				this.n12 = - f;
				this.n13 = d * e;

				this.n21 = ac * f + bd;
				this.n22 = a * e;
				this.n23 = ad * f - bc;

				this.n31 = bc * f - ad;
				this.n32 = b * e;
				this.n33 = bd * f + ac;
				break;

			default: // 'XYZ'

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				this.n11 = c * e;
				this.n12 = - c * f;
				this.n13 = d;

				this.n21 = af + be * d;
				this.n22 = ae - bf * d;
				this.n23 = - b * c;

				this.n31 = bf - ae * d;
				this.n32 = be + af * d;
				this.n33 = a * c;
				break;

		}

		return this;

	},


	setRotationFromQuaternion: function( q ) {

		var x = q.x, y = q.y, z = q.z, w = q.w,
		x2 = x + x, y2 = y + y, z2 = z + z,
		xx = x * x2, xy = x * y2, xz = x * z2,
		yy = y * y2, yz = y * z2, zz = z * z2,
		wx = w * x2, wy = w * y2, wz = w * z2;

		this.n11 = 1 - ( yy + zz );
		this.n12 = xy - wz;
		this.n13 = xz + wy;

		this.n21 = xy + wz;
		this.n22 = 1 - ( xx + zz );
		this.n23 = yz - wx;

		this.n31 = xz - wy;
		this.n32 = yz + wx;
		this.n33 = 1 - ( xx + yy );

		return this;

	},

	scale: function ( v ) {

		var x = v.x, y = v.y, z = v.z;

		this.n11 *= x; this.n12 *= y; this.n13 *= z;
		this.n21 *= x; this.n22 *= y; this.n23 *= z;
		this.n31 *= x; this.n32 *= y; this.n33 *= z;
		this.n41 *= x; this.n42 *= y; this.n43 *= z;

		return this;

	},

	compose: function ( translation, rotation, scale ) {

		var mRotation = THREE.Matrix4.__m1;
		var mScale = THREE.Matrix4.__m2;

		mRotation.identity();
		mRotation.setRotationFromQuaternion( rotation );

		mScale.setScale( scale.x, scale.y, scale.z );

		this.multiply( mRotation, mScale );

		this.n14 = translation.x;
		this.n24 = translation.y;
		this.n34 = translation.z;

		return this;

	},

	decompose: function ( translation, rotation, scale ) {

		// grab the axis vectors

		var x = THREE.Matrix4.__v1;
		var y = THREE.Matrix4.__v2;
		var z = THREE.Matrix4.__v3;

		x.set( this.n11, this.n21, this.n31 );
		y.set( this.n12, this.n22, this.n32 );
		z.set( this.n13, this.n23, this.n33 );

		translation = ( translation instanceof THREE.Vector3 ) ? translation : new THREE.Vector3();
		rotation = ( rotation instanceof THREE.Quaternion ) ? rotation : new THREE.Quaternion();
		scale = ( scale instanceof THREE.Vector3 ) ? scale : new THREE.Vector3();

		scale.x = x.length();
		scale.y = y.length();
		scale.z = z.length();

		translation.x = this.n14;
		translation.y = this.n24;
		translation.z = this.n34;

		// scale the rotation part

		var matrix = THREE.Matrix4.__m1;

		matrix.copy( this );

		matrix.n11 /= scale.x;
		matrix.n21 /= scale.x;
		matrix.n31 /= scale.x;

		matrix.n12 /= scale.y;
		matrix.n22 /= scale.y;
		matrix.n32 /= scale.y;

		matrix.n13 /= scale.z;
		matrix.n23 /= scale.z;
		matrix.n33 /= scale.z;

		rotation.setFromRotationMatrix( matrix );

		return [ translation, rotation, scale ];

	},

	extractPosition: function ( m ) {

		this.n14 = m.n14;
		this.n24 = m.n24;
		this.n34 = m.n34;

		return this;

	},

	extractRotation: function ( m ) {

		var vector = THREE.Matrix4.__v1;

		var scaleX = 1 / vector.set( m.n11, m.n21, m.n31 ).length();
		var scaleY = 1 / vector.set( m.n12, m.n22, m.n32 ).length();
		var scaleZ = 1 / vector.set( m.n13, m.n23, m.n33 ).length();

		this.n11 = m.n11 * scaleX;
		this.n21 = m.n21 * scaleX;
		this.n31 = m.n31 * scaleX;

		this.n12 = m.n12 * scaleY;
		this.n22 = m.n22 * scaleY;
		this.n32 = m.n32 * scaleY;

		this.n13 = m.n13 * scaleZ;
		this.n23 = m.n23 * scaleZ;
		this.n33 = m.n33 * scaleZ;

		return this;

	}

};

THREE.Matrix4.makeInvert3x3 = function ( m1 ) {

	// input:  THREE.Matrix4, output: THREE.Matrix3
	// ( based on http://code.google.com/p/webgl-mjs/ )

	var m33 = m1.m33, m33m = m33.m,
	a11 =   m1.n33 * m1.n22 - m1.n32 * m1.n23,
	a21 = - m1.n33 * m1.n21 + m1.n31 * m1.n23,
	a31 =   m1.n32 * m1.n21 - m1.n31 * m1.n22,
	a12 = - m1.n33 * m1.n12 + m1.n32 * m1.n13,
	a22 =   m1.n33 * m1.n11 - m1.n31 * m1.n13,
	a32 = - m1.n32 * m1.n11 + m1.n31 * m1.n12,
	a13 =   m1.n23 * m1.n12 - m1.n22 * m1.n13,
	a23 = - m1.n23 * m1.n11 + m1.n21 * m1.n13,
	a33 =   m1.n22 * m1.n11 - m1.n21 * m1.n12,

	det = m1.n11 * a11 + m1.n21 * a12 + m1.n31 * a13,

	idet;

	// no inverse

	if ( det === 0 ) {

		console.error( 'THREE.Matrix4.makeInvert3x3: Matrix not invertible.' );

	}

	idet = 1.0 / det;

	m33m[ 0 ] = idet * a11; m33m[ 1 ] = idet * a21; m33m[ 2 ] = idet * a31;
	m33m[ 3 ] = idet * a12; m33m[ 4 ] = idet * a22; m33m[ 5 ] = idet * a32;
	m33m[ 6 ] = idet * a13; m33m[ 7 ] = idet * a23; m33m[ 8 ] = idet * a33;

	return m33;

}

THREE.Matrix4.makeFrustum = function ( left, right, bottom, top, near, far ) {

	var m, x, y, a, b, c, d;

	m = new THREE.Matrix4();

	x = 2 * near / ( right - left );
	y = 2 * near / ( top - bottom );

	a = ( right + left ) / ( right - left );
	b = ( top + bottom ) / ( top - bottom );
	c = - ( far + near ) / ( far - near );
	d = - 2 * far * near / ( far - near );

	m.n11 = x;  m.n12 = 0;  m.n13 = a;   m.n14 = 0;
	m.n21 = 0;  m.n22 = y;  m.n23 = b;   m.n24 = 0;
	m.n31 = 0;  m.n32 = 0;  m.n33 = c;   m.n34 = d;
	m.n41 = 0;  m.n42 = 0;  m.n43 = - 1; m.n44 = 0;

	return m;

};

THREE.Matrix4.makePerspective = function ( fov, aspect, near, far ) {

	var ymax, ymin, xmin, xmax;

	ymax = near * Math.tan( fov * Math.PI / 360 );
	ymin = - ymax;
	xmin = ymin * aspect;
	xmax = ymax * aspect;

	return THREE.Matrix4.makeFrustum( xmin, xmax, ymin, ymax, near, far );

};

THREE.Matrix4.makeOrtho = function ( left, right, top, bottom, near, far ) {

	var m, x, y, z, w, h, p;

	m = new THREE.Matrix4();

	w = right - left;
	h = top - bottom;
	p = far - near;

	x = ( right + left ) / w;
	y = ( top + bottom ) / h;
	z = ( far + near ) / p;

	m.n11 = 2 / w; m.n12 = 0;     m.n13 = 0;      m.n14 = -x;
	m.n21 = 0;     m.n22 = 2 / h; m.n23 = 0;      m.n24 = -y;
	m.n31 = 0;     m.n32 = 0;     m.n33 = -2 / p; m.n34 = -z;
	m.n41 = 0;     m.n42 = 0;     m.n43 = 0;      m.n44 = 1;

	return m;

};

THREE.Matrix4.__v1 = new THREE.Vector3();
THREE.Matrix4.__v2 = new THREE.Vector3();
THREE.Matrix4.__v3 = new THREE.Vector3();

THREE.Matrix4.__m1 = new THREE.Matrix4();
THREE.Matrix4.__m2 = new THREE.Matrix4();
/**
 * @author mr.doob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Object3D = function () {

	this.name = '';

	this.id = THREE.Object3DCount ++;

	this.parent = undefined;
	this.children = [];

	this.up = new THREE.Vector3( 0, 1, 0 );

	this.position = new THREE.Vector3();
	this.rotation = new THREE.Vector3();
	this.eulerOrder = 'XYZ';
	this.scale = new THREE.Vector3( 1, 1, 1 );

	this.dynamic = false; // when true it retains arrays so they can be updated with __dirty*

	this.doubleSided = false;
	this.flipSided = false;

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();
	this.matrixRotationWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = true;

	this.quaternion = new THREE.Quaternion();
	this.useQuaternion = false;

	this.boundRadius = 0.0;
	this.boundRadiusScale = 1.0;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this._vector = new THREE.Vector3();

};


THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	translate: function ( distance, axis ) {

		this.matrix.rotateAxis( axis );
		this.position.addSelf( axis.multiplyScalar( distance ) );

	},

	translateX: function ( distance ) {

		this.translate( distance, this._vector.set( 1, 0, 0 ) );

	},

	translateY: function ( distance ) {

		this.translate( distance, this._vector.set( 0, 1, 0 ) );

	},

	translateZ: function ( distance ) {

		this.translate( distance, this._vector.set( 0, 0, 1 ) );

	},

	lookAt: function ( vector ) {

		// TODO: Add hierarchy support.

		this.matrix.lookAt( vector, this.position, this.up );

		if ( this.rotationAutoUpdate ) {

			this.rotation.setRotationFromMatrix( this.matrix );

		}

	},

	add: function ( object ) {

		if ( this.children.indexOf( object ) === - 1 ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			// add to scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene )  {

				scene.addObject( object );

			}

		}

	},

	remove: function ( object ) {

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;
			this.children.splice( index, 1 );

			// remove from scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene ) {

				scene.removeObject( object );

			}

		}

	},

	getChildByName: function ( name, doRecurse ) {

		var c, cl, child, recurseResult;

		for ( c = 0, cl = this.children.length; c < cl; c ++ ) {

			child = this.children[ c ];

			if ( child.name === name ) {

				return child;

			}

			if ( doRecurse ) {

				recurseResult = child.getChildByName( name, doRecurse );

				if ( recurseResult !== undefined ) {

					return recurseResult;

				}

			}

		}

		return undefined;

	},

	updateMatrix: function () {

		this.matrix.setPosition( this.position );

		if ( this.useQuaternion )  {

			this.matrix.setRotationFromQuaternion( this.quaternion );

		} else {

			this.matrix.setRotationFromEuler( this.rotation, this.eulerOrder );

		}

		if ( this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1 ) {

			this.matrix.scale( this.scale );
			this.boundRadiusScale = Math.max( this.scale.x, Math.max( this.scale.y, this.scale.z ) );

		}

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiply( this.parent.matrixWorld, this.matrix );

			} else {

				this.matrixWorld.copy( this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	}

};

THREE.Object3DCount = 0;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.Projector = function() {

	var _object, _objectCount, _objectPool = [],
	_vertex, _vertexCount, _vertexPool = [],
	_face, _face3Count, _face3Pool = [], _face4Count, _face4Pool = [],
	_line, _lineCount, _linePool = [],
	_particle, _particleCount, _particlePool = [],

	_renderData = { objects: [], sprites: [], lights: [], elements: [] },

	_vector3 = new THREE.Vector3(),
	_vector4 = new THREE.Vector4(),

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenobjectMatrixWorld = new THREE.Matrix4(),

	_frustum = [
		new THREE.Vector4(),
		new THREE.Vector4(),
		new THREE.Vector4(),
		new THREE.Vector4(),
		new THREE.Vector4(),
		new THREE.Vector4()
	 ],

	_clippedVertex1PositionScreen = new THREE.Vector4(),
	_clippedVertex2PositionScreen = new THREE.Vector4(),

	_face3VertexNormals;

	this.computeFrustum = function ( m ) {

		_frustum[ 0 ].set( m.n41 - m.n11, m.n42 - m.n12, m.n43 - m.n13, m.n44 - m.n14 );
		_frustum[ 1 ].set( m.n41 + m.n11, m.n42 + m.n12, m.n43 + m.n13, m.n44 + m.n14 );
		_frustum[ 2 ].set( m.n41 + m.n21, m.n42 + m.n22, m.n43 + m.n23, m.n44 + m.n24 );
		_frustum[ 3 ].set( m.n41 - m.n21, m.n42 - m.n22, m.n43 - m.n23, m.n44 - m.n24 );
		_frustum[ 4 ].set( m.n41 - m.n31, m.n42 - m.n32, m.n43 - m.n33, m.n44 - m.n34 );
		_frustum[ 5 ].set( m.n41 + m.n31, m.n42 + m.n32, m.n43 + m.n33, m.n44 + m.n34 );

		for ( var i = 0; i < 6; i ++ ) {

			var plane = _frustum[ i ];
			plane.divideScalar( Math.sqrt( plane.x * plane.x + plane.y * plane.y + plane.z * plane.z ) );

		}

	}

	this.projectVector = function ( vector, camera ) {

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiply( camera.projectionMatrix, camera.matrixWorldInverse );
		_projScreenMatrix.multiplyVector3( vector );

		return vector;

	};

	this.unprojectVector = function ( vector, camera ) {

		camera.projectionMatrixInverse.getInverse( camera.projectionMatrix );

		_projScreenMatrix.multiply( camera.matrixWorld, camera.projectionMatrixInverse );
		_projScreenMatrix.multiplyVector3( vector );

		return vector;

	};

	/**
	 * Translates a 2D point from NDC to a THREE.Ray
	 * that can be used for picking.
	 * @vector - THREE.Vector3 that represents 2D point
	 * @camera - THREE.Camera
	 */
	this.pickingRay = function ( vector, camera ) {

		var end, ray, t;

		// set two vectors with opposing z values
		vector.z = -1.0;
		end = new THREE.Vector3( vector.x, vector.y, 1.0 );

		this.unprojectVector( vector, camera );
		this.unprojectVector( end, camera );

		// find direction from vector to end
		end.subSelf( vector ).normalize();

		return new THREE.Ray( vector, end );

	};

	this.projectGraph = function ( root, sort ) {

		_objectCount = 0;

		_renderData.objects.length = 0;
		_renderData.sprites.length = 0;
		_renderData.lights.length = 0;

		var projectObject = function ( object ) {

			if ( object.visible === false ) return;

			if ( ( object instanceof THREE.Mesh || object instanceof THREE.Line ) &&
			( object.frustumCulled === false || isInFrustum( object ) ) ) {

				_projScreenMatrix.multiplyVector3( _vector3.copy( object.position ) );

				_object = getNextObjectInPool();
				_object.object = object;
				_object.z = _vector3.z;

				_renderData.objects.push( _object );

			} else if ( object instanceof THREE.Sprite || object instanceof THREE.Particle ) {

				_projScreenMatrix.multiplyVector3( _vector3.copy( object.position ) );

				_object = getNextObjectInPool();
				_object.object = object;
				_object.z = _vector3.z;

				_renderData.sprites.push( _object );

			} else if ( object instanceof THREE.Light ) {

				_renderData.lights.push( object );

			}

			for ( var c = 0, cl = object.children.length; c < cl; c ++ ) {

				projectObject( object.children[ c ] );

			}

		};

		projectObject( root );

		sort && _renderData.objects.sort( painterSort );

		return _renderData;

	};

	this.projectScene = function ( scene, camera, sort ) {

		var near = camera.near, far = camera.far,
		o, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,
		objectMatrixWorld, objectMatrixWorldRotation, objectMaterial,
		geometry, geometryMaterials, vertices, vertex, vertexPositionScreen,
		faces, face, faceVertexNormals, normal, faceVertexUvs, uvs,
		v1, v2, v3, v4;

		_face3Count = 0;
		_face4Count = 0;
		_lineCount = 0;
		_particleCount = 0;

		_renderData.elements.length = 0;

		if ( camera.parent === undefined ) {

			console.warn( 'DEPRECATED: Camera hasn\'t been added to a Scene. Adding it...' );
			scene.add( camera );

		}

		scene.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiply( camera.projectionMatrix, camera.matrixWorldInverse );

		this.computeFrustum( _projScreenMatrix );

		_renderData = this.projectGraph( scene, false );

		for ( o = 0, ol = _renderData.objects.length; o < ol; o++ ) {

			object = _renderData.objects[ o ].object;

			objectMatrixWorld = object.matrixWorld;
			objectMaterial = object.material;

			_vertexCount = 0;

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;
				geometryMaterials = object.geometry.materials;
				vertices = geometry.vertices;
				faces = geometry.faces;
				faceVertexUvs = geometry.faceVertexUvs;

				objectMatrixWorldRotation = object.matrixRotationWorld.extractRotation( objectMatrixWorld );

				for ( v = 0, vl = vertices.length; v < vl; v ++ ) {

					_vertex = getNextVertexInPool();
					_vertex.positionWorld.copy( vertices[ v ].position );

					objectMatrixWorld.multiplyVector3( _vertex.positionWorld );

					_vertex.positionScreen.copy( _vertex.positionWorld );
					_projScreenMatrix.multiplyVector4( _vertex.positionScreen );

					_vertex.positionScreen.x /= _vertex.positionScreen.w;
					_vertex.positionScreen.y /= _vertex.positionScreen.w;

					_vertex.visible = _vertex.positionScreen.z > near && _vertex.positionScreen.z < far;

				}

				for ( f = 0, fl = faces.length; f < fl; f ++ ) {

					face = faces[ f ];

					if ( face instanceof THREE.Face3 ) {

						v1 = _vertexPool[ face.a ];
						v2 = _vertexPool[ face.b ];
						v3 = _vertexPool[ face.c ];

						if ( v1.visible && v2.visible && v3.visible &&
							( object.doubleSided || ( object.flipSided !=
							( v3.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -
							( v3.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) < 0 ) ) ) {

							_face = getNextFace3InPool();

							_face.v1.copy( v1 );
							_face.v2.copy( v2 );
							_face.v3.copy( v3 );

						} else {

							continue;

						}

					} else if ( face instanceof THREE.Face4 ) {

						v1 = _vertexPool[ face.a ];
						v2 = _vertexPool[ face.b ];
						v3 = _vertexPool[ face.c ];
						v4 = _vertexPool[ face.d ];

						if ( v1.visible && v2.visible && v3.visible && v4.visible &&
							( object.doubleSided || ( object.flipSided !=
							( ( v4.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -
							( v4.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) < 0 ||
							( v2.positionScreen.x - v3.positionScreen.x ) * ( v4.positionScreen.y - v3.positionScreen.y ) -
							( v2.positionScreen.y - v3.positionScreen.y ) * ( v4.positionScreen.x - v3.positionScreen.x ) < 0 ) ) ) ) {

							_face = getNextFace4InPool();

							_face.v1.copy( v1 );
							_face.v2.copy( v2 );
							_face.v3.copy( v3 );
							_face.v4.copy( v4 );

						} else {

							continue;

						}

					}

					_face.normalWorld.copy( face.normal );
					objectMatrixWorldRotation.multiplyVector3( _face.normalWorld );

					_face.centroidWorld.copy( face.centroid );
					objectMatrixWorld.multiplyVector3( _face.centroidWorld );

					_face.centroidScreen.copy( _face.centroidWorld );
					_projScreenMatrix.multiplyVector3( _face.centroidScreen );

					faceVertexNormals = face.vertexNormals;

					for ( n = 0, nl = faceVertexNormals.length; n < nl; n ++ ) {

						normal = _face.vertexNormalsWorld[ n ];
						normal.copy( faceVertexNormals[ n ] );
						objectMatrixWorldRotation.multiplyVector3( normal );

					}

					for ( c = 0, cl = faceVertexUvs.length; c < cl; c ++ ) {

						uvs = faceVertexUvs[ c ][ f ];

						if ( !uvs ) continue;

						for ( u = 0, ul = uvs.length; u < ul; u ++ ) {

							_face.uvs[ c ][ u ] = uvs[ u ];

						}

					}

					_face.material = objectMaterial;
					_face.faceMaterial = face.materialIndex !== null ? geometryMaterials[ face.materialIndex ] : null;

					_face.z = _face.centroidScreen.z;

					_renderData.elements.push( _face );

				}

			} else if ( object instanceof THREE.Line ) {

				_projScreenobjectMatrixWorld.multiply( _projScreenMatrix, objectMatrixWorld );

				vertices = object.geometry.vertices;

				v1 = getNextVertexInPool();
				v1.positionScreen.copy( vertices[ 0 ].position );
				_projScreenobjectMatrixWorld.multiplyVector4( v1.positionScreen );

				for ( v = 1, vl = vertices.length; v < vl; v++ ) {

					v1 = getNextVertexInPool();
					v1.positionScreen.copy( vertices[ v ].position );
					_projScreenobjectMatrixWorld.multiplyVector4( v1.positionScreen );

					v2 = _vertexPool[ _vertexCount - 2 ];

					_clippedVertex1PositionScreen.copy( v1.positionScreen );
					_clippedVertex2PositionScreen.copy( v2.positionScreen );

					if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) ) {

						// Perform the perspective divide
						_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
						_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

						_line = getNextLineInPool();
						_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
						_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

						_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

						_line.material = objectMaterial;

						_renderData.elements.push( _line );

					}

				}

			}

		}

		for ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {

			object = _renderData.sprites[ o ].object;

			objectMatrixWorld = object.matrixWorld;

			if ( object instanceof THREE.Particle ) {

				_vector4.set( objectMatrixWorld.n14, objectMatrixWorld.n24, objectMatrixWorld.n34, 1 );
				_projScreenMatrix.multiplyVector4( _vector4 );

				_vector4.z /= _vector4.w;

				if ( _vector4.z > 0 && _vector4.z < 1 ) {

					_particle = getNextParticleInPool();
					_particle.x = _vector4.x / _vector4.w;
					_particle.y = _vector4.y / _vector4.w;
					_particle.z = _vector4.z;

					_particle.rotation = object.rotation.z;

					_particle.scale.x = object.scale.x * Math.abs( _particle.x - ( _vector4.x + camera.projectionMatrix.n11 ) / ( _vector4.w + camera.projectionMatrix.n14 ) );
					_particle.scale.y = object.scale.y * Math.abs( _particle.y - ( _vector4.y + camera.projectionMatrix.n22 ) / ( _vector4.w + camera.projectionMatrix.n24 ) );

					_particle.material = object.material;

					_renderData.elements.push( _particle );

				}

			}

		}

		sort && _renderData.elements.sort( painterSort );

		return _renderData;

	};

	// Pools

	function getNextObjectInPool() {

		var object = _objectPool[ _objectCount ] = _objectPool[ _objectCount ] || new THREE.RenderableObject();

		_objectCount ++;

		return object;

	}

	function getNextVertexInPool() {

		var vertex = _vertexPool[ _vertexCount ] = _vertexPool[ _vertexCount ] || new THREE.RenderableVertex();

		_vertexCount ++;

		return vertex;

	}

	function getNextFace3InPool() {

		var face = _face3Pool[ _face3Count ] = _face3Pool[ _face3Count ] || new THREE.RenderableFace3();

		_face3Count ++;

		return face;

	}

	function getNextFace4InPool() {

		var face = _face4Pool[ _face4Count ] = _face4Pool[ _face4Count ] || new THREE.RenderableFace4();

		_face4Count ++;

		return face;

	}

	function getNextLineInPool() {

		var line = _linePool[ _lineCount ] = _linePool[ _lineCount ] || new THREE.RenderableLine();

		_lineCount ++;

		return line;

	}

	function getNextParticleInPool() {

		var particle = _particlePool[ _particleCount ] = _particlePool[ _particleCount ] || new THREE.RenderableParticle();
		_particleCount ++;
		return particle;

	}

	//

	function painterSort( a, b ) {

		return b.z - a.z;

	}

	function isInFrustum( object ) {

		var distance, matrix = object.matrixWorld,
		radius = - object.geometry.boundingSphere.radius * Math.max( object.scale.x, Math.max( object.scale.y, object.scale.z ) );

		for ( var i = 0; i < 6; i ++ ) {

			distance = _frustum[ i ].x * matrix.n14 + _frustum[ i ].y * matrix.n24 + _frustum[ i ].z * matrix.n34 + _frustum[ i ].w;
			if ( distance <= radius ) return false;

		}

		return true;

	};

	function clipLine( s1, s2 ) {

		var alpha1 = 0, alpha2 = 1,

		// Calculate the boundary coordinate of each vertex for the near and far clip planes,
		// Z = -1 and Z = +1, respectively.
		bc1near =  s1.z + s1.w,
		bc2near =  s2.z + s2.w,
		bc1far =  - s1.z + s1.w,
		bc2far =  - s2.z + s2.w;

		if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

			// Both vertices lie entirely within all clip planes.
			return true;

		} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {

			// Both vertices lie entirely outside one of the clip planes.
			return false;

		} else {

			// The line segment spans at least one clip plane.

			if ( bc1near < 0 ) {

				// v1 lies outside the near plane, v2 inside
				alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

			} else if ( bc2near < 0 ) {

				// v2 lies outside the near plane, v1 inside
				alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

			}

			if ( bc1far < 0 ) {

				// v1 lies outside the far plane, v2 inside
				alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

			} else if ( bc2far < 0 ) {

				// v2 lies outside the far plane, v2 inside
				alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

			}

			if ( alpha2 < alpha1 ) {

				// The line segment spans two boundaries, but is outside both of them.
				// (This can't happen when we're only clipping against just near/far but good
				//  to leave the check here for future usage if other clip planes are added.)
				return false;

			} else {

				// Update the s1 and s2 vertices to match the clipped line segment.
				s1.lerpSelf( s2, alpha1 );
				s2.lerpSelf( s1, 1 - alpha2 );

				return true;

			}

		}

	}

};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Quaternion = function( x, y, z, w ) {

	this.set(

		x || 0,
		y || 0,
		z || 0,
		w !== undefined ? w : 1

	);

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	copy: function ( q ) {

		this.x = q.x;
		this.y = q.y;
		this.z = q.z;
		this.w = q.w;

		return this;

	},

	setFromEuler: function ( vec3 ) {

		var c = Math.PI / 360, // 0.5 * Math.PI / 360, // 0.5 is an optimization
		x = vec3.x * c,
		y = vec3.y * c,
		z = vec3.z * c,

		c1 = Math.cos( y  ),
		s1 = Math.sin( y  ),
		c2 = Math.cos( -z ),
		s2 = Math.sin( -z ),
		c3 = Math.cos( x  ),
		s3 = Math.sin( x  ),

		c1c2 = c1 * c2,
		s1s2 = s1 * s2;

		this.w = c1c2 * c3  - s1s2 * s3;
	  	this.x = c1c2 * s3  + s1s2 * c3;
		this.y = s1 * c2 * c3 + c1 * s2 * s3;
		this.z = c1 * s2 * c3 - s1 * c2 * s3;

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
		// axis have to be normalized

		var halfAngle = angle / 2,
			s = Math.sin( halfAngle );

		this.x = axis.x * s;
		this.y = axis.y * s;
		this.z = axis.z * s;
		this.w = Math.cos( halfAngle );

		return this;

	},

	setFromRotationMatrix: function ( m ) {
		// Adapted from: http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
		function copySign(a, b) {
			return b < 0 ? -Math.abs(a) : Math.abs(a);
		}
		var absQ = Math.pow(m.determinant(), 1.0 / 3.0);
		this.w = Math.sqrt( Math.max( 0, absQ + m.n11 + m.n22 + m.n33 ) ) / 2;
		this.x = Math.sqrt( Math.max( 0, absQ + m.n11 - m.n22 - m.n33 ) ) / 2;
		this.y = Math.sqrt( Math.max( 0, absQ - m.n11 + m.n22 - m.n33 ) ) / 2;
		this.z = Math.sqrt( Math.max( 0, absQ - m.n11 - m.n22 + m.n33 ) ) / 2;
		this.x = copySign( this.x, ( m.n32 - m.n23 ) );
		this.y = copySign( this.y, ( m.n13 - m.n31 ) );
		this.z = copySign( this.z, ( m.n21 - m.n12 ) );
		this.normalize();
		return this;
	},

	calculateW : function () {

		this.w = - Math.sqrt( Math.abs( 1.0 - this.x * this.x - this.y * this.y - this.z * this.z ) );

		return this;

	},

	inverse: function () {

		this.x *= -1;
		this.y *= -1;
		this.z *= -1;

		return this;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	normalize: function () {

		var l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		if ( l === 0 ) {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;

		} else {

			l = 1 / l;

			this.x = this.x * l;
			this.y = this.y * l;
			this.z = this.z * l;
			this.w = this.w * l;

		}

		return this;

	},

	multiplySelf: function ( quat2 ) {

		var qax = this.x,  qay = this.y,  qaz = this.z,  qaw = this.w,
		qbx = quat2.x, qby = quat2.y, qbz = quat2.z, qbw = quat2.w;

		this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		return this;

	},

	multiply: function ( q1, q2 ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		this.x =  q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;
		this.y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;
		this.z =  q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;
		this.w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;

		return this;

	},

	multiplyVector3: function ( vec, dest ) {

		if( !dest ) { dest = vec; }

		var x    = vec.x,  y  = vec.y,  z  = vec.z,
			qx   = this.x, qy = this.y, qz = this.z, qw = this.w;

		// calculate quat * vec

		var ix =  qw * x + qy * z - qz * y,
			iy =  qw * y + qz * x - qx * z,
			iz =  qw * z + qx * y - qy * x,
			iw = -qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		dest.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		dest.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		dest.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

		return dest;

	}

}

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

	var cosHalfTheta = qa.w * qb.w + qa.x * qb.x + qa.y * qb.y + qa.z * qb.z;

	if (cosHalfTheta < 0) {
		qm.w = -qb.w; qm.x = -qb.x; qm.y = -qb.y; qm.z = -qb.z;
		cosHalfTheta = -cosHalfTheta;
	} else {
		qm.copy(qb);
	}

	if ( Math.abs( cosHalfTheta ) >= 1.0 ) {

		qm.w = qa.w; qm.x = qa.x; qm.y = qa.y; qm.z = qa.z;
		return qm;

	}

	var halfTheta = Math.acos( cosHalfTheta ),
	sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

	if ( Math.abs( sinHalfTheta ) < 0.001 ) {

		qm.w = 0.5 * ( qa.w + qb.w );
		qm.x = 0.5 * ( qa.x + qb.x );
		qm.y = 0.5 * ( qa.y + qb.y );
		qm.z = 0.5 * ( qa.z + qb.z );

		return qm;

	}

	var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
	ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

	qm.w = ( qa.w * ratioA + qm.w * ratioB );
	qm.x = ( qa.x * ratioA + qm.x * ratioB );
	qm.y = ( qa.y * ratioA + qm.y * ratioB );
	qm.z = ( qa.z * ratioA + qm.z * ratioB );

	return qm;

}
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Vertex = function ( position ) {

	this.position = position || new THREE.Vector3();

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [ ];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex;

	this.centroid = new THREE.Vector3();

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [ ];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex;

	this.centroid = new THREE.Vector3();

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.UV = function ( u, v ) {

	this.u = u || 0;
	this.v = v || 0;

};

THREE.UV.prototype = {

	constructor: THREE.UV,

	set: function ( u, v ) {

		this.u = u;
		this.v = v;

		return this;

	},

	copy: function ( uv ) {

		this.u = uv.u;
		this.v = uv.v;

		return this;

	},

	clone: function () {

		return new THREE.UV( this.u, this.v );

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Geometry = function () {

	this.id = THREE.GeometryCount ++;

	this.vertices = [];
	this.colors = []; // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon

	this.materials = [];

	this.faces = [];

	this.faceUvs = [[]];
	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphColors = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = false; // unless set to true the *Arrays will be deleted once sent to a buffer.

};

THREE.Geometry.prototype = {

	constructor : THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var matrixRotation = new THREE.Matrix4();
		matrixRotation.extractRotation( matrix, new THREE.Vector3( 1, 1, 1 ) );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];

			matrix.multiplyVector3( vertex.position );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];

			matrixRotation.multiplyVector3( face.normal );

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				matrixRotation.multiplyVector3( face.vertexNormals[ j ] );

			}

			matrix.multiplyVector3( face.centroid );

		}

	},

	computeCentroids: function () {

		var f, fl, face;

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			face.centroid.set( 0, 0, 0 );

			if ( face instanceof THREE.Face3 ) {

				face.centroid.addSelf( this.vertices[ face.a ].position );
				face.centroid.addSelf( this.vertices[ face.b ].position );
				face.centroid.addSelf( this.vertices[ face.c ].position );
				face.centroid.divideScalar( 3 );

			} else if ( face instanceof THREE.Face4 ) {

				face.centroid.addSelf( this.vertices[ face.a ].position );
				face.centroid.addSelf( this.vertices[ face.b ].position );
				face.centroid.addSelf( this.vertices[ face.c ].position );
				face.centroid.addSelf( this.vertices[ face.d ].position );
				face.centroid.divideScalar( 4 );

			}

		}

	},

	computeFaceNormals: function ( useVertexNormals ) {

		var n, nl, v, vl, vertex, f, fl, face, vA, vB, vC,
		cb = new THREE.Vector3(), ab = new THREE.Vector3();

		/*
		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertex = this.vertices[ v ];
			vertex.normal.set( 0, 0, 0 );

		}
		*/

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( useVertexNormals && face.vertexNormals.length  ) {

				cb.set( 0, 0, 0 );

				for ( n = 0, nl = face.vertexNormals.length; n < nl; n++ ) {

					cb.addSelf( face.vertexNormals[n] );

				}

				cb.divideScalar( 3 );

				if ( ! cb.isZero() ) {

					cb.normalize();

				}

				face.normal.copy( cb );

			} else {

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.sub( vC.position, vB.position );
				ab.sub( vA.position, vB.position );
				cb.crossSelf( ab );

				if ( !cb.isZero() ) {

					cb.normalize();

				}

				face.normal.copy( cb );

			}

		}

	},

	computeVertexNormals: function () {

		var v, vl, f, fl, face, vertices;

		// create internal buffers for reuse when calling this method repeatedly
		// (otherwise memory allocation / deallocation every frame is big resource hog)

		if ( this.__tmpVertices === undefined ) {

			this.__tmpVertices = new Array( this.vertices.length );
			vertices = this.__tmpVertices;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( face instanceof THREE.Face3 ) {

					face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

				} else if ( face instanceof THREE.Face4 ) {

					face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

				}

			}

		} else {

			vertices = this.__tmpVertices;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].set( 0, 0, 0 );

			}

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( face instanceof THREE.Face3 ) {

				vertices[ face.a ].addSelf( face.normal );
				vertices[ face.b ].addSelf( face.normal );
				vertices[ face.c ].addSelf( face.normal );

			} else if ( face instanceof THREE.Face4 ) {

				vertices[ face.a ].addSelf( face.normal );
				vertices[ face.b ].addSelf( face.normal );
				vertices[ face.c ].addSelf( face.normal );
				vertices[ face.d ].addSelf( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( face instanceof THREE.Face3 ) {

				face.vertexNormals[ 0 ].copy( vertices[ face.a ] );
				face.vertexNormals[ 1 ].copy( vertices[ face.b ] );
				face.vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else if ( face instanceof THREE.Face4 ) {

				face.vertexNormals[ 0 ].copy( vertices[ face.a ] );
				face.vertexNormals[ 1 ].copy( vertices[ face.b ] );
				face.vertexNormals[ 2 ].copy( vertices[ face.c ] );
				face.vertexNormals[ 3 ].copy( vertices[ face.d ] );

			}

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ].position;
			vB = context.vertices[ b ].position;
			vC = context.vertices[ c ].position;

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.u - uvA.u;
			s2 = uvC.u - uvA.u;
			t1 = uvB.v - uvA.v;
			t2 = uvC.v - uvA.v;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].addSelf( sdir );
			tan1[ b ].addSelf( sdir );
			tan1[ c ].addSelf( sdir );

			tan2[ a ].addSelf( tdir );
			tan2[ b ].addSelf( tdir );
			tan2[ c ].addSelf( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			if ( face instanceof THREE.Face3 ) {

				handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

			} else if ( face instanceof THREE.Face4 ) {

				handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );
				handleTriangle( this, face.a, face.b, face.d, 0, 1, 3 );

			}

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < face.vertexNormals.length; i++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.subSelf( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.cross( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = (test < 0.0) ? -1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeBoundingBox: function () {

		var vertex;

		if ( this.vertices.length > 0 ) {

			this.boundingBox = { 'x': [ this.vertices[ 0 ].position.x, this.vertices[ 0 ].position.x ],
			'y': [ this.vertices[ 0 ].position.y, this.vertices[ 0 ].position.y ],
			'z': [ this.vertices[ 0 ].position.z, this.vertices[ 0 ].position.z ] };

			for ( var v = 1, vl = this.vertices.length; v < vl; v ++ ) {

				vertex = this.vertices[ v ];

				if ( vertex.position.x < this.boundingBox.x[ 0 ] ) {

					this.boundingBox.x[ 0 ] = vertex.position.x;

				} else if ( vertex.position.x > this.boundingBox.x[ 1 ] ) {

					this.boundingBox.x[ 1 ] = vertex.position.x;

				}

				if ( vertex.position.y < this.boundingBox.y[ 0 ] ) {

					this.boundingBox.y[ 0 ] = vertex.position.y;

				} else if ( vertex.position.y > this.boundingBox.y[ 1 ] ) {

					this.boundingBox.y[ 1 ] = vertex.position.y;

				}

				if ( vertex.position.z < this.boundingBox.z[ 0 ] ) {

					this.boundingBox.z[ 0 ] = vertex.position.z;

				} else if ( vertex.position.z > this.boundingBox.z[ 1 ] ) {

					this.boundingBox.z[ 1 ] = vertex.position.z;

				}

			}

		}

	},

	computeBoundingSphere: function () {

		// var radius = this.boundingSphere === null ? 0 : this.boundingSphere.radius;

		var radius = 0;

		for ( var v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			radius = Math.max( radius, this.vertices[ v ].position.length() );

		}

		this.boundingSphere = { radius: radius };

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function() {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ].position;
			key = [ Math.round( v.x * precision ), Math.round( v.y * precision ), Math.round( v.z * precision ) ].join( '_' );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// Start to patch face indices

		for( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			if ( face instanceof THREE.Face3 ) {

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

			} else if ( face instanceof THREE.Face4 ) {

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
				face.d = changes[ face.d ];

			}

		}

		// Use unique set of vertices

		this.vertices = unique;

	}

};

THREE.GeometryCount = 0;
/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > this.points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > this.points.length - 3 ? intPoint : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( !nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.Edge = function( v1, v2, vi1, vi2 ) {

	this.vertices = [ v1, v2 ]; // vertex references
	this.vertexIndices = [ vi1, vi2 ]; // vertex indices

	this.faces = []; // face references
	this.faceIndices = [];	// face indices

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.Camera = function () {

	if ( arguments.length ) {

		console.warn( 'DEPRECATED: Camera() is now PerspectiveCamera() or OrthographicCamera().' );
		return new THREE.PerspectiveCamera( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ], arguments[ 3 ] );

	}

	THREE.Object3D.call( this );

	this.matrixWorldInverse = new THREE.Matrix4();

	this.projectionMatrix = new THREE.Matrix4();
	this.projectionMatrixInverse = new THREE.Matrix4();


};

THREE.Camera.prototype = new THREE.Object3D();
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.lookAt = function ( vector ) {

	// TODO: Add hierarchy support.

	this.matrix.lookAt( this.position, vector, this.up );

	if ( this.rotationAutoUpdate ) {

		this.rotation.setRotationFromMatrix( this.matrix );

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = new THREE.Camera();
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	this.projectionMatrix = THREE.Matrix4.makeOrtho( this.left, this.right, this.top, this.bottom, this.near, this.far );

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = new THREE.Camera();
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameSize ) {

	frameSize = frameSize !== undefined ? frameSize : 43.25; // 36x24mm

	this.fov = 2 * Math.atan( frameSize / ( focalLength * 2 ) );
	this.fov = 180 / Math.PI * this.fov;

	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( this.fov * Math.PI / 360 ) * this.near;
		var bottom = -top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix = THREE.Matrix4.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far );

	} else {

		this.projectionMatrix = THREE.Matrix4.makePerspective( this.fov, this.aspect, this.near, this.far );

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
 
THREE.Light = function ( hex ) {

	THREE.Object3D.call( this );

	this.color = new THREE.Color( hex );

};

THREE.Light.prototype = new THREE.Object3D();
THREE.Light.prototype.constructor = THREE.Light;
THREE.Light.prototype.supr = THREE.Object3D.prototype;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( hex ) {

	THREE.Light.call( this, hex );

};

THREE.AmbientLight.prototype = new THREE.Light();
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight; 
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.DirectionalLight = function ( hex, intensity, distance ) {

	THREE.Light.call( this, hex );

	this.position = new THREE.Vector3( 0, 1, 0 );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.DirectionalLight.prototype = new THREE.Light();
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.PointLight = function ( hex, intensity, distance ) {

	THREE.Light.call( this, hex );

	this.position = new THREE.Vector3( 0, 0, 0 );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = new THREE.Light();
THREE.PointLight.prototype.constructor = THREE.PointLight;
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( hex, intensity, distance, castShadow ) {

	THREE.Light.call( this, hex );

	this.position = new THREE.Vector3( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

	this.castShadow = ( castShadow !== undefined ) ? castShadow : false;

};

THREE.SpotLight.prototype = new THREE.Light();
THREE.SpotLight.prototype.constructor = THREE.SpotLight;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Material = function ( parameters ) {

	this.name = '';

	this.id = THREE.MaterialCount ++;

	parameters = parameters || {};

	this.opacity = parameters.opacity !== undefined ? parameters.opacity : 1;
	this.transparent = parameters.transparent !== undefined ? parameters.transparent : false;

	this.blending = parameters.blending !== undefined ? parameters.blending : THREE.NormalBlending;

	this.depthTest = parameters.depthTest !== undefined ? parameters.depthTest : true;
	this.depthWrite = parameters.depthWrite !== undefined ? parameters.depthWrite : true;

	this.polygonOffset = parameters.polygonOffset !== undefined ? parameters.polygonOffset : false;
	this.polygonOffsetFactor = parameters.polygonOffsetFactor !== undefined ? parameters.polygonOffsetFactor : 0;
	this.polygonOffsetUnits = parameters.polygonOffsetUnits !== undefined ? parameters.polygonOffsetUnits : 0;

	this.alphaTest = parameters.alphaTest !== undefined ? parameters.alphaTest : 0;

	this.overdraw = parameters.overdraw !== undefined ? parameters.overdraw : false; // Boolean for fixing antialiasing gaps in CanvasRenderer 

}

THREE.MaterialCount = 0;

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

THREE.NormalBlending = 0;
THREE.AdditiveBlending = 1;
THREE.SubtractiveBlending = 2;
THREE.MultiplyBlending = 3;
THREE.AdditiveAlphaBlending = 4;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.color = parameters.color !== undefined ? new THREE.Color( parameters.color ) : new THREE.Color( 0xffffff );

	this.linewidth = parameters.linewidth !== undefined ? parameters.linewidth : 1;
	this.linecap = parameters.linecap !== undefined ? parameters.linecap : 'round';
	this.linejoin = parameters.linejoin !== undefined ? parameters.linejoin : 'round';

	this.vertexColors = parameters.vertexColors ? parameters.vertexColors : false;

	this.fog = parameters.fog !== undefined ? parameters.fog : true;

};

THREE.LineBasicMaterial.prototype = new THREE.Material();
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: false / THREE.VertexColors / THREE.FaceColors,
 *  skinning: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.color = parameters.color !== undefined ? new THREE.Color( parameters.color ) : new THREE.Color( 0xffffff );

	this.map = parameters.map !== undefined ? parameters.map : null;

	this.lightMap = parameters.lightMap !== undefined ? parameters.lightMap : null;

	this.envMap = parameters.envMap !== undefined ? parameters.envMap : null;
	this.combine = parameters.combine !== undefined ? parameters.combine : THREE.MultiplyOperation;
	this.reflectivity = parameters.reflectivity !== undefined ? parameters.reflectivity : 1;
	this.refractionRatio = parameters.refractionRatio !== undefined ? parameters.refractionRatio : 0.98;

	this.fog = parameters.fog !== undefined ? parameters.fog : true;

	this.shading = parameters.shading !== undefined ? parameters.shading : THREE.SmoothShading;

	this.wireframe = parameters.wireframe !== undefined ? parameters.wireframe : false;
	this.wireframeLinewidth = parameters.wireframeLinewidth !== undefined ? parameters.wireframeLinewidth : 1;
	this.wireframeLinecap = parameters.wireframeLinecap !== undefined ? parameters.wireframeLinecap : 'round';
	this.wireframeLinejoin = parameters.wireframeLinejoin !== undefined ? parameters.wireframeLinejoin : 'round';

	this.vertexColors = parameters.vertexColors !== undefined ? parameters.vertexColors : false;

	this.skinning = parameters.skinning !== undefined ? parameters.skinning : false;
	this.morphTargets = parameters.morphTargets !== undefined ? parameters.morphTargets : false;

};

THREE.MeshBasicMaterial.prototype = new THREE.Material();
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: false / THREE.VertexColors / THREE.FaceColors,
 *  skinning: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.color = parameters.color !== undefined ? new THREE.Color( parameters.color ) : new THREE.Color( 0xffffff );
	this.ambient = parameters.ambient !== undefined ? new THREE.Color( parameters.ambient ) : new THREE.Color( 0x050505 );

	this.map = parameters.map !== undefined ? parameters.map : null;

	this.lightMap = parameters.lightMap !== undefined ? parameters.lightMap : null;

	this.envMap = parameters.envMap !== undefined ? parameters.envMap : null;
	this.combine = parameters.combine !== undefined ? parameters.combine : THREE.MultiplyOperation;
	this.reflectivity = parameters.reflectivity !== undefined ? parameters.reflectivity : 1;
	this.refractionRatio = parameters.refractionRatio !== undefined ? parameters.refractionRatio : 0.98;

	this.fog = parameters.fog !== undefined ? parameters.fog : true;

	this.shading = parameters.shading !== undefined ? parameters.shading : THREE.SmoothShading;

	this.wireframe = parameters.wireframe !== undefined ? parameters.wireframe : false;
	this.wireframeLinewidth = parameters.wireframeLinewidth !== undefined ? parameters.wireframeLinewidth : 1;
	this.wireframeLinecap = parameters.wireframeLinecap !== undefined ? parameters.wireframeLinecap : 'round';
	this.wireframeLinejoin = parameters.wireframeLinejoin !== undefined ? parameters.wireframeLinejoin : 'round';

	this.vertexColors = parameters.vertexColors !== undefined ? parameters.vertexColors : false;

	this.skinning = parameters.skinning !== undefined ? parameters.skinning : false;
	this.morphTargets = parameters.morphTargets !== undefined ? parameters.morphTargets : false;

};

THREE.MeshLambertMaterial.prototype = new THREE.Material();
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: false / THREE.VertexColors / THREE.FaceColors,
 *  skinning: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.color = parameters.color !== undefined ? new THREE.Color( parameters.color ) : new THREE.Color( 0xffffff );
	this.ambient = parameters.ambient !== undefined ? new THREE.Color( parameters.ambient ) : new THREE.Color( 0x050505 );
	this.specular = parameters.specular !== undefined ? new THREE.Color( parameters.specular ) : new THREE.Color( 0x111111 );
	this.shininess = parameters.shininess !== undefined ? parameters.shininess : 30;

	this.metal = parameters.metal !== undefined ? parameters.metal : false;
	this.perPixel = parameters.perPixel !== undefined ? parameters.perPixel : false;

	this.map = parameters.map !== undefined ? parameters.map : null;

	this.lightMap = parameters.lightMap !== undefined ? parameters.lightMap : null;

	this.envMap = parameters.envMap !== undefined ? parameters.envMap : null;
	this.combine = parameters.combine !== undefined ? parameters.combine : THREE.MultiplyOperation;
	this.reflectivity = parameters.reflectivity !== undefined ? parameters.reflectivity : 1;
	this.refractionRatio = parameters.refractionRatio !== undefined ? parameters.refractionRatio : 0.98;

	this.fog = parameters.fog !== undefined ? parameters.fog : true;

	this.shading = parameters.shading !== undefined ? parameters.shading : THREE.SmoothShading;

	this.wireframe = parameters.wireframe !== undefined ? parameters.wireframe : false;
	this.wireframeLinewidth = parameters.wireframeLinewidth !== undefined ? parameters.wireframeLinewidth : 1;
	this.wireframeLinecap = parameters.wireframeLinecap !== undefined ? parameters.wireframeLinecap : 'round';
	this.wireframeLinejoin = parameters.wireframeLinejoin !== undefined ? parameters.wireframeLinejoin : 'round';

	this.vertexColors = parameters.vertexColors !== undefined ? parameters.vertexColors : false;

	this.skinning = parameters.skinning !== undefined ? parameters.skinning : false;
	this.morphTargets = parameters.morphTargets !== undefined ? parameters.morphTargets : false;

};

THREE.MeshPhongMaterial.prototype = new THREE.Material();
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * } 
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.shading = parameters.shading !== undefined ? parameters.shading : THREE.SmoothShading; // doesn't really apply here, normals are not used

	this.wireframe = parameters.wireframe !== undefined ? parameters.wireframe : false;
	this.wireframeLinewidth = parameters.wireframeLinewidth !== undefined ? parameters.wireframeLinewidth : 1;

};

THREE.MeshDepthMaterial.prototype = new THREE.Material();
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.shading = parameters.shading ? parameters.shading : THREE.FlatShading;

	this.wireframe = parameters.wireframe ? parameters.wireframe : false;
	this.wireframeLinewidth = parameters.wireframeLinewidth ? parameters.wireframeLinewidth : 1;

};

THREE.MeshNormalMaterial.prototype = new THREE.Material();
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function () {

};
THREE.MeshShaderMaterial = function ( parameters ) {

	console.warn( 'DEPRECATED: MeshShaderMaterial() is now ShaderMaterial().' );

	return new THREE.ShaderMaterial( parameters );

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ParticleBasicMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.color = parameters.color !== undefined ? new THREE.Color( parameters.color ) : new THREE.Color( 0xffffff );

	this.map = parameters.map !== undefined ? parameters.map : null;

	this.size = parameters.size !== undefined ? parameters.size : 1;
	this.sizeAttenuation = parameters.sizeAttenuation !== undefined ? parameters.sizeAttenuation : true;

	this.vertexColors = parameters.vertexColors !== undefined ? parameters.vertexColors : false;

	this.fog = parameters.fog !== undefined ? parameters.fog : true;

};

THREE.ParticleBasicMaterial.prototype = new THREE.Material();
THREE.ParticleBasicMaterial.prototype.constructor = THREE.ParticleBasicMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <hex>,
 *  program: <function>,
 *  opacity: <float>,
 *  blending: THREE.NormalBlending
 * }
 */

THREE.ParticleCanvasMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.color = parameters.color !== undefined ? new THREE.Color( parameters.color ) : new THREE.Color( 0xffffff );
	this.program = parameters.program !== undefined ? parameters.program : function ( context, color ) {};

};

THREE.ParticleCanvasMaterial.prototype = new THREE.Material();
THREE.ParticleCanvasMaterial.prototype.constructor = THREE.ParticleCanvasMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.ParticleDOMMaterial = function ( domElement ) {

	THREE.Material.call( this );

	this.domElement = domElement;

};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  fragmentShader: <string>,
 *  vertexShader: <string>,

 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },

 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,

 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,

 *  lights: <bool>,
 *  vertexColors: <bool>,
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	parameters = parameters || {};

	this.fragmentShader = parameters.fragmentShader !== undefined ? parameters.fragmentShader : "void main() {}";
	this.vertexShader = parameters.vertexShader !== undefined ? parameters.vertexShader : "void main() {}";
	this.uniforms = parameters.uniforms !== undefined ? parameters.uniforms : {};
	this.attributes = parameters.attributes;

	this.shading = parameters.shading !== undefined ? parameters.shading : THREE.SmoothShading;

	this.wireframe = parameters.wireframe !== undefined ? parameters.wireframe : false;
	this.wireframeLinewidth = parameters.wireframeLinewidth !== undefined ? parameters.wireframeLinewidth : 1;

	this.fog = parameters.fog !== undefined ? parameters.fog : false; // set to use scene fog
	this.lights = parameters.lights !== undefined ? parameters.lights : false; // set to use scene lights
	this.vertexColors = parameters.vertexColors !== undefined ? parameters.vertexColors : false; // set to use "color" attribute stream
	this.skinning = parameters.skinning !== undefined ? parameters.skinning : false; // set to use skinning attribute streams
	this.morphTargets = parameters.morphTargets !== undefined ? parameters.morphTargets : false; // set to use morph targets

};

THREE.ShaderMaterial.prototype = new THREE.Material();
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter ) {

	this.id = THREE.TextureCount ++;

	this.image = image;

	this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	clone: function () {

		var clonedTexture = new THREE.Texture( this.image, this.mapping, this.wrapS, this.wrapT, this.magFilter, this.minFilter );

		clonedTexture.offset.copy( this.offset );
		clonedTexture.repeat.copy( this.repeat );

		return clonedTexture;

	}

};

THREE.TextureCount = 0;

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;

// Mapping modes

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.LatitudeReflectionMapping = function () {};
THREE.LatitudeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

THREE.UVMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 0;
THREE.ClampToEdgeWrapping = 1;
THREE.MirroredRepeatWrapping = 2;

// Filters

THREE.NearestFilter = 3;
THREE.NearestMipMapNearestFilter = 4;
THREE.NearestMipMapLinearFilter = 5;
THREE.LinearFilter = 6;
THREE.LinearMipMapNearestFilter = 7;
THREE.LinearMipMapLinearFilter = 8;

// Types

THREE.ByteType = 9;
THREE.UnsignedByteType = 10;
THREE.ShortType = 11;
THREE.UnsignedShortType = 12;
THREE.IntType = 13;
THREE.UnsignedIntType = 14;
THREE.FloatType = 15;

// Formats

THREE.AlphaFormat = 16;
THREE.RGBFormat = 17;
THREE.RGBAFormat = 18;
THREE.LuminanceFormat = 19;
THREE.LuminanceAlphaFormat = 20;
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, mapping, wrapS, wrapT, magFilter, minFilter ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter );

	this.image = { data: data, width: width, height: height };

	this.format = format !== undefined ? format : THREE.RGBAFormat;

};

THREE.DataTexture.prototype = new THREE.Texture();
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

THREE.DataTexture.prototype.clone = function () {

	var clonedTexture = new THREE.DataTexture( this.data.slice( 0 ), this.mapping, this.wrapS, this.wrapT, this.magFilter, this.minFilter );

	clonedTexture.offset.copy( this.offset );
	clonedTexture.repeat.copy( this.repeat );

	return clonedTexture;

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Particle = function ( material ) {

	THREE.Object3D.call( this );

	this.material = material;

};

THREE.Particle.prototype = new THREE.Object3D();
THREE.Particle.prototype.constructor = THREE.Particle;
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ParticleSystem = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry;
	this.material = material;

	this.sortParticles = false;

};

THREE.ParticleSystem.prototype = new THREE.Object3D();
THREE.ParticleSystem.prototype.constructor = THREE.ParticleSystem;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, type ) {

	THREE.Object3D.call( this );

	this.geometry = geometry;
	this.material = material;

	this.type = ( type !== undefined ) ? type : THREE.LineStrip;

	if ( this.geometry ) {

		if ( ! this.geometry.boundingSphere ) {

			this.geometry.computeBoundingSphere();

		}

	}

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = new THREE.Object3D();
THREE.Line.prototype.constructor = THREE.Line;
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry;
	this.material = material;

	if ( material instanceof Array ) {

		console.warn( 'DEPRECATED: Mesh material can no longer be an Array. Using material at index 0...' );
		this.material = material[ 0 ];

	}

	if ( this.geometry ) {

		// calc bound radius

		if( !this.geometry.boundingSphere ) {

			this.geometry.computeBoundingSphere();

		}

		this.boundRadius = geometry.boundingSphere.radius;


		// setup morph targets

		if( this.geometry.morphTargets.length ) {

			this.morphTargetBase = -1;
			this.morphTargetForcedOrder = [];
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for( var m = 0; m < this.geometry.morphTargets.length; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

			}

		}

	}

}

THREE.Mesh.prototype = new THREE.Object3D();
THREE.Mesh.prototype.constructor = THREE.Mesh;
THREE.Mesh.prototype.supr = THREE.Object3D.prototype;


/*
 * Get Morph Target Index by Name
 */

THREE.Mesh.prototype.getMorphTargetIndexByName = function( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];
	}

	console.log( "THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0." );
	return 0;

}
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Bone = function( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;
	this.skinMatrix = new THREE.Matrix4();

};

THREE.Bone.prototype = new THREE.Object3D();
THREE.Bone.prototype.constructor = THREE.Bone;
THREE.Bone.prototype.supr = THREE.Object3D.prototype;


THREE.Bone.prototype.update = function( parentSkinMatrix, forceUpdate ) {

	// update local

	if ( this.matrixAutoUpdate ) {

		forceUpdate |= this.updateMatrix();

	}

	// update skin matrix

	if ( forceUpdate || this.matrixWorldNeedsUpdate ) {

		if( parentSkinMatrix ) {

			this.skinMatrix.multiply( parentSkinMatrix, this.matrix );

		} else {

			this.skinMatrix.copy( this.matrix );

		}

		this.matrixWorldNeedsUpdate = false;
		forceUpdate = true;

	}

	// update children

	var child, i, l = this.children.length;

	for ( i = 0; i < l; i ++ ) {

		this.children[ i ].update( this.skinMatrix, forceUpdate );

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SkinnedMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	// init bones

	this.identityMatrix = new THREE.Matrix4();

	this.bones = [];
	this.boneMatrices = [];

	var b, bone, gbone, p, q, s;

	if ( this.geometry.bones !== undefined ) {

		for ( b = 0; b < this.geometry.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = this.addBone();

			bone.name = gbone.name;
			bone.position.set( p[0], p[1], p[2] );
			bone.quaternion.set( q[0], q[1], q[2], q[3] );
			bone.useQuaternion = true;

			if ( s !== undefined ) {

				bone.scale.set( s[0], s[1], s[2] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( b = 0; b < this.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];
			bone = this.bones[ b ];

			if ( gbone.parent === -1 ) {

				this.add( bone );

			} else {

				this.bones[ gbone.parent ].add( bone );

			}

		}

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

		this.pose();

	}

};

THREE.SkinnedMesh.prototype = new THREE.Mesh();
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.addBone = function( bone ) {

	if ( bone === undefined ) {

		bone = new THREE.Bone( this );

	}

	this.bones.push( bone );

	return bone;

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function ( force ) {

	this.matrixAutoUpdate && this.updateMatrix();

	// update matrixWorld

	if ( this.matrixWorldNeedsUpdate || force ) {

		if ( this.parent ) {

			this.matrixWorld.multiply( this.parent.matrixWorld, this.matrix );

		} else {

			this.matrixWorld.copy( this.matrix );

		}

		this.matrixWorldNeedsUpdate = false;

		force = true;

	}

	// update children

	for ( var i = 0, l = this.children.length; i < l; i ++ ) {

		var child = this.children[ i ];

		if ( child instanceof THREE.Bone ) {

			child.update( this.identityMatrix, false );

		} else {

			child.updateMatrixWorld( true );

		}

	}

	// flatten bone matrices to array

	var b, bl = this.bones.length,
		ba = this.bones,
		bm = this.boneMatrices;

	for ( b = 0; b < bl; b ++ ) {

		ba[ b ].skinMatrix.flattenToArrayOffset( bm, b * 16 );

	}

};

/*
 * Pose
 */

THREE.SkinnedMesh.prototype.pose = function() {

	this.updateMatrixWorld( true );

	var bim, bone, boneInverses = [];

	for ( var b = 0; b < this.bones.length; b ++ ) {

		bone = this.bones[ b ];

		var inverseMatrix = new THREE.Matrix4();
		inverseMatrix.getInverse( bone.skinMatrix );

		boneInverses.push( inverseMatrix );

		bone.skinMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

	}

	// project vertices to local

	if ( this.geometry.skinVerticesA === undefined ) {

		this.geometry.skinVerticesA = [];
		this.geometry.skinVerticesB = [];

		var orgVertex, vertex;

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			orgVertex = this.geometry.vertices[ i ].position;

			var indexA = this.geometry.skinIndices[ i ].x;
			var indexB = this.geometry.skinIndices[ i ].y;

			vertex = new THREE.Vector3( orgVertex.x, orgVertex.y, orgVertex.z );
			this.geometry.skinVerticesA.push( boneInverses[ indexA ].multiplyVector3( vertex ) );

			vertex = new THREE.Vector3( orgVertex.x, orgVertex.y, orgVertex.z );
			this.geometry.skinVerticesB.push( boneInverses[ indexB ].multiplyVector3( vertex ) );

			// todo: add more influences

			// normalize weights

			if ( this.geometry.skinWeights[ i ].x + this.geometry.skinWeights[ i ].y !== 1 ) {

				var len = ( 1.0 - ( this.geometry.skinWeights[ i ].x + this.geometry.skinWeights[ i ].y ) ) * 0.5;
				this.geometry.skinWeights[ i ].x += len;
				this.geometry.skinWeights[ i ].y += len;

			}

		}

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype = new THREE.Mesh();
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / ( this.geometry.morphTargets.length - 1 );

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= -1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

	}

	var keyframe = THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.geometry.morphTargets.length - 1 );

	if ( keyframe != this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Ribbon = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry;
	this.material = material;

};

THREE.Ribbon.prototype = new THREE.Object3D();
THREE.Ribbon.prototype.constructor = THREE.Ribbon;
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.LODs = [];

};

THREE.LOD.prototype = new THREE.Object3D();
THREE.LOD.prototype.constructor = THREE.LOD;
THREE.LOD.prototype.supr = THREE.Object3D.prototype;

THREE.LOD.prototype.addLevel = function ( object3D, visibleAtDistance ) {

	if ( visibleAtDistance === undefined ) {

		visibleAtDistance = 0;

	}

	visibleAtDistance = Math.abs( visibleAtDistance );

	for ( var l = 0; l < this.LODs.length; l++ ) {

		if ( visibleAtDistance < this.LODs[ l ].visibleAtDistance ) {

			break;

		}

	}

	this.LODs.splice( l, 0, { visibleAtDistance: visibleAtDistance, object3D: object3D } );
	this.add( object3D );

};

THREE.LOD.prototype.update = function ( camera ) {

	if ( this.LODs.length > 1 ) {

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		var inverse  = camera.matrixWorldInverse;
		var radius   = this.boundRadius * this.boundRadiusScale;
		var distance = -( inverse.n31 * this.position.x + inverse.n32 * this.position.y + inverse.n33 * this.position.z + inverse.n34 );

		this.LODs[ 0 ].object3D.visible = true;

		for ( var l = 1; l < this.LODs.length; l ++ ) {

			if( distance >= this.LODs[ l ].visibleAtDistance ) {

				this.LODs[ l - 1 ].object3D.visible = false;
				this.LODs[ l     ].object3D.visible = true;

			} else {

				break;

			}

		}

		for( ; l < this.LODs.length; l ++ ) {

			this.LODs[ l ].object3D.visible = false;

		}

	}

};
/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.Sprite = function ( parameters ) {

	THREE.Object3D.call( this );

	this.color = ( parameters.color !== undefined ) ? new THREE.Color( parameters.color ) : new THREE.Color( 0xffffff );
	this.map = ( parameters.map instanceof THREE.Texture ) ? parameters.map : THREE.ImageUtils.loadTexture( parameters.map );
	this.blending = ( parameters.blending !== undefined ) ? parameters.blending : THREE.NormalBlending;

	this.useScreenCoordinates = ( parameters.useScreenCoordinates !== undefined ) ? parameters.useScreenCoordinates : true;
	this.mergeWith3D = ( parameters.mergeWith3D !== undefined ) ? parameters.mergeWith3D : !this.useScreenCoordinates;
	this.affectedByDistance = ( parameters.affectedByDistance !== undefined ) ? parameters.affectedByDistance : !this.useScreenCoordinates;
	this.scaleByViewport = ( parameters.scaleByViewport !== undefined ) ? parameters.scaleByViewport : !this.affectedByDistance;
	this.alignment = ( parameters.alignment instanceof THREE.Vector2 ) ? parameters.alignment : THREE.SpriteAlignment.center;

	this.rotation3d = this.rotation;
	this.rotation = 0;
	this.opacity = 1;

	this.uvOffset = new THREE.Vector2( 0, 0 );
	this.uvScale  = new THREE.Vector2( 1, 1 );

};

THREE.Sprite.prototype = new THREE.Object3D();
THREE.Sprite.prototype.constructor = THREE.Sprite;


/*
 * Custom update matrix
 */

THREE.Sprite.prototype.updateMatrix = function () {

	this.matrix.setPosition( this.position );

	this.rotation3d.set( 0, 0, this.rotation );
	this.matrix.setRotationFromEuler( this.rotation3d );

	if ( this.scale.x !== 1 || this.scale.y !== 1 ) {

		this.matrix.scale( this.scale );
		this.boundRadiusScale = Math.max( this.scale.x, this.scale.y );

	}

	this.matrixWorldNeedsUpdate = true;

};

/*
 * Alignment
 */

THREE.SpriteAlignment = {};
THREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );
THREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );
THREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );
THREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );
THREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );
THREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );
THREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );
THREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );
THREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.fog = null;
	this.overrideMaterial = null;

	this.matrixAutoUpdate = false;

	this.objects = [];
	this.lights = [];

	this.__objectsAdded = [];
	this.__objectsRemoved = [];

};

THREE.Scene.prototype = new THREE.Object3D();
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.addObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		if ( this.lights.indexOf( object ) === - 1 ) {

			this.lights.push( object );

		}

	} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {

		if ( this.objects.indexOf( object ) === - 1 ) {

			this.objects.push( object );
			this.__objectsAdded.push( object );

			// check if previously removed

			var i = this.__objectsRemoved.indexOf( object );

			if ( i !== -1 ) {

				this.__objectsRemoved.splice( i, 1 );

			}

		}

	}

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.addObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.removeObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		var i = this.lights.indexOf( object );

		if ( i !== -1 ) {

			this.lights.splice( i, 1 );

		}

	} else if ( !( object instanceof THREE.Camera ) ) {

		var i = this.objects.indexOf( object );

		if( i !== -1 ) {

			this.objects.splice( i, 1 );
			this.__objectsRemoved.push( object );

			// check if previously added

			var ai = this.__objectsAdded.indexOf( object );

			if ( ai !== -1 ) {

				this.__objectsAdded.splice( ai, 1 );

			}

		}

	}

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.removeObject( object.children[ c ] );

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( hex, near, far ) {

	this.color = new THREE.Color( hex );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};
/**
 * @author mr.doob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( hex, density ) {

	this.color = new THREE.Color( hex );
	this.density = ( density !== undefined ) ? density : 0.00025;

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.DOMRenderer = function () {

	THREE.Renderer.call( this );

	var _renderList = null,
	_projector = new THREE.Projector(),
	_div = document.createElement( 'div' ),
	_width, _height, _widthHalf, _heightHalf;

	this.domElement = _div;

	this.setSize = function ( width, height ) {

		_width = width; _height = height;
		_widthHalf = _width / 2; _heightHalf = _height / 2;

	};

	this.render = function ( scene, camera ) {

		var e, el, m, ml, element, material, dom, v1x, v1y;

		_renderList = _projector.projectScene( scene, camera );

		for ( e = 0, el = _renderList.length; e < el; e++ ) {

			element = _renderList[ e ];

			if ( element instanceof THREE.RenderableParticle ) {

				v1x = element.x * _widthHalf + _widthHalf; v1y = element.y * _heightHalf + _heightHalf;

				for ( m = 0, ml = element.material.length; m < ml; m++ ) {

					material = element.material[ m ];

					if ( material instanceof THREE.ParticleDOMMaterial ) {

						dom = material.domElement;
						dom.style.left = v1x + 'px';
						dom.style.top = v1y + 'px';

					}

				}

			}

		}

	};

}
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.CanvasRenderer = function ( parameters ) {

	var _this = this,
	_renderData, _elements, _lights,
	_projector = new THREE.Projector(),

	parameters = parameters || {},

	_canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),

	_canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf,
	_context = _canvas.getContext( '2d' ),

	_clearColor = new THREE.Color( 0x000000 ),
	_clearOpacity = 0,

	_contextGlobalAlpha = 1,
	_contextGlobalCompositeOperation = 0,
	_contextStrokeStyle = null,
	_contextFillStyle = null,
	_contextLineWidth = null,
	_contextLineCap = null,
	_contextLineJoin = null,

	_v1, _v2, _v3, _v4,
	_v5 = new THREE.RenderableVertex(),
	_v6 = new THREE.RenderableVertex(),

	_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,
	_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,

	_color = new THREE.Color(),
	_color1 = new THREE.Color(),
	_color2 = new THREE.Color(),
	_color3 = new THREE.Color(),
	_color4 = new THREE.Color(),

	_patterns = [], _imagedatas = [],

	_near, _far,

	_image, _uvs,
	_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,

	_clipRect = new THREE.Rectangle(),
	_clearRect = new THREE.Rectangle(),
	_bboxRect = new THREE.Rectangle(),

	_enableLighting = false,
	_ambientLight = new THREE.Color(),
	_directionalLights = new THREE.Color(),
	_pointLights = new THREE.Color(),

	_pi2 = Math.PI * 2,
	_vector3 = new THREE.Vector3(), // Needed for PointLight

	_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,
	_gradientMap, _gradientMapContext, _gradientMapQuality = 16;

	_pixelMap = document.createElement( 'canvas' );
	_pixelMap.width = _pixelMap.height = 2;

	_pixelMapContext = _pixelMap.getContext( '2d' );
	_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
	_pixelMapContext.fillRect( 0, 0, 2, 2 );

	_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );
	_pixelMapData = _pixelMapImage.data;

	_gradientMap = document.createElement( 'canvas' );
	_gradientMap.width = _gradientMap.height = _gradientMapQuality;

	_gradientMapContext = _gradientMap.getContext( '2d' );
	_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );
	_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );

	_gradientMapQuality --; // Fix UVs

	this.domElement = _canvas;

	this.autoClear = true;
	this.sortObjects = true;
	this.sortElements = true;

	this.info = {

		render: {

			vertices: 0,
			faces: 0

		}

	}

	this.setSize = function ( width, height ) {

		_canvasWidth = width;
		_canvasHeight = height;
		_canvasWidthHalf = Math.floor( _canvasWidth / 2 );
		_canvasHeightHalf = Math.floor( _canvasHeight / 2 );

		_canvas.width = _canvasWidth;
		_canvas.height = _canvasHeight;

		_clipRect.set( - _canvasWidthHalf, - _canvasHeightHalf, _canvasWidthHalf, _canvasHeightHalf );
		_clearRect.set( - _canvasWidthHalf, - _canvasHeightHalf, _canvasWidthHalf, _canvasHeightHalf );

		_contextGlobalAlpha = 1;
		_contextGlobalCompositeOperation = 0;
		_contextStrokeStyle = null;
		_contextFillStyle = null;
		_contextLineWidth = null;
		_contextLineCap = null;
		_contextLineJoin = null;

	};

	this.setClearColor = function( color, opacity ) {

		_clearColor.copy( color );
		_clearOpacity = opacity;

		_clearRect.set( - _canvasWidthHalf, - _canvasHeightHalf, _canvasWidthHalf, _canvasHeightHalf );

	};

	this.setClearColorHex = function( hex, opacity ) {

		_clearColor.setHex( hex );
		_clearOpacity = opacity;

		_clearRect.set( - _canvasWidthHalf, - _canvasHeightHalf, _canvasWidthHalf, _canvasHeightHalf );

	};

	this.clear = function () {

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		if ( !_clearRect.isEmpty() ) {

			_clearRect.minSelf( _clipRect );
			_clearRect.inflate( 2 );

			if ( _clearOpacity < 1 ) {

				_context.clearRect( Math.floor( _clearRect.getX() ), Math.floor( _clearRect.getY() ), Math.floor( _clearRect.getWidth() ), Math.floor( _clearRect.getHeight() ) );

			}

			if ( _clearOpacity > 0 ) {

				setBlending( THREE.NormalBlending );
				setOpacity( 1 );

				setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearOpacity + ')' );

				_context.fillRect( Math.floor( _clearRect.getX() ), Math.floor( _clearRect.getY() ), Math.floor( _clearRect.getWidth() ), Math.floor( _clearRect.getHeight() ) );

			}

			_clearRect.empty();

		}


	};

	this.render = function ( scene, camera ) {

		var e, el, element, material;

		this.autoClear ? this.clear() : _context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;

		_renderData = _projector.projectScene( scene, camera, this.sortElements );
		_elements = _renderData.elements;
		_lights = _renderData.lights;

		/* DEBUG
		_context.fillStyle = 'rgba( 0, 255, 255, 0.5 )';
		_context.fillRect( _clipRect.getX(), _clipRect.getY(), _clipRect.getWidth(), _clipRect.getHeight() );
		*/

		_enableLighting = _lights.length > 0;

		if ( _enableLighting ) {

			 calculateLights( _lights );

		}

		for ( e = 0, el = _elements.length; e < el; e++ ) {

			element = _elements[ e ];

			material = element.material;
			material = material instanceof THREE.MeshFaceMaterial ? element.faceMaterial : material;

			if ( material == null || material.opacity == 0 ) continue;

			_bboxRect.empty();

			if ( element instanceof THREE.RenderableParticle ) {

				_v1 = element;
				_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;

				renderParticle( _v1, element, material, scene );

			} else if ( element instanceof THREE.RenderableLine ) {

				_v1 = element.v1; _v2 = element.v2;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;

				_bboxRect.addPoint( _v1.positionScreen.x, _v1.positionScreen.y );
				_bboxRect.addPoint( _v2.positionScreen.x, _v2.positionScreen.y );

				if ( _clipRect.intersects( _bboxRect ) ) {

					renderLine( _v1, _v2, element, material, scene );

				}


			} else if ( element instanceof THREE.RenderableFace3 ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
				_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;

				if ( material.overdraw ) {

					expand( _v1.positionScreen, _v2.positionScreen );
					expand( _v2.positionScreen, _v3.positionScreen );
					expand( _v3.positionScreen, _v1.positionScreen );

				}

				_bboxRect.add3Points( _v1.positionScreen.x, _v1.positionScreen.y,
						      _v2.positionScreen.x, _v2.positionScreen.y,
						      _v3.positionScreen.x, _v3.positionScreen.y );

				if ( _clipRect.intersects( _bboxRect ) ) {

					renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material, scene );

				}

			} else if ( element instanceof THREE.RenderableFace4 ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3; _v4 = element.v4;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
				_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;
				_v4.positionScreen.x *= _canvasWidthHalf; _v4.positionScreen.y *= _canvasHeightHalf;

				_v5.positionScreen.copy( _v2.positionScreen );
				_v6.positionScreen.copy( _v4.positionScreen );

				if ( material.overdraw ) {

					expand( _v1.positionScreen, _v2.positionScreen );
					expand( _v2.positionScreen, _v4.positionScreen );
					expand( _v4.positionScreen, _v1.positionScreen );

					expand( _v3.positionScreen, _v5.positionScreen );
					expand( _v3.positionScreen, _v6.positionScreen );

				}

				_bboxRect.addPoint( _v1.positionScreen.x, _v1.positionScreen.y );
				_bboxRect.addPoint( _v2.positionScreen.x, _v2.positionScreen.y );
				_bboxRect.addPoint( _v3.positionScreen.x, _v3.positionScreen.y );
				_bboxRect.addPoint( _v4.positionScreen.x, _v4.positionScreen.y );

				if ( _clipRect.intersects( _bboxRect ) ) {

					renderFace4( _v1, _v2, _v3, _v4, _v5, _v6, element, material, scene );

				}

			}

			/*
			_context.lineWidth = 1;
			_context.strokeStyle = 'rgba( 0, 255, 0, 0.5 )';
			_context.strokeRect( _bboxRect.getX(), _bboxRect.getY(), _bboxRect.getWidth(), _bboxRect.getHeight() );
			*/

			_clearRect.addRectangle( _bboxRect );


		}

		/* DEBUG
		_context.lineWidth = 1;
		_context.strokeStyle = 'rgba( 255, 0, 0, 0.5 )';
		_context.strokeRect( _clearRect.getX(), _clearRect.getY(), _clearRect.getWidth(), _clearRect.getHeight() );
		*/

		_context.setTransform( 1, 0, 0, 1, 0, 0 );

		//

		function calculateLights( lights ) {

			var l, ll, light, lightColor;

			_ambientLight.setRGB( 0, 0, 0 );
			_directionalLights.setRGB( 0, 0, 0 );
			_pointLights.setRGB( 0, 0, 0 );

			for ( l = 0, ll = lights.length; l < ll; l ++ ) {

				light = lights[ l ];
				lightColor = light.color;

				if ( light instanceof THREE.AmbientLight ) {

					_ambientLight.r += lightColor.r;
					_ambientLight.g += lightColor.g;
					_ambientLight.b += lightColor.b;

				} else if ( light instanceof THREE.DirectionalLight ) {

					// for particles

					_directionalLights.r += lightColor.r;
					_directionalLights.g += lightColor.g;
					_directionalLights.b += lightColor.b;

				} else if ( light instanceof THREE.PointLight ) {

					// for particles

					_pointLights.r += lightColor.r;
					_pointLights.g += lightColor.g;
					_pointLights.b += lightColor.b;

				}

			}

		}

		function calculateLight( lights, position, normal, color ) {

			var l, ll, light, lightColor, lightPosition, amount;

			for ( l = 0, ll = lights.length; l < ll; l ++ ) {

				light = lights[ l ];
				lightColor = light.color;

				if ( light instanceof THREE.DirectionalLight ) {

					lightPosition = light.matrixWorld.getPosition();

					amount = normal.dot( lightPosition );

					if ( amount <= 0 ) continue;

					amount *= light.intensity;

					color.r += lightColor.r * amount;
					color.g += lightColor.g * amount;
					color.b += lightColor.b * amount;

				} else if ( light instanceof THREE.PointLight ) {

					lightPosition = light.matrixWorld.getPosition();

					amount = normal.dot( _vector3.sub( lightPosition, position ).normalize() );

					if ( amount <= 0 ) continue;

					amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

					if ( amount == 0 ) continue;

					amount *= light.intensity;

					color.r += lightColor.r * amount;
					color.g += lightColor.g * amount;
					color.b += lightColor.b * amount;

				}

			}

		}

		function renderParticle ( v1, element, material, scene ) {

			setOpacity( material.opacity );
			setBlending( material.blending );

			var width, height, scaleX, scaleY,
			bitmap, bitmapWidth, bitmapHeight;

			if ( material instanceof THREE.ParticleBasicMaterial ) {

				if ( material.map ) {

					bitmap = material.map.image;
					bitmapWidth = bitmap.width >> 1;
					bitmapHeight = bitmap.height >> 1;

					scaleX = element.scale.x * _canvasWidthHalf;
					scaleY = element.scale.y * _canvasHeightHalf;

					width = scaleX * bitmapWidth;
					height = scaleY * bitmapHeight;

					// TODO: Rotations break this...

					_bboxRect.set( v1.x - width, v1.y - height, v1.x  + width, v1.y + height );

					if ( !_clipRect.intersects( _bboxRect ) ) {

						return;

					}

					_context.save();
					_context.translate( v1.x, v1.y );
					_context.rotate( - element.rotation );
					_context.scale( scaleX, - scaleY );

					_context.translate( - bitmapWidth, - bitmapHeight );
					_context.drawImage( bitmap, 0, 0 );

					_context.restore();

				}

				/* DEBUG
				_context.beginPath();
				_context.moveTo( v1.x - 10, v1.y );
				_context.lineTo( v1.x + 10, v1.y );
				_context.moveTo( v1.x, v1.y - 10 );
				_context.lineTo( v1.x, v1.y + 10 );
				_context.closePath();
				_context.strokeStyle = 'rgb(255,255,0)';
				_context.stroke();
				*/

			} else if ( material instanceof THREE.ParticleCanvasMaterial ) {

				width = element.scale.x * _canvasWidthHalf;
				height = element.scale.y * _canvasHeightHalf;

				_bboxRect.set( v1.x - width, v1.y - height, v1.x + width, v1.y + height );

				if ( !_clipRect.intersects( _bboxRect ) ) {

					return;

				}

				setStrokeStyle( material.color.getContextStyle() );
				setFillStyle( material.color.getContextStyle() );

				_context.save();
				_context.translate( v1.x, v1.y );
				_context.rotate( - element.rotation );
				_context.scale( width, height );

				material.program( _context );

				_context.restore();

			}

		}

		function renderLine( v1, v2, element, material, scene ) {

			setOpacity( material.opacity );
			setBlending( material.blending );

			_context.beginPath();
			_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
			_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );
			_context.closePath();

			if ( material instanceof THREE.LineBasicMaterial ) {

				setLineWidth( material.linewidth );
				setLineCap( material.linecap );
				setLineJoin( material.linejoin );
				setStrokeStyle( material.color.getContextStyle() );

				_context.stroke();
				_bboxRect.inflate( material.linewidth * 2 );

			}

		}

		function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material, scene ) {

			_this.info.render.vertices += 3;
			_this.info.render.faces ++;

			setOpacity( material.opacity );
			setBlending( material.blending );

			_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
			_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
			_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;

			drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );

			if ( material instanceof THREE.MeshBasicMaterial ) {

				if ( material.map/* && !material.wireframe*/ ) {

					if ( material.map.mapping instanceof THREE.UVMapping ) {

						_uvs = element.uvs[ 0 ];
						patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].u, _uvs[ uv1 ].v, _uvs[ uv2 ].u, _uvs[ uv2 ].v, _uvs[ uv3 ].u, _uvs[ uv3 ].v, material.map );

					}


				} else if ( material.envMap ) {

					if ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {

						var cameraMatrix = camera.matrixWorldInverse;

						_vector3.copy( element.vertexNormalsWorld[ uv1 ] );
						_uv1x = ( _vector3.x * cameraMatrix.n11 + _vector3.y * cameraMatrix.n12 + _vector3.z * cameraMatrix.n13 ) * 0.5 + 0.5;
						_uv1y = - ( _vector3.x * cameraMatrix.n21 + _vector3.y * cameraMatrix.n22 + _vector3.z * cameraMatrix.n23 ) * 0.5 + 0.5;

						_vector3.copy( element.vertexNormalsWorld[ uv2 ] );
						_uv2x = ( _vector3.x * cameraMatrix.n11 + _vector3.y * cameraMatrix.n12 + _vector3.z * cameraMatrix.n13 ) * 0.5 + 0.5;
						_uv2y = - ( _vector3.x * cameraMatrix.n21 + _vector3.y * cameraMatrix.n22 + _vector3.z * cameraMatrix.n23 ) * 0.5 + 0.5;

						_vector3.copy( element.vertexNormalsWorld[ uv3 ] );
						_uv3x = ( _vector3.x * cameraMatrix.n11 + _vector3.y * cameraMatrix.n12 + _vector3.z * cameraMatrix.n13 ) * 0.5 + 0.5;
						_uv3y = - ( _vector3.x * cameraMatrix.n21 + _vector3.y * cameraMatrix.n22 + _vector3.z * cameraMatrix.n23 ) * 0.5 + 0.5;

						patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );

					}/* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {

						

					}*/


				} else {

					material.wireframe ? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin ) : fillPath( material.color );

				}

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				if ( material.map && !material.wireframe ) {

					if ( material.map.mapping instanceof THREE.UVMapping ) {

						_uvs = element.uvs[ 0 ];
						patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].u, _uvs[ uv1 ].v, _uvs[ uv2 ].u, _uvs[ uv2 ].v, _uvs[ uv3 ].u, _uvs[ uv3 ].v, material.map );

					}

					setBlending( THREE.SubtractiveBlending );

				}

				if ( _enableLighting ) {

					if ( !material.wireframe && material.shading == THREE.SmoothShading && element.vertexNormalsWorld.length == 3 ) {

						_color1.r = _color2.r = _color3.r = _ambientLight.r;
						_color1.g = _color2.g = _color3.g = _ambientLight.g;
						_color1.b = _color2.b = _color3.b = _ambientLight.b;

						calculateLight( _lights, element.v1.positionWorld, element.vertexNormalsWorld[ 0 ], _color1 );
						calculateLight( _lights, element.v2.positionWorld, element.vertexNormalsWorld[ 1 ], _color2 );
						calculateLight( _lights, element.v3.positionWorld, element.vertexNormalsWorld[ 2 ], _color3 );

						_color1.r = Math.max( 0, Math.min( material.color.r * _color1.r, 1 ) );
						_color1.g = Math.max( 0, Math.min( material.color.g * _color1.g, 1 ) );
						_color1.b = Math.max( 0, Math.min( material.color.b * _color1.b, 1 ) );

						_color2.r = Math.max( 0, Math.min( material.color.r * _color2.r, 1 ) );
						_color2.g = Math.max( 0, Math.min( material.color.g * _color2.g, 1 ) );
						_color2.b = Math.max( 0, Math.min( material.color.b * _color2.b, 1 ) );

						_color3.r = Math.max( 0, Math.min( material.color.r * _color3.r, 1 ) );
						_color3.g = Math.max( 0, Math.min( material.color.g * _color3.g, 1 ) );
						_color3.b = Math.max( 0, Math.min( material.color.b * _color3.b, 1 ) );

						_color4.r = ( _color2.r + _color3.r ) * 0.5;
						_color4.g = ( _color2.g + _color3.g ) * 0.5;
						_color4.b = ( _color2.b + _color3.b ) * 0.5;

						_image = getGradientTexture( _color1, _color2, _color3, _color4 );

						clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

					} else {

						_color.r = _ambientLight.r;
						_color.g = _ambientLight.g;
						_color.b = _ambientLight.b;

						calculateLight( _lights, element.centroidWorld, element.normalWorld, _color );

						_color.r = Math.max( 0, Math.min( material.color.r * _color.r, 1 ) );
						_color.g = Math.max( 0, Math.min( material.color.g * _color.g, 1 ) );
						_color.b = Math.max( 0, Math.min( material.color.b * _color.b, 1 ) );

						material.wireframe ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin ) : fillPath( _color );

					}

				} else {

					material.wireframe ? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin ) : fillPath( material.color );

				}

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				_near = camera.near;
				_far = camera.far;

				_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z, _near, _far );
				_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z, _near, _far );
				_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z, _near, _far );

				_color4.r = ( _color2.r + _color3.r ) * 0.5;
				_color4.g = ( _color2.g + _color3.g ) * 0.5;
				_color4.b = ( _color2.b + _color3.b ) * 0.5;

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				_color.r = normalToComponent( element.normalWorld.x );
				_color.g = normalToComponent( element.normalWorld.y );
				_color.b = normalToComponent( element.normalWorld.z );

				material.wireframe ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin ) : fillPath( _color );

			}

		}

		function renderFace4( v1, v2, v3, v4, v5, v6, element, material, scene ) {

			_this.info.render.vertices += 4;
			_this.info.render.faces ++;

			setOpacity( material.opacity );
			setBlending( material.blending );

			if ( material.map || material.envMap ) {

				// Let renderFace3() handle this

				renderFace3( v1, v2, v4, 0, 1, 3, element, material, scene );
				renderFace3( v5, v3, v6, 1, 2, 3, element, material, scene );

				return;

			}

			_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
			_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
			_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;
			_v4x = v4.positionScreen.x; _v4y = v4.positionScreen.y;
			_v5x = v5.positionScreen.x; _v5y = v5.positionScreen.y;
			_v6x = v6.positionScreen.x; _v6y = v6.positionScreen.y;

			if ( material instanceof THREE.MeshBasicMaterial ) {

				drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );

				material.wireframe ? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin ) : fillPath( material.color );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				if ( _enableLighting ) {

					if ( !material.wireframe && material.shading == THREE.SmoothShading && element.vertexNormalsWorld.length == 4 ) {

						_color1.r = _color2.r = _color3.r = _color4.r = _ambientLight.r;
						_color1.g = _color2.g = _color3.g = _color4.g = _ambientLight.g;
						_color1.b = _color2.b = _color3.b = _color4.b = _ambientLight.b;

						calculateLight( _lights, element.v1.positionWorld, element.vertexNormalsWorld[ 0 ], _color1 );
						calculateLight( _lights, element.v2.positionWorld, element.vertexNormalsWorld[ 1 ], _color2 );
						calculateLight( _lights, element.v4.positionWorld, element.vertexNormalsWorld[ 3 ], _color3 );
						calculateLight( _lights, element.v3.positionWorld, element.vertexNormalsWorld[ 2 ], _color4 );

						_color1.r = Math.max( 0, Math.min( material.color.r * _color1.r, 1 ) );
						_color1.g = Math.max( 0, Math.min( material.color.g * _color1.g, 1 ) );
						_color1.b = Math.max( 0, Math.min( material.color.b * _color1.b, 1 ) );

						_color2.r = Math.max( 0, Math.min( material.color.r * _color2.r, 1 ) );
						_color2.g = Math.max( 0, Math.min( material.color.g * _color2.g, 1 ) );
						_color2.b = Math.max( 0, Math.min( material.color.b * _color2.b, 1 ) );

						_color3.r = Math.max( 0, Math.min( material.color.r * _color3.r, 1 ) );
						_color3.g = Math.max( 0, Math.min( material.color.g * _color3.g, 1 ) );
						_color3.b = Math.max( 0, Math.min( material.color.b * _color3.b, 1 ) );

						_color4.r = Math.max( 0, Math.min( material.color.r * _color4.r, 1 ) );
						_color4.g = Math.max( 0, Math.min( material.color.g * _color4.g, 1 ) );
						_color4.b = Math.max( 0, Math.min( material.color.b * _color4.b, 1 ) );

						_image = getGradientTexture( _color1, _color2, _color3, _color4 );

						// TODO: UVs are incorrect, v4->v3?

						drawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );
						clipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );

						drawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );
						clipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );

					} else {

						_color.r = _ambientLight.r;
						_color.g = _ambientLight.g;
						_color.b = _ambientLight.b;

						calculateLight( _lights, element.centroidWorld, element.normalWorld, _color );

						_color.r = Math.max( 0, Math.min( material.color.r * _color.r, 1 ) );
						_color.g = Math.max( 0, Math.min( material.color.g * _color.g, 1 ) );
						_color.b = Math.max( 0, Math.min( material.color.b * _color.b, 1 ) );

						drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );

						material.wireframe ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin ) : fillPath( _color );

					}

				} else {

					drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );

					material.wireframe ? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin ) : fillPath( material.color );

				}

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				_color.r = normalToComponent( element.normalWorld.x );
				_color.g = normalToComponent( element.normalWorld.y );
				_color.b = normalToComponent( element.normalWorld.z );

				drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );

				material.wireframe ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin ) : fillPath( _color );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				_near = camera.near;
				_far = camera.far;

				_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z, _near, _far );
				_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z, _near, _far );
				_color3.r = _color3.g = _color3.b = 1 - smoothstep( v4.positionScreen.z, _near, _far );
				_color4.r = _color4.g = _color4.b = 1 - smoothstep( v3.positionScreen.z, _near, _far );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				// TODO: UVs are incorrect, v4->v3?

				drawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );
				clipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );

				drawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );
				clipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );

			}

		}

		//

		function drawTriangle( x0, y0, x1, y1, x2, y2 ) {

			_context.beginPath();
			_context.moveTo( x0, y0 );
			_context.lineTo( x1, y1 );
			_context.lineTo( x2, y2 );
			_context.lineTo( x0, y0 );
			_context.closePath();

		}

		function drawQuad( x0, y0, x1, y1, x2, y2, x3, y3 ) {

			_context.beginPath();
			_context.moveTo( x0, y0 );
			_context.lineTo( x1, y1 );
			_context.lineTo( x2, y2 );
			_context.lineTo( x3, y3 );
			_context.lineTo( x0, y0 );
			_context.closePath();

		}

		function strokePath( color, linewidth, linecap, linejoin ) {

			setLineWidth( linewidth );
			setLineCap( linecap );
			setLineJoin( linejoin );
			setStrokeStyle( color.getContextStyle() );

			_context.stroke();

			_bboxRect.inflate( linewidth * 2 );

		}

		function fillPath( color ) {

			setFillStyle( color.getContextStyle() );
			_context.fill();

		}

		function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {

			if ( texture.image.width == 0 ) return;

			if ( texture.needsUpdate == true || _patterns[ texture.id ] == undefined ) {

				var repeatX = texture.wrapS == THREE.RepeatWrapping;
				var repeatY = texture.wrapT == THREE.RepeatWrapping;

				_patterns[ texture.id ] = _context.createPattern( texture.image, repeatX && repeatY ? 'repeat' : repeatX && !repeatY ? 'repeat-x' : !repeatX && repeatY ? 'repeat-y' : 'no-repeat' );

				texture.needsUpdate = false;

			}

			setFillStyle( _patterns[ texture.id ] );

			// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

			var a, b, c, d, e, f, det, idet,
			offsetX = texture.offset.x / texture.repeat.x,
			offsetY = texture.offset.y / texture.repeat.y,
			width = texture.image.width * texture.repeat.x,
			height = texture.image.height * texture.repeat.y;

			u0 = ( u0 + offsetX ) * width;
			v0 = ( v0 + offsetY ) * height;

			u1 = ( u1 + offsetX ) * width;
			v1 = ( v1 + offsetY ) * height;

			u2 = ( u2 + offsetX ) * width;
			v2 = ( v2 + offsetY ) * height;

			x1 -= x0; y1 -= y0;
			x2 -= x0; y2 -= y0;

			u1 -= u0; v1 -= v0;
			u2 -= u0; v2 -= v0;

			det = u1 * v2 - u2 * v1;

			if ( det == 0 ) {

				if ( _imagedatas[ texture.id ] == undefined ) {

					var canvas = document.createElement( 'canvas' )
					canvas.width = texture.image.width;
					canvas.height = texture.image.height;

					var context = canvas.getContext( '2d' );
					context.drawImage( texture.image, 0, 0 );

					_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;

					delete canvas;

				}

				var data = _imagedatas[ texture.id ];
				var index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;

				_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );
				fillPath( _color );

				return;

			}

			idet = 1 / det;

			a = ( v2 * x1 - v1 * x2 ) * idet;
			b = ( v2 * y1 - v1 * y2 ) * idet;
			c = ( u1 * x2 - u2 * x1 ) * idet;
			d = ( u1 * y2 - u2 * y1 ) * idet;

			e = x0 - a * u0 - c * v0;
			f = y0 - b * u0 - d * v0;

			_context.save();
			_context.transform( a, b, c, d, e, f );
			_context.fill();
			_context.restore();

		}

		function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {

			// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

			var a, b, c, d, e, f, det, idet,
			width = image.width - 1,
			height = image.height - 1;

			u0 *= width; v0 *= height;
			u1 *= width; v1 *= height;
			u2 *= width; v2 *= height;

			x1 -= x0; y1 -= y0;
			x2 -= x0; y2 -= y0;

			u1 -= u0; v1 -= v0;
			u2 -= u0; v2 -= v0;

			det = u1 * v2 - u2 * v1;

			idet = 1 / det;

			a = ( v2 * x1 - v1 * x2 ) * idet;
			b = ( v2 * y1 - v1 * y2 ) * idet;
			c = ( u1 * x2 - u2 * x1 ) * idet;
			d = ( u1 * y2 - u2 * y1 ) * idet;

			e = x0 - a * u0 - c * v0;
			f = y0 - b * u0 - d * v0;

			_context.save();
			_context.transform( a, b, c, d, e, f );
			_context.clip();
			_context.drawImage( image, 0, 0 );
			_context.restore();

		}

		function getGradientTexture( color1, color2, color3, color4 ) {

			// http://mrdoob.com/blog/post/710

			var c1r = ~~ ( color1.r * 255 ), c1g = ~~ ( color1.g * 255 ), c1b = ~~ ( color1.b * 255 ),
			c2r = ~~ ( color2.r * 255 ), c2g = ~~ ( color2.g * 255 ), c2b = ~~ ( color2.b * 255 ),
			c3r = ~~ ( color3.r * 255 ), c3g = ~~ ( color3.g * 255 ), c3b = ~~ ( color3.b * 255 ),
			c4r = ~~ ( color4.r * 255 ), c4g = ~~ ( color4.g * 255 ), c4b = ~~ ( color4.b * 255 );

			_pixelMapData[ 0 ] = c1r < 0 ? 0 : c1r > 255 ? 255 : c1r;
			_pixelMapData[ 1 ] = c1g < 0 ? 0 : c1g > 255 ? 255 : c1g;
			_pixelMapData[ 2 ] = c1b < 0 ? 0 : c1b > 255 ? 255 : c1b;

			_pixelMapData[ 4 ] = c2r < 0 ? 0 : c2r > 255 ? 255 : c2r;
			_pixelMapData[ 5 ] = c2g < 0 ? 0 : c2g > 255 ? 255 : c2g;
			_pixelMapData[ 6 ] = c2b < 0 ? 0 : c2b > 255 ? 255 : c2b;

			_pixelMapData[ 8 ] = c3r < 0 ? 0 : c3r > 255 ? 255 : c3r;
			_pixelMapData[ 9 ] = c3g < 0 ? 0 : c3g > 255 ? 255 : c3g;
			_pixelMapData[ 10 ] = c3b < 0 ? 0 : c3b > 255 ? 255 : c3b;

			_pixelMapData[ 12 ] = c4r < 0 ? 0 : c4r > 255 ? 255 : c4r;
			_pixelMapData[ 13 ] = c4g < 0 ? 0 : c4g > 255 ? 255 : c4g;
			_pixelMapData[ 14 ] = c4b < 0 ? 0 : c4b > 255 ? 255 : c4b;

			_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );
			_gradientMapContext.drawImage( _pixelMap, 0, 0 );

			return _gradientMap;

		}

		function smoothstep( value, min, max ) {

			var x = ( value - min ) / ( max - min );
			return x * x * ( 3 - 2 * x );

		}

		function normalToComponent( normal ) {

			var component = ( normal + 1 ) * 0.5;
			return component < 0 ? 0 : ( component > 1 ? 1 : component );

		}

		// Hide anti-alias gaps

		function expand( v1, v2 ) {

			var x = v2.x - v1.x, y =  v2.y - v1.y,
			det = x * x + y * y, idet;

			if ( det == 0 ) return;

			idet = 1 / Math.sqrt( det );

			x *= idet; y *= idet;

			v2.x += x; v2.y += y;
			v1.x -= x; v1.y -= y;

		}
	};

	// Context cached methods.

	function setOpacity( value ) {

		if ( _contextGlobalAlpha != value ) {

			_context.globalAlpha = _contextGlobalAlpha = value;

		}

	}

	function setBlending( value ) {

		if ( _contextGlobalCompositeOperation != value ) {

			switch ( value ) {

				case THREE.NormalBlending:

					_context.globalCompositeOperation = 'source-over';

					break;

				case THREE.AdditiveBlending:

					_context.globalCompositeOperation = 'lighter';

					break;

				case THREE.SubtractiveBlending:

					_context.globalCompositeOperation = 'darker';

					break;

			}

			_contextGlobalCompositeOperation = value;

		}

	}

	function setLineWidth( value ) {

		if ( _contextLineWidth != value ) {

			_context.lineWidth = _contextLineWidth = value;

		}

	}

	function setLineCap( value ) {

		// "butt", "round", "square"

		if ( _contextLineCap != value ) {

			_context.lineCap = _contextLineCap = value;

		}

	}

	function setLineJoin( value ) {

		// "round", "bevel", "miter"

		if ( _contextLineJoin != value ) {

			_context.lineJoin = _contextLineJoin = value;

		}

	}

	function setStrokeStyle( style ) {

		if ( _contextStrokeStyle != style ) {

			_context.strokeStyle = _contextStrokeStyle = style;

		}

	}

	function setFillStyle( style ) {

		if ( _contextFillStyle != style ) {

			_context.fillStyle = _contextFillStyle = style;

		}

	}

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.SVGRenderer = function () {

	var _this = this,
	_renderData, _elements, _lights,
	_projector = new THREE.Projector(),
	_svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
	_svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf,

	_v1, _v2, _v3, _v4,

	_clipRect = new THREE.Rectangle(),
	_bboxRect = new THREE.Rectangle(),

	_enableLighting = false,
	_color = new THREE.Color(),
	_ambientLight = new THREE.Color(),
	_directionalLights = new THREE.Color(),
	_pointLights = new THREE.Color(),

	_w, // z-buffer to w-buffer
	_vector3 = new THREE.Vector3(), // Needed for PointLight

	_svgPathPool = [], _svgCirclePool = [], _svgLinePool = [],
	_svgNode, _pathCount, _circleCount, _lineCount,
	_quality = 1;

	this.domElement = _svg;

	this.autoClear = true;
	this.sortObjects = true;
	this.sortElements = true;

	this.info = {

		render: {

			vertices: 0,
			faces: 0

		}

	}

	this.setQuality = function( quality ) {

		switch(quality) {

			case "high": _quality = 1; break;
			case "low": _quality = 0; break;

		}

	};

	this.setSize = function( width, height ) {

		_svgWidth = width; _svgHeight = height;
		_svgWidthHalf = _svgWidth / 2; _svgHeightHalf = _svgHeight / 2;

		_svg.setAttribute( 'viewBox', ( - _svgWidthHalf ) + ' ' + ( - _svgHeightHalf ) + ' ' + _svgWidth + ' ' + _svgHeight );
		_svg.setAttribute( 'width', _svgWidth );
		_svg.setAttribute( 'height', _svgHeight );

		_clipRect.set( - _svgWidthHalf, - _svgHeightHalf, _svgWidthHalf, _svgHeightHalf );

	};

	this.clear = function () {

		while ( _svg.childNodes.length > 0 ) {

			_svg.removeChild( _svg.childNodes[ 0 ] );

		}

	};

	this.render = function ( scene, camera ) {

		var e, el, element, material;

		this.autoClear && this.clear();

		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;

		_renderData = _projector.projectScene( scene, camera, this.sortElements );
		_elements = _renderData.elements;
		_lights = _renderData.lights;

		_pathCount = 0; _circleCount = 0; _lineCount = 0;

		_enableLighting = _lights.length > 0;

		if ( _enableLighting ) {

			 calculateLights( _lights );

		}

		for ( e = 0, el = _elements.length; e < el; e ++ ) {

			element = _elements[ e ];

			material = element.material;
			material = material instanceof THREE.MeshFaceMaterial ? element.faceMaterial : material;

			if ( material == null || material.opacity == 0 ) continue;

			_bboxRect.empty();

			if ( element instanceof THREE.RenderableParticle ) {

				_v1 = element;
				_v1.x *= _svgWidthHalf; _v1.y *= -_svgHeightHalf;

				renderParticle( _v1, element, material, scene );

			} else if ( element instanceof THREE.RenderableLine ) {

				_v1 = element.v1; _v2 = element.v2;

				_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;
				_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;

				_bboxRect.addPoint( _v1.positionScreen.x, _v1.positionScreen.y );
				_bboxRect.addPoint( _v2.positionScreen.x, _v2.positionScreen.y );

				if ( !_clipRect.intersects( _bboxRect ) ) {

					continue;

				}

				renderLine( _v1, _v2, element, material, scene );

			} else if ( element instanceof THREE.RenderableFace3 ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

				_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;
				_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;
				_v3.positionScreen.x *= _svgWidthHalf; _v3.positionScreen.y *= - _svgHeightHalf;

				_bboxRect.addPoint( _v1.positionScreen.x, _v1.positionScreen.y );
				_bboxRect.addPoint( _v2.positionScreen.x, _v2.positionScreen.y );
				_bboxRect.addPoint( _v3.positionScreen.x, _v3.positionScreen.y );

				if ( !_clipRect.intersects( _bboxRect ) ) {

					continue;

				}

				renderFace3( _v1, _v2, _v3, element, material, scene );

			} else if ( element instanceof THREE.RenderableFace4 ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3; _v4 = element.v4;

				_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= -_svgHeightHalf;
				_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= -_svgHeightHalf;
				_v3.positionScreen.x *= _svgWidthHalf; _v3.positionScreen.y *= -_svgHeightHalf;
				_v4.positionScreen.x *= _svgWidthHalf; _v4.positionScreen.y *= -_svgHeightHalf;

				_bboxRect.addPoint( _v1.positionScreen.x, _v1.positionScreen.y );
				_bboxRect.addPoint( _v2.positionScreen.x, _v2.positionScreen.y );
				_bboxRect.addPoint( _v3.positionScreen.x, _v3.positionScreen.y );
				_bboxRect.addPoint( _v4.positionScreen.x, _v4.positionScreen.y );

				if ( !_clipRect.intersects( _bboxRect) ) {

					continue;

				}

				renderFace4( _v1, _v2, _v3, _v4, element, material, scene );

			}

		}

	};

	function calculateLights( lights ) {

		var l, ll, light, lightColor;

		_ambientLight.setRGB( 0, 0, 0 );
		_directionalLights.setRGB( 0, 0, 0 );
		_pointLights.setRGB( 0, 0, 0 );

		for ( l = 0, ll = lights.length; l < ll; l++ ) {

			light = lights[ l ];
			lightColor = light.color;

			if ( light instanceof THREE.AmbientLight ) {

				_ambientLight.r += lightColor.r;
				_ambientLight.g += lightColor.g;
				_ambientLight.b += lightColor.b;

			} else if ( light instanceof THREE.DirectionalLight ) {

				_directionalLights.r += lightColor.r;
				_directionalLights.g += lightColor.g;
				_directionalLights.b += lightColor.b;

			} else if ( light instanceof THREE.PointLight ) {

				_pointLights.r += lightColor.r;
				_pointLights.g += lightColor.g;
				_pointLights.b += lightColor.b;

			}

		}

	}

	function calculateLight( lights, position, normal, color ) {

		var l, ll, light, lightColor, lightPosition, amount;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];
			lightColor = light.color;

			if ( light instanceof THREE.DirectionalLight ) {

				lightPosition = light.matrixWorld.getPosition();

				amount = normal.dot( lightPosition );

				if ( amount <= 0 ) continue;

				amount *= light.intensity;

				color.r += lightColor.r * amount;
				color.g += lightColor.g * amount;
				color.b += lightColor.b * amount;

			} else if ( light instanceof THREE.PointLight ) {

				lightPosition = light.matrixWorld.getPosition();

				amount = normal.dot( _vector3.sub( lightPosition, position ).normalize() );

				if ( amount <= 0 ) continue;

				amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

				if ( amount == 0 ) continue;

				amount *= light.intensity;

				color.r += lightColor.r * amount;
				color.g += lightColor.g * amount;
				color.b += lightColor.b * amount;

			}

		}

	}

	function renderParticle( v1, element, material, scene ) {

		/*
		_svgNode = getCircleNode( _circleCount++ );
		_svgNode.setAttribute( 'cx', v1.x );
		_svgNode.setAttribute( 'cy', v1.y );
		_svgNode.setAttribute( 'r', element.scale.x * _svgWidthHalf );

		if ( material instanceof THREE.ParticleCircleMaterial ) {

			if ( _enableLighting ) {

				_color.r = _ambientLight.r + _directionalLights.r + _pointLights.r;
				_color.g = _ambientLight.g + _directionalLights.g + _pointLights.g;
				_color.b = _ambientLight.b + _directionalLights.b + _pointLights.b;

				_color.r = material.color.r * _color.r;
				_color.g = material.color.g * _color.g;
				_color.b = material.color.b * _color.b;

				_color.updateStyleString();

			} else {

				_color = material.color;

			}

			_svgNode.setAttribute( 'style', 'fill: ' + _color.__styleString );

		}

		_svg.appendChild( _svgNode );
		*/

	}

	function renderLine ( v1, v2, element, material, scene ) {

		_svgNode = getLineNode( _lineCount ++ );

		_svgNode.setAttribute( 'x1', v1.positionScreen.x );
		_svgNode.setAttribute( 'y1', v1.positionScreen.y );
		_svgNode.setAttribute( 'x2', v2.positionScreen.x );
		_svgNode.setAttribute( 'y2', v2.positionScreen.y );

		if ( material instanceof THREE.LineBasicMaterial ) {

			_svgNode.setAttribute( 'style', 'fill: none; stroke: ' + material.color.getContextStyle() + '; stroke-width: ' + material.linewidth + '; stroke-opacity: ' + material.opacity + '; stroke-linecap: ' + material.linecap + '; stroke-linejoin: ' + material.linejoin );

			_svg.appendChild( _svgNode );

		}

	}

	function renderFace3( v1, v2, v3, element, material, scene ) {

		_this.info.render.vertices += 3;
		_this.info.render.faces ++;

		_svgNode = getPathNode( _pathCount ++ );
		_svgNode.setAttribute( 'd', 'M ' + v1.positionScreen.x + ' ' + v1.positionScreen.y + ' L ' + v2.positionScreen.x + ' ' + v2.positionScreen.y + ' L ' + v3.positionScreen.x + ',' + v3.positionScreen.y + 'z' );

		if ( material instanceof THREE.MeshBasicMaterial ) {

			_color.copy( material.color );

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			if ( _enableLighting ) {

				_color.r = _ambientLight.r;
				_color.g = _ambientLight.g;
				_color.b = _ambientLight.b;

				calculateLight( _lights, element.centroidWorld, element.normalWorld, _color );

				_color.r = Math.max( 0, Math.min( material.color.r * _color.r, 1 ) );
				_color.g = Math.max( 0, Math.min( material.color.g * _color.g, 1 ) );
				_color.b = Math.max( 0, Math.min( material.color.b * _color.b, 1 ) );

			} else {

				_color.copy( material.color );

			}

		} else if ( material instanceof THREE.MeshDepthMaterial ) {

			_w = 1 - ( material.__2near / (material.__farPlusNear - element.z * material.__farMinusNear) );
			_color.setRGB( _w, _w, _w );

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			_color.setRGB( normalToComponent( element.normalWorld.x ), normalToComponent( element.normalWorld.y ), normalToComponent( element.normalWorld.z ) );

		}

		if ( material.wireframe ) {

			_svgNode.setAttribute( 'style', 'fill: none; stroke: ' + _color.getContextStyle() + '; stroke-width: ' + material.wireframeLinewidth + '; stroke-opacity: ' + material.opacity + '; stroke-linecap: ' + material.wireframeLinecap + '; stroke-linejoin: ' + material.wireframeLinejoin );

		} else {

			_svgNode.setAttribute( 'style', 'fill: ' + _color.getContextStyle() + '; fill-opacity: ' + material.opacity );

		}

		_svg.appendChild( _svgNode );

	}

	function renderFace4( v1, v2, v3, v4, element, material, scene ) {

		_this.info.render.vertices += 4;
		_this.info.render.faces ++;

		_svgNode = getPathNode( _pathCount ++ );
		_svgNode.setAttribute( 'd', 'M ' + v1.positionScreen.x + ' ' + v1.positionScreen.y + ' L ' + v2.positionScreen.x + ' ' + v2.positionScreen.y + ' L ' + v3.positionScreen.x + ',' + v3.positionScreen.y + ' L ' + v4.positionScreen.x + ',' + v4.positionScreen.y + 'z' );

		if ( material instanceof THREE.MeshBasicMaterial ) {

			_color.copy( material.color );

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			if ( _enableLighting ) {

				_color.r = _ambientLight.r;
				_color.g = _ambientLight.g;
				_color.b = _ambientLight.b;

				calculateLight( _lights, element.centroidWorld, element.normalWorld, _color );

				_color.r = Math.max( 0, Math.min( material.color.r * _color.r, 1 ) );
				_color.g = Math.max( 0, Math.min( material.color.g * _color.g, 1 ) );
				_color.b = Math.max( 0, Math.min( material.color.b * _color.b, 1 ) );

			} else {

				_color.copy( material.color );

			}

		} else if ( material instanceof THREE.MeshDepthMaterial ) {

			_w = 1 - ( material.__2near / (material.__farPlusNear - element.z * material.__farMinusNear) );
			_color.setRGB( _w, _w, _w );

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			_color.setRGB( normalToComponent( element.normalWorld.x ), normalToComponent( element.normalWorld.y ), normalToComponent( element.normalWorld.z ) );

		}

		if ( material.wireframe ) {

			_svgNode.setAttribute( 'style', 'fill: none; stroke: ' + _color.getContextStyle() + '; stroke-width: ' + material.wireframeLinewidth + '; stroke-opacity: ' + material.opacity + '; stroke-linecap: ' + material.wireframeLinecap + '; stroke-linejoin: ' + material.wireframeLinejoin );

		} else {

			_svgNode.setAttribute( 'style', 'fill: ' + _color.getContextStyle() + '; fill-opacity: ' + material.opacity );

		}

		_svg.appendChild( _svgNode );

	}

	function getLineNode( id ) {

		if ( _svgLinePool[ id ] == null ) {

			_svgLinePool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'line' );

			if ( _quality == 0 ) {

				_svgLinePool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed

			}

			return _svgLinePool[ id ];

		}

		return _svgLinePool[ id ];

	}

	function getPathNode( id ) {

		if ( _svgPathPool[ id ] == null ) {

			_svgPathPool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );

			if ( _quality == 0 ) {

				_svgPathPool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed

			}

			return _svgPathPool[ id ];

		}

		return _svgPathPool[ id ];

	}

	function getCircleNode( id ) {

		if ( _svgCirclePool[id] == null ) {

			_svgCirclePool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'circle' );

			if ( _quality == 0 ) {

				_svgCirclePool[id].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed

			}

			return _svgCirclePool[ id ];

		}

		return _svgCirclePool[ id ];

	}

	function normalToComponent( normal ) {

		var component = ( normal + 1 ) * 0.5;
		return component < 0 ? 0 : ( component > 1 ? 1 : component );

	}

	function pad( str ) {

		while ( str.length < 6 ) str = '0' + str;
		return str;

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderChunk = {

	// FOG

	fog_pars_fragment: [

		"#ifdef USE_FOG",

			"uniform vec3 fogColor;",

			"#ifdef FOG_EXP2",

				"uniform float fogDensity;",

			"#else",

				"uniform float fogNear;",
				"uniform float fogFar;",

			"#endif",

		"#endif"

	].join("\n"),

	fog_fragment: [

		"#ifdef USE_FOG",

			"float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"#ifdef FOG_EXP2",

				"const float LOG2 = 1.442695;",
				"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
				"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",

			"#else",

				"float fogFactor = smoothstep( fogNear, fogFar, depth );",

			"#endif",

			"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

		"#endif"

	].join("\n"),

	// ENVIRONMENT MAP

	envmap_pars_fragment: [

		"#ifdef USE_ENVMAP",

			"varying vec3 vReflect;",

			"uniform float reflectivity;",
			"uniform samplerCube envMap;",
			"uniform float flipEnvMap;",
			"uniform int combine;",

		"#endif"

	].join("\n"),

	envmap_fragment: [

		"#ifdef USE_ENVMAP",

			"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * vReflect.x, vReflect.yz ) );",

			"#ifdef GAMMA_INPUT",

				"cubeColor.xyz *= cubeColor.xyz;",

			"#endif",

			"if ( combine == 1 ) {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, reflectivity );",

			"} else {",

				"gl_FragColor.xyz = gl_FragColor.xyz * cubeColor.xyz;",

			"}",

		"#endif"

	].join("\n"),

	envmap_pars_vertex: [

		"#ifdef USE_ENVMAP",

			"varying vec3 vReflect;",

			"uniform float refractionRatio;",
			"uniform bool useRefract;",

		"#endif"

	].join("\n"),

	envmap_vertex : [

		"#ifdef USE_ENVMAP",

			"vec4 mPosition = objectMatrix * vec4( position, 1.0 );",
			"vec3 nWorld = mat3( objectMatrix[ 0 ].xyz, objectMatrix[ 1 ].xyz, objectMatrix[ 2 ].xyz ) * normal;",

			"if ( useRefract ) {",

				"vReflect = refract( normalize( mPosition.xyz - cameraPosition ), normalize( nWorld.xyz ), refractionRatio );",

			"} else {",

				"vReflect = reflect( normalize( mPosition.xyz - cameraPosition ), normalize( nWorld.xyz ) );",

			"}",

		"#endif"

	].join("\n"),

	// COLOR MAP (particles)

	map_particle_pars_fragment: [

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),


	map_particle_fragment: [

		"#ifdef USE_MAP",

			"gl_FragColor = gl_FragColor * texture2D( map, gl_PointCoord );",

		"#endif"

	].join("\n"),

	// COLOR MAP (triangles)

	map_pars_vertex: [

		"#ifdef USE_MAP",

			"varying vec2 vUv;",
			"uniform vec4 offsetRepeat;",

		"#endif"

	].join("\n"),

	map_pars_fragment: [

		"#ifdef USE_MAP",

			"varying vec2 vUv;",
			"uniform sampler2D map;",

		"#endif"

	].join("\n"),

	map_vertex: [

		"#ifdef USE_MAP",

			"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",

		"#endif"

	].join("\n"),

	map_fragment: [

		"#ifdef USE_MAP",

			"#ifdef GAMMA_INPUT",

				"vec4 texelColor = texture2D( map, vUv );",
				"texelColor.xyz *= texelColor.xyz;",

				"gl_FragColor = gl_FragColor * texelColor;",

			"#else",

				"gl_FragColor = gl_FragColor * texture2D( map, vUv );",

			"#endif",

		"#endif"

	].join("\n"),

	// LIGHT MAP

	lightmap_pars_fragment: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",
			"uniform sampler2D lightMap;",

		"#endif"

	].join("\n"),

	lightmap_pars_vertex: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",

		"#endif"

	].join("\n"),

	lightmap_fragment: [

		"#ifdef USE_LIGHTMAP",

			"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",

		"#endif"

	].join("\n"),

	lightmap_vertex: [

		"#ifdef USE_LIGHTMAP",

			"vUv2 = uv2;",

		"#endif"

	].join("\n"),

	// LIGHTS LAMBERT

	lights_lambert_pars_vertex: [

		"uniform vec3 ambient;",
		"uniform vec3 diffuse;",

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

		"#endif"

	].join("\n"),

	lights_lambert_vertex: [

		"vLightWeighting = vec3( 0.0 );",

		"#if MAX_DIR_LIGHTS > 0",

		"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

			"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"float directionalLightWeighting = max( dot( transformedNormal, normalize( lDirection.xyz ) ), 0.0 );",
			"vLightWeighting += directionalLightColor[ i ] * directionalLightWeighting;",

		"}",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",

				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",

				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"lVector = normalize( lVector );",

				"float pointLightWeighting = max( dot( transformedNormal, lVector ), 0.0 );",
				"vLightWeighting += pointLightColor[ i ] * pointLightWeighting * lDistance;",

			"}",

		"#endif",

		"vLightWeighting = vLightWeighting * diffuse + ambient * ambientLightColor;",

	].join("\n"),

	// LIGHTS PHONG

	lights_phong_pars_vertex: [

		"#if MAX_POINT_LIGHTS > 0",
		"#ifndef PHONG_PER_PIXEL",

			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

		"#endif",
		"#endif"

	].join("\n"),


	lights_phong_vertex: [

		"#if MAX_POINT_LIGHTS > 0",
		"#ifndef PHONG_PER_PIXEL",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",

				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",

				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"lVector = normalize( lVector );",

				"vPointLight[ i ] = vec4( lVector, lDistance );",

			"}",

		"#endif",
		"#endif"

	].join("\n"),

	lights_phong_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",

			"#ifdef PHONG_PER_PIXEL",

				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#else",

				"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

			"#endif",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;"

	].join("\n"),

	lights_phong_fragment: [

		"vec3 normal = normalize( vNormal );",
		"vec3 viewPosition = normalize( vViewPosition );",

		"#if MAX_POINT_LIGHTS > 0",

			"vec3 pointDiffuse  = vec3( 0.0 );",
			"vec3 pointSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"#ifdef PHONG_PER_PIXEL",

					"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",

					"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

					"float lDistance = 1.0;",

					"if ( pointLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

				"#else",

					"vec3 lVector = normalize( vPointLight[ i ].xyz );",
					"float lDistance = vPointLight[ i ].w;",

				"#endif",

				"vec3 pointHalfVector = normalize( lVector + viewPosition );",
				"float pointDistance = lDistance;",

				"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
				"float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );",

				"float pointSpecularWeight = pow( pointDotNormalHalf, shininess );",

				"#ifdef PHYSICALLY_BASED_SHADING",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( dot( lVector, pointHalfVector ), 5.0 );",
					"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance;",

				"#else",

					"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance;",

				"#endif",

				"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * pointDistance;",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"vec3 dirDiffuse  = vec3( 0.0 );",
			"vec3 dirSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",

				"vec3 dirVector = normalize( lDirection.xyz );",
				"vec3 dirHalfVector = normalize( lDirection.xyz + viewPosition );",

				"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
				"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

				"float dirSpecularWeight = pow( dirDotNormalHalf, shininess );",

				"#ifdef PHYSICALLY_BASED_SHADING",

					/*
					// fresnel term from skin shader
					"const float F0 = 0.128;",

					"float base = 1.0 - dot( viewPosition, dirHalfVector );",
					"float exponential = pow( base, 5.0 );",

					"float fresnel = exponential + F0 * ( 1.0 - exponential );",
					*/

					/*
					// fresnel term from fresnel shader
					"const float mFresnelBias = 0.08;",
					"const float mFresnelScale = 0.3;",
					"const float mFresnelPower = 5.0;",

					"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );",
					*/

					// normalization factor
					//float specularNormalization = ( shininess + 2.0 ) / 8.0;

					//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( dot( dirVector, dirHalfVector ), 5.0 );",
					"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;",

				"#else",

					"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;",

				"#endif",

				"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",

			"}",

		"#endif",

		"vec3 totalDiffuse = vec3( 0.0 );",
		"vec3 totalSpecular = vec3( 0.0 );",

		"#if MAX_DIR_LIGHTS > 0",

			"totalDiffuse += dirDiffuse;",
			"totalSpecular += dirSpecular;",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"totalDiffuse += pointDiffuse;",
			"totalSpecular += pointSpecular;",

		"#endif",

		"#ifdef METAL",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

		"#else",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

		"#endif"

	].join("\n"),

	// VERTEX COLORS

	color_pars_fragment: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_fragment: [

		"#ifdef USE_COLOR",

			"gl_FragColor = gl_FragColor * vec4( vColor, opacity );",

		"#endif"

	].join("\n"),

	color_pars_vertex: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_vertex: [

		"#ifdef USE_COLOR",

			"#ifdef GAMMA_INPUT",

				"vColor = color * color;",

			"#else",

				"vColor = color;",

			"#endif",

		"#endif"

	].join("\n"),

	// SKINNING

	skinning_pars_vertex: [

		"#ifdef USE_SKINNING",

			"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",

		"#endif"

	].join("\n"),

	skinning_vertex: [

		"#ifdef USE_SKINNING",

			"gl_Position  = ( boneGlobalMatrices[ int( skinIndex.x ) ] * skinVertexA ) * skinWeight.x;",
			"gl_Position += ( boneGlobalMatrices[ int( skinIndex.y ) ] * skinVertexB ) * skinWeight.y;",

			// this doesn't work, no idea why
			//"gl_Position  = projectionMatrix * cameraInverseMatrix * objectMatrix * gl_Position;",

			"gl_Position  = projectionMatrix * viewMatrix * objectMatrix * gl_Position;",

		"#endif"

	].join("\n"),

	// MORPHING

	morphtarget_pars_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"uniform float morphTargetInfluences[ 8 ];",

		"#endif"

	].join("\n"),

	morphtarget_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"vec3 morphed = vec3( 0.0, 0.0, 0.0 );",
			"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
			"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
			"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
			"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",
			"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
			"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
			"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
			"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",
			"morphed += position;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( morphed, 1.0 );",

		"#endif"

	].join("\n"),

	default_vertex : [

		"#ifndef USE_MORPHTARGETS",
		"#ifndef USE_SKINNING",

			"gl_Position = projectionMatrix * mvPosition;",

		"#endif",
		"#endif"

	].join("\n"),

	// SHADOW MAP

	// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
	//  http://spidergl.org/example.php?id=6
	// 	http://fabiensanglard.net/shadowmapping

	shadowmap_pars_fragment: [

		"#ifdef USE_SHADOWMAP",

			"uniform sampler2D shadowMap[ MAX_SHADOWS ];",

			"uniform float shadowDarkness;",
			"uniform float shadowBias;",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",

			"float unpackDepth( const in vec4 rgba_depth ) {",

				"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"float depth = dot( rgba_depth, bit_shift );",
				"return depth;",

			"}",

		"#endif"

	].join("\n"),

	shadowmap_fragment: [

		"#ifdef USE_SHADOWMAP",

			"#ifdef SHADOWMAP_SOFT",

				"const float xPixelOffset = 1.0 / SHADOWMAP_WIDTH;",
				"const float yPixelOffset = 1.0 / SHADOWMAP_HEIGHT;",

			"#endif",

			"vec3 shadowColor = vec3( 1.0 );",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",
				"shadowCoord.z += shadowBias;",

				"if ( shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0 ) {",

					"#ifdef SHADOWMAP_SOFT",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
							"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",

								"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",

								// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
								//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",

								"float fDepth = unpackDepth( rgbaDepth );",

								"if ( fDepth < shadowCoord.z )",
									"shadow += 1.0;",

						"}",

						"shadow /= 9.0;",
						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness * shadow ) );",

					"#else",

						"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
						"float fDepth = unpackDepth( rgbaDepth );",

						"if ( fDepth < shadowCoord.z )",

							// spot with multiple shadows is darker

							"shadowColor = shadowColor * vec3( shadowDarkness );",

							// spot with multiple shadows has the same color as single shadow spot

							//"shadowColor = min( shadowColor, vec3( shadowDarkness ) );",

					"#endif",

				"}",


				// uncomment to see light frustum boundaries
				//"if ( !( shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0 ) )",
				//	"gl_FragColor.xyz =  gl_FragColor.xyz * vec3( 1.0, 0.0, 0.0 );",

			"}",

			"#ifdef GAMMA_OUTPUT",

				"shadowColor *= shadowColor;",

			"#endif",

			"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",

		"#endif"

	].join("\n"),

	shadowmap_pars_vertex: [

		"#ifdef USE_SHADOWMAP",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
			"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",

		"#endif"

	].join("\n"),

	shadowmap_vertex: [

		"#ifdef USE_SHADOWMAP",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vShadowCoord[ i ] = shadowMatrix[ i ] * objectMatrix * vec4( position, 1.0 );",

			"}",

		"#endif"

	].join("\n"),

	// ALPHATEST

	alphatest_fragment: [

		"#ifdef ALPHATEST",

			"if ( gl_FragColor.a < ALPHATEST ) discard;",

		"#endif"

	].join("\n"),

	// LINEAR SPACE

	linear_to_gamma_fragment: [

		"#ifdef GAMMA_OUTPUT",

			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"#endif"

	].join("\n"),


};

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var u, p, tmp, merged = {};

		for ( u = 0; u < uniforms.length; u++ ) {

			tmp = this.clone( uniforms[ u ] );

			for ( p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var u, p, parameter, parameter_src, uniforms_dst = {};

		for ( u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( p in uniforms_src[ u ] ) {

				parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: 0, texture: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: 2, texture: null },

		"envMap" : { type: "t", value: 1, texture: null },
		"flipEnvMap" : { type: "f", value: -1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },
		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },
		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: 0, texture: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: 6, texture: [] },
		"shadowMatrix" : { type: "m4v", value: [] },

		"shadowBias" : { type: "f", value: 0.0039 },
		"shadowDarkness": { type: "f", value: 0.2 }

	}

};

THREE.ShaderLib = {

	'sprite': {

		vertexShader: [

			"uniform int useScreenCoordinates;",
			"uniform int affectedByDistance;",
			"uniform vec3 screenPosition;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform float rotation;",
			"uniform vec2 scale;",
			"uniform vec2 alignment;",
			"uniform vec2 uvOffset;",
			"uniform vec2 uvScale;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",

			"void main() {",

				"vUV = uvOffset + uv * uvScale;",

				"vec2 alignedPosition = position + alignment;",

				"vec2 rotatedPosition;",
				"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;",
				"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;",

				"vec4 finalPosition;",

				"if( useScreenCoordinates != 0 ) {",

					"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );",

				"} else {",

					"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
					"finalPosition.xy += rotatedPosition * ( affectedByDistance == 1 ? 1.0 : finalPosition.z );",

				"}",

				"gl_Position = finalPosition;",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"#ifdef GL_ES",
				"precision highp float;",
			"#endif",

			"uniform vec3 color;",
			"uniform sampler2D map;",
			"uniform float opacity;",

			"varying vec2 vUV;",

			"void main() {",

				"vec4 texture = texture2D( map, vUV );",
				"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",

			"}"

		].join( "\n" )

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"void main() {",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			"void main() {",

				"float depth = gl_FragCoord.z / gl_FragCoord.w;",
				"float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			"void main() {",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"vNormal = normalize( normalMatrix * normal );",

				"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			"void main() {",

				"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

			"}"

		].join("\n")

	},

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0x050505 ) }
			}

		] ),

		vertexShader: [

			"varying vec3 vLightWeighting;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				"vec3 transformedNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],


			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightWeighting;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],

				"gl_FragColor.xyz = gl_FragColor.xyz * vLightWeighting;",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0x050505 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 }
			}

		] ),

		vertexShader: [

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				"#ifndef USE_ENVMAP",

					"vec4 mPosition = objectMatrix * vec4( position, 1.0 );",

				"#endif",

				"vViewPosition = -mvPosition.xyz;",

				"vec3 transformedNormal = normalMatrix * normal;",
				"vNormal = transformedNormal;",

				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms:  THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"#ifdef USE_SIZEATTENUATION",
					"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"#else",
					"gl_PointSize = size;",
				"#endif",

				"gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	// Depth encoding into RGBA texture
	// 	based on SpiderGL shadow map example
	// 		http://spidergl.org/example.php?id=6
	// 	originally from
	//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	// 	see also here:
	//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],

			"void main() {",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"vec4 pack_depth( const in float depth ) {",

				"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"vec4 res = fract( depth * bit_shift );",
				"res -= res.xxyz * bit_mask;",
				"return res;",

			"}",

			"void main() {",

				"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	// constructor parameters

	var parameters = parameters || {},

	_canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = parameters.clearColor !== undefined ? new THREE.Color( parameters.clearColor ) : new THREE.Color( 0x000000 ),
	_clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0,

	_maxLights = parameters.maxLights !== undefined ? parameters.maxLights : 4;

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	this.autoUpdateObjects = true;
	this.autoUpdateScene = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;
	this.physicallyBasedShading = false;

	// shadow map

	this.shadowMapBias = 0.0039;
	this.shadowMapDarkness = 0.5;
	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	this.shadowCameraNear = 1;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowMap = [];

	this.shadowMapEnabled = false;
	this.shadowMapAutoUpdate = true;
	this.shadowMapSoft = true;

	// morphs

	this.maxMorphTargets = 8;

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0

		}

	};

	// internal properties

	var _this = this,

	_gl,

	_programs = [],

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_geometryGroupCounter = 0,

	// GL state cache

	_oldDoubleSided = null,
	_oldFlipSided = null,
	_oldBlending = null,
	_oldDepthTest = null,
	_oldDepthWrite = null,
	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,
	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = 0,
	_viewportHeight = 0,

	// frustum cache

	_frustum = [
		new THREE.Vector4(),
		new THREE.Vector4(),
		new THREE.Vector4(),
		new THREE.Vector4(),
		new THREE.Vector4(),
		new THREE.Vector4()
	 ],

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projectionMatrixArray = new Float32Array( 16 ),
	_viewMatrixArray = new Float32Array( 16 ),

	_vector3 = new THREE.Vector4(),

	// light arrays cache

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: new Array(), positions: new Array() },
		point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() }

	};

	// shadow maps

	var _cameraLight, _shadowMatrix = [];
	var _depthMaterial, _depthMaterialMorph;

	// sprites

	var _sprite = {};
	var _spriteAttributesEnabled = false;

	// initialize

	_gl = initGL();

	setDefaultGLState();

	initSprites();
	initShadowmaps();

	this.context = _gl;

	var _supportsVertexTextures = ( maxVertexTextures() > 0 );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.setSize = function ( width, height ) {

		_canvas.width = width;
		_canvas.height = height;

		this.setViewport( 0, 0, _canvas.width, _canvas.height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x;
		_viewportY = y;

		_viewportWidth = width;
		_viewportHeight = height;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor( x, y, width, height );

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColorHex = function ( hex, alpha ) {

		_clearColor.setHex( hex );
		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.copy( color );
		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Deallocation

	this.deallocateObject = function ( object ) {

		if ( ! object.__webglInit ) return;

		object.__webglInit = false;

		delete object._modelViewMatrix;

		delete object._normalMatrixArray;
		delete object._modelViewMatrixArray;
		delete object._objectMatrixArray;

		if ( object instanceof THREE.Mesh ) {

			for ( var g in object.geometry.geometryGroups ) {

				deleteMeshBuffers( object.geometry.geometryGroups[ g ] );

			}

		} else if ( object instanceof THREE.Ribbon ) {

			deleteRibbonBuffers( object.geometry );

		} else if ( object instanceof THREE.Line ) {

			deleteLineBuffers( object.geometry );

		} else if ( object instanceof THREE.ParticleSystem ) {

			deleteParticleBuffers( object.geometry );

		}

	};

	this.deallocateTexture = function ( texture ) {

		if ( ! texture.__webglInit ) return;

		texture.__webglInit = false;
		_gl.deleteTexture( texture.__webglTexture );

		_this.info.memory.textures --;

	};

	// Rendering

	this.updateShadowMap = function ( scene, camera ) {

		renderShadowMap( scene, camera );

	};

	// Internal functions

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createRibbonBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinVertexABuffer = _gl.createBuffer();
		geometryGroup.__webglSkinVertexBBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		if ( geometryGroup.numMorphTargets ) {

			var m, ml;

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Buffer deallocation

	function deleteParticleBuffers ( geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );

		_this.info.memory.geometries --;

	};

	function deleteLineBuffers ( geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );

		_this.info.memory.geometries --;

	};

	function deleteRibbonBuffers ( geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );

		_this.info.memory.geometries --;

	};

	function deleteMeshBuffers ( geometryGroup ) {

		_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );
		_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );
		_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );
		_gl.deleteBuffer( geometryGroup.__webglColorBuffer );
		_gl.deleteBuffer( geometryGroup.__webglUVBuffer );
		_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );

		_gl.deleteBuffer( geometryGroup.__webglSkinVertexABuffer );
		_gl.deleteBuffer( geometryGroup.__webglSkinVertexBBuffer );
		_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );
		_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );

		_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );
		_gl.deleteBuffer( geometryGroup.__webglLineBuffer );

		if ( geometryGroup.numMorphTargets ) {

			for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

			}

		}


		if ( geometryGroup.__webglCustomAttributesList ) {

			for ( var id in geometryGroup.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometryGroup.__webglCustomAttributesList[ id ].buffer );

			}

		}

		_this.info.memory.geometries --;

	};

	// Buffer initialization

	function initCustomAttributes ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		var material = object.material;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initRibbonBuffers ( geometry ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__webglVertexCount = nvertices;

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,
			faces4 = geometryGroup.faces4,

			nvertices = faces3.length * 3 + faces4.length * 4,
			ntris     = faces3.length * 1 + faces4.length * 2,
			nlines    = faces3.length * 3 + faces4.length * 4,

			material = getBufferMaterial( object, geometryGroup ),

			uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		//console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceUvs.length > 0 || geometry.faceVertexUvs.length > 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceUvs.length > 1 || geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinVertexAArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinVertexBArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
		geometryGroup.__lineArray = new Uint16Array( nlines * 2 );

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if( attribute.type === "v2" ) size = 2;
					else if( attribute.type === "v3" ) size = 3;
					else if( attribute.type === "v4" ) size = 4;
					else if( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		if ( object.material && ! ( object.material instanceof THREE.MeshFaceMaterial ) ) {

			return object.material;

		} else if ( geometryGroup.materialIndex >= 0 ) {

			return object.geometry.materials[ geometryGroup.materialIndex ];

		}

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	function bufferGuessNormalType ( material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {

			return false;

		}

		if ( materialNeedsSmoothNormals( material ) ) {

			return THREE.SmoothShading;

		} else {

			return THREE.FlatShading;

		}

	};

	function bufferGuessVertexColorType ( material ) {

		if ( material.vertexColors ) {

			return material.vertexColors;

		}

		return false;

	};

	function bufferGuessUVType ( material ) {

		// material must use some texture to require uvs

		if ( material.map || material.lightMap || material instanceof THREE.ShaderMaterial ) {

			return true;

		}

		return false;

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.__dirtyVertices,
		dirtyElements = geometry.__dirtyElements,
		dirtyColors = geometry.__dirtyColors,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrix.multiplySelf( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ].position;

				_vector3.copy( vertex );
				_projScreenMatrix.multiplyVector3( _vector3 );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( function( a, b ) { return b[ 0 ] - a[ 0 ]; } );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ].position;

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ].position;

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
					     ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === "c" ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	};

	function setLineBuffers ( geometry, hint ) {

		var v, c, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		vl = vertices.length,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		dirtyVertices = geometry.__dirtyVertices,
		dirtyColors = geometry.__dirtyColors,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ].position;

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	};

	function setRibbonBuffers ( geometry, hint ) {

		var v, c, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		vl = vertices.length,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		dirtyVertices = geometry.__dirtyVertices,
		dirtyColors = geometry.__dirtyColors;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ].position;

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

	};

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			// console.log( object );
			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === THREE.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinVertexAArray = geometryGroup.__skinVertexAArray,
		skinVertexBArray = geometryGroup.__skinVertexBArray,
		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.__dirtyVertices,
		dirtyElements = geometry.__dirtyElements,
		dirtyUvs = geometry.__dirtyUvs,
		dirtyNormals = geometry.__dirtyNormals,
		dirtyTangents = geometry.__dirtyTangents,
		dirtyColors = geometry.__dirtyColors,
		dirtyMorphTargets = geometry.__dirtyMorphTargets,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		chunk_faces4 = geometryGroup.faces4,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinVerticesA = geometry.skinVerticesA,
		obj_skinVerticesB = geometry.skinVerticesB,
		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ].position;
				v2 = vertices[ face.b ].position;
				v3 = vertices[ face.c ].position;

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				v1 = vertices[ face.a ].position;
				v2 = vertices[ face.b ].position;
				v3 = vertices[ face.c ].position;
				v4 = vertices[ face.d ].position;

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				vertexArray[ offset + 9 ]  = v4.x;
				vertexArray[ offset + 10 ] = v4.y;
				vertexArray[ offset + 11 ] = v4.z;

				offset += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ]	];

					v1 = morphTargets[ vk ].vertices[ face.a ].position;
					v2 = morphTargets[ vk ].vertices[ face.b ].position;
					v3 = morphTargets[ vk ].vertices[ face.c ].position;

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					offset_morphTarget += 9;

				}

				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces4[ f ] ];

					v1 = morphTargets[ vk ].vertices[ face.a ].position;
					v2 = morphTargets[ vk ].vertices[ face.b ].position;
					v3 = morphTargets[ vk ].vertices[ face.c ].position;
					v4 = morphTargets[ vk ].vertices[ face.d ].position;

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					vka[ offset_morphTarget + 9 ]  = v4.x;
					vka[ offset_morphTarget + 10 ] = v4.y;
					vka[ offset_morphTarget + 11 ] = v4.z;

					offset_morphTarget += 12;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				// vertices A

				sa1 = obj_skinVerticesA[ face.a ];
				sa2 = obj_skinVerticesA[ face.b ];
				sa3 = obj_skinVerticesA[ face.c ];

				skinVertexAArray[ offset_skin ]     = sa1.x;
				skinVertexAArray[ offset_skin + 1 ] = sa1.y;
				skinVertexAArray[ offset_skin + 2 ] = sa1.z;
				skinVertexAArray[ offset_skin + 3 ] = 1; // pad for faster vertex shader

				skinVertexAArray[ offset_skin + 4 ] = sa2.x;
				skinVertexAArray[ offset_skin + 5 ] = sa2.y;
				skinVertexAArray[ offset_skin + 6 ] = sa2.z;
				skinVertexAArray[ offset_skin + 7 ] = 1;

				skinVertexAArray[ offset_skin + 8 ]  = sa3.x;
				skinVertexAArray[ offset_skin + 9 ]  = sa3.y;
				skinVertexAArray[ offset_skin + 10 ] = sa3.z;
				skinVertexAArray[ offset_skin + 11 ] = 1;

				// vertices B

				sb1 = obj_skinVerticesB[ face.a ];
				sb2 = obj_skinVerticesB[ face.b ];
				sb3 = obj_skinVerticesB[ face.c ];

				skinVertexBArray[ offset_skin ]     = sb1.x;
				skinVertexBArray[ offset_skin + 1 ] = sb1.y;
				skinVertexBArray[ offset_skin + 2 ] = sb1.z;
				skinVertexBArray[ offset_skin + 3 ] = 1; // pad for faster vertex shader

				skinVertexBArray[ offset_skin + 4 ] = sb2.x;
				skinVertexBArray[ offset_skin + 5 ] = sb2.y;
				skinVertexBArray[ offset_skin + 6 ] = sb2.z;
				skinVertexBArray[ offset_skin + 7 ] = 1;

				skinVertexBArray[ offset_skin + 8 ]  = sb3.x;
				skinVertexBArray[ offset_skin + 9 ]  = sb3.y;
				skinVertexBArray[ offset_skin + 10 ] = sb3.z;
				skinVertexBArray[ offset_skin + 11 ] = 1;

				offset_skin += 12;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];
				sw4 = obj_skinWeights[ face.d ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				skinWeightArray[ offset_skin + 12 ] = sw4.x;
				skinWeightArray[ offset_skin + 13 ] = sw4.y;
				skinWeightArray[ offset_skin + 14 ] = sw4.z;
				skinWeightArray[ offset_skin + 15 ] = sw4.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];
				si4 = obj_skinIndices[ face.d ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				skinIndexArray[ offset_skin + 12 ] = si4.x;
				skinIndexArray[ offset_skin + 13 ] = si4.y;
				skinIndexArray[ offset_skin + 14 ] = si4.z;
				skinIndexArray[ offset_skin + 15 ] = si4.w;

				// vertices A

				sa1 = obj_skinVerticesA[ face.a ];
				sa2 = obj_skinVerticesA[ face.b ];
				sa3 = obj_skinVerticesA[ face.c ];
				sa4 = obj_skinVerticesA[ face.d ];

				skinVertexAArray[ offset_skin ]     = sa1.x;
				skinVertexAArray[ offset_skin + 1 ] = sa1.y;
				skinVertexAArray[ offset_skin + 2 ] = sa1.z;
				skinVertexAArray[ offset_skin + 3 ] = 1; // pad for faster vertex shader

				skinVertexAArray[ offset_skin + 4 ] = sa2.x;
				skinVertexAArray[ offset_skin + 5 ] = sa2.y;
				skinVertexAArray[ offset_skin + 6 ] = sa2.z;
				skinVertexAArray[ offset_skin + 7 ] = 1;

				skinVertexAArray[ offset_skin + 8 ]  = sa3.x;
				skinVertexAArray[ offset_skin + 9 ]  = sa3.y;
				skinVertexAArray[ offset_skin + 10 ] = sa3.z;
				skinVertexAArray[ offset_skin + 11 ] = 1;

				skinVertexAArray[ offset_skin + 12 ] = sa4.x;
				skinVertexAArray[ offset_skin + 13 ] = sa4.y;
				skinVertexAArray[ offset_skin + 14 ] = sa4.z;
				skinVertexAArray[ offset_skin + 15 ] = 1;

				// vertices B

				sb1 = obj_skinVerticesB[ face.a ];
				sb2 = obj_skinVerticesB[ face.b ];
				sb3 = obj_skinVerticesB[ face.c ];
				sb4 = obj_skinVerticesB[ face.d ];

				skinVertexBArray[ offset_skin ]     = sb1.x;
				skinVertexBArray[ offset_skin + 1 ] = sb1.y;
				skinVertexBArray[ offset_skin + 2 ] = sb1.z;
				skinVertexBArray[ offset_skin + 3 ] = 1; // pad for faster vertex shader

				skinVertexBArray[ offset_skin + 4 ] = sb2.x;
				skinVertexBArray[ offset_skin + 5 ] = sb2.y;
				skinVertexBArray[ offset_skin + 6 ] = sb2.z;
				skinVertexBArray[ offset_skin + 7 ] = 1;

				skinVertexBArray[ offset_skin + 8 ]  = sb3.x;
				skinVertexBArray[ offset_skin + 9 ]  = sb3.y;
				skinVertexBArray[ offset_skin + 10 ] = sb3.z;
				skinVertexBArray[ offset_skin + 11 ] = 1;

				skinVertexBArray[ offset_skin + 12 ] = sb4.x;
				skinVertexBArray[ offset_skin + 13 ] = sb4.y;
				skinVertexBArray[ offset_skin + 14 ] = sb4.z;
				skinVertexBArray[ offset_skin + 15 ] = 1;

				offset_skin += 16;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinVertexABuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinVertexAArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinVertexBBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinVertexBArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors && vertexColorType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 4 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];
					c4 = vertexColors[ 3 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;
					c4 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				colorArray[ offset_color + 9 ]  = c4.r;
				colorArray[ offset_color + 10 ] = c4.g;
				colorArray[ offset_color + 11 ] = c4.b;

				offset_color += 12;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];
				t4 = vertexTangents[ 3 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				tangentArray[ offset_tangent + 12 ] = t4.x;
				tangentArray[ offset_tangent + 13 ] = t4.y;
				tangentArray[ offset_tangent + 14 ] = t4.z;
				tangentArray[ offset_tangent + 15 ] = t4.w;

				offset_tangent += 16;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals && normalType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 4 && needsSmoothNormals ) {

					for ( i = 0; i < 4; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 4; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				face = obj_faces[ fi ];
				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.u;
					uvArray[ offset_uv + 1 ] = uvi.v;

					offset_uv += 2;

				}

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				fi = chunk_faces4[ f ];

				face = obj_faces[ fi ];
				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 4; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.u;
					uvArray[ offset_uv + 1 ] = uvi.v;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				face = obj_faces[ fi ];
				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.u;
					uv2Array[ offset_uv2 + 1 ] = uv2i.v;

					offset_uv2 += 2;

				}

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				fi = chunk_faces4[ f ];

				face = obj_faces[ fi ];
				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 4; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.u;
					uv2Array[ offset_uv2 + 1 ] = uv2i.v;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				faceArray[ offset_face ]     = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 3;

				faceArray[ offset_face + 3 ] = vertexIndex + 1;
				faceArray[ offset_face + 4 ] = vertexIndex + 2;
				faceArray[ offset_face + 5 ] = vertexIndex + 3;

				offset_face += 6;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 3;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				lineArray[ offset_line + 6 ] = vertexIndex + 2;
				lineArray[ offset_line + 7 ] = vertexIndex + 3;

				offset_line += 8;

				vertexIndex += 4;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
							customAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];

							offset_custom += 4;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;
							customAttribute.array[ offset_custom + 3 ] = value;

							offset_custom += 4;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinVertexAArray;
			delete geometryGroup.__skinVertexBArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	// Buffer rendering

	function renderBufferImmediate ( object, program, shading ) {

		if ( ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();

		if ( object.hasPos ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormal ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	function renderBuffer ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.opacity === 0 ) return;

		var program, attributes, linewidth, primitives, a, attribute, i, il;

		program = setProgram( camera, lights, fog, material, object );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		// vertices

		if ( !material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( geometryGroup.__webglUVBuffer ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

					_gl.enableVertexAttribArray( attributes.uv );

				} else {

					_gl.disableVertexAttribArray( attributes.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( geometryGroup.__webglUV2Buffer ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

					_gl.enableVertexAttribArray( attributes.uv2 );

				} else {

					_gl.disableVertexAttribArray( attributes.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinVertexA >= 0 && attributes.skinVertexB >= 0 &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinVertexABuffer );
				_gl.vertexAttribPointer( attributes.skinVertexA, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinVertexBBuffer );
				_gl.vertexAttribPointer( attributes.skinVertexB, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;

		// render ribbon

		} else if ( object instanceof THREE.Ribbon ) {

			_gl.drawArrays( _gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );

			_this.info.render.calls ++;

		}

	};

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== - 1 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
				_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find most influencing

			var used = [];
			var candidateInfluence = - 1;
			var candidate = 0;
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;
			var m = 0;

			if ( object.morphTargetBase !== - 1 ) {

				used[ object.morphTargetBase ] = true;

			}

			while ( m < material.numSupportedMorphTargets ) {

				for ( i = 0; i < il; i ++ ) {

					if ( !used[ i ] && influences[ i ] > candidateInfluence ) {

						candidate = i;
						candidateInfluence = influences[ candidate ];

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ candidate ] );
				_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

				object.__webglMorphTargetInfluences[ m ] = candidateInfluence;

				used[ candidate ] = 1;
				candidateInfluence = -1;
				m ++;

			}

		}

		// load updated influences uniform

		if( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	}

	// Frustum

	function computeFrustum ( m ) {

		_frustum[ 0 ].set( m.n41 - m.n11, m.n42 - m.n12, m.n43 - m.n13, m.n44 - m.n14 );
		_frustum[ 1 ].set( m.n41 + m.n11, m.n42 + m.n12, m.n43 + m.n13, m.n44 + m.n14 );
		_frustum[ 2 ].set( m.n41 + m.n21, m.n42 + m.n22, m.n43 + m.n23, m.n44 + m.n24 );
		_frustum[ 3 ].set( m.n41 - m.n21, m.n42 - m.n22, m.n43 - m.n23, m.n44 - m.n24 );
		_frustum[ 4 ].set( m.n41 - m.n31, m.n42 - m.n32, m.n43 - m.n33, m.n44 - m.n34 );
		_frustum[ 5 ].set( m.n41 + m.n31, m.n42 + m.n32, m.n43 + m.n33, m.n44 + m.n34 );

		var i, plane;

		for ( i = 0; i < 6; i ++ ) {

			plane = _frustum[ i ];
			plane.divideScalar( Math.sqrt( plane.x * plane.x + plane.y * plane.y + plane.z * plane.z ) );

		}

	};

	function isInFrustum ( object ) {

		var distance, matrix = object.matrixWorld,
		radius = - object.geometry.boundingSphere.radius * Math.max( object.scale.x, Math.max( object.scale.y, object.scale.z ) );

		for ( var i = 0; i < 6; i ++ ) {

			distance = _frustum[ i ].x * matrix.n14 + _frustum[ i ].y * matrix.n24 + _frustum[ i ].z * matrix.n34 + _frustum[ i ].w;
			if ( distance <= radius ) return false;

		}

		return true;

	};


	function painterSort ( a, b ) {

		return b.z - a.z;

	};

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		var i, il,

		program, material,
		webglObject, object,
		renderList,

		lights = scene.lights,
		fog = scene.fog;

		_currentMaterialId = -1;

		if ( this.autoUpdateObjects ) this.initWebGLObjects( scene );

		if ( this.shadowMapEnabled && this.shadowMapAutoUpdate ) renderShadowMap( scene, camera );

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;

		if ( camera.parent === undefined ) {

			console.warn( 'DEPRECATED: Camera hasn\'t been added to a Scene. Adding it...' );
			scene.add( camera );

		}

		if ( this.autoUpdateScene ) scene.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );
		camera.matrixWorldInverse.flattenToArray( _viewMatrixArray );
		camera.projectionMatrix.flattenToArray( _projectionMatrixArray );

		_projScreenMatrix.multiply( camera.projectionMatrix, camera.matrixWorldInverse );
		computeFrustum( _projScreenMatrix );

		setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for regular objects (frustum culled)

		renderList = scene.__webglObjects;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh ) || ! ( object.frustumCulled ) || isInFrustum( object ) ) {

					object.matrixWorld.flattenToArray( object._objectMatrixArray );

					setupMatrices( object, camera, true );

					unrollBufferMaterial( webglObject );

					webglObject.render = true;

					if ( this.sortObjects ) {

						if ( object.renderDepth ) {

							webglObject.z = object.renderDepth;

						} else {

							_vector3.copy( object.position );
							_projScreenMatrix.multiplyVector3( _vector3 );

							webglObject.z = _vector3.z;

						}

					}

				}

			}

		}

		if ( this.sortObjects ) {

			renderList.sort( painterSort );

		}

		// set matrices for immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if( object.matrixAutoUpdate ) {

					object.matrixWorld.flattenToArray( object._objectMatrixArray );

				}

				setupMatrices( object, camera, true );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			setBlending( scene.overrideMaterial.blending );
			setDepthTest( scene.overrideMaterial.depthTest );
			setDepthWrite( scene.overrideMaterial.depthWrite );
			setPolygonOffset( scene.overrideMaterial.polygonOffset, scene.overrideMaterial.polygonOffsetFactor, scene.overrideMaterial.polygonOffsetUnits );

			renderObjects( scene.__webglObjects, false, "", camera, lights, fog, true, scene.overrideMaterial );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "", camera, lights, fog, false, scene.overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			setBlending( THREE.NormalBlending );

			renderObjects( scene.__webglObjects, true, "opaque", camera, lights, fog, false );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "opaque", camera, lights, fog, false );

			// transparent pass (back-to-front order)

			renderObjects( scene.__webglObjects, false, "transparent", camera, lights, fog, true );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "transparent", camera, lights, fog, true );

		}

		// render 2d

		if ( scene.__webglSprites.length ) {

			renderSprites( scene, camera );

		}

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		//_gl.finish();

	};

	function renderShadowMap ( scene, camera ) {

		var i, il, j, jl,

		shadowMap, shadowMatrix,
		program, buffer, material,
		webglObject, object, light,

		shadowIndex = 0,

		lights = scene.lights,
		fog = null;

		if ( ! _cameraLight ) {

			_cameraLight = new THREE.PerspectiveCamera( _this.shadowCameraFov, _this.shadowMapWidth / _this.shadowMapHeight, _this.shadowCameraNear, _this.shadowCameraFar );

		}

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( light.castShadow && light instanceof THREE.SpotLight ) {

				_currentMaterialId = -1;

				if ( ! _this.shadowMap[ shadowIndex ] ) {

					var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

					_this.shadowMap[ shadowIndex ] = new THREE.WebGLRenderTarget( _this.shadowMapWidth, _this.shadowMapHeight, pars );
					_shadowMatrix[ shadowIndex ] = new THREE.Matrix4();

				}

				shadowMap = _this.shadowMap[ shadowIndex ];
				shadowMatrix = _shadowMatrix[ shadowIndex ];

				_cameraLight.position.copy( light.position );
				_cameraLight.lookAt( light.target.position );

				if ( _cameraLight.parent == null ) {

					console.warn( "Camera is not on the Scene. Adding it..." );
					scene.add( _cameraLight );

				}

				if ( this.autoUpdateScene ) scene.updateMatrixWorld();

				_cameraLight.matrixWorldInverse.getInverse( _cameraLight.matrixWorld );

				// compute shadow matrix

				shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
								  0.0, 0.5, 0.0, 0.5,
								  0.0, 0.0, 0.5, 0.5,
								  0.0, 0.0, 0.0, 1.0 );

				shadowMatrix.multiplySelf( _cameraLight.projectionMatrix );
				shadowMatrix.multiplySelf( _cameraLight.matrixWorldInverse );

				// render shadow map

				_cameraLight.matrixWorldInverse.flattenToArray( _viewMatrixArray );
				_cameraLight.projectionMatrix.flattenToArray( _projectionMatrixArray );

				_projScreenMatrix.multiply( _cameraLight.projectionMatrix, _cameraLight.matrixWorldInverse );
				computeFrustum( _projScreenMatrix );

				setRenderTarget( shadowMap );

				// using arbitrary clear color in depth pass
				// creates variance in shadows

				_gl.clearColor( 1, 1, 1, 1 );
				//_gl.clearColor( 0, 0, 0, 1 );

				_this.clear();

				_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

				// set matrices & frustum culling

				jl = scene.__webglObjects.length;

				for ( j = 0; j < jl; j ++ ) {

					webglObject = scene.__webglObjects[ j ];
					object = webglObject.object;

					webglObject.render = false;

					if ( object.visible && object.castShadow ) {

						if ( ! ( object instanceof THREE.Mesh ) || ! ( object.frustumCulled ) || isInFrustum( object ) ) {

							object.matrixWorld.flattenToArray( object._objectMatrixArray );

							setupMatrices( object, _cameraLight, false );

							webglObject.render = true;

						}

					}

				}

				// render regular objects

				setDepthTest( true );
				setBlending( THREE.NormalBlending ); // maybe blending should be just disabled?

				//_gl.cullFace( _gl.FRONT );

				for ( j = 0; j < jl; j ++ ) {

					webglObject = scene.__webglObjects[ j ];

					if ( webglObject.render ) {

						object = webglObject.object;
						buffer = webglObject.buffer;

						setObjectFaces( object );

						if ( object.customDepthMaterial ) {

							material = object.customDepthMaterial;

						} else if ( object.geometry.morphTargets.length ) {

							material = _depthMaterialMorph;

						} else {

							material = _depthMaterial;

						}

						renderBuffer( _cameraLight, lights, fog, material, buffer, object );

					}

				}

				// set matrices and render immediate objects

				jl = scene.__webglObjectsImmediate.length;

				for ( j = 0; j < jl; j ++ ) {

					webglObject = scene.__webglObjectsImmediate[ j ];
					object = webglObject.object;

					if ( object.visible && object.castShadow ) {

						if( object.matrixAutoUpdate ) {

							object.matrixWorld.flattenToArray( object._objectMatrixArray );

						}

						_currentGeometryGroupHash = -1;

						setupMatrices( object, _cameraLight, false );

						setObjectFaces( object );

						program = setProgram( _cameraLight, lights, fog, _depthMaterial, object );

						if ( object.immediateRenderCallback ) {

							object.immediateRenderCallback( program, _gl, _frustum );

						} else {

							object.render( function( object ) { renderBufferImmediate( object, program, _depthMaterial.shading ); } );

						}

					}

				}

				//_gl.cullFace( _gl.BACK );

				shadowIndex ++;

			}

		}

	};

	function renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, buffer, material, start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i !== end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) setBlending( material.blending );

					setDepthTest( material.depthTest );
					setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				setObjectFaces( object );

				renderBuffer( camera, lights, fog, material, buffer, object );

			}

		}

	};

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, material, program;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				_currentGeometryGroupHash = -1;

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) setBlending( material.blending );

					setDepthTest( material.depthTest );
					setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				setObjectFaces( object );

				program = setProgram( camera, lights, fog, material, object );

				if ( object.immediateRenderCallback ) {

					object.immediateRenderCallback( program, _gl, _frustum );

				} else {

					object.render( function( object ) { renderBufferImmediate( object, program, material.shading ); } );

				}

			}

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	};

	function unrollBufferMaterial ( globject ) {

		var object = globject.object,
			buffer = globject.buffer,
			material, materialIndex, meshMaterial;

		meshMaterial = object.material;

		if ( meshMaterial instanceof THREE.MeshFaceMaterial ) {

			materialIndex = buffer.materialIndex;

			if ( materialIndex >= 0 ) {

				material = object.geometry.materials[ materialIndex ];

				if ( material.transparent ) {

					globject.transparent = material;
					globject.opaque = null;

				} else {

					globject.opaque = material;
					globject.transparent = null;

				}

			}

		} else {

			material = meshMaterial;

			if ( material ) {

				if ( material.transparent ) {

					globject.transparent = material;
					globject.opaque = null;

				} else {

					globject.opaque = material;
					globject.transparent = null;

				}

			}

		}

	};

	function renderSprites ( scene, camera ) {

		var o, ol, object;
		var attributes = _sprite.attributes;
		var uniforms = _sprite.uniforms;
		var invAspect = _viewportHeight / _viewportWidth;
		var size, scale = [];
		var screenPosition;
		var halfViewportWidth = _viewportWidth * 0.5;
		var halfViewportHeight = _viewportHeight * 0.5;
		var mergeWith3D = true;

		// setup gl

		_gl.useProgram( _sprite.program );
		_currentProgram = _sprite.program;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_currentGeometryGroupHash = -1;

		if ( !_spriteAttributesEnabled ) {

			_gl.enableVertexAttribArray( _sprite.attributes.position );
			_gl.enableVertexAttribArray( _sprite.attributes.uv );

			_spriteAttributesEnabled = true;

		}

		_gl.disable( _gl.CULL_FACE );
		_gl.enable( _gl.BLEND );
		_gl.depthMask( true );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );
		_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );

		_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, _projectionMatrixArray );

		_gl.activeTexture( _gl.TEXTURE0 );
		_gl.uniform1i( uniforms.map, 0 );

		// update positions and sort

		for( o = 0, ol = scene.__webglSprites.length; o < ol; o ++ ) {

			object = scene.__webglSprites[ o ];

			if ( !object.visible || object.opacity === 0 ) continue;

			if( !object.useScreenCoordinates ) {

				object._modelViewMatrix.multiplyToArray( camera.matrixWorldInverse, object.matrixWorld, object._modelViewMatrixArray );
				object.z = -object._modelViewMatrix.n34;

			} else {

				object.z = -object.position.z;

			}

		}

		scene.__webglSprites.sort( painterSort );

		// render all sprites

		for ( o = 0, ol = scene.__webglSprites.length; o < ol; o ++ ) {

			object = scene.__webglSprites[ o ];

			if ( !object.visible || object.opacity === 0 ) continue;

			if ( object.map && object.map.image && object.map.image.width ) {

				if ( object.useScreenCoordinates ) {

					_gl.uniform1i( uniforms.useScreenCoordinates, 1 );
					_gl.uniform3f( uniforms.screenPosition, ( object.position.x - halfViewportWidth  ) / halfViewportWidth,
															( halfViewportHeight - object.position.y ) / halfViewportHeight,
															  Math.max( 0, Math.min( 1, object.position.z )));

				} else {

					_gl.uniform1i( uniforms.useScreenCoordinates, 0 );
					_gl.uniform1i( uniforms.affectedByDistance, object.affectedByDistance ? 1 : 0 );
					_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrixArray );

				}

				size = object.map.image.width / ( object.scaleByViewport ? _viewportHeight : 1 );

				scale[ 0 ] = size * invAspect * object.scale.x;
				scale[ 1 ] = size * object.scale.y;

				_gl.uniform2f( uniforms.uvScale, object.uvScale.x, object.uvScale.y );
				_gl.uniform2f( uniforms.uvOffset, object.uvOffset.x, object.uvOffset.y );
				_gl.uniform2f( uniforms.alignment, object.alignment.x, object.alignment.y );

				_gl.uniform1f( uniforms.opacity, object.opacity );
				_gl.uniform3f( uniforms.color, object.color.r, object.color.g, object.color.b );

				_gl.uniform1f( uniforms.rotation, object.rotation );
				_gl.uniform2fv( uniforms.scale, scale );

				if ( object.mergeWith3D && !mergeWith3D ) {

					_gl.enable( _gl.DEPTH_TEST );
					mergeWith3D = true;

				} else if ( !object.mergeWith3D && mergeWith3D ) {

					_gl.disable( _gl.DEPTH_TEST );
					mergeWith3D = false;

				}

				setBlending( object.blending );
				setTexture( object.map, 0 );

				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

			}

		}


		// restore gl

		_gl.enable( _gl.CULL_FACE );
		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthMask( _oldDepthWrite );

	}

	// Geometry splitting

	function sortFacesByMaterial ( geometry ) {

		var f, fl, face, materialIndex, vertices,
			materialHash, groupHash,
			hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;

		geometry.geometryGroups = {};

		for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			face = geometry.faces[ f ];
			materialIndex = face.materialIndex;

			materialHash = ( materialIndex !== undefined ) ? materialIndex : -1;

			if ( hash_map[ materialHash ] === undefined ) {

				hash_map[ materialHash ] = { 'hash': materialHash, 'counter': 0 };

			}

			groupHash = hash_map[ materialHash ].hash + '_' + hash_map[ materialHash ].counter;

			if ( geometry.geometryGroups[ groupHash ] === undefined ) {

				geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets };

			}

			vertices = face instanceof THREE.Face3 ? 3 : 4;

			if ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {

				hash_map[ materialHash ].counter += 1;
				groupHash = hash_map[ materialHash ].hash + '_' + hash_map[ materialHash ].counter;

				if ( geometry.geometryGroups[ groupHash ] === undefined ) {

					geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets };

				}

			}

			if ( face instanceof THREE.Face3 ) {

				geometry.geometryGroups[ groupHash ].faces3.push( f );

			} else {

				geometry.geometryGroups[ groupHash ].faces4.push( f );

			}

			geometry.geometryGroups[ groupHash ].vertices += vertices;

		}

		geometry.geometryGroupsList = [];

		for ( var g in geometry.geometryGroups ) {

			geometry.geometryGroups[ g ].id = _geometryGroupCounter ++;

			geometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );

		}

	};

	// Objects refresh

	this.initWebGLObjects = function ( scene ) {

		if ( !scene.__webglObjects ) {

			scene.__webglObjects = [];
			scene.__webglObjectsImmediate = [];
			scene.__webglSprites = [];

		}

		while ( scene.__objectsAdded.length ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.splice( 0, 1 );

		}

		while ( scene.__objectsRemoved.length ) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.splice( 0, 1 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {

			updateObject( scene.__webglObjects[ o ].object );

		}

	};

	// Objects adding

	function addObject ( object, scene ) {

		var g, geometry, geometryGroup;

		if ( ! object.__webglInit ) {

			object.__webglInit = true;

			object._modelViewMatrix = new THREE.Matrix4();

			object._normalMatrixArray = new Float32Array( 9 );
			object._modelViewMatrixArray = new Float32Array( 16 );
			object._objectMatrixArray = new Float32Array( 16 );

			object.matrixWorld.flattenToArray( object._objectMatrixArray );

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				if ( geometry.geometryGroups === undefined ) {

					sortFacesByMaterial( geometry );

				}

				// create separate VBOs per geometry chunk

				for ( g in geometry.geometryGroups ) {

					geometryGroup = geometry.geometryGroups[ g ];

					// initialise VBO on the first access

					if ( ! geometryGroup.__webglVertexBuffer ) {

						createMeshBuffers( geometryGroup );
						initMeshBuffers( geometryGroup, object );

						geometry.__dirtyVertices = true;
						geometry.__dirtyMorphTargets = true;
						geometry.__dirtyElements = true;
						geometry.__dirtyUvs = true;
						geometry.__dirtyNormals = true;
						geometry.__dirtyTangents = true;
						geometry.__dirtyColors = true;

					}

				}

			} else if ( object instanceof THREE.Ribbon ) {

				geometry = object.geometry;

				if( ! geometry.__webglVertexBuffer ) {

					createRibbonBuffers( geometry );
					initRibbonBuffers( geometry );

					geometry.__dirtyVertices = true;
					geometry.__dirtyColors = true;

				}

			} else if ( object instanceof THREE.Line ) {

				geometry = object.geometry;

				if( ! geometry.__webglVertexBuffer ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.__dirtyVertices = true;
					geometry.__dirtyColors = true;

				}

			} else if ( object instanceof THREE.ParticleSystem ) {

				geometry = object.geometry;

				if ( ! geometry.__webglVertexBuffer ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.__dirtyVertices = true;
					geometry.__dirtyColors = true;

				}

			}

		}

		if ( ! object.__webglActive ) {

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				for ( g in geometry.geometryGroups ) {

					geometryGroup = geometry.geometryGroups[ g ];

					addBuffer( scene.__webglObjects, geometryGroup, object );

				}

			} else if ( object instanceof THREE.Ribbon ||
						object instanceof THREE.Line ||
						object instanceof THREE.ParticleSystem ) {

				geometry = object.geometry;
				addBuffer( scene.__webglObjects, geometry, object );

			} else if ( THREE.MarchingCubes !== undefined && object instanceof THREE.MarchingCubes || object.immediateRenderCallback ) {

				addBufferImmediate( scene.__webglObjectsImmediate, object );

			} else if ( object instanceof THREE.Sprite ) {

				scene.__webglSprites.push( object );

			}

			object.__webglActive = true;

		}

	};

	function addBuffer ( objlist, buffer, object ) {

		objlist.push(
			{
				buffer: buffer,
				object: object,
				opaque: null,
				transparent: null
			}
		);

	};

	function addBufferImmediate ( objlist, object ) {

		objlist.push(
			{
				object: object,
				opaque: null,
				transparent: null
			}
		);

	};

	// Objects updates

	function updateObject ( object ) {

		var geometry = object.geometry,
			geometryGroup, customAttributesDirty, material;

		if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			for( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {

				geometryGroup = geometry.geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.__dirtyVertices || geometry.__dirtyMorphTargets || geometry.__dirtyElements ||
					 geometry.__dirtyUvs || geometry.__dirtyNormals ||
					 geometry.__dirtyColors || geometry.__dirtyTangents || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );

				}

			}

			geometry.__dirtyVertices = false;
			geometry.__dirtyMorphTargets = false;
			geometry.__dirtyElements = false;
			geometry.__dirtyUvs = false;
			geometry.__dirtyNormals = false;
			geometry.__dirtyColors = false;
			geometry.__dirtyTangents = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Ribbon ) {

			if ( geometry.__dirtyVertices || geometry.__dirtyColors ) {

				setRibbonBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.__dirtyVertices = false;
			geometry.__dirtyColors = false;

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometryGroup );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.__dirtyVertices ||  geometry.__dirtyColors || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.__dirtyVertices = false;
			geometry.__dirtyColors = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.ParticleSystem ) {

			material = getBufferMaterial( object, geometryGroup );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.__dirtyVertices || geometry.__dirtyColors || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.__dirtyVertices = false;
			geometry.__dirtyColors = false;

			material.attributes && clearCustomAttributes( material );

		}

	};

	// Objects updates - custom attributes check

	function areCustomAttributesDirty ( material ) {

		for ( var a in material.attributes ) {

			if ( material.attributes[ a ].needsUpdate ) return true;

		}

		return false;

	};

	function clearCustomAttributes ( material ) {

		for ( var a in material.attributes ) {

			material.attributes[ a ].needsUpdate = false;

		}

	};

	// Objects removal

	function removeObject ( object, scene ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.ParticleSystem ||
			 object instanceof THREE.Ribbon ||
			 object instanceof THREE.Line ) {

			removeInstances( scene.__webglObjects, object );

		} else if ( object instanceof THREE.Sprite ) {

			removeInstancesDirect( scene.__webglSprites, object );

		} else if ( object instanceof THREE.MarchingCubes || object.immediateRenderCallback ) {

			removeInstances( scene.__webglObjectsImmediate, object );

		}

		object.__webglActive = false;

	};

	function removeInstances ( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	function removeInstancesDirect ( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ] === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	// Materials

	this.initMaterial = function ( material, lights, fog, object ) {

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.ParticleBasicMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			setMaterialShaders( material, THREE.ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		parameters = {

			map: !!material.map, envMap: !!material.envMap, lightMap: !!material.lightMap,
			vertexColors: material.vertexColors,
			fog: fog, useFog: material.fog,
			sizeAttenuation: material.sizeAttenuation,
			skinning: material.skinning,
			morphTargets: material.morphTargets,
			maxMorphTargets: this.maxMorphTargets,
			maxDirLights: maxLightCount.directional, maxPointLights: maxLightCount.point,
			maxBones: maxBones,
			shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
			shadowMapSoft: this.shadowMapSoft,
			shadowMapWidth: this.shadowMapWidth,
			shadowMapHeight: this.shadowMapHeight,
			maxShadows: maxShadows,
			alphaTest: material.alphaTest,
			metal: material.metal,
			perPixel: material.perPixel

		};

		material.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, parameters );

		var attributes = material.program.attributes;

		if ( attributes.position >= 0 ) _gl.enableVertexAttribArray( attributes.position );
		if ( attributes.color >= 0 ) _gl.enableVertexAttribArray( attributes.color );
		if ( attributes.normal >= 0 ) _gl.enableVertexAttribArray( attributes.normal );
		if ( attributes.tangent >= 0 ) _gl.enableVertexAttribArray( attributes.tangent );

		if ( material.skinning &&
			 attributes.skinVertexA >=0 && attributes.skinVertexB >= 0 &&
			 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

			_gl.enableVertexAttribArray( attributes.skinVertexA );
			_gl.enableVertexAttribArray( attributes.skinVertexB );
			_gl.enableVertexAttribArray( attributes.skinIndex );
			_gl.enableVertexAttribArray( attributes.skinWeight );

		}

		if ( material.attributes ) {

			for ( a in material.attributes ) {

				if( attributes[ a ] !== undefined && attributes[ a ] >= 0 ) _gl.enableVertexAttribArray( attributes[ a ] );

			}

		}

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i < this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					_gl.enableVertexAttribArray( attributes[ id ] );
					material.numSupportedMorphTargets ++;

				}

			}

		}

		material.uniformsList = [];

		for ( u in material.uniforms ) {

			material.uniformsList.push( [ material.uniforms[ u ], u ] );

		}

	};

	function setMaterialShaders ( material, shaders ) {

		material.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );
		material.vertexShader = shaders.vertexShader;
		material.fragmentShader = shaders.fragmentShader;

	};

	function setProgram ( camera, lights, fog, material, object ) {

		if ( ! material.program ) {

			_this.initMaterial( material, lights, fog, object );

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

				for ( var i = 0, il = _this.maxMorphTargets; i < il; i ++ ) {

					object.__webglMorphTargetInfluences[ i ] = 0;

				}

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

		if ( program !== _currentProgram ) {

			_gl.useProgram( program );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

		if ( refreshMaterial ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, _projectionMatrixArray );

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				setupLights( program, lights );
				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.ParticleBasicMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, material );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if( p_uniforms.cameraPosition !== null ) {

					_gl.uniform3f( p_uniforms.cameraPosition, camera.position.x, camera.position.y, camera.position.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, _viewMatrixArray );

				}

			}

			if ( material.skinning ) {

				loadUniformsSkinning( p_uniforms, object );

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( material instanceof THREE.ShaderMaterial ||
			 material.envMap ||
			 material.skinning ||
			 object.receiveShadow ) {

			if ( p_uniforms.objectMatrix !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.objectMatrix, false, object._objectMatrixArray );

			}

		}

		return program;

	};

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.texture = material.map;

		if ( material.map ) {

			uniforms.offsetRepeat.value.set( material.map.offset.x, material.map.offset.y, material.map.repeat.x, material.map.repeat.y );

		}

		uniforms.lightMap.texture = material.lightMap;

		uniforms.envMap.texture = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	};

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	};

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.texture = material.map;

	};

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	};

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.specular.value = material.specular;

		}

	};

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );

		} else {

			uniforms.ambient.value = material.ambient;

		}

	};

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

	};

	function refreshUniformsShadow ( uniforms, material ) {

		if ( uniforms.shadowMatrix ) {

			for ( var i = 0; i < _shadowMatrix.length; i ++ ) {

				uniforms.shadowMatrix.value[ i ] = _shadowMatrix[ i ];
				uniforms.shadowMap.texture[ i ] = _this.shadowMap[ i ];


			}

			uniforms.shadowDarkness.value = _this.shadowMapDarkness;
			uniforms.shadowBias.value = _this.shadowMapBias;

		}

	};

	// Uniforms (load to GPU)

	function loadUniformsSkinning ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.cameraInverseMatrix, false, _viewMatrixArray );
		_gl.uniformMatrix4fv( uniforms.boneGlobalMatrices, false, object.boneMatrices );

	};


	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrixArray );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrixArray );

		}

	};

	function loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, i, il, j, jl, offset;

		for( j = 0, jl = uniforms.length; j < jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( !location ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.value;

			// single integer

			if( type === "i" ) {

				_gl.uniform1i( location, value );

			// single float

			} else if( type === "f" ) {

				_gl.uniform1f( location, value );

			// single THREE.Vector2

			} else if( type === "v2" ) {

				_gl.uniform2f( location, value.x, value.y );

			// single THREE.Vector3

			} else if( type === "v3" ) {

				_gl.uniform3f( location, value.x, value.y, value.z );

			// single THREE.Vector4

			} else if( type === "v4" ) {

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			// single THREE.Color

			} else if( type === "c" ) {

				_gl.uniform3f( location, value.r, value.g, value.b );

			// flat array of floats (JS or typed array)

			} else if( type === "fv1" ) {

				_gl.uniform1fv( location, value );

			// flat array of floats with 3 x N size (JS or typed array)

			} else if( type === "fv" ) {

				_gl.uniform3fv( location, value );

			// array of THREE.Vector3

			} else if( type === "v3v" ) {

				if ( ! uniform._array ) {

					uniform._array = new Float32Array( 3 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 3;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;

				}

				_gl.uniform3fv( location, uniform._array );

			// single THREE.Matrix4

			} else if( type === "m4" ) {

				if ( ! uniform._array ) {

					uniform._array = new Float32Array( 16 );

				}

				value.flattenToArray( uniform._array );
				_gl.uniformMatrix4fv( location, false, uniform._array );

			// array of THREE.Matrix4

			} else if( type === "m4v" ) {

				if ( ! uniform._array ) {

					uniform._array = new Float32Array( 16 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

				}

				_gl.uniformMatrix4fv( location, false, uniform._array );


			// single THREE.Texture (2d or cube)

			} else if( type === "t" ) {

				_gl.uniform1i( location, value );

				texture = uniform.texture;

				if ( !texture ) continue;

				if ( texture.image instanceof Array && texture.image.length === 6 ) {

					setCubeTexture( texture, value );

				} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, value );

				} else {

					setTexture( texture, value );

				}

			// array of THREE.Texture (2d)

			} else if( type === "tv" ) {

				if ( ! uniform._array ) {

					uniform._array = [];

					for( i = 0, il = uniform.texture.length; i < il; i ++ ) {

						uniform._array[ i ] = value + i;

					}

				}

				_gl.uniform1iv( location, uniform._array );

				for( i = 0, il = uniform.texture.length; i < il; i ++ ) {

					texture = uniform.texture[ i ];

					if ( !texture ) continue;

					setTexture( texture, uniform._array[ i ] );

				}

			}

		}

	};

	function setupMatrices ( object, camera, computeNormalMatrix ) {

		object._modelViewMatrix.multiplyToArray( camera.matrixWorldInverse, object.matrixWorld, object._modelViewMatrixArray );

		if ( computeNormalMatrix ) {

			THREE.Matrix4.makeInvert3x3( object._modelViewMatrix ).transposeIntoArray( object._normalMatrixArray );

		}

	};

	function setupLights ( program, lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, position, intensity, distance,

		zlights = _lights,

		dcolors = zlights.directional.colors,
		dpositions = zlights.directional.positions,

		pcolors = zlights.point.colors,
		ppositions = zlights.point.positions,
		pdistances = zlights.point.distances,

		dlength = 0,
		plength = 0,

		doffset = 0,
		poffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];
			color = light.color;

			position = light.position;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				doffset = dlength * 3;

				if ( _this.gammaInput ) {

					dcolors[ doffset ]     = color.r * color.r * intensity * intensity;
					dcolors[ doffset + 1 ] = color.g * color.g * intensity * intensity;
					dcolors[ doffset + 2 ] = color.b * color.b * intensity * intensity;

				} else {

					dcolors[ doffset ]     = color.r * intensity;
					dcolors[ doffset + 1 ] = color.g * intensity;
					dcolors[ doffset + 2 ] = color.b * intensity;

				}

				dpositions[ doffset ]     = position.x;
				dpositions[ doffset + 1 ] = position.y;
				dpositions[ doffset + 2 ] = position.z;

				dlength += 1;

			} else if ( light instanceof THREE.SpotLight ) { // hack, not a proper spotlight

				doffset = dlength * 3;

				if ( _this.gammaInput ) {

					dcolors[ doffset ]     = color.r * color.r * intensity * intensity;
					dcolors[ doffset + 1 ] = color.g * color.g * intensity * intensity;
					dcolors[ doffset + 2 ] = color.b * color.b * intensity * intensity;

				} else {

					dcolors[ doffset ]     = color.r * intensity;
					dcolors[ doffset + 1 ] = color.g * intensity;
					dcolors[ doffset + 2 ] = color.b * intensity;

				}

				n = 1 / position.length();

				dpositions[ doffset ]     = position.x * n;
				dpositions[ doffset + 1 ] = position.y * n;
				dpositions[ doffset + 2 ] = position.z * n;

				dlength += 1;

			} else if( light instanceof THREE.PointLight ) {

				poffset = plength * 3;

				if ( _this.gammaInput ) {

					pcolors[ poffset ]     = color.r * color.r * intensity * intensity;
					pcolors[ poffset + 1 ] = color.g * color.g * intensity * intensity;
					pcolors[ poffset + 2 ] = color.b * color.b * intensity * intensity;

				} else {

					pcolors[ poffset ]     = color.r * intensity;
					pcolors[ poffset + 1 ] = color.g * intensity;
					pcolors[ poffset + 2 ] = color.b * intensity;

				}

				ppositions[ poffset ]     = position.x;
				ppositions[ poffset + 1 ] = position.y;
				ppositions[ poffset + 2 ] = position.z;

				pdistances[ plength ] = distance;

				plength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dlength * 3, ll = dcolors.length; l < ll; l ++ ) dcolors[ l ] = 0.0;
		for ( l = plength * 3, ll = pcolors.length; l < ll; l ++ ) pcolors[ l ] = 0.0;

		zlights.point.length = plength;
		zlights.directional.length = dlength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	};

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFace ) {

		if ( cullFace ) {

			if ( !frontFace || frontFace === "ccw" ) {

				_gl.frontFace( _gl.CCW );

			} else {

				_gl.frontFace( _gl.CW );

			}

			if( cullFace === "back" ) {

				_gl.cullFace( _gl.BACK );

			} else if( cullFace === "front" ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		} else {

			_gl.disable( _gl.CULL_FACE );

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	};

	function setObjectFaces ( object ) {

		if ( _oldDoubleSided !== object.doubleSided ) {

			if( object.doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = object.doubleSided;

		}

		if ( _oldFlipSided !== object.flipSided ) {

			if( object.flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = object.flipSided;

		}

	};

	function setDepthTest ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	function setDepthWrite ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	};

	function setBlending ( blending ) {

		if ( blending !== _oldBlending ) {

			switch ( blending ) {

				case THREE.AdditiveBlending:

					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

					break;

				case THREE.SubtractiveBlending:

					// TODO: Find blendFuncSeparate() combination

					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

					break;

				case THREE.MultiplyBlending:

					// TODO: Find blendFuncSeparate() combination

					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

					break;

				default:

					_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
					_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

					break;

			}

			_oldBlending = blending;

		}

	};

	// Shaders

	function buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, parameters ) {

		var p, pl, program, code;
		var chunks = [];

		// Generate code

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( fragmentShader );
			chunks.push( vertexShader );

		}

		for ( p in parameters ) {

			chunks.push( p );
			chunks.push( parameters[ p ] );

		}

		code = chunks.join();

		// Check if code has been already compiled

		for ( p = 0, pl = _programs.length; p < pl; p ++ ) {

			if ( _programs[ p ].code === code ) {

				// console.log( "Code already compiled." /*: \n\n" + code*/ );

				return _programs[ p ].program;

			}

		}

		//console.log( "building new program " );

		//

		program = _gl.createProgram();

		var prefix_vertex = [

			_supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
			_this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			"#define MAX_BONES " + parameters.maxBones,

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",
			parameters.skinning ? "#define USE_SKINNING" : "",
			parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
			parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapSoft ? "#define SHADOWMAP_SOFT" : "",

			parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 objectMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"uniform mat4 cameraInverseMatrix;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",
				"attribute vec3 morphTarget4;",
				"attribute vec3 morphTarget5;",
				"attribute vec3 morphTarget6;",
				"attribute vec3 morphTarget7;",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinVertexA;",
				"attribute vec4 skinVertexB;",
				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		].join("\n");

		var prefix_fragment = [

			"#ifdef GL_ES",
			"precision " + _precision + " float;",
			"#endif",

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
			_this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
			( parameters.useFog && parameters.fog instanceof THREE.FogExp2 ) ? "#define FOG_EXP2" : "",

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.metal ? "#define METAL" : "",
			parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapSoft ? "#define SHADOWMAP_SOFT" : "",
			parameters.shadowMapSoft ? "#define SHADOWMAP_WIDTH " + parameters.shadowMapWidth.toFixed( 1 ) : "",
			parameters.shadowMapSoft ? "#define SHADOWMAP_HEIGHT " + parameters.shadowMapHeight.toFixed( 1 ) : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		].join("\n");

		_gl.attachShader( program, getShader( "fragment", prefix_fragment + fragmentShader ) );
		_gl.attachShader( program, getShader( "vertex", prefix_vertex + vertexShader ) );

		_gl.linkProgram( program );

		if ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {

			console.error( "Could not initialise shader\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + ", gl error [" + _gl.getError() + "]" );

		}

		//console.log( prefix_fragment + fragmentShader );
		//console.log( prefix_vertex + vertexShader );

		program.uniforms = {};
		program.attributes = {};

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'objectMatrix', 'cameraPosition',
			'cameraInverseMatrix', 'boneGlobalMatrices', 'morphTargetInfluences'

		];

		for ( u in uniforms ) {

			identifiers.push( u );

		}

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinVertexA", "skinVertexB", "skinIndex", "skinWeight"

		];

		for ( i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( a in attributes ) {

			identifiers.push( a );

		}

		cacheAttributeLocations( program, identifiers );

		program.id = _programs.length;

		_programs.push( { program: program, code: code } );

		_this.info.memory.programs = _programs.length;

		return program;

	};

	// Shader parameters cache

	function cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program, id );

		}

	};

	function cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program, id );

		}

	};

	function getShader ( type, string ) {

		var shader;

		if ( type === "fragment" ) {

			shader = _gl.createShader( _gl.FRAGMENT_SHADER );

		} else if ( type === "vertex" ) {

			shader = _gl.createShader( _gl.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {

			console.error( _gl.getShaderInfoLog( shader ) );
			console.error( string );
			return null;

		}

		return shader;

	};

	// Textures

	function setTextureParameters ( textureType, texture, image ) {

		if ( isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ) ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

			return true;

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			return false;

		}

	};

	function setTexture ( texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( ! texture.__webglInit ) {

				texture.__webglInit = true;
				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			var needsMipMaps = setTextureParameters( _gl.TEXTURE_2D, texture, texture.image );

			if ( texture instanceof THREE.DataTexture ) {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, paramThreeToGL( texture.format ), texture.image.width, texture.image.height, 0, paramThreeToGL( texture.format ), _gl.UNSIGNED_BYTE, texture.image.data );

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE, texture.image );

			}

			if ( needsMipMaps ) {

				_gl.generateMipmap( _gl.TEXTURE_2D );

			}

			texture.needsUpdate = false;

			if ( texture.onUpdated ) texture.onUpdated();

		} else {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.image.__webglTextureCube = _gl.createTexture();

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				var needsMipMaps = setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, texture.image[ 0 ] );

				for ( var i = 0; i < 6; i ++ ) {

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE, texture.image[ i ] );

				}

				if ( needsMipMaps ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	};

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	};

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	};

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	};

	function setRenderTarget ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && ! renderTarget.__webglFramebuffer ) {

			if( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.__webglTexture = _gl.createTexture();

			// Setup texture, create render and frame buffers

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, renderTarget );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, paramThreeToGL( renderTarget.format ), renderTarget.width, renderTarget.height, 0, paramThreeToGL( renderTarget.format ), paramThreeToGL( renderTarget.type ), null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();
				renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, renderTarget );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, paramThreeToGL( renderTarget.format ), renderTarget.width, renderTarget.height, 0, paramThreeToGL( renderTarget.format ), paramThreeToGL( renderTarget.type ), null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );
				setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null);

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	};

	// fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		switch ( f ) {

			case THREE.NearestFilter:
			case THREE.NearestMipMapNearestFilter:
			case THREE.NearestMipMapLinearFilter: return _gl.NEAREST; break;

			case THREE.LinearFilter:
			case THREE.LinearMipMapNearestFilter:
			case THREE.LinearMipMapLinearFilter:
			default:

				return _gl.LINEAR; break;

		}

	};

	function paramThreeToGL ( p ) {

		switch ( p ) {

			case THREE.RepeatWrapping: return _gl.REPEAT; break;
			case THREE.ClampToEdgeWrapping: return _gl.CLAMP_TO_EDGE; break;
			case THREE.MirroredRepeatWrapping: return _gl.MIRRORED_REPEAT; break;

			case THREE.NearestFilter: return _gl.NEAREST; break;
			case THREE.NearestMipMapNearestFilter: return _gl.NEAREST_MIPMAP_NEAREST; break;
			case THREE.NearestMipMapLinearFilter: return _gl.NEAREST_MIPMAP_LINEAR; break;

			case THREE.LinearFilter: return _gl.LINEAR; break;
			case THREE.LinearMipMapNearestFilter: return _gl.LINEAR_MIPMAP_NEAREST; break;
			case THREE.LinearMipMapLinearFilter: return _gl.LINEAR_MIPMAP_LINEAR; break;

			case THREE.ByteType: return _gl.BYTE; break;
			case THREE.UnsignedByteType: return _gl.UNSIGNED_BYTE; break;
			case THREE.ShortType: return _gl.SHORT; break;
			case THREE.UnsignedShortType: return _gl.UNSIGNED_SHORT; break;
			case THREE.IntType: return _gl.INT; break;
			case THREE.UnsignedShortType: return _gl.UNSIGNED_INT; break;
			case THREE.FloatType: return _gl.FLOAT; break;

			case THREE.AlphaFormat: return _gl.ALPHA; break;
			case THREE.RGBFormat: return _gl.RGB; break;
			case THREE.RGBAFormat: return _gl.RGBA; break;
			case THREE.LuminanceFormat: return _gl.LUMINANCE; break;
			case THREE.LuminanceAlphaFormat: return _gl.LUMINANCE_ALPHA; break;

		}

		return 0;

	};

	function isPowerOfTwo ( value ) {

		return ( value & ( value - 1 ) ) === 0;

	};

	// Allocations

	function allocateBones ( object ) {

		// default for when object is not specified
		// ( for example when prebuilding shader
		//   to be used with multiple objects )
		//
		// 	- leave some extra space for other uniforms
		//  - limit here is ANGLE's 254 max uniform vectors
		//    (up to 54 should be safe)

		var maxBones = 50;

		if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

			maxBones = object.bones.length;

		}

		return maxBones;

	};

	function allocateLights ( lights ) {

		var l, ll, light, dirLights, pointLights, maxDirLights, maxPointLights;
		dirLights = pointLights = maxDirLights = maxPointLights = 0;

		for ( l = 0, ll = lights.length; l < ll; l++ ) {

			light = lights[ l ];

			if ( light instanceof THREE.SpotLight ) dirLights ++; // hack, not a proper spotlight
			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;

		}

		if ( ( pointLights + dirLights ) <= _maxLights ) {

			maxDirLights = dirLights;
			maxPointLights = pointLights;

		} else {

			maxDirLights = Math.ceil( _maxLights * dirLights / ( pointLights + dirLights ) );
			maxPointLights = _maxLights - maxDirLights;

		}

		return { 'directional' : maxDirLights, 'point' : maxPointLights };

	};

	function allocateShadows ( lights ) {

		var l, ll, light, maxShadows = 0;

		for ( l = 0, ll = lights.length; l < ll; l++ ) {

			light = lights[ l ];

			if ( light instanceof THREE.SpotLight && light.castShadow ) maxShadows ++;

		}

		return maxShadows;

	};

	function maxVertexTextures () {

		return _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );

	};

	// Initialization

	function initSprites () {

		_sprite.vertices = new Float32Array( 8 + 8 );
		_sprite.faces    = new Uint16Array( 6 );

		var i = 0;

		_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1;	// vertex 0
		_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;	// uv 0

		_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1;	// vertex 1
		_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;	// uv 1

		_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;	// vertex 2
		_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;	// uv 2

		_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;	// vertex 3
		_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;	// uv 3

		i = 0;

		_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;
		_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;

		_sprite.vertexBuffer  = _gl.createBuffer();
		_sprite.elementBuffer = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );

		_sprite.program = _gl.createProgram();
		_gl.attachShader( _sprite.program, getShader( "fragment", THREE.ShaderLib.sprite.fragmentShader ) );
		_gl.attachShader( _sprite.program, getShader( "vertex",   THREE.ShaderLib.sprite.vertexShader   ) );
		_gl.linkProgram( _sprite.program );

		_sprite.attributes = {};
		_sprite.uniforms = {};

		_sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, "position" );
		_sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, "uv" );

		_sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, "uvOffset" );
		_sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, "uvScale" );

		_sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, "rotation" );
		_sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, "scale" );
		_sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, "alignment" );

		_sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, "color" );
		_sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, "map" );
		_sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, "opacity" );

		_sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, "useScreenCoordinates" );
		_sprite.uniforms.affectedByDistance   = _gl.getUniformLocation( _sprite.program, "affectedByDistance" );
		_sprite.uniforms.screenPosition    	  = _gl.getUniformLocation( _sprite.program, "screenPosition" );
		_sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, "modelViewMatrix" );
		_sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, "projectionMatrix" );

		//_gl.enableVertexAttribArray( _sprite.attributes.position );
		//_gl.enableVertexAttribArray( _sprite.attributes.uv );

	};

	function initShadowmaps () {

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;

	}

	function initGL () {

		var gl;

		try {

			if ( ! ( gl = _canvas.getContext( 'experimental-webgl', { antialias: _antialias, stencil: _stencil, preserveDrawingBuffer: _preserveDrawingBuffer } ) ) ) {

				throw 'Error creating WebGL context.';

			}

			console.log(
				navigator.userAgent + " | " +
				gl.getParameter( gl.VERSION ) + " | " +
				gl.getParameter( gl.VENDOR ) + " | " +
				gl.getParameter( gl.RENDERER ) + " | " +
				gl.getParameter( gl.SHADING_LANGUAGE_VERSION )
			);

		} catch ( error ) {

			console.error( error );

		}

		return gl;

	};

	function setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

};
/**
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

};

THREE.WebGLRenderTarget.prototype.clone = function() {

	var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

	tmp.wrapS = this.wrapS;
	tmp.wrapT = this.wrapT;

	tmp.magFilter = this.magFilter;
	tmp.minFilter = this.minFilter;

	tmp.offset.copy( this.offset );
	tmp.repeat.copy( this.repeat );

	tmp.format = this.format;
	tmp.type = this.type;

	tmp.depthBuffer = this.depthBuffer;
	tmp.stencilBuffer = this.stencilBuffer;

	return tmp;

};
/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = new THREE.WebGLRenderTarget();
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.RenderableVertex = function () {

	this.positionWorld = new THREE.Vector3();
	this.positionScreen = new THREE.Vector4();

	this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {

	this.positionWorld.copy( vertex.positionWorld );
	this.positionScreen.copy( vertex.positionScreen );

}
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.RenderableFace3 = function () {

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();
	this.v3 = new THREE.RenderableVertex();

	this.centroidWorld = new THREE.Vector3();
	this.centroidScreen = new THREE.Vector3();

	this.normalWorld = new THREE.Vector3();
	this.vertexNormalsWorld = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

	this.material = null;
	this.faceMaterial = null;
	this.uvs = [[]];

	this.z = null;

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.RenderableFace4 = function () {

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();
	this.v3 = new THREE.RenderableVertex();
	this.v4 = new THREE.RenderableVertex();

	this.centroidWorld = new THREE.Vector3();
	this.centroidScreen = new THREE.Vector3();

	this.normalWorld = new THREE.Vector3();
	this.vertexNormalsWorld = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

	this.material = null;
	this.faceMaterial = null;
	this.uvs = [[]];

	this.z = null;

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.RenderableObject = function () {

	this.object = null;
	this.z = null;

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.RenderableParticle = function () {

	this.x = null;
	this.y = null;
	this.z = null;

	this.rotation = null;
	this.scale = new THREE.Vector2();

	this.material = null;

};
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.RenderableLine = function () {

	this.z = null;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();

	this.material = null;

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ColorUtils = {

	adjustHSV : function ( color, h, s, v ) {

		var hsv = THREE.ColorUtils.__hsv;

		THREE.ColorUtils.rgbToHsv( color, hsv );

		hsv.h = THREE.Math.clamp( hsv.h + h, 0, 1 );
		hsv.s = THREE.Math.clamp( hsv.s + s, 0, 1 );
		hsv.v = THREE.Math.clamp( hsv.v + v, 0, 1 );

		color.setHSV( hsv.h, hsv.s, hsv.v );

	},

	// based on MochiKit implementation by Bob Ippolito

	rgbToHsv : function ( color, hsv ) {

		var r = color.r;
		var g = color.g;
		var b = color.b;

		var max = Math.max( Math.max( r, g ), b );
		var min = Math.min( Math.min( r, g ), b );

		var hue;
		var saturation;
		var value = max;

		if ( min === max )	{

			hue = 0;
			saturation = 0;

		} else {

			var delta = ( max - min );
			saturation = delta / max;

			if ( r === max ) {

				hue = ( g - b ) / delta;

			} else if ( g === max ) {

				hue = 2 + ( ( b - r ) / delta );

			} else	{

				hue = 4 + ( ( r - g ) / delta );
			}

			hue /= 6;

			if ( hue < 0 ) {

				hue += 1;

			}

			if ( hue > 1 ) {

				hue -= 1;

			}

		}

		if ( hsv === undefined ) {

			hsv = { h: 0, s: 0, v: 0 };

		}

		hsv.h = hue;
		hsv.s = saturation;
		hsv.v = value;

		return hsv;

	}

};

THREE.ColorUtils.__hsv = { h: 0, s: 0, v: 0 };/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.GeometryUtils = {

	merge: function ( geometry1, object2 /* mesh | geometry */ ) {

		var matrix, matrixRotation,
		vertexOffset = geometry1.vertices.length,
		uvPosition = geometry1.faceVertexUvs[ 0 ].length,
		geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,
		vertices1 = geometry1.vertices,
		vertices2 = geometry2.vertices,
		faces1 = geometry1.faces,
		faces2 = geometry2.faces,
		uvs1 = geometry1.faceVertexUvs[ 0 ],
		uvs2 = geometry2.faceVertexUvs[ 0 ];

		var geo1MaterialsMap = {};

		for ( var i = 0; i < geometry1.materials.length; i ++ ) {

			var id = geometry1.materials[ i ].id;

			geo1MaterialsMap[ id ] = i;

		}


		if ( object2 instanceof THREE.Mesh ) {

			object2.matrixAutoUpdate && object2.updateMatrix();

			matrix = object2.matrix;
			matrixRotation = new THREE.Matrix4();
			matrixRotation.extractRotation( matrix, object2.scale );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = new THREE.Vertex( vertex.position.clone() );

			if ( matrix ) matrix.multiplyVector3( vertexCopy.position );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			if ( face instanceof THREE.Face3 ) {

				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );

			} else if ( face instanceof THREE.Face4 ) {

				faceCopy = new THREE.Face4( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset, face.d + vertexOffset );

			}

			faceCopy.normal.copy( face.normal );

			if ( matrixRotation ) matrixRotation.multiplyVector3( faceCopy.normal );

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( matrixRotation ) matrixRotation.multiplyVector3( normal );

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			if ( face.materialIndex !== undefined ) {

				var material2 = geometry2.materials[ face.materialIndex ];
				var materialId2 = material2.id;

				var materialIndex = geo1MaterialsMap[ materialId2 ];

				if ( materialIndex === undefined ) {

					materialIndex = geometry1.materials.length;
					geometry1.materials.push( material2 );

				}

				faceCopy.materialIndex = materialIndex;

			}

			faceCopy.centroid.copy( face.centroid );
			if ( matrix ) matrix.multiplyVector3( faceCopy.centroid );

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.UV( uv[ j ].u, uv[ j ].v ) );

			}

			uvs1.push( uvCopy );

		}

	},

	clone: function ( geometry ) {

		var cloneGeo = new THREE.Geometry();

		var i, il;

		var vertices = geometry.vertices,
			faces = geometry.faces,
			uvs = geometry.faceVertexUvs[ 0 ];

		// materials

		if ( geometry.materials ) {

			cloneGeo.materials = geometry.materials.slice();

		}

		// vertices

		for ( i = 0, il = vertices.length; i < il; i ++ ) {

			var vertex = vertices[ i ];
			var vertexCopy = new THREE.Vertex( vertex.position.clone() );

			cloneGeo.vertices.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces.length; i < il; i ++ ) {

			var face = faces[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			if ( face instanceof THREE.Face3 ) {

				faceCopy = new THREE.Face3( face.a, face.b, face.c );

			} else if ( face instanceof THREE.Face4 ) {

				faceCopy = new THREE.Face4( face.a, face.b, face.c, face.d );

			}

			faceCopy.normal.copy( face.normal );

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ];
				faceCopy.vertexNormals.push( normal.clone() );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex;

			faceCopy.centroid.copy( face.centroid );

			cloneGeo.faces.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.UV( uv[ j ].u, uv[ j ].v ) );

			}

			cloneGeo.faceVertexUvs[ 0 ].push( uvCopy );

		}

		return cloneGeo;

	},

	// Get random point in triangle (via barycentric coordinates)
	// 	(uniform distribution)
	// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle

	randomPointInTriangle: function( vectorA, vectorB, vectorC ) {

		var a, b, c,
			point = new THREE.Vector3(),
			tmp = THREE.GeometryUtils.__v1;

		a = THREE.GeometryUtils.random();
		b = THREE.GeometryUtils.random();

		if ( ( a + b ) > 1 ) {

			a = 1 - a;
			b = 1 - b;

		}

		c = 1 - a - b;

		point.copy( vectorA );
		point.multiplyScalar( a );

		tmp.copy( vectorB );
		tmp.multiplyScalar( b );

		point.addSelf( tmp );

		tmp.copy( vectorC );
		tmp.multiplyScalar( c );

		point.addSelf( tmp );

		return point;

	},

	// Get random point in face (triangle / quad)
	// (uniform distribution)

	randomPointInFace: function( face, geometry, useCachedAreas ) {

		var vA, vB, vC, vD;

		if ( face instanceof THREE.Face3 ) {

			vA = geometry.vertices[ face.a ].position;
			vB = geometry.vertices[ face.b ].position;
			vC = geometry.vertices[ face.c ].position;

			return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );

		} else if ( face instanceof THREE.Face4 ) {

			vA = geometry.vertices[ face.a ].position;
			vB = geometry.vertices[ face.b ].position;
			vC = geometry.vertices[ face.c ].position;
			vD = geometry.vertices[ face.d ].position;

			var area1, area2;

			if ( useCachedAreas ) {

				if ( face._area1 && face._area2 ) {

					area1 = face._area1;
					area2 = face._area2;

				} else {

					area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );
					area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );

					face._area1 = area1;
					face._area2 = area2;

				}

			} else {

				area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD ),
				area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );

			}

			var r = THREE.GeometryUtils.random() * ( area1 + area2 );

			if ( r < area1 ) {

				return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vD );

			} else {

				return THREE.GeometryUtils.randomPointInTriangle( vB, vC, vD );

			}

		}

	},

	// Get uniformly distributed random points in mesh
	// 	- create array with cumulative sums of face areas
	//  - pick random number from 0 to total area
	//  - find corresponding place in area array by binary search
	//	- get random point in face

	randomPointsInGeometry: function( geometry, n ) {

		var face, i,
			faces = geometry.faces,
			vertices = geometry.vertices,
			il = faces.length,
			totalArea = 0,
			cumulativeAreas = [],
			vA, vB, vC, vD;

		// precompute face areas

		for ( i = 0; i < il; i ++ ) {

			face = faces[ i ];

			if ( face instanceof THREE.Face3 ) {

				vA = vertices[ face.a ].position;
				vB = vertices[ face.b ].position;
				vC = vertices[ face.c ].position;

				face._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );

			} else if ( face instanceof THREE.Face4 ) {

				vA = vertices[ face.a ].position;
				vB = vertices[ face.b ].position;
				vC = vertices[ face.c ].position;
				vD = vertices[ face.d ].position;

				face._area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );
				face._area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );

				face._area = face._area1 + face._area2;

			}

			totalArea += face._area;

			cumulativeAreas[ i ] = totalArea;

		}

		// binary search cumulative areas array

		function binarySearchIndices( value ) {

			function binarySearch( start, end ) {

				// return closest larger index
				// if exact number is not found

				if ( end < start )
					return start;

				var mid = start + Math.floor( ( end - start ) / 2 );

				if ( cumulativeAreas[ mid ] > value ) {

					return binarySearch( start, mid - 1 );

				} else if ( cumulativeAreas[ mid ] < value ) {

					return binarySearch( mid + 1, end );

				} else {

					return mid;

				}

			}

			var result = binarySearch( 0, cumulativeAreas.length - 1 )
			return result;

		}

		// pick random face weighted by face area

		var r, index,
			result = [];

		var stats = {};

		for ( i = 0; i < n; i ++ ) {

			r = THREE.GeometryUtils.random() * totalArea;

			index = binarySearchIndices( r );

			result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );

			if ( ! stats[ index ] ) {

				stats[ index ] = 1;

			} else {

				stats[ index ] += 1;

			}

		}

		return result;

	},

	// Get triangle area (by Heron's formula)
	// 	http://en.wikipedia.org/wiki/Heron%27s_formula

	triangleArea: function( vectorA, vectorB, vectorC ) {

		var s, a, b, c,
			tmp = THREE.GeometryUtils.__v1;

		tmp.sub( vectorA, vectorB );
		a = tmp.length();

		tmp.sub( vectorA, vectorC );
		b = tmp.length();

		tmp.sub( vectorB, vectorC );
		c = tmp.length();

		s = 0.5 * ( a + b + c );

		return Math.sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );

	},

	center: function( geometry ) {

		geometry.computeBoundingBox();

		var matrix = new THREE.Matrix4();

		var dx = -0.5 * ( geometry.boundingBox.x[ 1 ] + geometry.boundingBox.x[ 0 ] );
		var dy = -0.5 * ( geometry.boundingBox.y[ 1 ] + geometry.boundingBox.y[ 0 ] );
		var dz = -0.5 * ( geometry.boundingBox.z[ 1 ] + geometry.boundingBox.z[ 0 ] );

		matrix.setTranslation( dx, dy, dz );

		geometry.applyMatrix( matrix );

		geometry.computeBoundingBox();

	}


};

THREE.GeometryUtils.random = THREE.Math.random16;

THREE.GeometryUtils.__v1 = new THREE.Vector3();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageUtils = {

	loadTexture: function ( path, mapping, callback ) {

		var image = new Image(), texture = new THREE.Texture( image, mapping );

		image.onload = function () { texture.needsUpdate = true; if ( callback ) callback( this ); };
		image.crossOrigin = '';
		image.src = path;

		return texture;

	},

	loadTextureCube: function ( array, mapping, callback ) {

		var i, l, images = [], texture = new THREE.Texture( images, mapping );

		images.loadCount = 0;

		for ( i = 0, l = array.length; i < l; ++i ) {

			images[ i ] = new Image();
			images[ i ].onload = function () {

				images.loadCount += 1;
				if ( images.loadCount === 6 ) texture.needsUpdate = true;
				if ( callback ) callback( this );

			};

			images[ i ].crossOrigin = '';
			images[ i ].src = array[ i ];

		}

		return texture;

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		var depth = depth | 1;
		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 1; y < height; y ++ ) {

				var ly = y - 1 < 0 ? height - 1 : y - 1;
				var uy = ( y + 1 ) % height;
				var lx = x - 1 < 0 ? width - 1 : x - 1;
				var ux = ( x + 1 ) % width;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 / 2.0 ) * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	showHierarchy : function ( root, visible ) {

		THREE.SceneUtils.traverseHierarchy( root, function( node ) { node.visible = visible; } );

	},

	traverseHierarchy : function ( root, callback ) {

		var n, i, l = root.children.length;

		for ( i = 0; i < l; i ++ ) {

			n = root.children[ i ];

			callback( n );

			THREE.SceneUtils.traverseHierarchy( n, callback );

		}

	},

	createMultiMaterialObject : function ( geometry, materials ) {

		var i, il = materials.length,
			group = new THREE.Object3D();

		for ( i = 0; i < il; i ++ ) {

			var object = new THREE.Mesh( geometry, materials[ i ] );
			group.add( object );

		}

		return group;

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 *
 * ShaderUtils currently contains:
 *
 *	fresnel
 *	normal
 * 	cube
 *
 */

if ( THREE.WebGLRenderer ) {

THREE.ShaderUtils = {

	lib: {

		/* -------------------------------------------------------------------------
		//	Fresnel shader
		//	- based on Nvidia Cg tutorial
		 ------------------------------------------------------------------------- */

		'fresnel': {

			uniforms: {

				"mRefractionRatio": { type: "f", value: 1.02 },
				"mFresnelBias": { type: "f", value: 0.1 },
				"mFresnelPower": { type: "f", value: 2.0 },
				"mFresnelScale": { type: "f", value: 1.0 },
				"tCube": { type: "t", value: 1, texture: null }

			},

			fragmentShader: [

				"uniform samplerCube tCube;",

				"varying vec3 vReflect;",
				"varying vec3 vRefract[3];",
				"varying float vReflectionFactor;",

				"void main() {",

					"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
					"vec4 refractedColor = vec4( 1.0, 1.0, 1.0, 1.0 );",

					"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;",
					"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;",
					"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;",
					"refractedColor.a = 1.0;",

					"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );",

				"}"

			].join("\n"),

			vertexShader: [

				"uniform float mRefractionRatio;",
				"uniform float mFresnelBias;",
				"uniform float mFresnelScale;",
				"uniform float mFresnelPower;",

				"varying vec3 vReflect;",
				"varying vec3 vRefract[3];",
				"varying float vReflectionFactor;",

				"void main() {",

					"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
					"vec4 mPosition = objectMatrix * vec4( position, 1.0 );",

					"vec3 nWorld = normalize ( mat3( objectMatrix[0].xyz, objectMatrix[1].xyz, objectMatrix[2].xyz ) * normal );",

					"vec3 I = mPosition.xyz - cameraPosition;",

					"vReflect = reflect( I, nWorld );",
					"vRefract[0] = refract( normalize( I ), nWorld, mRefractionRatio );",
					"vRefract[1] = refract( normalize( I ), nWorld, mRefractionRatio * 0.99 );",
					"vRefract[2] = refract( normalize( I ), nWorld, mRefractionRatio * 0.98 );",
					"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), nWorld ), mFresnelPower );",

					"gl_Position = projectionMatrix * mvPosition;",

				"}"

			].join("\n")

		},

		/* -------------------------------------------------------------------------
		//	Normal map shader
		//		- Blinn-Phong
		//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
		//		- point and directional lights (use with "lights: true" material option)
		 ------------------------------------------------------------------------- */

		'normal' : {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{

				"enableAO"		  : { type: "i", value: 0 },
				"enableDiffuse"	  : { type: "i", value: 0 },
				"enableSpecular"  : { type: "i", value: 0 },
				"enableReflection": { type: "i", value: 0 },

				"tDiffuse"	   : { type: "t", value: 0, texture: null },
				"tCube"		   : { type: "t", value: 1, texture: null },
				"tNormal"	   : { type: "t", value: 2, texture: null },
				"tSpecular"	   : { type: "t", value: 3, texture: null },
				"tAO"		   : { type: "t", value: 4, texture: null },
				"tDisplacement": { type: "t", value: 5, texture: null },

				"uNormalScale": { type: "f", value: 1.0 },

				"uDisplacementBias": { type: "f", value: 0.0 },
				"uDisplacementScale": { type: "f", value: 1.0 },

				"uDiffuseColor": { type: "c", value: new THREE.Color( 0xeeeeee ) },
				"uSpecularColor": { type: "c", value: new THREE.Color( 0x111111 ) },
				"uAmbientColor": { type: "c", value: new THREE.Color( 0x050505 ) },
				"uShininess": { type: "f", value: 30 },
				"uOpacity": { type: "f", value: 1 },

				"uReflectivity": { type: "f", value: 0.5 },

				"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
				"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

				}

			] ),

			fragmentShader: [

				"uniform vec3 uAmbientColor;",
				"uniform vec3 uDiffuseColor;",
				"uniform vec3 uSpecularColor;",
				"uniform float uShininess;",
				"uniform float uOpacity;",

				"uniform bool enableDiffuse;",
				"uniform bool enableSpecular;",
				"uniform bool enableAO;",
				"uniform bool enableReflection;",

				"uniform sampler2D tDiffuse;",
				"uniform sampler2D tNormal;",
				"uniform sampler2D tSpecular;",
				"uniform sampler2D tAO;",

				"uniform samplerCube tCube;",

				"uniform float uNormalScale;",
				"uniform float uReflectivity;",

				"varying vec3 vTangent;",
				"varying vec3 vBinormal;",
				"varying vec3 vNormal;",
				"varying vec2 vUv;",

				"uniform vec3 ambientLightColor;",

				"#if MAX_DIR_LIGHTS > 0",
					"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
					"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
				"#endif",

				"#if MAX_POINT_LIGHTS > 0",
					"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
					"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
				"#endif",

				"varying vec3 vViewPosition;",

				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],

				"void main() {",

					"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );",

					"vec3 specularTex = vec3( 1.0 );",

					"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
					"normalTex.xy *= uNormalScale;",
					"normalTex = normalize( normalTex );",

					"if( enableDiffuse )",
						"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

					"if( enableAO )",
						"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

					"if( enableSpecular )",
						"specularTex = texture2D( tSpecular, vUv ).xyz;",

					"mat3 tsb = mat3( vTangent, vBinormal, vNormal );",
					"vec3 finalNormal = tsb * normalTex;",

					"vec3 normal = normalize( finalNormal );",
					"vec3 viewPosition = normalize( vViewPosition );",

					// point lights

					"#if MAX_POINT_LIGHTS > 0",

						"vec3 pointDiffuse = vec3( 0.0 );",
						"vec3 pointSpecular = vec3( 0.0 );",

						"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

							"vec3 pointVector = normalize( vPointLight[ i ].xyz );",
							"vec3 pointHalfVector = normalize( vPointLight[ i ].xyz + viewPosition );",
							"float pointDistance = vPointLight[ i ].w;",

							"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
							"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

							"float pointSpecularWeight = specularTex.r * pow( pointDotNormalHalf, uShininess );",

							"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;",
							"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;",

						"}",

					"#endif",

					// directional lights

					"#if MAX_DIR_LIGHTS > 0",

						"vec3 dirDiffuse = vec3( 0.0 );",
						"vec3 dirSpecular = vec3( 0.0 );",

						"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

							"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",

							"vec3 dirVector = normalize( lDirection.xyz );",
							"vec3 dirHalfVector = normalize( lDirection.xyz + viewPosition );",

							"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
							"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

							"float dirSpecularWeight = specularTex.r * pow( dirDotNormalHalf, uShininess );",

							"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;",
							"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;",

						"}",

					"#endif",

					// all lights contribution summation

					"vec3 totalDiffuse = vec3( 0.0 );",
					"vec3 totalSpecular = vec3( 0.0 );",

					"#if MAX_DIR_LIGHTS > 0",

						"totalDiffuse += dirDiffuse;",
						"totalSpecular += dirSpecular;",

					"#endif",

					"#if MAX_POINT_LIGHTS > 0",

						"totalDiffuse += pointDiffuse;",
						"totalSpecular += pointSpecular;",

					"#endif",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor) + totalSpecular;",

					"if ( enableReflection ) {",

						"vec3 wPos = cameraPosition - vViewPosition;",
						"vec3 vReflect = reflect( normalize( wPos ), normal );",
						"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
						"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, uReflectivity );",

					"}",

					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],

				"}"

			].join("\n"),

			vertexShader: [

				"attribute vec4 tangent;",

				"uniform vec2 uOffset;",
				"uniform vec2 uRepeat;",

				"#ifdef VERTEX_TEXTURES",

					"uniform sampler2D tDisplacement;",
					"uniform float uDisplacementScale;",
					"uniform float uDisplacementBias;",

				"#endif",

				"varying vec3 vTangent;",
				"varying vec3 vBinormal;",
				"varying vec3 vNormal;",
				"varying vec2 vUv;",

				"#if MAX_POINT_LIGHTS > 0",

					"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
					"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

					"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

				"#endif",

				"varying vec3 vViewPosition;",

				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

				"void main() {",

					"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

					"vViewPosition = -mvPosition.xyz;",

					"vNormal = normalize( normalMatrix * normal );",

					// tangent and binormal vectors

					"vTangent = normalize( normalMatrix * tangent.xyz );",

					"vBinormal = cross( vNormal, vTangent ) * tangent.w;",
					"vBinormal = normalize( vBinormal );",

					"vUv = uv * uRepeat + uOffset;",

					// point lights

					"#if MAX_POINT_LIGHTS > 0",

						"for( int i = 0; i < MAX_POINT_LIGHTS; i++ ) {",

							"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",

							"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

							"float lDistance = 1.0;",

							"if ( pointLightDistance[ i ] > 0.0 )",
								"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

							"lVector = normalize( lVector );",

							"vPointLight[ i ] = vec4( lVector, lDistance );",

						"}",

					"#endif",

					// displacement mapping

					"#ifdef VERTEX_TEXTURES",

						"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
						"float df = uDisplacementScale * dv.x + uDisplacementBias;",
						"vec4 displacedPosition = vec4( vNormal.xyz * df, 0.0 ) + mvPosition;",
						"gl_Position = projectionMatrix * displacedPosition;",

					"#else",

						"gl_Position = projectionMatrix * mvPosition;",

					"#endif",

					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n")

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'cube': {

			uniforms: { "tCube": { type: "t", value: 1, texture: null },
						"tFlip": { type: "f", value: -1 } },

			vertexShader: [

				"varying vec3 vViewPosition;",

				"void main() {",

					"vec4 mPosition = objectMatrix * vec4( position, 1.0 );",
					"vViewPosition = cameraPosition - mPosition.xyz;",

					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform samplerCube tCube;",
				"uniform float tFlip;",

				"varying vec3 vViewPosition;",

				"void main() {",

					"vec3 wPos = cameraPosition - vViewPosition;",
					"gl_FragColor = textureCube( tCube, vec3( tFlip * wPos.x, wPos.yz ) );",

				"}"

			].join("\n")

		}

	}

};

};/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 * 
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 *
 * This file contains following classes:
 *
 * -- 2d classes --
 * THREE.Curve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	};

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	};

	return pts;

};

// Get total curve length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( !divisions ) divisions = 200;

	if ( this.cacheArcLengths && ( this.cacheArcLengths.length == divisions + 1 ) ) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

	  	comparison = arcLengths[ i ] - targetArcLength;

	  	if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// In case any sub curve does not implement its tangent / normal finding,
// we get 2 points with a small delta and find a gradient of the 2 points
// which seems to make a reasonable approximation

THREE.Curve.prototype.getNormalVector = function( t ) {

	var vec = this.getTangent( t );

	return new THREE.Vector2( -vec.y , vec.x );

};

// Returns a unit vector tangent at t

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );
	
	var vec = pt1.clone().subSelf(pt2);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	if ( ! ( v1 instanceof THREE.Vector2 ) ) {

		// Fall back for old constuctor signature - should be removed over time

		THREE.LineCurve.oldConstructor.apply( this, arguments );
		return;

	}

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.oldConstructor = function ( x1, y1, x2, y2 ) {

	this.constructor( new THREE.Vector2( x1, y1 ), new THREE.Vector2( x2, y2 ) );

};

THREE.LineCurve.prototype = new THREE.Curve();
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = new THREE.Vector2();

	point.sub( this.v2, this.v1 );
	point.multiplyScalar( t ).addSelf( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = new THREE.Vector2();

	tangent.sub( this.v2, this.v1 );
	tangent.normalize();

	return tangent;

};

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	if ( !( v1 instanceof THREE.Vector2 ) ) {

		var args = Array.prototype.slice.call( arguments );

		v0 = new THREE.Vector2( args[ 0 ], args[ 1 ] );
		v1 = new THREE.Vector2( args[ 2 ], args[ 3 ] );
		v2 = new THREE.Vector2( args[ 4 ], args[ 5 ] );

	}

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = new THREE.Curve();
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return new THREE.Vector2( tx, ty );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	// iterate sub segments
	// 	get lengths for sub segments
	// 	if segment is bezier
	//		perform subdivisions

	var tx, ty;

	tx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};


/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	if ( ! ( v1 instanceof THREE.Vector2 ) ) {

		var args = Array.prototype.slice.call( arguments );

		v0 = new THREE.Vector2( args[ 0 ], args[ 1 ] );
		v1 = new THREE.Vector2( args[ 2 ], args[ 3 ] );
		v2 = new THREE.Vector2( args[ 4 ], args[ 5 ] );
		v3 = new THREE.Vector2( args[ 6 ], args[ 7 ] );

	}

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = new THREE.Curve();
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	// return normal unit vector

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};


/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = (points == undefined) ? [] : points;

};

THREE.SplineCurve.prototype = new THREE.Curve();
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var v = new THREE.Vector2();
	var c = [];
	var points = this.points, point, intPoint, weight;
	point = ( points.length - 1 ) * t;

	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
	c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

	v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
	v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );

	return v;

};

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius,
							aStartAngle, aEndAngle,
							aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.aRadius = aRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.ArcCurve.prototype = new THREE.Curve();
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

THREE.ArcCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( !this.aClockwise ) {

		t = 1 - t;

	}

	var angle = this.aStartAngle + t * deltaAngle;

	var tx = this.aX + this.aRadius * Math.cos( angle );
	var ty = this.aY + this.aRadius * Math.sin( angle );

	return new THREE.Vector2( tx, ty );

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return -3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;
	},


	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
		var h01 = -6 * t * t + 6 * t; 	//  2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3  t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


/*
getPoint DONE
getLength DONE
getLengths DONE

curve.getPoints(); DONE
curve.getPointAtArcLength(t); DONE
curve.transform(params);
curve.getTangentAt(t); DONE
*/

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function( constructor, getPointFunc ) {

    var subClass = constructor;

	subClass.prototype = new THREE.Curve();

	subClass.prototype.constructor = constructor;
    subClass.prototype.getPoint = getPointFunc;

	return subClass;

};


/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var r = new THREE.Vector3();


		r.sub( this.v2, this.v1 ); // diff
		r.multiplyScalar( t );
		r.addSelf( this.v1 );

		return r;

	}

);


/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		tz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);



/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		tz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);



/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

	function ( t ) {

		var v = new THREE.Vector3();
		var c = [];
		var points = this.points, point, intPoint, weight;
		point = ( points.length - 1 ) * t;

		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

		v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
		v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
		v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );

		return v;

	}

);
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];

};

THREE.CurvePath.prototype = new THREE.Curve();
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {

};

// Add a line curve  if start and end of lines are not connected

THREE.CurvePath.prototype.closePath = function() {

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates, as well as centroid

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY;
	var minX, minY;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	sum = new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < maxY ) minY = p.y;

		sum.addSelf( p.x, p.y );

	}

	return {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY,
		centroid: sum.divideScalar( il )

	};

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or ParticleSystem objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

    var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

    var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

    for( var i = 0; i < points.length; i ++ ) {

        geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( points[ i ].x, points[ i ].y, 0 ) ) );

    }

    return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		var xNorm = oldX/ bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = new THREE.CurvePath();
THREE.Path.prototype.constructor = THREE.Path;


THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc'								// Circle

};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	var v, vlen = vectors.length;

	for ( v = 1; v < vlen; v++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
                                               aCP2x, aCP2y,
                                               aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?
// TODO ARC ( x, y, x - radius, y - radius, startAngle, endAngle )

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );

	var curve = new THREE.ArcCurve( aX, aY, aRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	// console.log( 'arc', args );

	this.actions.push( { action: THREE.PathActions.ARC, args: args } );

 };


THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( !divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			// points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

		  	}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			laste = this.actions[ i - 1 ].args;

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !!args[ 5 ];

			var lastx = laste[ laste.length - 2 ],
				lasty = laste[ laste.length - 1 ];

			if ( laste.length == 0 ) {

				lastx = lasty = 0;

			}


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;
			var t;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( !aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = lastx + aX + aRadius * Math.cos( angle );
				ty = lasty + aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}

	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};



// This was used for testing purposes. Should be removed soon.

THREE.Path.prototype.transform = function( path, segments ) {

	var bounds = this.getBoundingBox();
	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints

	//console.log( path.cacheArcLengths() );
	//path.getLengths(400);
	//segments = 40;

	return this.getWrapPoints( oldPts, path );

};

// Read http://www.tinaja.com/glib/nonlingr.pdf
// nonlinear transforms

THREE.Path.prototype.nltransform = function( a, b, c, d, e, f ) {

	// a - horizontal size
	// b - lean
	// c - x offset
	// d - vertical size
	// e - climb
	// f - y offset

	var oldPts = this.getPoints();

	var i, il, p, oldX, oldY;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[i];

		oldX = p.x;
		oldY = p.y;

		p.x = a * oldX + b * oldY + c;
		p.y = d * oldY + e * oldX + f;

	}

	return oldPts;

};


// FUTURE Export JSON Format

/* Draws this path onto a 2d canvas easily */

THREE.Path.prototype.debug = function( canvas ) {

	var bounds = this.getBoundingBox();

	if ( !canvas ) {

		canvas = document.createElement( "canvas" );

		canvas.setAttribute( 'width',  bounds.maxX + 100 );
		canvas.setAttribute( 'height', bounds.maxY + 100 );

		document.body.appendChild( canvas );

	}

	var ctx = canvas.getContext( "2d" );
	ctx.fillStyle = "white";
	ctx.fillRect( 0, 0, canvas.width, canvas.height );

	ctx.strokeStyle = "black";
	ctx.beginPath();

	var i, il, item, action, args;

	// Debug Path

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		args = item.args;
		action = item.action;

		// Short hand for now

		if ( action != THREE.PathActions.CSPLINE_THRU ) {

			ctx[ action ].apply( ctx, args );

		}

		/*
		switch ( action ) {

			case THREE.PathActions.MOVE_TO:

				ctx[ action ]( args[ 0 ], args[ 1 ] );
				break;

			case THREE.PathActions.LINE_TO:

				ctx[ action ]( args[ 0 ], args[ 1 ] );
				break;

			case THREE.PathActions.QUADRATIC_CURVE_TO:

				ctx[ action ]( args[ 0 ], args[ 1 ], args[ 2 ], args[ 3 ] );
				break;

			case THREE.PathActions.CUBIC_CURVE_TO:

				ctx[ action ]( args[ 0 ], args[ 1 ], args[ 2 ], args[ 3 ], args[ 4 ], args[ 5 ] );
				break;

		}
		*/

	}

	ctx.stroke();
	ctx.closePath();

	// Debug Points

	ctx.strokeStyle = "red";

	/* TO CLEAN UP */

	var p, points = this.getPoints();

	//var theta = -90 /180 * Math.PI;
	//var p, points = this.transform( 0.866, - 0.866,0, 0.500 , 0.50,-50 );

	//0.866, - 0.866,0, 0.500 , 0.50,-50

	// Math.cos(theta),Math.sin(theta),100,
	// Math.cos(theta),-Math.sin(theta),-50

	// translate, scale, rotation


	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		ctx.beginPath();
		ctx.arc( p.x, p.y, 1.5, 0, Math.PI * 2, false );
		ctx.stroke();
		ctx.closePath();

	}

};

// Breaks path into shapes

THREE.Path.prototype.toShapes = function() {

	var i, il, item, action, args;

	var subPaths = [], lastPath = new THREE.Path();

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		args = item.args;
		action = item.action;

		if ( action == THREE.PathActions.MOVE_TO ) {

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );
				lastPath = new THREE.Path();

			}

		}

		lastPath[ action ].apply( lastPath, args );

	}

	if ( lastPath.actions.length != 0 ) {

		subPaths.push( lastPath );

	}

	//console.log(subPaths);

	if ( subPaths.length == 0 ) return [];

	var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );

	var tmpPath, tmpShape, shapes = [];

	//console.log("Holes first", holesFirst);

	if ( holesFirst ) {

		tmpShape = new THREE.Shape();

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];

			if ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {

				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );
				tmpShape = new THREE.Shape();

				//console.log('cw', i);

			} else {

				tmpShape.holes.push( tmpPath );

				//console.log('ccw', i);

			}

		}

	} else {

		// Shapes first

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];

			if ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {


				if ( tmpShape ) shapes.push( tmpShape );

				tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

			} else {

				tmpShape.holes.push( tmpPath );

			}

		}

		shapes.push( tmpShape );

	}

	//console.log("shape", shapes);

	return shapes;

};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function ( ) {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = new THREE.Path();
THREE.Shape.prototype.constructor = THREE.Path;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	/*
		contour - array of vector2 for contour
		holes   - array of array of vector2
	*/

	removeHoles: function ( contour, holes ) {

		var shape = contour.concat(); // work on this shape
		var allpoints = shape.concat();

		/* For each isolated shape, find the closest points and break to the hole to allow triangulation */


		var prevShapeVert, nextShapeVert,
			prevHoleVert, nextHoleVert,
			holeIndex, shapeIndex,
			shapeId, shapeGroup,
			h, h2,
			hole, shortest, d,
			p, pts1, pts2,
			tmpShape1, tmpShape2,
			tmpHole1, tmpHole2,
			verts = [];

		for ( h = 0; h < holes.length; h ++ ) {

			hole = holes[ h ];

			/*
			shapeholes[ h ].concat(); // preserves original
			holes.push( hole );
			*/

			Array.prototype.push.apply( allpoints, hole );

			shortest = Number.POSITIVE_INFINITY;


			// Find the shortest pair of pts between shape and hole

			// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)
			// Using distanceToSquared() intead of distanceTo() should speed a little
			// since running square roots operations are reduced.

			for ( h2 = 0; h2 < hole.length; h2 ++ ) {

				pts1 = hole[ h2 ];
				var dist = [];

				for ( p = 0; p < shape.length; p++ ) {

					pts2 = shape[ p ];
					d = pts1.distanceToSquared( pts2 );
					dist.push( d );

					if ( d < shortest ) {

						shortest = d;
						holeIndex = h2;
						shapeIndex = p;

					}

				}

			}

			//console.log("shortest", shortest, dist);

			prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
			prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			var areaapts = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var areaa = THREE.FontUtils.Triangulate.area( areaapts );

			var areabpts = [

				hole[ holeIndex ],
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			var areab = THREE.FontUtils.Triangulate.area( areabpts );

			var shapeOffset = 1;
			var holeOffset = -1;

			var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;
			shapeIndex += shapeOffset;
			holeIndex += holeOffset;

			if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
			shapeIndex %= shape.length;

			if ( holeIndex < 0 ) { holeIndex += hole.length;  }
			holeIndex %= hole.length;

			prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
			prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			areaapts = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var areaa2 = THREE.FontUtils.Triangulate.area( areaapts );

			areabpts = [

				hole[ holeIndex ],
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			var areab2 = THREE.FontUtils.Triangulate.area( areabpts );
			//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));

			if ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {

				// In case areas are not correct.
				//console.log("USE THIS");

				shapeIndex = oldShapeIndex;
				holeIndex = oldHoleIndex ;

				if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
				shapeIndex %= shape.length;

				if ( holeIndex < 0 ) { holeIndex += hole.length;  }
				holeIndex %= hole.length;

				prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
				prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			} else {

				//console.log("USE THAT ")

			}

			tmpShape1 = shape.slice( 0, shapeIndex );
			tmpShape2 = shape.slice( shapeIndex );
			tmpHole1 = hole.slice( holeIndex );
			tmpHole2 = hole.slice( 0, holeIndex );

			// Should check orders here again?

			var trianglea = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var triangleb = [

				hole[ holeIndex ] ,
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			verts.push( trianglea );
			verts.push( triangleb );

			shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

		}

		return {

			shape:shape, 		/* shape with no holes */
			isolatedPts: verts, /* isolated faces */
			allpoints: allpoints

		}


	},

	triangulateShape: function ( contour, holes ) {

		var shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );

		var shape = shapeWithoutHoles.shape,
			allpoints = shapeWithoutHoles.allpoints,
			isolatedPts = shapeWithoutHoles.isolatedPts;

		var triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		//console.log( "triangles",triangles, triangles.length );
		//console.log( "allpoints",allpoints, allpoints.length );

		var i, il, f, face,
			key, index,
			allPointsMap = {},
			isolatedPointsMap = {};

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		// check isolated points vertices against all points map

		for ( i = 0, il = isolatedPts.length; i < il; i ++ ) {

			face = isolatedPts[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat( isolatedPts );

	}, // end triangulate shapes

	/*
	triangulate2 : function( pts, holes ) {

		// For use with Poly2Tri.js

		var allpts = pts.concat();
		var shape = [];
		for (var p in pts) {
			shape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));
		}

		var swctx = new js.poly2tri.SweepContext(shape);

		for (var h in holes) {
			var aHole = holes[h];
			var newHole = []
			for (i in aHole) {
				newHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));
				allpts.push(aHole[i]);
			}
			swctx.AddHole(newHole);
		}

		var find;
		var findIndexForPt = function (pt) {
			find = new THREE.Vector2(pt.x, pt.y);
			var p;
			for (p=0, pl = allpts.length; p<pl; p++) {
				if (allpts[p].equals(find)) return p;
			}
			return -1;
		};

		// triangulate
		js.poly2tri.sweep.Triangulate(swctx);

		var triangles =  swctx.GetTriangles();
		var tr ;
		var facesPts = [];
		for (var t in triangles) {
			tr =  triangles[t];
			facesPts.push([
				findIndexForPt(tr.GetPoint(0)),
				findIndexForPt(tr.GetPoint(1)),
				findIndexForPt(tr.GetPoint(2))
					]);
		}


	//	console.log(facesPts);
	//	console.log("triangles", triangles.length, triangles);

		// Returns array of faces with 3 element each
	return facesPts;
	},
*/

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * TextPath
 *
 **/

THREE.TextPath = function ( text, parameters ) {

	THREE.Path.call( this );

	this.parameters = parameters || {};

	this.set( text );

};

THREE.TextPath.prototype.set = function ( text, parameters ) {

	this.text = text;

	var parameters = parameters || this.parameters;

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;

	var font = parameters.font !== undefined ? parameters.font : "helvetiker";
	var weight = parameters.weight !== undefined ? parameters.weight : "normal";
	var style = parameters.style !== undefined ? parameters.style : "normal";

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

};



THREE.TextPath.prototype.toShapes = function () {

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( this.text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

	//console.log(path);
	//console.log(fontShapes);

	// Either find actions or curves.

	//var text3d = new THREE.ExtrudeGeometry( shapes , { amount: 20, bevelEnabled:true, bevelThickness:3	} );

	//return text3d;

};
/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = (function() {

	var playing = [];
	var library = {};
	var that    = {};


	//--- update ---

	that.update = function( deltaTimeMS ) {

		for( var i = 0; i < playing.length; i++ )
			playing[ i ].update( deltaTimeMS );

	};


	//--- add ---

	that.addToUpdate = function( animation ) {

		if( playing.indexOf( animation ) === -1 )
			playing.push( animation );

	};


	//--- remove ---

	that.removeFromUpdate = function( animation ) {

		var index = playing.indexOf( animation );

		if( index !== -1 )
			playing.splice( index, 1 );

	};


	//--- add ---

	that.add = function( data ) {

		if( library[ data.name ] !== undefined )
			console.log( "THREE.AnimationHandler.add: Warning! " + data.name + " already exists in library. Overwriting." );

		library[ data.name ] = data;
		initData( data );

	};


	//--- get ---

	that.get = function( name ) {

		if( typeof name === "string" ) {

			if( library[ name ] ) {

				return library[ name ];

			} else {

				console.log( "THREE.AnimationHandler.get: Couldn't find animation " + name );
				return null;

			}

		} else {

			// todo: add simple tween library

		}

	};

	//--- parse ---

	that.parse = function( root ) {

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for( var b = 0; b < root.bones.length; b++ ) {

				hierarchy.push( root.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	};

	var parseRecurseHierarchy = function( root, hierarchy ) {

		hierarchy.push( root );

		for( var c = 0; c < root.children.length; c++ )
			parseRecurseHierarchy( root.children[ c ], hierarchy );

	}


	//--- init data ---

	var initData = function( data ) {

		if( data.initialized === true )
			return;


		// loop through all keys

		for( var h = 0; h < data.hierarchy.length; h ++ ) {

			for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if( data.hierarchy[ h ].keys[ k ].time < 0 )
					data.hierarchy[ h ].keys[ k ].time = 0;


				// create quaternions

				if( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				 !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );

				}
			}


			// prepare morph target keys

			if( data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = -1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for( var morphTargetName in usedMorphTargets ) {

						for( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}


		// JIT

		var lengthInFrames = parseInt( data.length * data.fps, 10 );

		data.JIT = {};
		data.JIT.hierarchy = [];

		for( var h = 0; h < data.hierarchy.length; h ++ )
			data.JIT.hierarchy.push( new Array( lengthInFrames ) );


		// done

		data.initialized = true;

	};


	// interpolation types

	that.LINEAR = 0;
	that.CATMULLROM = 1;
	that.CATMULLROM_FORWARD = 2;

	return that;

}());
/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function( root, data, interpolationType, JITCompile ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );
	this.currentTime = 0;
	this.timeScale = 1;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;
	this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;
	this.JITCompile = JITCompile !== undefined ? JITCompile : true;

	this.points = [];
	this.target = new THREE.Vector3();

};

// Play

THREE.Animation.prototype.play = function( loop, startTimeMS ) {

	if( !this.isPlaying ) {

		this.isPlaying = true;
		this.loop = loop !== undefined ? loop : true;
		this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;


		// reset key cache

		var h, hl = this.hierarchy.length,
			object;

		for ( h = 0; h < hl; h++ ) {

			object = this.hierarchy[ h ];

			if ( this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				object.useQuaternion = true;

			}

			object.matrixAutoUpdate = true;

			if ( object.animationCache === undefined ) {

				object.animationCache = {};
				object.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var prevKey = object.animationCache.prevKey;
			var nextKey = object.animationCache.nextKey;

			prevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];
			prevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];
			prevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];

			nextKey.pos = this.getNextKeyWith( "pos", h, 1 );
			nextKey.rot = this.getNextKeyWith( "rot", h, 1 );
			nextKey.scl = this.getNextKeyWith( "scl", h, 1 );

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};



// Pause

THREE.Animation.prototype.pause = function() {

	if( this.isPaused ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


// Stop

THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );


	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.hierarchy.length; h++ ) {

		if ( this.hierarchy[ h ].animationCache !== undefined ) {

			if( this.hierarchy[ h ] instanceof THREE.Bone ) {

				this.hierarchy[ h ].skinMatrix = this.hierarchy[ h ].animationCache.originalMatrix;

			} else {

				this.hierarchy[ h ].matrix = this.hierarchy[ h ].animationCache.originalMatrix;

			}


			delete this.hierarchy[ h ].animationCache;

		}

	}

};


// Update

THREE.Animation.prototype.update = function( deltaTimeMS ) {

	// early out

	if( !this.isPlaying ) return;


	// vars

	var types = [ "pos", "rot", "scl" ];
	var type;
	var scale;
	var vector;
	var prevXYZ, nextXYZ;
	var prevKey, nextKey;
	var object;
	var animationCache;
	var frame;
	var JIThierarchy = this.data.JIT.hierarchy;
	var currentTime, unloopedCurrentTime;
	var currentPoint, forwardPoint, angle;


	// update

	this.currentTime += deltaTimeMS * this.timeScale;

	unloopedCurrentTime = this.currentTime;
	currentTime         = this.currentTime = this.currentTime % this.data.length;
	frame               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );


	// update

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		object = this.hierarchy[ h ];
		animationCache = object.animationCache;

		// use JIT?

		if ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {

			if( object instanceof THREE.Bone ) {

				object.skinMatrix = JIThierarchy[ h ][ frame ];

				object.matrixAutoUpdate = false;
				object.matrixWorldNeedsUpdate = false;

			} else {

				object.matrix = JIThierarchy[ h ][ frame ];

				object.matrixAutoUpdate = false;
				object.matrixWorldNeedsUpdate = true;

			}

		// use interpolation

		} else {

			// make sure so original matrix and not JIT matrix is set

			if ( this.JITCompile ) {

				if( object instanceof THREE.Bone ) {

					object.skinMatrix = object.animationCache.originalMatrix;

				} else {

					object.matrix = object.animationCache.originalMatrix;

				}

			}


			// loop through pos/rot/scl

			for ( var t = 0; t < 3; t++ ) {

				// get keys

				type    = types[ t ];
				prevKey = animationCache.prevKey[ type ];
				nextKey = animationCache.nextKey[ type ];

				// switch keys?

				if ( nextKey.time <= unloopedCurrentTime ) {

					// did we loop?

					if ( currentTime < unloopedCurrentTime ) {

						if ( this.loop ) {

							prevKey = this.data.hierarchy[ h ].keys[ 0 ];
							nextKey = this.getNextKeyWith( type, h, 1 );

							while( nextKey.time < currentTime ) {

								prevKey = nextKey;
								nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

							}

						} else {

							this.stop();
							return;

						}

					} else {

						do {

							prevKey = nextKey;
							nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

						} while( nextKey.time < currentTime )

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}


				object.matrixAutoUpdate = true;
				object.matrixWorldNeedsUpdate = true;

				scale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
				prevXYZ = prevKey[ type ];
				nextXYZ = nextKey[ type ];


				// check scale error

				if ( scale < 0 || scale > 1 ) {

					console.log( "THREE.Animation.update: Warning! Scale out of bounds:" + scale + " on bone " + h );
					scale = scale < 0 ? 0 : 1;

				}

				// interpolate

				if ( type === "pos" ) {

					vector = object.position;

					if( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

						vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
							    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

						this.points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						this.points[ 1 ] = prevXYZ;
						this.points[ 2 ] = nextXYZ;
						this.points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

						scale = scale * 0.33 + 0.33;

						currentPoint = this.interpolateCatmullRom( this.points, scale );

						vector.x = currentPoint[ 0 ];
						vector.y = currentPoint[ 1 ];
						vector.z = currentPoint[ 2 ];

						if( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

							forwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );

							this.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							this.target.subSelf( vector );
							this.target.y = 0;
							this.target.normalize();

							angle = Math.atan2( this.target.x, this.target.z );
							object.rotation.set( 0, angle, 0 );

						}

					}

				} else if ( type === "rot" ) {

					THREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );

				} else if( type === "scl" ) {

					vector = object.scale;

					vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

				}

			}

		}

	}

	// update JIT?

	if ( this.JITCompile ) {

		if ( JIThierarchy[ 0 ][ frame ] === undefined ) {

			this.hierarchy[ 0 ].update( null, true );

			for ( var h = 0; h < this.hierarchy.length; h++ ) {

				if( this.hierarchy[ h ] instanceof THREE.Bone ) {

					JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();

				} else {

					JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();

				}

			}

		}

	}

};

// Catmull-Rom spline

THREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {

	var c = [], v3 = [],
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	point = ( points.length - 1 ) * scale;
	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
	c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

	pa = points[ c[ 0 ] ];
	pb = points[ c[ 1 ] ];
	pc = points[ c[ 2 ] ];
	pd = points[ c[ 3 ] ];

	w2 = weight * weight;
	w3 = weight * w2;

	v3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
	v3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
	v3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

	return v3;

};

THREE.Animation.prototype.interpolate = function( p0, p1, p2, p3, t, t2, t3 ) {

	var v0 = ( p2 - p0 ) * 0.5,
		v1 = ( p3 - p1 ) * 0.5;

	return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

};



// Get next key with

THREE.Animation.prototype.getNextKeyWith = function( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key-- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};
/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, heightOffset, cubeResolution ) {

	this.heightOffset = heightOffset;
	this.position = new THREE.Vector3( 0, heightOffset, 0 );

	// cameras

	var fov = 90, aspect = 1;

	this.cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	this.cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );

	this.cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	this.cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );

	this.cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	this.cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );

	this.cameraPX.position = this.position;
	this.cameraNX.position = this.position;

	this.cameraPY.position = this.position;
	this.cameraNY.position = this.position;

	this.cameraPZ.position = this.position;
	this.cameraNZ.position = this.position;

	this.cameraPX.up.set( 0, -1, 0 );
	this.cameraNX.up.set( 0, -1, 0 );

	this.cameraPY.up.set( 0, 0, 1 );
	this.cameraNY.up.set( 0, 0, -1 );

	this.cameraPZ.up.set( 0, -1, 0 );
	this.cameraNZ.up.set( 0, -1, 0 );

	// targets

	this.targetPX = new THREE.Vector3( 0, 0, 0 );
	this.targetNX = new THREE.Vector3( 0, 0, 0 );

	this.targetPY = new THREE.Vector3( 0, 0, 0 );
	this.targetNY = new THREE.Vector3( 0, 0, 0 );

	this.targetPZ = new THREE.Vector3( 0, 0, 0 );
	this.targetNZ = new THREE.Vector3( 0, 0, 0 );

	// cube render target

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updatePosition = function ( position ) {

		this.position.copy( position );

		this.position.y += this.heightOffset;

		this.targetPX.copy( this.position );
		this.targetNX.copy( this.position );

		this.targetPY.copy( this.position );
		this.targetNY.copy( this.position );

		this.targetPZ.copy( this.position );
		this.targetNZ.copy( this.position );

		this.targetPX.x += 1;
		this.targetNX.x -= 1;

		this.targetPY.y += 1;
		this.targetNY.y -= 1;

		this.targetPZ.z += 1;
		this.targetNZ.z -= 1;

		this.cameraPX.lookAt( this.targetPX );
		this.cameraNX.lookAt( this.targetNX );

		this.cameraPY.lookAt( this.targetPY );
		this.cameraNY.lookAt( this.targetNY );

		this.cameraPZ.lookAt( this.targetPZ );
		this.cameraNZ.lookAt( this.targetNZ );

	};

	this.updateCubeMap = function ( renderer, scene ) {

		var cubeTarget = this.renderTarget;

		cubeTarget.activeCubeFace = 0;
		renderer.render( scene, this.cameraPX, cubeTarget );

		cubeTarget.activeCubeFace = 1;
		renderer.render( scene, this.cameraNX, cubeTarget );

		cubeTarget.activeCubeFace = 2;
		renderer.render( scene, this.cameraPY, cubeTarget );

		cubeTarget.activeCubeFace = 3;
		renderer.render( scene, this.cameraNY, cubeTarget );

		cubeTarget.activeCubeFace = 4;
		renderer.render( scene, this.cameraPZ, cubeTarget );

		cubeTarget.activeCubeFace = 5;
		renderer.render( scene, this.cameraNZ, cubeTarget );

	};

};THREE.FirstPersonCamera = function () {

	console.warn( 'DEPRECATED: FirstPersonCamera() is FirstPersonControls().' );

};
THREE.PathCamera = function () {

	console.warn( 'DEPRECATED: PathCamera() is PathControls().' );

};
THREE.FlyCamera = function () {

	console.warn( 'DEPRECATED: FlyCamera() is FlyControls().' );

};
THREE.RollCamera = function () {

	console.warn( 'DEPRECATED: RollCamera() is RollControls().' );

};
THREE.TrackballCamera = function () {

	console.warn( 'DEPRECATED: TrackballCamera() is TrackballControls().' );

};
/*
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog 
 * 
 *	A handy general perpose camera, for setting FOV, Lens Focal Length,  
 *		and switching between perspective and orthographic views easily.
 *
 */


THREE.CombinedCamera = function ( width, height, fov, near, far, orthonear, orthofar ) {

	THREE.Camera.call( this );

	this.fov = fov;
	
	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;
	
	// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects
	this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthonear, orthofar );
	this.cameraP = new THREE.PerspectiveCamera( fov, width/height, near, far );

	this.zoom = 1;
	
	this.toPerspective();
	
	
	var aspect = width/height;
	
	


};

THREE.CombinedCamera.prototype = new THREE.Camera();
THREE.CombinedCamera.prototype.constructor = THREE.CoolCamera;

THREE.CombinedCamera.prototype.toPerspective = function () {

	this.near = this.cameraP.near;
	this.far = this.cameraP.far;
	this.cameraP.fov =  this.fov / this.zoom ;
	this.cameraP.updateProjectionMatrix();
	this.projectionMatrix = this.cameraP.projectionMatrix;
	
	this.inPersepectiveMode = true;
	this.inOrthographicMode = false;

};

THREE.CombinedCamera.prototype.toOrthographic = function () {

	// Orthographic from Perspective
	var fov = this.fov;
	var aspect = this.cameraP.aspect;
	var near = this.cameraP.near;
	var far = this.cameraP.far;
	
	
	// Just pretend we want the mid plane of the viewing frustum
	var hyperfocus = ( near + far ) / 2; 
	
	var halfHeight = Math.tan( fov / 2 ) * hyperfocus;
	var planeHeight = 2 * halfHeight;
	var planeWidth = planeHeight * aspect;
	var halfWidth = planeWidth / 2;
	
	halfHeight /= this.zoom;
	halfWidth /= this.zoom;
	
	this.cameraO.left = -halfWidth;
	this.cameraO.right = halfWidth;
	this.cameraO.top = halfHeight;
	this.cameraO.bottom = -halfHeight;
	
	// this.cameraO.left = -farHalfWidth;
	// this.cameraO.right = farHalfWidth;
	// this.cameraO.top = farHalfHeight;
	// this.cameraO.bottom = -farHalfHeight;

	// this.cameraO.left = this.left / this.zoom;
	// this.cameraO.right = this.right / this.zoom;
	// this.cameraO.top = this.top / this.zoom;
	// this.cameraO.bottom = this.bottom / this.zoom;
	
	this.cameraO.updateProjectionMatrix();

	this.near = this.cameraO.near;
	this.far = this.cameraO.far;
	this.projectionMatrix = this.cameraO.projectionMatrix;
	
	this.inPersepectiveMode = false;
	this.inOrthographicMode = true;

};

THREE.CombinedCamera.prototype.setFov = function(fov) {	
	this.fov = fov;
	
	if (this.inPersepectiveMode) {
		this.toPerspective();
	} else {
		this.toOrthographic();
	}

};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
THREE.CombinedCamera.prototype.setLens = function(focalLength, framesize) {

	if (!framesize) framesize = 43.25; // 36x24mm

	var fov = 2 * Math.atan( framesize / (focalLength * 2));
	fov = 180 / Math.PI * fov;
	this.setFov(fov);

	return fov;
};


THREE.CombinedCamera.prototype.setZoom = function(zoom) {

	this.zoom = zoom;
	
	if (this.inPersepectiveMode) {
		this.toPerspective();
	} else {
		this.toOrthographic();
	}
	

};

THREE.CombinedCamera.prototype.toFrontView = function() {
	this.rotation.x = 0;
	this.rotation.y = 0;
	this.rotation.z = 0;
	
	//TODO: Better way to disable camera.lookAt()?
	this.rotationAutoUpdate = false;
};

THREE.CombinedCamera.prototype.toBackView = function() {
	this.rotation.x = 0;
	this.rotation.y = Math.PI;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;
};
	
THREE.CombinedCamera.prototype.toLeftView = function() {
	this.rotation.x = 0;
	this.rotation.y = - Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;
};

THREE.CombinedCamera.prototype.toRightView = function() {
	this.rotation.x = 0;
	this.rotation.y = Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;
};

THREE.CombinedCamera.prototype.toTopView = function() {
	this.rotation.x = - Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;
};

THREE.CombinedCamera.prototype.toBottomView = function() {
	this.rotation.x = Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author paulirish / http://paulirish.com/
 */

THREE.FirstPersonControls = function ( object, domElement ) {

	this.object = object;
	this.target = new THREE.Vector3( 0, 0, 0 );

	this.domElement = ( domElement !== undefined ) ? domElement : document;

	this.movementSpeed = 1.0;
	this.lookSpeed = 0.005;

	this.noFly = false;
	this.lookVertical = true;
	this.autoForward = false;

	this.activeLook = true;

	this.heightSpeed = false;
	this.heightCoef = 1.0;
	this.heightMin = 0.0;

	this.constrainVertical = false;
	this.verticalMin = 0;
	this.verticalMax = Math.PI;

	this.autoSpeedFactor = 0.0;

	this.mouseX = 0;
	this.mouseY = 0;

	this.lat = 0;
	this.lon = 0;
	this.phi = 0;
	this.theta = 0;

	this.moveForward = false;
	this.moveBackward = false;
	this.moveLeft = false;
	this.moveRight = false;
	this.freeze = false;

	this.mouseDragOn = false;

	if ( this.domElement === document ) {

		this.viewHalfX = window.innerWidth / 2;
		this.viewHalfY = window.innerHeight / 2;

	} else {

		this.viewHalfX = this.domElement.offsetWidth / 2;
		this.viewHalfY = this.domElement.offsetHeight / 2;
		this.domElement.setAttribute( 'tabindex', -1 );

	}

	this.onMouseDown = function ( event ) {

		if ( this.domElement !== document ) {

			this.domElement.focus();

		}

		event.preventDefault();
		event.stopPropagation();

		if ( this.activeLook ) {

			switch ( event.button ) {

				case 0: this.moveForward = true; break;
				case 2: this.moveBackward = true; break;

			}

		}

		this.mouseDragOn = true;

	};

	this.onMouseUp = function ( event ) {

		event.preventDefault();
		event.stopPropagation();

		if ( this.activeLook ) {

			switch ( event.button ) {

				case 0: this.moveForward = false; break;
				case 2: this.moveBackward = false; break;

			}

		}

		this.mouseDragOn = false;

	};

	this.onMouseMove = function ( event ) {

		if ( this.domElement === document ) {

			this.mouseX = event.pageX - this.viewHalfX;
			this.mouseY = event.pageY - this.viewHalfY;

		} else {

			this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
			this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;

		}

	};

	this.onKeyDown = function ( event ) {

		switch( event.keyCode ) {

			case 38: /*up*/
			case 87: /*W*/ this.moveForward = true; break;

			case 37: /*left*/
			case 65: /*A*/ this.moveLeft = true; break;

			case 40: /*down*/
			case 83: /*S*/ this.moveBackward = true; break;

			case 39: /*right*/
			case 68: /*D*/ this.moveRight = true; break;

			case 82: /*R*/ this.moveUp = true; break;
			case 70: /*F*/ this.moveDown = true; break;

			case 81: /*Q*/ this.freeze = !this.freeze; break;

		}

	};

	this.onKeyUp = function ( event ) {

		switch( event.keyCode ) {

			case 38: /*up*/
			case 87: /*W*/ this.moveForward = false; break;

			case 37: /*left*/
			case 65: /*A*/ this.moveLeft = false; break;

			case 40: /*down*/
			case 83: /*S*/ this.moveBackward = false; break;

			case 39: /*right*/
			case 68: /*D*/ this.moveRight = false; break;

			case 82: /*R*/ this.moveUp = false; break;
			case 70: /*F*/ this.moveDown = false; break;

		}

	};

	this.update = function( delta ) {
		var actualMoveSpeed = 0;
		if ( !this.freeze ) {

			if ( this.heightSpeed ) {

				var y = THREE.Math.clamp( this.object.position.y, this.heightMin, this.heightMax );
				var heightDelta = y - this.heightMin;

				this.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );

			} else {

				this.autoSpeedFactor = 0.0;

			}

			actualMoveSpeed = delta * this.movementSpeed;

			if ( this.moveForward || ( this.autoForward && !this.moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) );
			if ( this.moveBackward ) this.object.translateZ( actualMoveSpeed );

			if ( this.moveLeft ) this.object.translateX( - actualMoveSpeed );
			if ( this.moveRight ) this.object.translateX( actualMoveSpeed );

			if ( this.moveUp ) this.object.translateY( actualMoveSpeed );
			if ( this.moveDown ) this.object.translateY( - actualMoveSpeed );

			var actualLookSpeed = delta * this.lookSpeed;

			if ( !this.activeLook ) {

				actualLookSpeed = 0;

			}

			this.lon += this.mouseX * actualLookSpeed;
			if( this.lookVertical ) this.lat -= this.mouseY * actualLookSpeed;

			this.lat = Math.max( - 85, Math.min( 85, this.lat ) );
			this.phi = ( 90 - this.lat ) * Math.PI / 180;
			this.theta = this.lon * Math.PI / 180;

			var targetPosition = this.target,
				position = this.object.position;

			targetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );
			targetPosition.y = position.y + 100 * Math.cos( this.phi );
			targetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );

		}

		var verticalLookRatio = 1;

		if ( this.constrainVertical ) {

			verticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );

		}

		this.lon += this.mouseX * actualLookSpeed;
		if( this.lookVertical ) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;

		this.lat = Math.max( - 85, Math.min( 85, this.lat ) );
		this.phi = ( 90 - this.lat ) * Math.PI / 180;

		this.theta = this.lon * Math.PI / 180;

		if ( this.constrainVertical ) {

			this.phi = THREE.Math.mapLinear( this.phi, 0, Math.PI, this.verticalMin, this.verticalMax );

		}

		var targetPosition = this.target,
			position = this.object.position;

		targetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );
		targetPosition.y = position.y + 100 * Math.cos( this.phi );
		targetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );

		this.object.lookAt( targetPosition );

	};


	this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

	this.domElement.addEventListener( 'mousemove', bind( this, this.onMouseMove ), false );
	this.domElement.addEventListener( 'mousedown', bind( this, this.onMouseDown ), false );
	this.domElement.addEventListener( 'mouseup', bind( this, this.onMouseUp ), false );
	this.domElement.addEventListener( 'keydown', bind( this, this.onKeyDown ), false );
	this.domElement.addEventListener( 'keyup', bind( this, this.onKeyUp ), false );

	function bind( scope, fn ) {

		return function () {

			fn.apply( scope, arguments );

		};

	};

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PathControls = function ( object, domElement ) {

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;

	this.id = "PathControls" + THREE.PathControlsIdCounter ++;

	// API

	this.duration = 10 * 1000; // milliseconds
	this.waypoints = [];

	this.useConstantSpeed = true;
	this.resamplingCoef = 50;

	this.debugPath = new THREE.Object3D();
	this.debugDummy = new THREE.Object3D();

	this.animationParent = new THREE.Object3D();

	this.lookSpeed = 0.005;
	this.lookVertical = true;
	this.lookHorizontal = true;
	this.verticalAngleMap   = { srcRange: [ 0, 2 * Math.PI ], dstRange: [ 0, 2 * Math.PI ] };
	this.horizontalAngleMap = { srcRange: [ 0, 2 * Math.PI ], dstRange: [ 0, 2 * Math.PI ] };

	// internals

	this.target = new THREE.Object3D();

	this.mouseX = 0;
	this.mouseY = 0;

	this.lat = 0;
	this.lon = 0;

	this.phi = 0;
	this.theta = 0;

	if ( this.domElement === document ) {

		this.viewHalfX = window.innerWidth / 2;
		this.viewHalfY = window.innerHeight / 2;

	} else {

		this.viewHalfX = this.domElement.offsetWidth / 2;
		this.viewHalfY = this.domElement.offsetHeight / 2;
		this.domElement.setAttribute( 'tabindex', -1 );

	}

	var PI2 = Math.PI * 2,
		PI180 = Math.PI / 180;

	// methods

	this.update = function ( delta ) {

		var srcRange, dstRange;

		if( this.lookHorizontal ) this.lon += this.mouseX * this.lookSpeed * delta;
		if( this.lookVertical )   this.lat -= this.mouseY * this.lookSpeed * delta;

		this.lon = Math.max( 0, Math.min( 360, this.lon ) );
		this.lat = Math.max( - 85, Math.min( 85, this.lat ) );

		this.phi = ( 90 - this.lat ) * PI180;
		this.theta = this.lon * PI180;

		this.phi = normalize_angle_rad( this.phi );

		// constrain vertical look angle

		srcRange = this.verticalAngleMap.srcRange;
		dstRange = this.verticalAngleMap.dstRange;

		var tmpPhi = THREE.Math.mapLinear( this.phi, srcRange[ 0 ], srcRange[ 1 ], dstRange[ 0 ], dstRange[ 1 ] );
		var tmpPhiFullRange = dstRange[ 1 ] - dstRange[ 0 ];
		var tmpPhiNormalized = ( tmpPhi - dstRange[ 0 ] ) / tmpPhiFullRange;

		this.phi = QuadraticEaseInOut( tmpPhiNormalized ) * tmpPhiFullRange + dstRange[ 0 ];

		// constrain horizontal look angle

		srcRange = this.horizontalAngleMap.srcRange;
		dstRange = this.horizontalAngleMap.dstRange;

		var tmpTheta = THREE.Math.mapLinear( this.theta, srcRange[ 0 ], srcRange[ 1 ], dstRange[ 0 ], dstRange[ 1 ] );
		var tmpThetaFullRange = dstRange[ 1 ] - dstRange[ 0 ];
		var tmpThetaNormalized = ( tmpTheta - dstRange[ 0 ] ) / tmpThetaFullRange;

		this.theta = QuadraticEaseInOut( tmpThetaNormalized ) * tmpThetaFullRange + dstRange[ 0 ];

		var targetPosition = this.target.position,
			position = this.object.position;

		targetPosition.x = 100 * Math.sin( this.phi ) * Math.cos( this.theta );
		targetPosition.y = 100 * Math.cos( this.phi );
		targetPosition.z = 100 * Math.sin( this.phi ) * Math.sin( this.theta );

		this.object.lookAt( this.target.position );

	};

	this.onMouseMove = function ( event ) {

		if ( this.domElement === document ) {

			this.mouseX = event.pageX - this.viewHalfX;
			this.mouseY = event.pageY - this.viewHalfY;

		} else {

			this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
			this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;

		}

	};

	// utils

	function normalize_angle_rad( a ) {

		var b = a % PI2;
		return b >= 0 ? b : b + PI2;

	};

	function distance( a, b ) {

		var dx = a[ 0 ] - b[ 0 ],
			dy = a[ 1 ] - b[ 1 ],
			dz = a[ 2 ] - b[ 2 ];

		return Math.sqrt( dx * dx + dy * dy + dz * dz );

	};

	function QuadraticEaseInOut ( k ) {

		if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
		return - 0.5 * ( --k * ( k - 2 ) - 1 );

	};

	function bind( scope, fn ) {

		return function () {

			fn.apply( scope, arguments );

		};

	};

	function initAnimationPath( parent, spline, name, duration ) {

		var animationData = {

		   name: name,
		   fps: 0.6,
		   length: duration,

		   hierarchy: []

		};

		var i,
			parentAnimation, childAnimation,
			path = spline.getControlPointsArray(),
			sl = spline.getLength(),
			pl = path.length,
			t = 0,
			first = 0,
			last  = pl - 1;

		parentAnimation = { parent: -1, keys: [] };
		parentAnimation.keys[ first ] = { time: 0,        pos: path[ first ], rot: [ 0, 0, 0, 1 ], scl: [ 1, 1, 1 ] };
		parentAnimation.keys[ last  ] = { time: duration, pos: path[ last ],  rot: [ 0, 0, 0, 1 ], scl: [ 1, 1, 1 ] };

		for ( i = 1; i < pl - 1; i++ ) {

			// real distance (approximation via linear segments)

			t = duration * sl.chunks[ i ] / sl.total;

			// equal distance

			//t = duration * ( i / pl );

			// linear distance

			//t += duration * distance( path[ i ], path[ i - 1 ] ) / sl.total;

			parentAnimation.keys[ i ] = { time: t, pos: path[ i ] };

		}

		animationData.hierarchy[ 0 ] = parentAnimation;

		THREE.AnimationHandler.add( animationData );

		return new THREE.Animation( parent, name, THREE.AnimationHandler.CATMULLROM_FORWARD, false );

	};


	function createSplineGeometry( spline, n_sub ) {

		var i, index, position,
			geometry = new THREE.Geometry();

		for ( i = 0; i < spline.points.length * n_sub; i ++ ) {

			index = i / ( spline.points.length * n_sub );
			position = spline.getPoint( index );

			geometry.vertices[ i ] = new THREE.Vertex( new THREE.Vector3( position.x, position.y, position.z ) );

		}

		return geometry;

	};

	function createPath( parent, spline ) {

		var lineGeo = createSplineGeometry( spline, 10 ),
			particleGeo = createSplineGeometry( spline, 10 ),
			lineMat = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 3 } ),
			lineObj = new THREE.Line( lineGeo, lineMat ),
			particleObj = new THREE.ParticleSystem( particleGeo, new THREE.ParticleBasicMaterial( { color: 0xffaa00, size: 3 } ) );

		lineObj.scale.set( 1, 1, 1 );
		parent.add( lineObj );

		particleObj.scale.set( 1, 1, 1 );
		parent.add( particleObj );

		var waypoint,
			geo = new THREE.SphereGeometry( 1, 16, 8 ),
			mat = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

		for ( var i = 0; i < spline.points.length; i ++ ) {

			waypoint = new THREE.Mesh( geo, mat );
			waypoint.position.copy( spline.points[ i ] );
			parent.add( waypoint );

		}

	};

	this.init = function ( ) {

		// constructor

		this.spline = new THREE.Spline();
		this.spline.initFromArray( this.waypoints );

		if ( this.useConstantSpeed ) {

			this.spline.reparametrizeByArcLength( this.resamplingCoef );

		}

		if ( this.createDebugDummy ) {

			var dummyParentMaterial = new THREE.MeshLambertMaterial( { color: 0x0077ff } ),
			dummyChildMaterial  = new THREE.MeshLambertMaterial( { color: 0x00ff00 } ),
			dummyParentGeo = new THREE.CubeGeometry( 10, 10, 20 ),
			dummyChildGeo  = new THREE.CubeGeometry( 2, 2, 10 );

			this.animationParent = new THREE.Mesh( dummyParentGeo, dummyParentMaterial );

			var dummyChild = new THREE.Mesh( dummyChildGeo, dummyChildMaterial );
			dummyChild.position.set( 0, 10, 0 );

			this.animation = initAnimationPath( this.animationParent, this.spline, this.id, this.duration );

			this.animationParent.add( this.object );
			this.animationParent.add( this.target );
			this.animationParent.add( dummyChild );

		} else {

			this.animation = initAnimationPath( this.animationParent, this.spline, this.id, this.duration );
			this.animationParent.add( this.target );
			this.animationParent.add( this.object );

		}

		if ( this.createDebugPath ) {

			createPath( this.debugPath, this.spline );

		}

		this.domElement.addEventListener( 'mousemove', bind( this, this.onMouseMove ), false );

	};

};

THREE.PathControlsIdCounter = 0;
/**
 * @author James Baicoianu / http://www.baicoianu.com/
 */

THREE.FlyControls = function ( object, domElement ) {

	this.object = object;

	this.domElement = ( domElement !== undefined ) ? domElement : document;
	if ( domElement ) this.domElement.setAttribute( 'tabindex', -1 );

	// API

	this.movementSpeed = 1.0;
	this.rollSpeed = 0.005;

	this.dragToLook = false;
	this.autoForward = false;

	// disable default target object behavior

	this.object.useQuaternion = true;

	// internals

	this.tmpQuaternion = new THREE.Quaternion();

	this.mouseStatus = 0;

	this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
	this.moveVector = new THREE.Vector3( 0, 0, 0 );
	this.rotationVector = new THREE.Vector3( 0, 0, 0 );

	this.handleEvent = function ( event ) {

		if ( typeof this[ event.type ] == 'function' ) {

			this[ event.type ]( event );

		}

	};

	this.keydown = function( event ) {

		if ( event.altKey ) {

			return;

		}

		switch( event.keyCode ) {

			case 16: /* shift */ this.movementSpeedMultiplier = .1; break;

			case 87: /*W*/ this.moveState.forward = 1; break;
			case 83: /*S*/ this.moveState.back = 1; break;

			case 65: /*A*/ this.moveState.left = 1; break;
			case 68: /*D*/ this.moveState.right = 1; break;

			case 82: /*R*/ this.moveState.up = 1; break;
			case 70: /*F*/ this.moveState.down = 1; break;

			case 38: /*up*/ this.moveState.pitchUp = 1; break;
			case 40: /*down*/ this.moveState.pitchDown = 1; break;

			case 37: /*left*/ this.moveState.yawLeft = 1; break;
			case 39: /*right*/ this.moveState.yawRight = 1; break;

			case 81: /*Q*/ this.moveState.rollLeft = 1; break;
			case 69: /*E*/ this.moveState.rollRight = 1; break;

		}

		this.updateMovementVector();
		this.updateRotationVector();

	};

	this.keyup = function( event ) {

		switch( event.keyCode ) {

			case 16: /* shift */ this.movementSpeedMultiplier = 1; break;

			case 87: /*W*/ this.moveState.forward = 0; break;
			case 83: /*S*/ this.moveState.back = 0; break;

			case 65: /*A*/ this.moveState.left = 0; break;
			case 68: /*D*/ this.moveState.right = 0; break;

			case 82: /*R*/ this.moveState.up = 0; break;
			case 70: /*F*/ this.moveState.down = 0; break;

			case 38: /*up*/ this.moveState.pitchUp = 0; break;
			case 40: /*down*/ this.moveState.pitchDown = 0; break;

			case 37: /*left*/ this.moveState.yawLeft = 0; break;
			case 39: /*right*/ this.moveState.yawRight = 0; break;

			case 81: /*Q*/ this.moveState.rollLeft = 0; break;
			case 69: /*E*/ this.moveState.rollRight = 0; break;

		}

		this.updateMovementVector();
		this.updateRotationVector();

	};

	this.mousedown = function( event ) {

		if ( this.domElement !== document ) {

			this.domElement.focus();

		}

		event.preventDefault();
		event.stopPropagation();

		if ( this.dragToLook ) {

			this.mouseStatus ++;

		} else {

			switch ( event.button ) {

				case 0: this.object.moveForward = true; break;
				case 2: this.object.moveBackward = true; break;

			}

		}

	};

	this.mousemove = function( event ) {

		if ( !this.dragToLook || this.mouseStatus > 0 ) {

			var container = this.getContainerDimensions();
			var halfWidth  = container.size[ 0 ] / 2;
			var halfHeight = container.size[ 1 ] / 2;

			this.moveState.yawLeft   = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth  ) / halfWidth;
			this.moveState.pitchDown =   ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;

			this.updateRotationVector();

		}

	};

	this.mouseup = function( event ) {

		event.preventDefault();
		event.stopPropagation();

		if ( this.dragToLook ) {

			this.mouseStatus --;

			this.moveState.yawLeft = this.moveState.pitchDown = 0;

		} else {

			switch ( event.button ) {

				case 0: this.moveForward = false; break;
				case 2: this.moveBackward = false; break;

			}

		}

		this.updateRotationVector();

	};

	this.update = function( delta ) {

		var moveMult = delta * this.movementSpeed;
		var rotMult = delta * this.rollSpeed;

		this.object.translateX( this.moveVector.x * moveMult );
		this.object.translateY( this.moveVector.y * moveMult );
		this.object.translateZ( this.moveVector.z * moveMult );

		this.tmpQuaternion.set( this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1 ).normalize();
		this.object.quaternion.multiplySelf( this.tmpQuaternion );

		this.object.matrix.setPosition( this.object.position );
		this.object.matrix.setRotationFromQuaternion( this.object.quaternion );
		this.object.matrixWorldNeedsUpdate = true;


	};

	this.updateMovementVector = function() {

		var forward = ( this.moveState.forward || ( this.autoForward && !this.moveState.back ) ) ? 1 : 0;

		this.moveVector.x = ( -this.moveState.left    + this.moveState.right );
		this.moveVector.y = ( -this.moveState.down    + this.moveState.up );
		this.moveVector.z = ( -forward + this.moveState.back );

		//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );

	};

	this.updateRotationVector = function() {

		this.rotationVector.x = ( -this.moveState.pitchDown + this.moveState.pitchUp );
		this.rotationVector.y = ( -this.moveState.yawRight  + this.moveState.yawLeft );
		this.rotationVector.z = ( -this.moveState.rollRight + this.moveState.rollLeft );

		//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );

	};

	this.getContainerDimensions = function() {

		if ( this.domElement != document ) {

			return {
				size	: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
				offset	: [ this.domElement.offsetLeft,  this.domElement.offsetTop ]
			};

		} else {

			return {
				size	: [ window.innerWidth, window.innerHeight ],
				offset	: [ 0, 0 ]
			};

		}

	};

	function bind( scope, fn ) {

		return function () {

			fn.apply( scope, arguments );

		};

	};

	this.domElement.addEventListener( 'mousemove', bind( this, this.mousemove ), false );
	this.domElement.addEventListener( 'mousedown', bind( this, this.mousedown ), false );
	this.domElement.addEventListener( 'mouseup',   bind( this, this.mouseup ), false );

	this.domElement.addEventListener( 'keydown', bind( this, this.keydown ), false );
	this.domElement.addEventListener( 'keyup',   bind( this, this.keyup ), false );

	this.updateMovementVector();
	this.updateRotationVector();

};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.RollControls = function ( object, domElement ) {

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// API

	this.mouseLook = true;
	this.autoForward = false;

	this.lookSpeed = 1;
	this.movementSpeed = 1;
	this.rollSpeed = 1;

	this.constrainVertical = [ -0.9, 0.9 ];

	// disable default target object behavior

	this.object.matrixAutoUpdate = false;

	// internals

	this.forward = new THREE.Vector3( 0, 0, 1 );
	this.roll = 0;

	var xTemp = new THREE.Vector3();
	var yTemp = new THREE.Vector3();
	var zTemp = new THREE.Vector3();
	var rollMatrix = new THREE.Matrix4();

	var doRoll = false, rollDirection = 1, forwardSpeed = 0, sideSpeed = 0, upSpeed = 0;

	var mouseX = 0, mouseY = 0;

	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;

	// custom update

	this.update = function ( delta ) {

		if ( this.mouseLook ) {

			var actualLookSpeed = delta * this.lookSpeed;

			this.rotateHorizontally( actualLookSpeed * mouseX );
			this.rotateVertically( actualLookSpeed * mouseY );

		}

		var actualSpeed = delta * this.movementSpeed;
		var forwardOrAuto = ( forwardSpeed > 0 || ( this.autoForward && ! ( forwardSpeed < 0 ) ) ) ? 1 : forwardSpeed;

		this.object.translateZ( -actualSpeed * forwardOrAuto );
		this.object.translateX( actualSpeed * sideSpeed );
		this.object.translateY( actualSpeed * upSpeed );

		if( doRoll ) {

			this.roll += this.rollSpeed * delta * rollDirection;

		}

		// cap forward up / down

		if( this.forward.y > this.constrainVertical[ 1 ] ) {

			this.forward.y = this.constrainVertical[ 1 ];
			this.forward.normalize();

		} else if( this.forward.y < this.constrainVertical[ 0 ] ) {

			this.forward.y = this.constrainVertical[ 0 ];
			this.forward.normalize();

		}


		// construct unrolled camera matrix

		zTemp.copy( this.forward );
		yTemp.set( 0, 1, 0 );

		xTemp.cross( yTemp, zTemp ).normalize();
		yTemp.cross( zTemp, xTemp ).normalize();

		this.object.matrix.n11 = xTemp.x; this.object.matrix.n12 = yTemp.x; this.object.matrix.n13 = zTemp.x;
		this.object.matrix.n21 = xTemp.y; this.object.matrix.n22 = yTemp.y; this.object.matrix.n23 = zTemp.y;
		this.object.matrix.n31 = xTemp.z; this.object.matrix.n32 = yTemp.z; this.object.matrix.n33 = zTemp.z;

		// calculate roll matrix

		rollMatrix.identity();
		rollMatrix.n11 = Math.cos( this.roll ); rollMatrix.n12 = -Math.sin( this.roll );
		rollMatrix.n21 = Math.sin( this.roll ); rollMatrix.n22 =  Math.cos( this.roll );

		// multiply camera with roll

		this.object.matrix.multiplySelf( rollMatrix );
		this.object.matrixWorldNeedsUpdate = true;

		// set position

		this.object.matrix.n14 = this.object.position.x;
		this.object.matrix.n24 = this.object.position.y;
		this.object.matrix.n34 = this.object.position.z;


	};

	this.translateX = function ( distance ) {

		this.object.position.x += this.object.matrix.n11 * distance;
		this.object.position.y += this.object.matrix.n21 * distance;
		this.object.position.z += this.object.matrix.n31 * distance;

	};

	this.translateY = function ( distance ) {

		this.object.position.x += this.object.matrix.n12 * distance;
		this.object.position.y += this.object.matrix.n22 * distance;
		this.object.position.z += this.object.matrix.n32 * distance;

	};

	this.translateZ = function ( distance ) {

		this.object.position.x -= this.object.matrix.n13 * distance;
		this.object.position.y -= this.object.matrix.n23 * distance;
		this.object.position.z -= this.object.matrix.n33 * distance;

	};


	this.rotateHorizontally = function ( amount ) {

		// please note that the amount is NOT degrees, but a scale value

		xTemp.set( this.object.matrix.n11, this.object.matrix.n21, this.object.matrix.n31 );
		xTemp.multiplyScalar( amount );

		this.forward.subSelf( xTemp );
		this.forward.normalize();

	};

	this.rotateVertically = function ( amount ) {

		// please note that the amount is NOT degrees, but a scale value

		yTemp.set( this.object.matrix.n12, this.object.matrix.n22, this.object.matrix.n32 );
		yTemp.multiplyScalar( amount );

		this.forward.addSelf( yTemp );
		this.forward.normalize();

	};

	function onKeyDown( event ) {

		switch( event.keyCode ) {

			case 38: /*up*/
			case 87: /*W*/ forwardSpeed = 1; break;

			case 37: /*left*/
			case 65: /*A*/ sideSpeed = -1; break;

			case 40: /*down*/
			case 83: /*S*/ forwardSpeed = -1; break;

			case 39: /*right*/
			case 68: /*D*/ sideSpeed = 1; break;

			case 81: /*Q*/ doRoll = true; rollDirection = 1; break;
			case 69: /*E*/ doRoll = true; rollDirection = -1; break;

			case 82: /*R*/ upSpeed = 1; break;
			case 70: /*F*/ upSpeed = -1; break;

		}

	};

	function onKeyUp( event ) {

		switch( event.keyCode ) {

			case 38: /*up*/
			case 87: /*W*/ forwardSpeed = 0; break;

			case 37: /*left*/
			case 65: /*A*/ sideSpeed = 0; break;

			case 40: /*down*/
			case 83: /*S*/ forwardSpeed = 0; break;

			case 39: /*right*/
			case 68: /*D*/ sideSpeed = 0; break;

			case 81: /*Q*/ doRoll = false; break;
			case 69: /*E*/ doRoll = false; break;

			case 82: /*R*/ upSpeed = 0; break;
			case 70: /*F*/ upSpeed = 0; break;

		}

	};

	function onMouseMove( event ) {

		mouseX = ( event.clientX - windowHalfX ) / window.innerWidth;
		mouseY = ( event.clientY - windowHalfY ) / window.innerHeight;

	};

	function onMouseDown ( event ) {

		event.preventDefault();
		event.stopPropagation();

		switch ( event.button ) {

			case 0: forwardSpeed = 1; break;
			case 2: forwardSpeed = -1; break;

		}

	};

	function onMouseUp ( event ) {

		event.preventDefault();
		event.stopPropagation();

		switch ( event.button ) {

			case 0: forwardSpeed = 0; break;
			case 2: forwardSpeed = 0; break;

		}

	};

	this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

	this.domElement.addEventListener( 'mousemove', onMouseMove, false );
	this.domElement.addEventListener( 'mousedown', onMouseDown, false );
	this.domElement.addEventListener( 'mouseup', onMouseUp, false );
	this.domElement.addEventListener( 'keydown', onKeyDown, false );
	this.domElement.addEventListener( 'keyup', onKeyUp, false );

};
/**
 * @author Eberhard Graether / http://egraether.com/
 */

THREE.TrackballControls = function ( object, domElement ) {

	var _this = this,
	STATE = { NONE : -1, ROTATE : 0, ZOOM : 1, PAN : 2 };

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// API

	this.enabled = true;

	this.screen = { width: window.innerWidth, height: window.innerHeight, offsetLeft: 0, offsetTop: 0 };
	this.radius = ( this.screen.width + this.screen.height ) / 4;

	this.rotateSpeed = 1.0;
	this.zoomSpeed = 1.2;
	this.panSpeed = 0.3;

	this.noRotate = false;
	this.noZoom = false;
	this.noPan = false;

	this.staticMoving = false;
	this.dynamicDampingFactor = 0.2;

	this.minDistance = 0;
	this.maxDistance = Infinity;

	this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

	// internals

	this.target = new THREE.Vector3( 0, 0, 0 );

	var _keyPressed = false,
	_state = STATE.NONE,

	_eye = new THREE.Vector3(),

	_rotateStart = new THREE.Vector3(),
	_rotateEnd = new THREE.Vector3(),

	_zoomStart = new THREE.Vector2(),
	_zoomEnd = new THREE.Vector2(),

	_panStart = new THREE.Vector2(),
	_panEnd = new THREE.Vector2();


	// methods

	this.handleEvent = function ( event ) {

		if ( typeof this[ event.type ] == 'function' ) {

			this[ event.type ]( event );

		}

	};

	this.getMouseOnScreen = function( clientX, clientY ) {

		return new THREE.Vector2(
			( clientX - _this.screen.offsetLeft ) / _this.radius * 0.5,
			( clientY - _this.screen.offsetTop ) / _this.radius * 0.5
		);

	};

	this.getMouseProjectionOnBall = function( clientX, clientY ) {

		var mouseOnBall = new THREE.Vector3(
			( clientX - _this.screen.width * 0.5 - _this.screen.offsetLeft ) / _this.radius,
			( _this.screen.height * 0.5 + _this.screen.offsetTop - clientY ) / _this.radius,
			0.0
		);

		var length = mouseOnBall.length();

		if ( length > 1.0 ) {

			mouseOnBall.normalize();

		} else {

			mouseOnBall.z = Math.sqrt( 1.0 - length * length );

		}

		_eye.copy( _this.object.position ).subSelf( _this.target );

		var projection = _this.object.up.clone().setLength( mouseOnBall.y );
		projection.addSelf( _this.object.up.clone().crossSelf( _eye ).setLength( mouseOnBall.x ) );
		projection.addSelf( _eye.setLength( mouseOnBall.z ) );

		return projection;

	};

	this.rotateCamera = function() {

		var angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );

		if ( angle ) {

			var axis = ( new THREE.Vector3() ).cross( _rotateStart, _rotateEnd ).normalize(),
				quaternion = new THREE.Quaternion();

			angle *= _this.rotateSpeed;

			quaternion.setFromAxisAngle( axis, -angle );

			quaternion.multiplyVector3( _eye );
			quaternion.multiplyVector3( _this.object.up );

			quaternion.multiplyVector3( _rotateEnd );

			if ( _this.staticMoving ) {

				_rotateStart = _rotateEnd;

			} else {

				quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
				quaternion.multiplyVector3( _rotateStart );

			}

		}

	};

	this.zoomCamera = function() {

		var factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;

		if ( factor !== 1.0 && factor > 0.0 ) {

			_eye.multiplyScalar( factor );

			if ( _this.staticMoving ) {

				_zoomStart = _zoomEnd;

			} else {

				_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

			}

		}

	};

	this.panCamera = function() {

		var mouseChange = _panEnd.clone().subSelf( _panStart );

		if ( mouseChange.lengthSq() ) {

			mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

			var pan = _eye.clone().crossSelf( _this.object.up ).setLength( mouseChange.x );
			pan.addSelf( _this.object.up.clone().setLength( mouseChange.y ) );

			_this.object.position.addSelf( pan );
			_this.target.addSelf( pan );

			if ( _this.staticMoving ) {

				_panStart = _panEnd;

			} else {

				_panStart.addSelf( mouseChange.sub( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

			}

		}

	};

	this.checkDistances = function() {

		if ( !_this.noZoom || !_this.noPan ) {

			if ( _this.object.position.lengthSq() > _this.maxDistance * _this.maxDistance ) {

				_this.object.position.setLength( _this.maxDistance );

			}

			if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

				_this.object.position.add( _this.target, _eye.setLength( _this.minDistance ) );

			}

		}

	};

	this.update = function() {

		_eye.copy( _this.object.position ).subSelf( this.target );

		if ( !_this.noRotate ) {

			_this.rotateCamera();

		}
		
		if ( !_this.noZoom ) {

			_this.zoomCamera();

		}

		if ( !_this.noPan ) {

			_this.panCamera();

		}

		_this.object.position.add( _this.target, _eye );

		_this.checkDistances();

		_this.object.lookAt( _this.target );

	};


	// listeners

	function keydown( event ) {

		if ( ! _this.enabled ) return;

		if ( _state !== STATE.NONE ) {

			return;

		} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {

			_state = STATE.ROTATE;

		} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {

			_state = STATE.ZOOM;

		} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {

			_state = STATE.PAN;

		}

		if ( _state !== STATE.NONE ) {

			_keyPressed = true;

		}

	};

	function keyup( event ) {

		if ( ! _this.enabled ) return;

		if ( _state !== STATE.NONE ) {

			_state = STATE.NONE;

		}

	};

	function mousedown( event ) {

		if ( ! _this.enabled ) return;

		event.preventDefault();
		event.stopPropagation();

		if ( _state === STATE.NONE ) {

			_state = event.button;

			if ( _state === STATE.ROTATE && !_this.noRotate ) {

				_rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );

			} else if ( _state === STATE.ZOOM && !_this.noZoom ) {

				_zoomStart = _zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

			} else if ( !this.noPan ) {

				_panStart = _panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

			}

		}

	};

	function mousemove( event ) {

		if ( ! _this.enabled ) return;

		if ( _keyPressed ) {

			_rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );
			_zoomStart = _zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );
			_panStart = _panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

			_keyPressed = false;

		}

		if ( _state === STATE.NONE ) {

			return;

		} else if ( _state === STATE.ROTATE && !_this.noRotate ) {

			_rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );

		} else if ( _state === STATE.ZOOM && !_this.noZoom ) {

			_zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

		} else if ( _state === STATE.PAN && !_this.noPan ) {

			_panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

		}

	};

	function mouseup( event ) {

		if ( ! _this.enabled ) return;

		event.preventDefault();
		event.stopPropagation();

		_state = STATE.NONE;

	};

	this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

	this.domElement.addEventListener( 'mousemove', mousemove, false );
	this.domElement.addEventListener( 'mousedown', mousedown, false );
	this.domElement.addEventListener( 'mouseup', mouseup, false );

	window.addEventListener( 'keydown', keydown, false );
	window.addEventListener( 'keyup', keyup, false );

};
/**
 * @author mr.doob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.CubeGeometry = function ( width, height, depth, segmentsWidth, segmentsHeight, segmentsDepth, materials, sides ) {

	THREE.Geometry.call( this );

	var scope = this,
	width_half = width / 2,
	height_half = height / 2,
	depth_half = depth / 2;

	var mpx, mpy, mpz, mnx, mny, mnz;

	if ( materials !== undefined ) {

		if ( materials instanceof Array ) {

			this.materials = materials;

		} else {

			this.materials = [];

			for ( var i = 0; i < 6; i ++ ) {

				this.materials.push( materials );

			}

		}

		mpx = 0; mnx = 1; mpy = 2; mny = 3; mpz = 4; mnz = 5;

	} else {

		this.materials = [];

	}

	this.sides = { px: true, nx: true, py: true, ny: true, pz: true, nz: true };

	if ( sides != undefined ) {

		for ( var s in sides ) {

			if ( this.sides[ s ] != undefined ) {

				this.sides[ s ] = sides[ s ];

			}

		}

	}

	this.sides.px && buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, mpx ); // px
	this.sides.nx && buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, mnx ); // nx
	this.sides.py && buildPlane( 'x', 'z',   1,   1, width, depth, height_half, mpy ); // py
	this.sides.ny && buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, mny ); // ny
	this.sides.pz && buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, mpz ); // pz
	this.sides.nz && buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, mnz ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, material ) {

		var w, ix, iy,
		gridX = segmentsWidth || 1,
		gridY = segmentsHeight || 1,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = segmentsDepth || 1;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = segmentsDepth || 1;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( new THREE.Vertex( vector ) );

			}

		}

		for ( iy = 0; iy < gridY; iy++ ) {

			for ( ix = 0; ix < gridX; ix++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var face = new THREE.Face4( a + offset, b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = material;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [
							new THREE.UV( ix / gridX, iy / gridY ),
							new THREE.UV( ix / gridX, ( iy + 1 ) / gridY ),
							new THREE.UV( ( ix + 1 ) / gridX, ( iy + 1 ) / gridY ),
							new THREE.UV( ( ix + 1 ) / gridX, iy / gridY )
						] );

			}

		}

	}

	this.computeCentroids();
	this.mergeVertices();

};

THREE.CubeGeometry.prototype = new THREE.Geometry();
THREE.CubeGeometry.prototype.constructor = THREE.CubeGeometry;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, segmentsRadius, segmentsHeight, openEnded ) {

	THREE.Geometry.call( this );

	var radiusTop = radiusTop != null ? radiusTop : 20;
	var radiusBottom = radiusBottom != null ? radiusBottom : 20;
	var height = height || 100;
	var heightHalf = height / 2;
	var segmentsX = segmentsRadius || 8;
	var segmentsY = segmentsHeight || 1;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= segmentsY; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / segmentsY;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= segmentsX; x ++ ) {

			var u = x / segmentsX;

			var xpos = radius * Math.sin( u * Math.PI * 2 );
			var ypos = - v * height + heightHalf;
			var zpos = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( new THREE.Vertex( new THREE.Vector3( xpos, ypos, zpos ) ) );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.UV( u, v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < segmentsY; y ++ ) {

		for ( x = 0; x < segmentsX; x ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			// FIXME: These normals aren't right for cones.

			var n1 = this.vertices[ v1 ].position.clone().setY( 0 ).normalize();
			var n2 = this.vertices[ v2 ].position.clone().setY( 0 ).normalize();
			var n3 = this.vertices[ v3 ].position.clone().setY( 0 ).normalize();
			var n4 = this.vertices[ v4 ].position.clone().setY( 0 ).normalize();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );

		}

	}

	// top cap

	if ( !openEnded && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, heightHalf, 0 ) ) );

		for ( x = 0; x < segmentsX; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.UV( uv2.u, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( !openEnded && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, - heightHalf, 0 ) ) );

		for ( x = 0; x < segmentsX; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.UV( uv2.u, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

}
THREE.CylinderGeometry.prototype = new THREE.Geometry();
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *  steps: 			<int>,		// number of points for z-side extrusions
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  bevelSegments:	<int>, 			// number of bevel layers
 *
 *  extrudePath:	<THREE.CurvePath>	// path to extrude shape along
 *  bendPath:		<THREE.CurvePath> 	// path to bend the geometry around
 *
 *  material:		 <THREE.Material>	// material for front and back faces
 *  extrudeMaterial: <THREE.Material>	// material for extrusion and beveled faces
 *
 *  }
  **/

THREE.ExtrudeGeometry = function( shapes, options ) {

	if( typeof( shapes ) === "undefined" ) {

		shapes = [];
		return;

	}

	THREE.Geometry.call( this );

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	var s, sl = shapes.length, shape;

	this.shapebb = shapes[ sl - 1 ].getBoundingBox();

	for ( s = 0; s < sl; s ++ ) {

		shape = shapes[ s ];

		this.addShape( shape, options );

	}


	this.computeCentroids();
	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = new THREE.Geometry();
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;


THREE.ExtrudeGeometry.prototype.addShape = function( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var bendPath = options.bendPath;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var useSpacedPoints = options.useSpacedPoints !== undefined ? options.useSpacedPoints : false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	var shapebb = this.shapebb;
	//shapebb = shape.getBoundingBox();


	if ( extrudePath ) {

		extrudePts = extrudePath.getPoints( curveSegments );
		steps = extrudePts.length;
		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

	}

	// Safeguards if bevels are not enabled

	if ( !bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}


	// TODO, extrude by path's tangents? also via 3d path?

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;


	if ( bendPath ) {

		shape.addWrapPath( bendPath );

	}

	var shapePoints;

	if ( !useSpacedPoints ) {

	  	shapePoints = shape.extractAllPoints( curveSegments ); //

	} else {

		// QN - Would it be better to pass useSpacePoints parameter to shape, just like bendpath ?

		shapePoints = shape.extractAllSpacedPoints( curveSegments ) // for points with equal divisions

	}

    var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );
	//var faces = THREE.Shape.Utils.triangulate2( vertices, holes );

	// Would it be better to move points after triangulation?
	// shapePoints = shape.extractAllPointsWithBend( curveSegments, bendPath );
	// 	vertices = shapePoints.shape;
	// 	holes = shapePoints.holes;

	//console.log(faces);

	////
	///   Handle Vertices
	////

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	var i, il;

	function scalePt2 ( pt, vec, size ) {

		if ( !vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).addSelf( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	//------
	// Find directions for point movement
	//

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( pt_i, pt_j, pt_k ) {

		// Algorithm 2

		return getBevelVec2( pt_i, pt_j, pt_k );

	}

	function getBevelVec1( pt_i, pt_j, pt_k ) {

		var anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );
		var angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );

		if ( anglea > angleb ) {

			angleb += Math.PI * 2;

		}

		var anglec = ( anglea + angleb ) / 2;


		//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);

		var x = - Math.cos( anglec );
		var y = - Math.sin( anglec );

		var vec = new THREE.Vector2( x, y ); //.normalize();

		return vec;

	}

	function getBevelVec2( pt_i, pt_j, pt_k ) {

		var a = THREE.ExtrudeGeometry.__v1,
			b = THREE.ExtrudeGeometry.__v2,
			v_hat = THREE.ExtrudeGeometry.__v3,
			w_hat = THREE.ExtrudeGeometry.__v4,
			p = THREE.ExtrudeGeometry.__v5,
			q = THREE.ExtrudeGeometry.__v6,
			v, w,
			v_dot_w_hat, q_sub_p_dot_w_hat,
			s, intersection;

		// good reading for line-line intersection
		// http://sputsoft.com/blog/2010/03/line-line-intersection.html

		// define a as vector j->i
		// define b as vectot k->i

		a.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );
		b.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );

		// get unit vectors

		v = a.normalize();
		w = b.normalize();

		// normals from pt i

		v_hat.set( -v.y, v.x );
		w_hat.set( w.y, -w.x );

		// pts from i

		p.copy( pt_i ).addSelf( v_hat );
		q.copy( pt_i ).addSelf( w_hat );

		if ( p.equals( q ) ) {

			//console.log("Warning: lines are straight");
			return w_hat.clone();

		}

		// Points from j, k. helps prevents points cross overover most of the time

		p.copy( pt_j ).addSelf( v_hat );
		q.copy( pt_k ).addSelf( w_hat );

		v_dot_w_hat = v.dot( w_hat );
		q_sub_p_dot_w_hat = q.subSelf( p ).dot( w_hat );

		// We should not reach these conditions

		if ( v_dot_w_hat === 0 ) {

			console.log( "Either infinite or no solutions!" );

			if ( q_sub_p_dot_w_hat === 0 ) {

				console.log( "Its finite solutions." );

			} else {

				console.log( "Too bad, no solutions." );

			}

		}

		s = q_sub_p_dot_w_hat / v_dot_w_hat;

		if ( s < 0 ) {

			// in case of emergecy, revert to algorithm 1.

			return getBevelVec1( pt_i, pt_j, pt_k );

		}

		intersection = v.multiplyScalar( s ).addSelf( p );

		return intersection.subSelf( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly

	}

	var contourMovements = [];

	for ( i = 0, il = contour.length, j = il-1, k = i + 1; i < il; i++, j++, k++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			//vert = scalePt( contour[ i ], contourCentroid, bs, false );
			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
				//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );

				v( vert.x, vert.y,  -z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( !extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( !extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( !extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}


	////
	///   Handle Faces
	////

	// Bottom faces

	if ( bevelEnabled ) {

		var layer = 0 ; // steps + 1
		var offset = vlen * layer;

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];
			f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset );

		}

		layer = steps + bevelSegments * 2;
		offset = vlen * layer;

		// Top faces

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];
			f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

		}

	} else {

		for ( i = 0; i < flen; i++ ) {

			face = faces[ i ];
			f3( face[ 2 ], face[ 1 ], face[ 0 ] );

		}

		// Top faces

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];
			f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

		}

	}

	var tmpPt;
	var j, k, l, m;

	var layeroffset = 0;

	// Sides faces

	sidewalls( contour );
	layeroffset += contour.length;

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];
		sidewalls( ahole );

		//, true
		layeroffset += ahole.length;

	}

	// Create faces for the z-sides of the shape

	function sidewalls( contour ) {

		i = contour.length;

		while ( --i >= 0 ) {

			tmpPt = contour[ i ];

			j = i;
			k = i - 1;

			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );
				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d );

				if ( extrudeMaterial ) {

					var v1 = s / sl;
					var v2 = ( s + 1 ) / sl;

					var ztol = ( amount + bevelThickness * 2 );

					var u1 = ( scope.vertices[ a ].position.z + bevelThickness ) / ztol;
					var u2 = ( scope.vertices[ d ].position.z + bevelThickness ) / ztol;

					//console.log(vy1, vy2);

					scope.faceVertexUvs[ 0 ].push( [
						new THREE.UV( u1, v1 ),
						new THREE.UV( u2, v1 ),
						new THREE.UV( u2, v2 ),
						new THREE.UV( u1, v2 )
					] );
				}


			}

		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vertex( new THREE.Vector3( x, y, z ) ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		//normal, color, materials

		if ( material ) {

			var mx = shapebb.minX, my = shapebb.minY;

			var uy = shapebb.maxY; // - shapebb.minY;
			var ux = shapebb.maxX; // - shapebb.minX;

			var ax = scope.vertices[ a ].position.x,
				ay = scope.vertices[ a ].position.y,

				bx = scope.vertices[ b ].position.x,
				by = scope.vertices[ b ].position.y,

				cx = scope.vertices[ c ].position.x,
				cy = scope.vertices[ c ].position.y;

			scope.faceVertexUvs[ 0 ].push( [

				new THREE.UV( ax / ux, ay / uy ),
				new THREE.UV( bx / ux, by / uy ),
				new THREE.UV( cx / ux, cy / uy )

			] );
		}

	}

	function f4( a, b, c, d ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face4( a, b, c, d, null, null, extrudeMaterial ) );

	}

};


THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
/**
 * @author oosmoxiecode

 * uvs are messed up in this one, and commented away for now. There is an ugly "seam" by the shared vertices
 * when it "wraps" around, that needs to be fixed. Its because they share the first and the last vertices
 * so it draws the entire texture on the seam-faces, I think...
 */

THREE.IcosahedronGeometry = function ( subdivisions ) {

	var scope = this;
	var tempScope = new THREE.Geometry();
	var tempFaces;
	this.subdivisions = subdivisions || 0;

	//var temp_uv = [];

	THREE.Geometry.call(this);

	// create 12 vertices of a Icosahedron
	var t = (1 + Math.sqrt(5)) / 2;

	v(-1,  t,  0);
	v( 1,  t,  0);
	v(-1, -t,  0);
	v( 1, -t,  0);

	v( 0, -1,  t);
	v( 0,  1,  t);
	v( 0, -1, -t);
	v( 0,  1, -t);

	v( t,  0, -1);
	v( t,  0,  1);
	v(-t,  0, -1);
	v(-t,  0,  1);

	// 5 faces around point 0
	f3(0, 11, 5, tempScope);
	f3(0, 5, 1, tempScope);
	f3(0, 1, 7, tempScope);
	f3(0, 7, 10, tempScope);
	f3(0, 10, 11, tempScope);

	// 5 adjacent faces
	f3(1, 5, 9, tempScope);
	f3(5, 11, 4, tempScope);
	f3(11, 10, 2, tempScope);
	f3(10, 7, 6, tempScope);
	f3(7, 1, 8, tempScope);

	// 5 faces around point 3
	f3(3, 9, 4, tempScope);
	f3(3, 4, 2, tempScope);
	f3(3, 2, 6, tempScope);
	f3(3, 6, 8, tempScope);
	f3(3, 8, 9, tempScope);

	// 5 adjacent faces
	f3(4, 9, 5, tempScope);
	f3(2, 4, 11, tempScope);
	f3(6, 2, 10, tempScope);
	f3(8, 6, 7, tempScope);
	f3(9, 8, 1, tempScope);

	// subdivide faces to refine the triangles
	for (var i=0; i < this.subdivisions; i++) {
		tempFaces = new THREE.Geometry();
		for (var tri in tempScope.faces) {
			// replace each triangle by 4 triangles
			var a = getMiddlePoint(tempScope.faces[tri].a, tempScope.faces[tri].b);
			var b = getMiddlePoint(tempScope.faces[tri].b, tempScope.faces[tri].c);
			var c = getMiddlePoint(tempScope.faces[tri].c, tempScope.faces[tri].a);

			f3(tempScope.faces[tri].a, a, c, tempFaces);
			f3(tempScope.faces[tri].b, b, a, tempFaces);
			f3(tempScope.faces[tri].c, c, b, tempFaces);
			f3(a, b, c, tempFaces);
		}
		tempScope.faces = tempFaces.faces;
		tempScope.faceVertexUvs[ 0 ] = tempFaces.faceVertexUvs[ 0 ];
	}

	scope.faces = tempScope.faces;
	scope.faceVertexUvs[ 0 ] = tempScope.faceVertexUvs[ 0 ];

	this.computeCentroids();
	this.computeFaceNormals( true );

	function v( x, y, z ) {

		var length = Math.sqrt(x * x + y * y + z * z);
		var i = scope.vertices.push( new THREE.Vertex( new THREE.Vector3( x/length, y/length, z/length ) ) );

		return i-1;
	}

	function f3( a, b, c, inscope ) {

		var v1 = scope.vertices[ a ].position;
		var v2 = scope.vertices[ b ].position;
		var v3 = scope.vertices[ c ].position;

		var face = new THREE.Face3( a, b, c );
		face.vertexNormals.push( v1.clone().normalize(), v2.clone().normalize(), v3.clone().normalize() );

		inscope.faces.push( face );

		inscope.faceVertexUvs[ 0 ].push( [
			new THREE.UV( 1 - ( ( ( Math.atan2( v1.z, v1.x ) + Math.PI ) % Math.PI ) / Math.PI * 0.5 ), 0.5 - v1.y / 2 ),
			new THREE.UV( 1 - ( ( ( Math.atan2( v2.z, v2.x ) + Math.PI ) % Math.PI ) / Math.PI * 0.5 ), 0.5 - v2.y / 2 ),
			new THREE.UV( 1 - ( ( ( Math.atan2( v3.z, v3.x ) + Math.PI ) % Math.PI ) / Math.PI * 0.5 ), 0.5 - v3.y / 2 )
		] );

	}

	function getMiddlePoint(p1,p2) {
		var pos1 = scope.vertices[p1].position;
		var pos2 = scope.vertices[p2].position;

		var x = (pos1.x + pos2.x) / 2;
		var y = (pos1.y + pos2.y) / 2;
		var z = (pos1.z + pos2.z) / 2;

		var i = v(x, y, z);
		return i;
	}

}

THREE.IcosahedronGeometry.prototype = new THREE.Geometry();
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
/**
 * @author astrodud / http://astrodud.isgreat.org/
 */

THREE.LatheGeometry = function ( points, steps, angle ) {

	THREE.Geometry.call( this );

	this.steps = steps || 12;
	this.angle = angle || 2 * Math.PI;

	var stepSize = this.angle / this.steps,
	newV = [], oldInds = [], newInds = [], startInds = [],
	matrix = new THREE.Matrix4().setRotationZ( stepSize );

	for ( var j = 0; j < points.length; j ++ ) {

		this.vertices.push( new THREE.Vertex( points[ j ] ) );

		newV[ j ] = points[ j ].clone();
		oldInds[ j ] = this.vertices.length - 1;

	}

	for ( var r = 0; r <= this.angle + 0.001; r += stepSize ) { // need the +0.001 for it go up to angle

		for ( var j = 0; j < newV.length; j ++ ) {

			if ( r < this.angle ) {

				newV[ j ] = matrix.multiplyVector3( newV[ j ].clone() );
				this.vertices.push( new THREE.Vertex( newV[ j ] ) );
				newInds[ j ] = this.vertices.length - 1;

			} else {

				newInds = startInds; // wrap it up!

			}

		}

		if ( r == 0 ) startInds = oldInds;

		for ( var j = 0; j < oldInds.length - 1; j ++ ) {

			this.faces.push( new THREE.Face4( newInds[ j ], newInds[ j + 1 ], oldInds[ j + 1 ], oldInds[ j ] ) );
			this.faceVertexUvs[ 0 ].push( [

				new THREE.UV( 1 - r / this.angle, j / points.length ),
				new THREE.UV( 1 - r / this.angle, ( j + 1 ) / points.length ),
				new THREE.UV( 1 - ( r - stepSize ) / this.angle, ( j + 1 ) / points.length ),
				new THREE.UV( 1 - ( r - stepSize ) / this.angle, j / points.length )

			] );

		}

		oldInds = newInds;
		newInds = [];

	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = new THREE.Geometry();
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
/**
 * Octahedrons have 8 sides. This octahedron supports subdivision.
 * 
 * Vertices have 'smooth' normals, 
 * to make a sharp edge choose a material that uses face normals instead.
 *
 * @author daniel.deady@knectar.com
 * @param radius
 * @param detail Final number of triangles = 4^detail * 8
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	THREE.Geometry.call( this );

	detail = detail || 0;

	var that = this; // ugly scope hack

	prepare( new THREE.Vector3( +1, 0, 0 ) ); // right
	prepare( new THREE.Vector3( -1, 0, 0 ) ); // left
	prepare( new THREE.Vector3( 0, +1, 0 ) ); // up
	prepare( new THREE.Vector3( 0, -1, 0 ) ); // down
	prepare( new THREE.Vector3( 0, 0, +1 ) ); // front
	prepare( new THREE.Vector3( 0, 0, -1 ) ); // back
	var midpoints = [], p = this.vertices;

	// careful to output faces counter-clockwise, that is required for meshes
	make( p[0], p[2], p[4], detail );
	make( p[0], p[4], p[3], detail );
	make( p[0], p[3], p[5], detail );
	make( p[0], p[5], p[2], detail );
	make( p[1], p[2], p[5], detail );
	make( p[1], p[5], p[3], detail );
	make( p[1], p[3], p[4], detail );
	make( p[1], p[4], p[2], detail );

	/**
	 * Project vector onto sphere's surface
	 */
	function prepare( vector ) {

		var normal = vector.clone().normalize();
		var vertex = new THREE.Vertex( normal.clone().multiplyScalar( radius ) );
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.UV( u, v );

		return vertex;

	}

	/**
	 * Approximate a curved face with recursively sub-divided triangles.
	 */
	function make( v1, v2, v3, detail ) {

		if ( detail < 1 ) {

			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.position, v2.position, v3.position ] );
			face.centroid.addSelf( v1.position ).addSelf( v2.position ).addSelf( v3.position ).divideScalar( 3 );
			face.normal = face.centroid.clone().normalize();
			that.faces.push( face );

			var azi = azimuth( face.centroid );
			that.faceVertexUvs[ 0 ].push( [ 
				correctUV( v1.uv, v1.position, azi ),
				correctUV( v2.uv, v2.position, azi ),
				correctUV( v3.uv, v3.position, azi )
			] );

		}
		else {

			detail -= 1;
			// split triangle into 4 smaller triangles
			make( v1, midpoint( v1, v2 ), midpoint( v1, v3 ), detail ); // top quadrant
			make( midpoint( v1, v2 ), v2, midpoint( v2, v3 ), detail ); // left quadrant
			make( midpoint( v1, v3 ), midpoint( v2, v3 ), v3, detail ); // right quadrant
			make( midpoint( v1, v2 ), midpoint( v2, v3 ), midpoint( v1, v3 ), detail ); // center quadrant

		}

	}

	function midpoint( v1, v2 ) {

		if ( !midpoints[ v1.index ] ) midpoints[ v1.index ] = [];
		if ( !midpoints[ v2.index ] ) midpoints[ v2.index ] = [];
		var mid = midpoints[ v1.index ][ v2.index ];
		if ( mid === undefined ) {
			// generate mean point and project to surface with prepare()
			midpoints[ v1.index ][ v2.index ] = midpoints[ v2.index ][ v1.index ] = mid = prepare( 
				new THREE.Vector3().add( v1.position, v2.position ).divideScalar( 2 ) 
			);
		}
		return mid;

	}

	/**
	 * Angle around the Y axis, counter-clockwise when looking from above.
	 */
	function azimuth( vector ) {

		return Math.atan2( vector.z, -vector.x );

	}

	/**
	 * Angle above the XZ plane.
	 */
	function inclination( vector ) {

		return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}

	/**
	 * Texture fixing helper. Spheres have some odd behaviours.
	 */
	function correctUV( uv, vector, azimuth ) {

		if ( (azimuth < 0) && (uv.u === 1) ) uv = new THREE.UV( uv.u - 1, uv.v );
		if ( (vector.x === 0) && (vector.z === 0) ) uv = new THREE.UV( azimuth / 2 / Math.PI + 0.5, uv.v );
		return uv;

	}

	this.boundingSphere = { radius: radius };

};

THREE.OctahedronGeometry.prototype = new THREE.Geometry();
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
/**
 * @author mr.doob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, segmentsWidth, segmentsHeight ) {

	THREE.Geometry.call( this );

	var ix, iy,
	width_half = width / 2,
	height_half = height / 2,
	gridX = segmentsWidth || 1,
	gridY = segmentsHeight || 1,
	gridX1 = gridX + 1,
	gridY1 = gridY + 1,
	segment_width = width / gridX,
	segment_height = height / gridY,
	normal = new THREE.Vector3( 0, 0, 1 );

	for ( iy = 0; iy < gridY1; iy++ ) {

		for ( ix = 0; ix < gridX1; ix++ ) {

			var x = ix * segment_width - width_half;
			var y = iy * segment_height - height_half;

			this.vertices.push( new THREE.Vertex( new THREE.Vector3( x, - y, 0 ) ) );

		}

	}

	for ( iy = 0; iy < gridY; iy++ ) {

		for ( ix = 0; ix < gridX; ix++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			var face = new THREE.Face4( a, b, c, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [
						new THREE.UV( ix / gridX, iy / gridY ),
						new THREE.UV( ix / gridX, ( iy + 1 ) / gridY ),
						new THREE.UV( ( ix + 1 ) / gridX, ( iy + 1 ) / gridY ),
						new THREE.UV( ( ix + 1 ) / gridX, iy / gridY )
					] );

		}

	}

	this.computeCentroids();

};

THREE.PlaneGeometry.prototype = new THREE.Geometry();
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
/**
 * @author mr.doob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	var radius = radius || 50;
	var segmentsX = Math.max( 3, Math.floor( segmentsWidth ) || 8 );
	var segmentsY = Math.max( 2, Math.floor( segmentsHeight ) || 6 );

	var phiStart = phiStart != undefined ? phiStart : 0;
	var phiLength = phiLength != undefined ? phiLength : Math.PI * 2;

	var thetaStart = thetaStart != undefined ? thetaStart : 0;
	var thetaLength = thetaLength != undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= segmentsY; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= segmentsX; x ++ ) {

			var u = x / segmentsX;
			var v = y / segmentsY;

			var xpos = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			var ypos = radius * Math.cos( thetaStart + v * thetaLength );
			var zpos = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( new THREE.Vertex( new THREE.Vector3( xpos, ypos, zpos ) ) );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.UV( u, v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < segmentsY; y ++ ) {

		for ( x = 0; x < segmentsX; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].position.clone().normalize();
			var n2 = this.vertices[ v2 ].position.clone().normalize();
			var n3 = this.vertices[ v3 ].position.clone().normalize();
			var n4 = this.vertices[ v4 ].position.clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].position.y ) == radius ) {

				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].position.y ) ==  radius ) {

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );

			}

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = { radius: radius };

};

THREE.SphereGeometry.prototype = new THREE.Geometry();
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *
 *  bend:			<bool>			// bend according to hardcoded curve (generates bendPath)
 *  bendPath:       <curve>         // wraps text according to bend Path
 *  }
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */
/*	Usage Examples
	
	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textPath = new THREE.TextPath( text, options );
	var textShapes = textPath.toShapes();
	var text3d = new ExtrudeGeometry( textShapes, options );
	
*/


THREE.TextGeometry = function ( text, parameters ) {

	var textPath = new THREE.TextPath( text, parameters );
	var textShapes = textPath.toShapes();

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	if ( parameters.bend ) {

		var b = textShapes[ textShapes.length - 1 ].getBoundingBox();
		var max = b.maxX;

		parameters.bendPath = new THREE.QuadraticBezierCurve( new THREE.Vector2( 0, 0 ),
															  new THREE.Vector2( max / 2, 120 ),
															  new THREE.Vector2( max, 0 ) );

	}

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

};

THREE.TextGeometry.prototype = new THREE.ExtrudeGeometry();
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;


THREE.FontUtils = {

	faces : {},

	// Just for now. face[weight][style]

	face : "helvetiker",
	weight: "normal",
	style : "normal",
	size : 150,
	divisions : 10,

	getFace : function() {

		return this.faces[ this.face ][ this.weight ][ this.style ];

	},

	loadFace : function( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText : function( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;
			//characterPts.push( ret.points );
			//allPts = allPts.concat( ret.points );
			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths : fontPaths, offset : width };

	},




	extractGlyphPoints : function( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( !glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch( action ) {

				case 'm':

					// Move To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;

					pts.push( new THREE.Vector2( x, y ) );

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;
					pts.push( new THREE.Vector2( x, y ) );
					path.lineTo(x,y);
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i++ ] * scaleX + offset;
					cpy  = outline[ i++ ] * scaleY;
					cpx1 = outline[ i++ ] * scaleX + offset;
					cpy1 = outline[ i++ ] * scaleY;

					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
							pts.push( new THREE.Vector2( tx, ty ) );

					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i++ ] *  scaleX + offset;
					cpy  = outline[ i++ ] *  scaleY;
					cpx1 = outline[ i++ ] *  scaleX + offset;
					cpy1 = outline[ i++ ] * -scaleY;
					cpx2 = outline[ i++ ] *  scaleX + offset;
					cpy2 = outline[ i++ ] * -scaleY;

					path.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );
							pts.push( new THREE.Vector2( tx, ty ) );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha*scale, points:pts, path:path};
	}

};



/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count-- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( "Warning, unable to triangulate polygon!" );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				/*
				result.push( contour[ a ] );
				result.push( contour[ b ] );
				result.push( contour[ c ] );
				*/
				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv--;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for( var p = n - 1, q = 0; q < n; p = q++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	// see if p is inside triangle abc

	var insideTriangle = function( ax, ay,
								   bx, by,
								   cx, cy,
								   px, py ) {

		  var aX, aY, bX, bY;
		  var cX, cY, apx, apy;
		  var bpx, bpy, cpx, cpy;
		  var cCROSSap, bCROSScp, aCROSSbp;

		  aX = cx - bx;  aY = cy - by;
		  bX = ax - cx;  bY = ay - cy;
		  cX = bx - ax;  cY = by - ay;
		  apx= px  -ax;  apy= py - ay;
		  bpx= px - bx;  bpy= py - by;
		  cpx= px - cx;  cpy= py - cy;

		  aCROSSbp = aX*bpy - aY*bpx;
		  cCROSSap = cX*apy - cY*apx;
		  bCROSScp = bX*cpy - bY*cpx;

		  return ( (aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0) );

	};


	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;

			for ( p = 0; p < n; p++ ) {

				if( (p == u) || (p == v) || (p == w) ) continue;

				px = contour[ verts[ p ] ].x
				py = contour[ verts[ p ] ].y

				if ( insideTriangle( ax, ay, bx, by, cx, cy, px, py ) ) return false;

		  }

		  return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

})(THREE.FontUtils);

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
/**
 * @author oosmoxiecode
 * @author mr.doob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, segmentsR, segmentsT, arc ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.segmentsR = segmentsR || 8;
	this.segmentsT = segmentsT || 6;
	this.arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= this.segmentsR; j ++ ) {

		for ( var i = 0; i <= this.segmentsT; i ++ ) {

			var u = i / this.segmentsT * this.arc;
			var v = j / this.segmentsR * Math.PI * 2;

			center.x = this.radius * Math.cos( u );
			center.y = this.radius * Math.sin( u );

			var vector = new THREE.Vector3();
			vector.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );
			vector.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );
			vector.z = this.tube * Math.sin( v );

			this.vertices.push( new THREE.Vertex( vector ) );

			uvs.push( new THREE.UV( i / this.segmentsT, 1 - j / this.segmentsR ) );
			normals.push( vector.clone().subSelf( center ).normalize() );

		}
	}


	for ( var j = 1; j <= this.segmentsR; j ++ ) {

		for ( var i = 1; i <= this.segmentsT; i ++ ) {

			var a = ( this.segmentsT + 1 ) * j + i - 1;
			var b = ( this.segmentsT + 1 ) * ( j - 1 ) + i - 1;
			var c = ( this.segmentsT + 1 ) * ( j - 1 ) + i;
			var d = ( this.segmentsT + 1 ) * j + i;

			var face = new THREE.Face4( a, b, c, d, [ normals[ a ], normals[ b ], normals[ c ], normals[ d ] ] );
			face.normal.addSelf( normals[ a ] );
			face.normal.addSelf( normals[ b ] );
			face.normal.addSelf( normals[ c ] );
			face.normal.addSelf( normals[ d ] );
			face.normal.normalize();

			this.faces.push( face );

			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
		}

	}

	this.computeCentroids();

};

THREE.TorusGeometry.prototype = new THREE.Geometry();
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, segmentsR, segmentsT, p, q, heightScale ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 200;
	this.tube = tube || 40;
	this.segmentsR = segmentsR || 64;
	this.segmentsT = segmentsT || 8;
	this.p = p || 2;
	this.q = q || 3;
	this.heightScale = heightScale || 1;
	this.grid = new Array(this.segmentsR);

	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < this.segmentsR; ++ i ) {

		this.grid[ i ] = new Array( this.segmentsT );

		for ( var j = 0; j < this.segmentsT; ++ j ) {

			var u = i / this.segmentsR * 2 * this.p * Math.PI;
			var v = j / this.segmentsT * 2 * Math.PI;
			var p = getPos( u, v, this.q, this.p, this.radius, this.heightScale );
			var p2 = getPos( u + 0.01, v, this.q, this.p, this.radius, this.heightScale );
			var cx, cy;

			tang.x = p2.x - p.x; tang.y = p2.y - p.y; tang.z = p2.z - p.z;
			n.x = p2.x + p.x; n.y = p2.y + p.y; n.z = p2.z + p.z; 
			bitan.cross( tang, n );
			n.cross( bitan, tang );
			bitan.normalize();
			n.normalize();

			cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = this.tube * Math.sin( v );

			p.x += cx * n.x + cy * bitan.x;
			p.y += cx * n.y + cy * bitan.y;
			p.z += cx * n.z + cy * bitan.z;

			this.grid[ i ][ j ] = vert( p.x, p.y, p.z );

		}

	}

	for ( var i = 0; i < this.segmentsR; ++ i ) {

		for ( var j = 0; j < this.segmentsT; ++ j ) {

			var ip = ( i + 1 ) % this.segmentsR;
			var jp = ( j + 1 ) % this.segmentsT;
			var a = this.grid[ i ][ j ]; 
			var b = this.grid[ ip ][ j ];
			var c = this.grid[ ip ][ jp ];
			var d = this.grid[ i ][ jp ]; 

			var uva = new THREE.UV( i / this.segmentsR, j / this.segmentsT );
			var uvb = new THREE.UV( ( i + 1 ) / this.segmentsR, j / this.segmentsT );
			var uvc = new THREE.UV( ( i + 1 ) / this.segmentsR, ( j + 1 ) / this.segmentsT );
			var uvd = new THREE.UV( i / this.segmentsR, ( j + 1 ) / this.segmentsT );

			this.faces.push( new THREE.Face4( a, b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva,uvb,uvc, uvd ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vertex( new THREE.Vector3( x, y, z ) ) ) - 1;

	}

	function getPos( u, v, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var cv = Math.cos( v );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = new THREE.Geometry();
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
/*
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog 
 * 
 *	Subdivision Geometry Modifier 
 *		using Catmull-Clark Subdivision Surfaces
 *		for creating smooth geometry meshes
 *
 *	Note: a modifier modifies vertices and faces of geometry,
 *		so use THREE.GeometryUtils.clone() if orignal geoemtry needs to be retained
 * 
 *	Readings: 
 *		http://en.wikipedia.org/wiki/Catmull%E2%80%93Clark_subdivision_surface
 *		http://www.rorydriscoll.com/2008/08/01/catmull-clark-subdivision-the-basics/
 *		http://xrt.wikidot.com/blog:31
 *		"Subdivision Surfaces in Character Animation"
 *
 *	Supports:
 *		Closed and Open geometries.
 *
 *	TODO: 
 *		crease vertex and "semi-sharp" features
 *		selective subdivision
 */

THREE.SubdivisionModifier = function( subdivisions ) {
	
	this.subdivisions = (subdivisions === undefined ) ? 1 : subdivisions;
	
	// Settings
	this.useOldVertexColors = false;
	this.supportUVs = true;
	
};

//THREE.SubdivisionModifier.prototype = new THREE.Modifier();

THREE.SubdivisionModifier.prototype.constructor = THREE.SubdivisionModifier;

// Applies the "modify" pattern
THREE.SubdivisionModifier.prototype.modify = function ( geometry ) {
	
	var repeats = this.subdivisions;
	
	while ( repeats-- > 0 ) {
		this.smooth( geometry );
	}
	
};

// Performs an iteration of Catmull-Clark Subdivision
THREE.SubdivisionModifier.prototype.smooth = function ( oldGeometry ) {
	
	//console.log( 'running smooth' );
	
	// New set of vertices, faces and uvs
	var newVertices = [], newFaces = [], newUVs = [];
	
	function v( x, y, z ) {
		newVertices.push( new THREE.Vertex( new THREE.Vector3( x, y, z ) ) );
	}
	
	var scope = this;

	function f4( a, b, c, d, oldFace, orders ) {
		
		// TODO move vertex selection over here!
		
		var newFace = new THREE.Face4( a, b, c, d, null, oldFace.color, oldFace.material );
		
		if (scope.useOldVertexColors) {
			
			newFace.vertexColors = []; 
			
			var color, tmpColor, order;
			for (var i=0;i<4;i++) {
				order = orders[i];
				
				color = new THREE.Color(),
				color.setRGB(0,0,0);
				
				for (var j=0, jl=0; j<order.length;j++) {
					tmpColor = oldFace.vertexColors[order[j]-1];
					color.r += tmpColor.r;
					color.g += tmpColor.g;
					color.b += tmpColor.b;
				}
				
				color.r /= order.length;
				color.g /= order.length;
				color.b /= order.length;
				
				newFace.vertexColors[i] = color;
				
			}
			
		}
		
		newFaces.push( newFace );
		
		if (!scope.supportUVs || uvForVertices.length!=0) {
			newUVs.push( [
				uvForVertices[a],
				uvForVertices[b],
				uvForVertices[c],
				uvForVertices[d]
			] );
			
		}
	}
	
	function edge_hash( a, b ) {

		return Math.min( a, b ) + "_" + Math.max( a, b );

	};
	
	function computeEdgeFaces( geometry ) {

		function addToMap( map, hash, i ) {

			if ( map[ hash ] === undefined ) {

				map[ hash ] = [];
				
			} 
			
			map[ hash ].push( i );

		};

		var i, il, v1, v2, j, k,
			face, faceIndices, faceIndex,
			edge,
			hash,
			vfMap = {};

		// construct vertex -> face map

		for( i = 0, il = geometry.faces.length; i < il; i ++ ) {

			face = geometry.faces[ i ];

			if ( face instanceof THREE.Face3 ) {

				hash = edge_hash( face.a, face.b );
				addToMap( vfMap, hash, i );

				hash = edge_hash( face.b, face.c );
				addToMap( vfMap, hash, i );

				hash = edge_hash( face.c, face.a );
				addToMap( vfMap, hash, i );

			} else if ( face instanceof THREE.Face4 ) {

				hash = edge_hash( face.a, face.b );
				addToMap( vfMap, hash, i );

				hash = edge_hash( face.b, face.c );
				addToMap( vfMap, hash, i );

				hash = edge_hash( face.c, face.d );
				addToMap( vfMap, hash, i );
				
				hash = edge_hash( face.d, face.a );
				addToMap( vfMap, hash, i );

			}

		}

		// extract faces
		
		// var edges = [];
		// 
		// var numOfEdges = 0;
		// for (i in vfMap) {
		// 	numOfEdges++;
		// 	
		// 	edge = vfMap[i];
		// 	edges.push(edge);
		// 	
		// }
		
		//console.log('vfMap', vfMap, 'geometry.edges',geometry.edges, 'numOfEdges', numOfEdges);

		return vfMap;

	};
	
	var originalPoints = oldGeometry.vertices;
	var originalFaces = oldGeometry.faces;
	
	var newPoints = originalPoints.concat(); // Vertices
		
	var facePoints = [], edgePoints = {};
	
	var sharpEdges = {}, sharpVertices = [], sharpFaces = [];
	
	var uvForVertices = [];
	
	// Step 1
	//	For each face, add a face point
	//	Set each face point to be the centroid of all original points for the respective face.
	
	var i, il, j, jl, face;
	
	// For Uvs
	var uvs = oldGeometry.faceVertexUvs[0];
	var abcd = 'abcd', vertice;
	
	for (i=0, il = uvs.length; i<il; i++ ) {
		for (j=0,jl=uvs[i].length;j<jl;j++) {
			vertice = originalFaces[i][abcd.charAt(j)];
			
			if (!uvForVertices[vertice]) {
				uvForVertices[vertice] = uvs[i][j];
			} else {
				//console.log('dup', 	uvForVertices[vertice]);
			}
			
			
		}
	}
			
	var avgUv ;
	for (i=0, il = originalFaces.length; i<il ;i++) {
		face = originalFaces[i];
		facePoints.push(face.centroid);
		newPoints.push( new THREE.Vertex(face.centroid) );
		
		
		if (!scope.supportUVs || uvForVertices.length==0) continue;
		
		// Prepare subdivided uv
		
		avgUv = new THREE.UV();
		
		if ( face instanceof THREE.Face3 ) {
			avgUv.u = uvForVertices[face.a].u + uvForVertices[face.b].u + uvForVertices[face.c].u;
			avgUv.v = uvForVertices[face.a].v + uvForVertices[face.b].v + uvForVertices[face.c].v;
			avgUv.u /= 3;
			avgUv.v /= 3;
			
		} else if ( face instanceof THREE.Face4 ) {
			avgUv.u = uvForVertices[face.a].u + uvForVertices[face.b].u + uvForVertices[face.c].u + uvForVertices[face.d].u;
			avgUv.v = uvForVertices[face.a].v + uvForVertices[face.b].v + uvForVertices[face.c].v + uvForVertices[face.d].v;
			avgUv.u /= 4;
			avgUv.v /= 4;
		}
	
		uvForVertices.push(avgUv);
	}

	// Step 2
	//	For each edge, add an edge point.
	//	Set each edge point to be the average of the two neighbouring face points and its two original endpoints.
	
	var vfMap = computeEdgeFaces ( oldGeometry );
	var edge, faceIndexA, faceIndexB, avg;
	
	//console.log('vfMap', vfMap);

	var edgeCount = 0;
	var originalVerticesLength = originalPoints.length;
	var edgeVertex, edgeVertexA, edgeVertexB;
	
	////
	
	var vertexEdgeMap = {};
	var vertexFaceMap = {};
	
	var addVertexEdgeMap = function(vertex, edge) {
		if (vertexEdgeMap[vertex]===undefined) {
			vertexEdgeMap[vertex] = [];
		}
		
		vertexEdgeMap[vertex].push(edge);
	};
	
	var addVertexFaceMap = function(vertex, face, edge) {
		if (vertexFaceMap[vertex]===undefined) {
			vertexFaceMap[vertex] = {};
		}
		
		//vertexFaceMap[vertex][face] = edge;
		vertexFaceMap[vertex][face] = null;
	};
	
	// Prepares vertexEdgeMap and vertexFaceMap
	for (i in vfMap) { // This is for every edge
		edge = vfMap[i];
		
		edgeVertex = i.split('_');
		edgeVertexA = edgeVertex[0];
		edgeVertexB = edgeVertex[1];
		
		// Maps an edgeVertex to connecting edges
		addVertexEdgeMap(edgeVertexA, [edgeVertexA, edgeVertexB] );
		addVertexEdgeMap(edgeVertexB, [edgeVertexA, edgeVertexB] );
		
		
		// faceIndexA = edge[0]; // face index a
		// faceIndexB = edge[1]; // face index b
		// 
		// // Add connecting faces for edge
		// addVertexFaceMap(edgeVertexA, faceIndexA);
		// addVertexFaceMap(edgeVertexB, faceIndexA);
		// 
		// 
		// if (faceIndexB) {
		// 	addVertexFaceMap(edgeVertexA, faceIndexB);
		// 	addVertexFaceMap(edgeVertexB, faceIndexB);
		// } else {
		// 	addVertexFaceMap(edgeVertexA, faceIndexA);
		// 	addVertexFaceMap(edgeVertexB, faceIndexA);
		// }
		
		for (j=0,jl=edge.length;j<jl;j++) {
			face = edge[j];
			
			addVertexFaceMap(edgeVertexA, face, i);
			addVertexFaceMap(edgeVertexB, face, i);
		}
		
		if (edge.length < 2) {
			// edge is "sharp";
			sharpEdges[i] = true;
			sharpVertices[edgeVertexA] = true;
			sharpVertices[edgeVertexB] = true;
			
		}
		
	}
	
	
	
	//console.log('vertexEdgeMap',vertexEdgeMap, 'vertexFaceMap', vertexFaceMap);
	
	
	for (i in vfMap) {
		edge = vfMap[i];
		
		faceIndexA = edge[0]; // face index a
		faceIndexB = edge[1]; // face index b
		
		edgeVertex = i.split('_');
		edgeVertexA = edgeVertex[0];
		edgeVertexB = edgeVertex[1];
		
		
		avg = new THREE.Vector3();
		
		//console.log(i, faceIndexB,facePoints[faceIndexB]);
		
		if (sharpEdges[i]) {
			//console.log('warning, ', i, 'edge has only 1 connecting face', edge);
			
			// For a sharp edge, average the edge end points.
			avg.addSelf(originalPoints[edgeVertexA].position);
			avg.addSelf(originalPoints[edgeVertexB].position);
			
			avg.multiplyScalar(0.5);
			
			sharpVertices[newPoints.length] = true;
			
		} else {
		
			avg.addSelf(facePoints[faceIndexA]);
			avg.addSelf(facePoints[faceIndexB]);
		
			avg.addSelf(originalPoints[edgeVertexA].position);
			avg.addSelf(originalPoints[edgeVertexB].position);
		
			avg.multiplyScalar(0.25);
		
		}
		
		edgePoints[i] = originalVerticesLength + originalFaces.length + edgeCount;
		//console.log(edgePoints[i], newPoints.length);
		
		newPoints.push( new THREE.Vertex(avg) );
	
		edgeCount ++;
		
		if (!scope.supportUVs || uvForVertices.length==0) continue;
		
		// Prepare subdivided uv
		
		avgUv = new THREE.UV();
		
		avgUv.u = uvForVertices[edgeVertexA].u + uvForVertices[edgeVertexB].u;
		avgUv.v = uvForVertices[edgeVertexA].v + uvForVertices[edgeVertexB].v;
		avgUv.u /= 2;
		avgUv.v /= 2;
	
		uvForVertices.push(avgUv);
		
	}
	
	// Step 3
	//	For each face point, add an edge for every edge of the face, 
	//	connecting the face point to each edge point for the face.
	
	
	var facePt, currentVerticeIndex;
	
	var hashAB, hashBC, hashCD, hashDA, hashCA;
	
	var abc123 = ['123', '12', '2', '23'];
	var bca123 = ['123', '23', '3', '31'];
	var cab123 = ['123', '31', '1', '12'];
	var abc1234 = ['1234', '12', '2', '23'];
	var bcd1234 = ['1234', '23', '3', '34'];
	var cda1234 = ['1234', '34', '4', '41'];
	var dab1234 = ['1234', '41', '1', '12'];
	
	
	for (i=0, il = facePoints.length; i<il ;i++) { // for every face
		facePt = facePoints[i];
		face = originalFaces[i];
		currentVerticeIndex = originalVerticesLength+ i;
		
		if ( face instanceof THREE.Face3 ) {
			
			// create 3 face4s
			
			hashAB = edge_hash( face.a, face.b );
			hashBC = edge_hash( face.b, face.c );
			hashCA = edge_hash( face.c, face.a );
			
			f4( currentVerticeIndex, edgePoints[hashAB], face.b, edgePoints[hashBC], face, abc123 );
			f4( currentVerticeIndex, edgePoints[hashBC], face.c, edgePoints[hashCA], face, bca123 );
			f4( currentVerticeIndex, edgePoints[hashCA], face.a, edgePoints[hashAB], face, cab123 );
			
		} else if ( face instanceof THREE.Face4 ) {
			// create 4 face4s
			
			hashAB = edge_hash( face.a, face.b );
			hashBC = edge_hash( face.b, face.c );
			hashCD = edge_hash( face.c, face.d );
			hashDA = edge_hash( face.d, face.a );
			
			f4( currentVerticeIndex, edgePoints[hashAB], face.b, edgePoints[hashBC], face, abc1234 );
			f4( currentVerticeIndex, edgePoints[hashBC], face.c, edgePoints[hashCD], face, bcd1234 );
			f4( currentVerticeIndex, edgePoints[hashCD], face.d, edgePoints[hashDA], face, cda1234 );
			f4( currentVerticeIndex, edgePoints[hashDA], face.a, edgePoints[hashAB], face, dab1234  );

				
		} else {
			console.log('face should be a face!', face);
		}
	}
	
	newVertices = newPoints;
	
	// console.log('original ', oldGeometry.vertices.length, oldGeometry.faces.length );
	// console.log('new points', newPoints.length, 'faces', newFaces.length );
	
	// Step 4
	
	//	For each original point P, 
	//		take the average F of all n face points for faces touching P, 
	//		and take the average R of all n edge midpoints for edges touching P, 
	//		where each edge midpoint is the average of its two endpoint vertices. 
	//	Move each original point to the point

	
	var F = new THREE.Vector3();
	var R = new THREE.Vector3();

	var n;
	for (i=0, il = originalPoints.length; i<il; i++) {
		// (F + 2R + (n-3)P) / n
		
		if (vertexEdgeMap[i]===undefined) continue;
		
		F.set(0,0,0);
		R.set(0,0,0);
		var newPos =  new THREE.Vector3(0,0,0);
		
		var f =0;
		for (j in vertexFaceMap[i]) {
			F.addSelf(facePoints[j]);
			f++;
		}
		
		var sharpEdgeCount = 0;
		
		n = vertexEdgeMap[i].length;
		
		for (j=0;j<n;j++) {
			if (
				sharpEdges[
					edge_hash(vertexEdgeMap[i][j][0],vertexEdgeMap[i][j][1])
				]) {
					sharpEdgeCount++;
				}
		}
		
		if ( sharpEdgeCount==2 ) {
			continue;
			// Do not move vertex if there's 2 connecting sharp edges.
		}

		/*
		if (sharpEdgeCount>2) {
			// TODO
		}
		*/
		
		F.divideScalar(f);
		
		
		
		for (j=0; j<n;j++) {
			edge = vertexEdgeMap[i][j];
			var midPt = originalPoints[edge[0]].position.clone().addSelf(originalPoints[edge[1]].position).divideScalar(2);
			R.addSelf(midPt);
			// R.addSelf(originalPoints[edge[0]].position);
			// R.addSelf(originalPoints[edge[1]].position);
		}
		
		R.divideScalar(n)
		
		newPos.addSelf(originalPoints[i].position);
		newPos.multiplyScalar(n - 3);
		
		newPos.addSelf(F);
		newPos.addSelf(R.multiplyScalar(2));
		newPos.divideScalar(n);
		
		newVertices[i].position = newPos;
		
		
	}
	
	var newGeometry = oldGeometry; // Let's pretend the old geometry is now new :P
	
	newGeometry.vertices = newVertices;
	newGeometry.faces = newFaces;
	newGeometry.faceVertexUvs[ 0 ] = newUVs;
	
	delete newGeometry.__tmpVertices; // makes __tmpVertices undefined :P
	
	newGeometry.computeCentroids();
	newGeometry.computeFaceNormals();
	newGeometry.computeVertexNormals();
	
};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	addStatusElement: function () {

		var e = document.createElement( "div" );

		e.style.position = "absolute";
		e.style.right = "0px";
		e.style.top = "0px";
		e.style.fontSize = "0.8em";
		e.style.textAlign = "left";
		e.style.background = "rgba(0,0,0,0.25)";
		e.style.color = "#fff";
		e.style.width = "120px";
		e.style.padding = "0.5em 0.5em 0.5em 0.5em";
		e.style.zIndex = 1000;

		e.innerHTML = "Loading ...";

		return e;

	},

	updateProgress: function ( progress ) {

		var message = "Loaded ";

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";


		} else {

			message += ( progress.loaded / 1000 ).toFixed(2) + " KB";

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlbase: function ( url ) {

		var parts = url.split( '/' );
		parts.pop();
		return parts.length < 1 ? '' : parts.join( '/' ) + '/';

	},

	initMaterials: function ( scope, materials, texture_path ) {

		scope.materials = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			scope.materials[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texture_path );

		}

	},

	hasNormals: function ( scope ) {

		var m, i, il = scope.materials.length;

		for( i = 0; i < il; i ++ ) {

			m = scope.materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texture_path ) {

		function is_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.floor( l ) == l;

		}

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function load_image( where, url ) {

			var image = new Image();

			image.onload = function () {

				if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {

					var w = nearest_pow2( this.width ),
						h = nearest_pow2( this.height );

					where.image.width = w;
					where.image.height = h;
					where.image.getContext("2d").drawImage( this, 0, 0, w, h );

				} else {

					where.image = this;

				}

				where.needsUpdate = true;

			};

			image.src = url;

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap ) {

			var texture = document.createElement( 'canvas' );

			where[ name ] = new THREE.Texture( texture );
			where[ name ].sourceFile = sourceFile;

			if( repeat ) {

				where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] != 1 ) where[ name ].wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] != 1 ) where[ name ].wrapT = THREE.RepeatWrapping;

			}

			if( offset ) {

				where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if( wrap ) {

				var wrapMap = {
				"repeat" 	: THREE.RepeatWrapping,
				"mirror"	: THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];

			}

			load_image( where[ name ], texture_path + "/" + sourceFile );

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		var material, mtype, mpars,
			color, specular, ambient,
			vertexColors;

		// defaults

		mtype = "MeshLambertMaterial";

		// vertexColors

		mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, wireframe: m.wireframe };

		// parameters from model file

		if ( m.shading ) {

			if ( m.shading == "Phong" ) mtype = "MeshPhongMaterial";
			else if ( m.shading == "Basic" ) mtype = "MeshBasicMaterial";

		}

		if ( m.blending ) {

			if ( m.blending == "Additive" ) mpars.blending = THREE.AdditiveBlending;
			else if ( m.blending == "Subtractive" ) mpars.blending = THREE.SubtractiveBlending;
			else if ( m.blending == "Multiply" ) mpars.blending = THREE.MultiplyBlending;

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors == "face" ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texture_path ) {

			create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap );

		}

		if ( m.mapLight && texture_path ) {

			create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap );

		}

		if ( m.mapNormal && texture_path ) {

			create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap );

		}

		if ( m.mapSpecular && texture_path ) {

			create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap );

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderUtils.lib[ "normal" ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			var diffuse = mpars.color;
			var specular = mpars.specular;
			var ambient = mpars.ambient;
			var shininess = mpars.shininess;

			uniforms[ "tNormal" ].texture = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ "uNormalScale" ].value = m.mapNormalFactor;

			}

			if ( mpars.map ) {

				uniforms[ "tDiffuse" ].texture = mpars.map;
				uniforms[ "enableDiffuse" ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ "tSpecular" ].texture = mpars.specularMap;
				uniforms[ "enableSpecular" ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ "tAO" ].texture = mpars.lightMap;
				uniforms[ "enableAO" ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ "uDiffuseColor" ].value.setHex( diffuse );
			uniforms[ "uSpecularColor" ].value.setHex( specular );
			uniforms[ "uAmbientColor" ].value.setHex( ambient );

			uniforms[ "uShininess" ].value = shininess;

			if ( mpars.opacity ) {

				uniforms[ "uOpacity" ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };

			material = new THREE.ShaderMaterial( parameters );

		} else {

			material = new THREE[ mtype ]( mpars );

		}

		return material;

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.BinaryLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

};

THREE.BinaryLoader.prototype = new THREE.Loader();
THREE.BinaryLoader.prototype.constructor = THREE.BinaryLoader;
THREE.BinaryLoader.prototype.supr = THREE.Loader.prototype;


// Load models generated by slim OBJ converter with BINARY option (converter_obj_three_slim.py -t binary)
//  - binary models consist of two files: JS and BIN
//  - parameters
//		- url (required)
//		- callback (required)
//		- texturePath (optional: if not specified, textures will be assumed to be in the same folder as JS model file)
//		- binaryPath (optional: if not specified, binary file will be assumed to be in the same folder as JS model file)

THREE.BinaryLoader.prototype.load = function( url, callback, texturePath, binaryPath ) {

	if ( url instanceof Object ) {

		console.warn( 'DEPRECATED: BinaryLoader( parameters ) is now BinaryLoader( url, callback, texturePath, binaryPath ).' );

		var parameters = url;

		url = parameters.model;
		callback = parameters.callback;
		texturePath = parameters.texture_path;
		binaryPath = parameters.bin_path;

	}

	texturePath = texturePath ? texturePath : this.extractUrlbase( url );
	binaryPath = binaryPath ? binaryPath : this.extractUrlbase( url );

	var callbackProgress = this.showProgress ? THREE.Loader.prototype.updateProgress : null;

	this.onLoadStart();

	// #1 load JS part via web worker

	this.loadAjaxJSON( this, url, callback, texturePath, binaryPath, callbackProgress );

};

THREE.BinaryLoader.prototype.loadAjaxJSON = function( context, url, callback, texturePath, binaryPath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	xhr.onreadystatechange = function() {

		if ( xhr.readyState == 4 ) {

			if ( xhr.status == 200 || xhr.status == 0 ) {

				try {

					var json = JSON.parse( xhr.responseText );

					if ( json.metadata === undefined || json.metadata.formatVersion === undefined || json.metadata.formatVersion !== 3 ) {

						console.error( 'Deprecated file format.' );
						return;

					}

					// #2 load BIN part via Ajax

					context.loadAjaxBuffers( json, callback, binaryPath, texturePath, callbackProgress );

				} catch ( error ) {

					console.error( error );
					console.warn( "DEPRECATED: [" + url + "] seems to be using old model format" );

				}

			} else {

				console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.overrideMimeType( "text/plain; charset=x-user-defined" );
	xhr.setRequestHeader( "Content-Type", "text/plain" );
	xhr.send( null );

};

THREE.BinaryLoader.prototype.loadAjaxBuffers = function( json, callback, binaryPath, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest(),
		url = binaryPath + "/" + json.buffers;

	var length = 0;

	xhr.onreadystatechange = function() {

		if ( xhr.readyState == 4 ) {

			if ( xhr.status == 200 || xhr.status == 0 ) {

				THREE.BinaryLoader.prototype.createBinModel( xhr.response, callback, texturePath, json.materials );

			} else {

				console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState == 3 ) {

			if ( callbackProgress ) {

				if ( length == 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState == 2 ) {

			length = xhr.getResponseHeader( "Content-Length" );

		}

	};

	xhr.open( "GET", url, true );
	xhr.responseType = "arraybuffer";
	xhr.send( null );

};

// Binary AJAX parser

THREE.BinaryLoader.prototype.createBinModel = function ( data, callback, texturePath, materials ) {

	var Model = function ( texturePath ) {

		var scope = this,
			currentOffset = 0,
			md,
			normals = [],
			uvs = [],
			start_tri_flat, start_tri_smooth, start_tri_flat_uv, start_tri_smooth_uv,
			start_quad_flat, start_quad_smooth, start_quad_flat_uv, start_quad_smooth_uv,
			tri_size, quad_size,
			len_tri_flat, len_tri_smooth, len_tri_flat_uv, len_tri_smooth_uv,
			len_quad_flat, len_quad_smooth, len_quad_flat_uv, len_quad_smooth_uv;


		THREE.Geometry.call( this );

		THREE.Loader.prototype.initMaterials( scope, materials, texturePath );

		md = parseMetaData( data, currentOffset );

		if ( md.signature !== "Three.js 003" ) {

			console.warn( "DEPRECATED: binary model seems to be using old format" );

		}

		currentOffset += md.header_bytes;
/*
		md.vertex_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
		md.material_index_bytes = Uint16Array.BYTES_PER_ELEMENT;
		md.normal_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
		md.uv_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
*/
		// buffers sizes

		tri_size =  md.vertex_index_bytes * 3 + md.material_index_bytes;
		quad_size = md.vertex_index_bytes * 4 + md.material_index_bytes;

		len_tri_flat      = md.ntri_flat      * ( tri_size );
		len_tri_smooth    = md.ntri_smooth    * ( tri_size + md.normal_index_bytes * 3 );
		len_tri_flat_uv   = md.ntri_flat_uv   * ( tri_size + md.uv_index_bytes * 3 );
		len_tri_smooth_uv = md.ntri_smooth_uv * ( tri_size + md.normal_index_bytes * 3 + md.uv_index_bytes * 3 );

		len_quad_flat      = md.nquad_flat      * ( quad_size );
		len_quad_smooth    = md.nquad_smooth    * ( quad_size + md.normal_index_bytes * 4 );
		len_quad_flat_uv   = md.nquad_flat_uv   * ( quad_size + md.uv_index_bytes * 4 );
		len_quad_smooth_uv = md.nquad_smooth_uv * ( quad_size + md.normal_index_bytes * 4 + md.uv_index_bytes * 4 );

		// read buffers

		currentOffset += init_vertices( currentOffset );

		currentOffset += init_normals( currentOffset );
		currentOffset += handlePadding( md.nnormals * 3 );

		currentOffset += init_uvs( currentOffset );

		start_tri_flat 		= currentOffset;
		start_tri_smooth    = start_tri_flat    + len_tri_flat    + handlePadding( md.ntri_flat * 2 );
		start_tri_flat_uv   = start_tri_smooth  + len_tri_smooth  + handlePadding( md.ntri_smooth * 2 );
		start_tri_smooth_uv = start_tri_flat_uv + len_tri_flat_uv + handlePadding( md.ntri_flat_uv * 2 );

		start_quad_flat     = start_tri_smooth_uv + len_tri_smooth_uv  + handlePadding( md.ntri_smooth_uv * 2 );
		start_quad_smooth   = start_quad_flat     + len_quad_flat	   + handlePadding( md.nquad_flat * 2 );
		start_quad_flat_uv  = start_quad_smooth   + len_quad_smooth    + handlePadding( md.nquad_smooth * 2 );
		start_quad_smooth_uv= start_quad_flat_uv  + len_quad_flat_uv   + handlePadding( md.nquad_flat_uv * 2 );

		// have to first process faces with uvs
		// so that face and uv indices match

		init_triangles_flat_uv( start_tri_flat_uv );
		init_triangles_smooth_uv( start_tri_smooth_uv );

		init_quads_flat_uv( start_quad_flat_uv );
		init_quads_smooth_uv( start_quad_smooth_uv );

		// now we can process untextured faces

		init_triangles_flat( start_tri_flat );
		init_triangles_smooth( start_tri_smooth );

		init_quads_flat( start_quad_flat );
		init_quads_smooth( start_quad_smooth );

		this.computeCentroids();
		this.computeFaceNormals();

		if ( THREE.Loader.prototype.hasNormals( this ) ) this.computeTangents();

		function handlePadding( n ) {

			return ( n % 4 ) ? ( 4 - n % 4 ) : 0;

		};

		function parseMetaData( data, offset ) {

			var metaData = {

				'signature'               :parseString( data, offset,  12 ),
				'header_bytes'            :parseUChar8( data, offset + 12 ),

				'vertex_coordinate_bytes' :parseUChar8( data, offset + 13 ),
				'normal_coordinate_bytes' :parseUChar8( data, offset + 14 ),
				'uv_coordinate_bytes'     :parseUChar8( data, offset + 15 ),

				'vertex_index_bytes'      :parseUChar8( data, offset + 16 ),
				'normal_index_bytes'      :parseUChar8( data, offset + 17 ),
				'uv_index_bytes'          :parseUChar8( data, offset + 18 ),
				'material_index_bytes'    :parseUChar8( data, offset + 19 ),

				'nvertices'    :parseUInt32( data, offset + 20 ),
				'nnormals'     :parseUInt32( data, offset + 20 + 4*1 ),
				'nuvs'         :parseUInt32( data, offset + 20 + 4*2 ),

				'ntri_flat'      :parseUInt32( data, offset + 20 + 4*3 ),
				'ntri_smooth'    :parseUInt32( data, offset + 20 + 4*4 ),
				'ntri_flat_uv'   :parseUInt32( data, offset + 20 + 4*5 ),
				'ntri_smooth_uv' :parseUInt32( data, offset + 20 + 4*6 ),

				'nquad_flat'      :parseUInt32( data, offset + 20 + 4*7 ),
				'nquad_smooth'    :parseUInt32( data, offset + 20 + 4*8 ),
				'nquad_flat_uv'   :parseUInt32( data, offset + 20 + 4*9 ),
				'nquad_smooth_uv' :parseUInt32( data, offset + 20 + 4*10 )

			};
/*
			console.log( "signature: " + metaData.signature );

			console.log( "header_bytes: " + metaData.header_bytes );
			console.log( "vertex_coordinate_bytes: " + metaData.vertex_coordinate_bytes );
			console.log( "normal_coordinate_bytes: " + metaData.normal_coordinate_bytes );
			console.log( "uv_coordinate_bytes: " + metaData.uv_coordinate_bytes );

			console.log( "vertex_index_bytes: " + metaData.vertex_index_bytes );
			console.log( "normal_index_bytes: " + metaData.normal_index_bytes );
			console.log( "uv_index_bytes: " + metaData.uv_index_bytes );
			console.log( "material_index_bytes: " + metaData.material_index_bytes );

			console.log( "nvertices: " + metaData.nvertices );
			console.log( "nnormals: " + metaData.nnormals );
			console.log( "nuvs: " + metaData.nuvs );

			console.log( "ntri_flat: " + metaData.ntri_flat );
			console.log( "ntri_smooth: " + metaData.ntri_smooth );
			console.log( "ntri_flat_uv: " + metaData.ntri_flat_uv );
			console.log( "ntri_smooth_uv: " + metaData.ntri_smooth_uv );

			console.log( "nquad_flat: " + metaData.nquad_flat );
			console.log( "nquad_smooth: " + metaData.nquad_smooth );
			console.log( "nquad_flat_uv: " + metaData.nquad_flat_uv );
			console.log( "nquad_smooth_uv: " + metaData.nquad_smooth_uv );

			var total = metaData.header_bytes
					  + metaData.nvertices * metaData.vertex_coordinate_bytes * 3
					  + metaData.nnormals * metaData.normal_coordinate_bytes * 3
					  + metaData.nuvs * metaData.uv_coordinate_bytes * 2
					  + metaData.ntri_flat * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes )
					  + metaData.ntri_smooth * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 )
					  + metaData.ntri_flat_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.uv_index_bytes*3 )
					  + metaData.ntri_smooth_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 + metaData.uv_index_bytes*3 )
					  + metaData.nquad_flat * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes )
					  + metaData.nquad_smooth * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 )
					  + metaData.nquad_flat_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.uv_index_bytes*4 )
					  + metaData.nquad_smooth_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 + metaData.uv_index_bytes*4 );
			console.log( "total bytes: " + total );
*/

			return metaData;

		};

		function parseString( data, offset, length ) {

			var charArray = new Uint8Array( data, offset, length );

			var text = "";

			for ( var i = 0; i < length; i ++ ) {

				text += String.fromCharCode( charArray[ offset + i ] );

			}

			return text;

		};

		function parseUChar8( data, offset ) {

			var charArray = new Uint8Array( data, offset, 1 );

			return charArray[ 0 ];

		};

		function parseUInt32( data, offset ) {

			var intArray = new Uint32Array( data, offset, 1 );

			return intArray[ 0 ];

		};

		function init_vertices( start ) {

			var nElements = md.nvertices;

			var coordArray = new Float32Array( data, start, nElements * 3 );

			var i, x, y, z;

			for( i = 0; i < nElements; i ++ ) {

				x = coordArray[ i * 3 ];
				y = coordArray[ i * 3 + 1 ];
				z = coordArray[ i * 3 + 2 ];

				vertex( scope, x, y, z );

			}

			return nElements * 3 * Float32Array.BYTES_PER_ELEMENT;

		};

		function init_normals( start ) {

			var nElements = md.nnormals;

			if ( nElements ) {

				var normalArray = new Int8Array( data, start, nElements * 3 );

				var i, x, y, z;

				for( i = 0; i < nElements; i ++ ) {

					x = normalArray[ i * 3 ];
					y = normalArray[ i * 3 + 1 ];
					z = normalArray[ i * 3 + 2 ];

					normals.push( x/127, y/127, z/127 );

				}

			}

			return nElements * 3 * Int8Array.BYTES_PER_ELEMENT;

		};

		function init_uvs( start ) {

			var nElements = md.nuvs;

			if ( nElements ) {

				var uvArray = new Float32Array( data, start, nElements * 2 );

				var i, u, v;

				for( i = 0; i < nElements; i ++ ) {

					u = uvArray[ i * 2 ];
					v = uvArray[ i * 2 + 1 ];

					uvs.push( u, v );

				}

			}

			return nElements * 2 * Float32Array.BYTES_PER_ELEMENT;

		};

		function init_uvs3( nElements, offset ) {

			var i, uva, uvb, uvc, u1, u2, u3, v1, v2, v3;

			var uvIndexBuffer = new Uint32Array( data, offset, 3 * nElements );

			for( i = 0; i < nElements; i ++ ) {

				uva = uvIndexBuffer[ i * 3 ];
				uvb = uvIndexBuffer[ i * 3 + 1 ];
				uvc = uvIndexBuffer[ i * 3 + 2 ];

				u1 = uvs[ uva*2 ];
				v1 = uvs[ uva*2 + 1 ];

				u2 = uvs[ uvb*2 ];
				v2 = uvs[ uvb*2 + 1 ];

				u3 = uvs[ uvc*2 ];
				v3 = uvs[ uvc*2 + 1 ];

				uv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );

			}

		};

		function init_uvs4( nElements, offset ) {

			var i, uva, uvb, uvc, uvd, u1, u2, u3, u4, v1, v2, v3, v4;

			var uvIndexBuffer = new Uint32Array( data, offset, 4 * nElements );

			for( i = 0; i < nElements; i ++ ) {

				uva = uvIndexBuffer[ i * 4 ];
				uvb = uvIndexBuffer[ i * 4 + 1 ];
				uvc = uvIndexBuffer[ i * 4 + 2 ];
				uvd = uvIndexBuffer[ i * 4 + 3 ];

				u1 = uvs[ uva*2 ];
				v1 = uvs[ uva*2 + 1 ];

				u2 = uvs[ uvb*2 ];
				v2 = uvs[ uvb*2 + 1 ];

				u3 = uvs[ uvc*2 ];
				v3 = uvs[ uvc*2 + 1 ];

				u4 = uvs[ uvd*2 ];
				v4 = uvs[ uvd*2 + 1 ];

				uv4( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3, u4, v4 );

			}

		};

		function init_faces3_flat( nElements, offsetVertices, offsetMaterials ) {

			var i, a, b, c, m;

			var vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );
			var materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );

			for( i = 0; i < nElements; i ++ ) {

				a = vertexIndexBuffer[ i * 3 ];
				b = vertexIndexBuffer[ i * 3 + 1 ];
				c = vertexIndexBuffer[ i * 3 + 2 ];

				m = materialIndexBuffer[ i ];

				f3( scope, a, b, c, m );

			}

		};

		function init_faces4_flat( nElements, offsetVertices, offsetMaterials ) {

			var i, a, b, c, d, m;

			var vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );
			var materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );

			for( i = 0; i < nElements; i ++ ) {

				a = vertexIndexBuffer[ i * 4 ];
				b = vertexIndexBuffer[ i * 4 + 1 ];
				c = vertexIndexBuffer[ i * 4 + 2 ];
				d = vertexIndexBuffer[ i * 4 + 3 ];

				m = materialIndexBuffer[ i ];

				f4( scope, a, b, c, d, m );

			}

		};

		function init_faces3_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {

			var i, a, b, c, m;
			var na, nb, nc;

			var vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );
			var normalIndexBuffer = new Uint32Array( data, offsetNormals, 3 * nElements );
			var materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );

			for( i = 0; i < nElements; i ++ ) {

				a = vertexIndexBuffer[ i * 3 ];
				b = vertexIndexBuffer[ i * 3 + 1 ];
				c = vertexIndexBuffer[ i * 3 + 2 ];

				na = normalIndexBuffer[ i * 3 ];
				nb = normalIndexBuffer[ i * 3 + 1 ];
				nc = normalIndexBuffer[ i * 3 + 2 ];

				m = materialIndexBuffer[ i ];

				f3n( scope, normals, a, b, c, m, na, nb, nc );

			}

		};

		function init_faces4_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {

			var i, a, b, c, d, m;
			var na, nb, nc, nd;

			var vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );
			var normalIndexBuffer = new Uint32Array( data, offsetNormals, 4 * nElements );
			var materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );

			for( i = 0; i < nElements; i ++ ) {

				a = vertexIndexBuffer[ i * 4 ];
				b = vertexIndexBuffer[ i * 4 + 1 ];
				c = vertexIndexBuffer[ i * 4 + 2 ];
				d = vertexIndexBuffer[ i * 4 + 3 ];

				na = normalIndexBuffer[ i * 4 ];
				nb = normalIndexBuffer[ i * 4 + 1 ];
				nc = normalIndexBuffer[ i * 4 + 2 ];
				nd = normalIndexBuffer[ i * 4 + 3 ];

				m = materialIndexBuffer[ i ];

				f4n( scope, normals, a, b, c, d, m, na, nb, nc, nd );

			}

		};

		function init_triangles_flat( start ) {

			var nElements = md.ntri_flat;

			if ( nElements ) {

				var offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				init_faces3_flat( nElements, start, offsetMaterials );

			}

		};

		function init_triangles_flat_uv( start ) {

			var nElements = md.ntri_flat_uv;

			if ( nElements ) {

				var offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

				init_faces3_flat( nElements, start, offsetMaterials );
				init_uvs3( nElements, offsetUvs );

			}

		};

		function init_triangles_smooth( start ) {

			var nElements = md.ntri_smooth;

			if ( nElements ) {

				var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				var offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

				init_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );

			}

		};

		function init_triangles_smooth_uv( start ) {

			var nElements = md.ntri_smooth_uv;

			if ( nElements ) {

				var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				var offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

				init_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );
				init_uvs3( nElements, offsetUvs );

			}

		};

		function init_quads_flat( start ) {

			var nElements = md.nquad_flat;

			if ( nElements ) {

				var offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				init_faces4_flat( nElements, start, offsetMaterials );

			}

		};

		function init_quads_flat_uv( start ) {

			var nElements = md.nquad_flat_uv;

			if ( nElements ) {

				var offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

				init_faces4_flat( nElements, start, offsetMaterials );
				init_uvs4( nElements, offsetUvs );

			}

		};

		function init_quads_smooth( start ) {

			var nElements = md.nquad_smooth;

			if ( nElements ) {

				var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				var offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

				init_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );

			}

		};

		function init_quads_smooth_uv( start ) {

			var nElements = md.nquad_smooth_uv;

			if ( nElements ) {

				var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				var offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

				init_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );
				init_uvs4( nElements, offsetUvs );

			}

		};

	};

	function vertex ( scope, x, y, z ) {

		scope.vertices.push( new THREE.Vertex( new THREE.Vector3( x, y, z ) ) );

	};

	function f3 ( scope, a, b, c, mi ) {

		scope.faces.push( new THREE.Face3( a, b, c, null, null, mi ) );

	};

	function f4 ( scope, a, b, c, d, mi ) {

		scope.faces.push( new THREE.Face4( a, b, c, d, null, null, mi ) );

	};

	function f3n ( scope, normals, a, b, c, mi, na, nb, nc ) {

		var nax = normals[ na*3     ],
			nay = normals[ na*3 + 1 ],
			naz = normals[ na*3 + 2 ],

			nbx = normals[ nb*3     ],
			nby = normals[ nb*3 + 1 ],
			nbz = normals[ nb*3 + 2 ],

			ncx = normals[ nc*3     ],
			ncy = normals[ nc*3 + 1 ],
			ncz = normals[ nc*3 + 2 ];

		scope.faces.push( new THREE.Face3( a, b, c,
						  [new THREE.Vector3( nax, nay, naz ),
						   new THREE.Vector3( nbx, nby, nbz ),
						   new THREE.Vector3( ncx, ncy, ncz )],
						  null,
						  mi ) );

	};

	function f4n ( scope, normals, a, b, c, d, mi, na, nb, nc, nd ) {

		var nax = normals[ na*3     ],
			nay = normals[ na*3 + 1 ],
			naz = normals[ na*3 + 2 ],

			nbx = normals[ nb*3     ],
			nby = normals[ nb*3 + 1 ],
			nbz = normals[ nb*3 + 2 ],

			ncx = normals[ nc*3     ],
			ncy = normals[ nc*3 + 1 ],
			ncz = normals[ nc*3 + 2 ],

			ndx = normals[ nd*3     ],
			ndy = normals[ nd*3 + 1 ],
			ndz = normals[ nd*3 + 2 ];

		scope.faces.push( new THREE.Face4( a, b, c, d,
						  [new THREE.Vector3( nax, nay, naz ),
						   new THREE.Vector3( nbx, nby, nbz ),
						   new THREE.Vector3( ncx, ncy, ncz ),
						   new THREE.Vector3( ndx, ndy, ndz )],
						  null,
						  mi ) );

	};

	function uv3 ( where, u1, v1, u2, v2, u3, v3 ) {

		var uv = [];
		uv.push( new THREE.UV( u1, v1 ) );
		uv.push( new THREE.UV( u2, v2 ) );
		uv.push( new THREE.UV( u3, v3 ) );
		where.push( uv );

	};

	function uv4 ( where, u1, v1, u2, v2, u3, v3, u4, v4 ) {

		var uv = [];
		uv.push( new THREE.UV( u1, v1 ) );
		uv.push( new THREE.UV( u2, v2 ) );
		uv.push( new THREE.UV( u3, v3 ) );
		uv.push( new THREE.UV( u4, v4 ) );
		where.push( uv );

	};

	Model.prototype = new THREE.Geometry();
	Model.prototype.constructor = Model;

	callback( new Model( texturePath ) );

};
/**
 * @author Tim Knip / http://www.floorplanner.com/ / tim at floorplanner.com
 */

THREE.ColladaLoader = function () {

	var COLLADA = null;
	var scene = null;
	var daeScene;

	var readyCallbackFunc = null;

 	var sources = {};
	var images = {};
	var animations = {};
	var controllers = {};
	var geometries = {};
	var materials = {};
	var effects = {};

	var visualScenes;
	var baseUrl;
	var morphs;
	var skins;

	var flip_uv = true;
	var preferredShading = THREE.SmoothShading;

	function load ( url, readyCallback ) {

		if ( document.implementation && document.implementation.createDocument ) {

			var namespaceURL = "http://www.collada.org/2005/11/COLLADASchema";
			var rootTagName = "COLLADA";

			var xmldoc = document.implementation.createDocument( namespaceURL, rootTagName, null );
			var me = this;

			// force reloading
			// (should be configurable? sometimes caching is desirable)

			url += "?rnd=" + Math.random();

			var req = new XMLHttpRequest();

			if( req.overrideMimeType ) {

				// need this? yes... if extension is other then *.xml :-S

				req.overrideMimeType( "text/xml" );

			}

			req.onreadystatechange = function() {

				if( req.readyState == 4 ) {

					if( req.status == 0 || req.status == 200 ) {

						readyCallbackFunc = readyCallback;
						parse( req.responseXML, undefined, url );

					}

				}

			}

			req.open( "GET", url, true );
			req.send( null );

		} else {

			alert( "Don't know how to parse XML!" );

		}

	};

	function parse ( doc, callBack, url ) {

		COLLADA = doc;
		callBack = callBack || readyCallbackFunc;

		if ( url !== undefined ) {

			var parts = url.split( '/' );
			parts.pop();
			baseUrl = parts.length < 1 ? '' : parts.join( '/' ) + '/';

		}

		images = parseLib( "//dae:library_images/dae:image", _Image, "image" );
		materials = parseLib( "//dae:library_materials/dae:material", Material, "material") ;
		effects = parseLib( "//dae:library_effects/dae:effect", Effect, "effect" );
		geometries = parseLib( "//dae:library_geometries/dae:geometry", Geometry, "geometry" );
		controllers = parseLib( "//dae:library_controllers/dae:controller", Controller, "controller" );
		animations = parseLib( "//dae:library_animations/dae:animation", Animation, "animation" );
		visualScenes = parseLib( ".//dae:library_visual_scenes/dae:visual_scene", VisualScene, "visual_scene" );

		morphs = [];
		skins = [];

		daeScene = parseScene();
		scene = new THREE.Object3D();

		for ( var i = 0; i < daeScene.nodes.length; i ++ ) {

			scene.add( createSceneGraph( daeScene.nodes[ i ] ) );

		}

		createAnimations();

		var result = {

			scene: scene,
			morphs: morphs,
			skins: skins,
			dae: {
				images: images,
				materials: materials,
				effects: effects,
				geometries: geometries,
				controllers: controllers,
				animations: animations,
				visualScenes: visualScenes,
				scene: daeScene
			}

		};

		if ( callBack ) {

			callBack( result );

		}

		return result;

	};

	function setPreferredShading ( shading ) {

		preferredShading = shading;

	};

	function parseLib ( q, classSpec, prefix ) {

		var elements = COLLADA.evaluate(q,
										COLLADA,
										_nsResolver,
										XPathResult.ORDERED_NODE_ITERATOR_TYPE,
										null) ;

		var lib = {};
		var element = elements.iterateNext();
		var i = 0;

		while ( element ) {

			var daeElement = ( new classSpec() ).parse( element );
			if ( daeElement.id.length == 0 ) daeElement.id = prefix + ( i++ );
			lib[ daeElement.id ] = daeElement;
			element = elements.iterateNext();

		}

		return lib;

	};

	function parseScene () {

		var sceneElement = COLLADA.evaluate( ".//dae:scene/dae:instance_visual_scene",
			COLLADA,
			_nsResolver,
			XPathResult.ORDERED_NODE_ITERATOR_TYPE,
			null ).iterateNext();

		if ( sceneElement ) {

			var url = sceneElement.getAttribute( 'url' ).replace( /^#/, '' );
			return visualScenes[ url ];

		} else {

			return null;

		}

	};

	function createAnimations () {

		calcAnimationBounds();

		for ( var animation_id in animations ) {

			createAnimation( animations[ animation_id ] );

		}

	};

	function createAnimation ( animation ) {

	};

	function calcAnimationBounds () {

		var start = 1000000;
		var end = -start;
		var frames = 0;

		for ( var id in animations ) {

			var animation = animations[ id ];

			for ( var i = 0; i < animation.sampler.length; i ++ ) {

				var sampler = animation.sampler[ i ];
				sampler.create();

				start = Math.min( start, sampler.startTime );
				end = Math.max( end, sampler.endTime );
				frames = Math.max( frames, sampler.input.length );

			}

		}

		return { start:start, end:end, frames:frames };

	};

	function createMorph ( geometry, ctrl ) {

		var morphCtrl = ctrl instanceof InstanceController ? controllers[ ctrl.url ] : ctrl;

		if ( !morphCtrl || !morphCtrl.morph ) {

			console.log("could not find morph controller!");
			return;

		}

		var morph = morphCtrl.morph;

		for ( var i = 0; i < morph.targets.length; i ++ ) {

			var target_id = morph.targets[ i ];
			var daeGeometry = geometries[ target_id ];

			if ( !daeGeometry.mesh ||
				 !daeGeometry.mesh.primitives ||
				 !daeGeometry.mesh.primitives.length ) {
				 continue;
			}

			var target = daeGeometry.mesh.primitives[ 0 ].geometry;

			if ( target.vertices.length === geometry.vertices.length ) {

				geometry.morphTargets.push( { name: "target_1", vertices: target.vertices } );

			}

		}

		geometry.morphTargets.push( { name: "target_Z", vertices: geometry.vertices } );

	};

	function createSkin ( geometry, ctrl, applyBindShape ) {

		var skinCtrl = controllers[ ctrl.url ];

		if ( !skinCtrl || !skinCtrl.skin ) {

			console.log( "could not find skin controller!" );
			return;

		}

		if ( !ctrl.skeleton || !ctrl.skeleton.length ) {

			console.log( "could not find the skeleton for the skin!" );
			return;

		}

		var skin = skinCtrl.skin;
		var skeleton = daeScene.getChildById( ctrl.skeleton[ 0 ] );
		var hierarchy = [];

		applyBindShape = applyBindShape !== undefined ? applyBindShape : true;

		var bones = [];
		geometry.skinWeights = [];
		geometry.skinIndices = [];

		//createBones( geometry.bones, skin, hierarchy, skeleton, null, -1 );
		//createWeights( skin, geometry.bones, geometry.skinIndices, geometry.skinWeights );

		/*
		geometry.animation = {
			name: 'take_001',
			fps: 30,
			length: 2,
			JIT: true,
			hierarchy: hierarchy
		};
		*/

		if ( applyBindShape ) {

			for ( var i = 0; i < geometry.vertices.length; i ++ ) {

				skin.bindShapeMatrix.multiplyVector3( geometry.vertices[ i ].position );

			}

		}

	};

	function setupSkeleton ( node, bones, frame, parent ) {

		node.world = node.world || new THREE.Matrix4();
		node.world.copy( node.matrix );

		if ( node.channels && node.channels.length ) {

			var channel = node.channels[ 0 ];
			var m = channel.sampler.output[ frame ];

			if ( m instanceof THREE.Matrix4 ) {

				node.world.copy( m );

			}

		}

		if ( parent ) {

			node.world.multiply( parent, node.world );

		}

		bones.push( node );

		for ( var i = 0; i < node.nodes.length; i ++ ) {

			setupSkeleton( node.nodes[ i ], bones, frame, node.world );

		}

	};

	function setupSkinningMatrices ( bones, skin ) {

		// FIXME: this is dumb...

		for ( var i = 0; i < bones.length; i ++ ) {

			var bone = bones[ i ];
			var found = -1;

			if ( bone.type != 'JOINT' ) continue;

			for ( var j = 0; j < skin.joints.length; j ++ ) {

				if ( bone.sid == skin.joints[ j ] ) {

					found = j;
					break;

				}

			}

			if ( found >= 0 ) {

				var inv = skin.invBindMatrices[ found ];

				bone.invBindMatrix = inv;
				bone.skinningMatrix = new THREE.Matrix4();
				bone.skinningMatrix.multiply(bone.world, inv); // (IBMi * JMi)

				bone.weights = [];

				for ( var j = 0; j < skin.weights.length; j ++ ) {

					for (var k = 0; k < skin.weights[ j ].length; k ++) {

						var w = skin.weights[ j ][ k ];

						if ( w.joint == found ) {

							bone.weights.push( w );

						}

					}

				}

			} else {

				throw 'ColladaLoader: Could not find joint \'' + bone.sid + '\'.';

			}

		}

	};

	function applySkin ( geometry, instanceCtrl, frame ) {

		var skinController = controllers[ instanceCtrl.url ];

		frame = frame !== undefined ? frame : 40;

		if ( !skinController || !skinController.skin ) {

			console.log( 'ColladaLoader: Could not find skin controller.' );
			return;

		}

		if ( !instanceCtrl.skeleton || !instanceCtrl.skeleton.length ) {

			console.log( 'ColladaLoader: Could not find the skeleton for the skin. ' );
			return;

		}

		var animationBounds = calcAnimationBounds();
		var skeleton = daeScene.getChildById( instanceCtrl.skeleton[0], true ) ||
					   daeScene.getChildBySid( instanceCtrl.skeleton[0], true );

		var i, j, w, vidx, weight;
		var v = new THREE.Vector3(), o, s;

		// move vertices to bind shape

		for ( i = 0; i < geometry.vertices.length; i ++ ) {

			skinController.skin.bindShapeMatrix.multiplyVector3( geometry.vertices[i].position );

		}

		// process animation, or simply pose the rig if no animation

		for ( frame = 0; frame < animationBounds.frames; frame ++ ) {

			var bones = [];
			var skinned = [];

			// zero skinned vertices

			for ( i = 0; i < geometry.vertices.length; i++ ) {

				skinned.push( new THREE.Vertex( new THREE.Vector3() ) );

			}

			// process the frame and setup the rig with a fresh
			// transform, possibly from the bone's animation channel(s)

			setupSkeleton( skeleton, bones, frame );
			setupSkinningMatrices( bones, skinController.skin );

			// skin 'm

			for ( i = 0; i < bones.length; i ++ ) {

				if ( bones[ i ].type != 'JOINT' ) continue;

				for ( j = 0; j < bones[ i ].weights.length; j ++ ) {

					w = bones[ i ].weights[ j ];
					vidx = w.index;
					weight = w.weight;

					o = geometry.vertices[vidx];
					s = skinned[vidx];

					v.x = o.position.x;
					v.y = o.position.y;
					v.z = o.position.z;

					bones[i].skinningMatrix.multiplyVector3(v);

					s.position.x += (v.x * weight);
					s.position.y += (v.y * weight);
					s.position.z += (v.z * weight);

				}

			}

			geometry.morphTargets.push( { name: "target_" + frame, vertices: skinned } );

		}

	};

	function createSceneGraph ( node, parent ) {

		var obj = new THREE.Object3D();
		var skinned = false;
		var skinController;
		var morphController;
		var i, j;

		// FIXME: controllers

		for ( i = 0; i < node.controllers.length; i ++ ) {

			var controller = controllers[ node.controllers[ i ].url ];

			switch ( controller.type ) {

				case 'skin':

					if ( geometries[ controller.skin.source ] ) {

						var inst_geom = new InstanceGeometry();

						inst_geom.url = controller.skin.source;
						inst_geom.instance_material = node.controllers[ i ].instance_material;

						node.geometries.push( inst_geom );
						skinned = true;
						skinController = node.controllers[ i ];

					} else if ( controllers[ controller.skin.source ] ) {

						// urgh: controller can be chained
						// handle the most basic case...

						var second = controllers[ controller.skin.source ];
						morphController = second;
					//	skinController = node.controllers[i];

						if ( second.morph && geometries[ second.morph.source ] ) {

							var inst_geom = new InstanceGeometry();

							inst_geom.url = second.morph.source;
							inst_geom.instance_material = node.controllers[ i ].instance_material;

							node.geometries.push( inst_geom );

						}

					}

					break;

				case 'morph':

					if ( geometries[ controller.morph.source ] ) {

						var inst_geom = new InstanceGeometry();

						inst_geom.url = controller.morph.source;
						inst_geom.instance_material = node.controllers[ i ].instance_material;

						node.geometries.push( inst_geom );
						morphController = node.controllers[ i ];

					}

					console.log( 'ColladaLoader: Morph-controller partially supported.' );

				default:
					break;

			}

		}

		// FIXME: multi-material mesh?
		// geometries

		for ( i = 0; i < node.geometries.length; i ++ ) {

			var instance_geometry = node.geometries[i];
			var instance_materials = instance_geometry.instance_material;
			var geometry = geometries[instance_geometry.url];
			var used_materials = {};
			var num_materials = 0;
			var first_material;

			if ( geometry ) {

				if ( !geometry.mesh || !geometry.mesh.primitives )
					continue;

				if ( obj.name.length == 0 ) {

					obj.name = geometry.id;

				}

				// collect used fx for this geometry-instance

				if ( instance_materials ) {

					for ( j = 0; j < instance_materials.length; j ++ ) {

						var inst_material = instance_materials[j];
						var effect_id = materials[inst_material.target].instance_effect.url;
						var shader = effects[effect_id].shader;

						shader.material.opacity = !shader.material.opacity ? 1 : shader.material.opacity;
						used_materials[inst_material.symbol] = shader.material;
						first_material = shader.material;
						num_materials ++;

					}

				}

				var mesh;
				var material = first_material || new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.FlatShading } );
				var geom = geometry.mesh.geometry3js;

				if ( num_materials > 1 ) {

					material = new THREE.MeshFaceMaterial();

					for ( j = 0; j < geom.faces.length; j ++ ) {

						var face = geom.faces[ j ];
						face.materials = [ used_materials[ face.daeMaterial ] ];

					}

				}

				if ( skinController !== undefined) {

					applySkin( geom, skinController );

					material.morphTargets = true;

					mesh = new THREE.SkinnedMesh( geom, material );
					mesh.skeleton = skinController.skeleton;
					mesh.skinController = controllers[ skinController.url ];
					mesh.skinInstanceController = skinController;
					mesh.name = 'skin_' + skins.length;

					skins.push( mesh );

				} else if ( morphController !== undefined ) {

					createMorph( geom, morphController );

					material.morphTargets = true;

					mesh = new THREE.Mesh( geom, material );
					mesh.name = 'morph_' + morphs.length;

					morphs.push( mesh );

				} else {

					mesh = new THREE.Mesh( geom, material );
					// mesh.geom.name = geometry.id;

				}

				node.geometries.length > 1 ? obj.add( mesh ) : obj = mesh;

			}

		}

		obj.name = node.id || "";
		node.matrix.decompose( obj.position, obj.rotation, obj.scale );

		for ( i = 0; i < node.nodes.length; i ++ ) {

			obj.add( createSceneGraph( node.nodes[i], node ) );

		}

		return obj;

	};

	function getJointId( skin, id ) {

		for ( var i = 0; i < skin.joints.length; i ++ ) {

			if ( skin.joints[ i ] == id ) {

				return i;

			}

		}

	};

	function getLibraryNode( id ) {

		return COLLADA.evaluate(".//dae:library_nodes//dae:node[@id='"+id+"']",
								COLLADA,
								_nsResolver,
								XPathResult.ORDERED_NODE_ITERATOR_TYPE,
								null).iterateNext();

	};

	function getChannelsForNode (node ) {

		var channels = [];
		var startTime = 1000000;
		var endTime = -1000000;

		for ( var id in animations ) {

			var animation = animations[id];

			for ( var i = 0; i < animation.channel.length; i ++ ) {

				var channel = animation.channel[i];
				var sampler = animation.sampler[i];
				var id = channel.target.split('/')[0];

				if ( id == node.id ) {

					sampler.create();
					channel.sampler = sampler;
					startTime = Math.min(startTime, sampler.startTime);
					endTime = Math.max(endTime, sampler.endTime);
					channels.push(channel);

				}

			}

		}

		if ( channels.length ) {

			node.startTime = startTime;
			node.endTime = endTime;

		}

		return channels;

	};

	function calcFrameDuration( node ) {

		var minT = 10000000;

		for ( var i = 0; i < node.channels.length; i ++ ) {

			var sampler = node.channels[i].sampler;

			for (var j = 0; j < sampler.input.length - 1; j ++ ) {

				var t0 = sampler.input[ j ];
				var t1 = sampler.input[ j + 1 ];
				minT = Math.min( minT, t1 - t0 );

			}
		}

		return minT;

	};

	function calcMatrixAt( node, t ) {

		var animated = {};

		var i, j;

		for ( i = 0; i < node.channels.length; i ++ ) {

			var channel = node.channels[ i ];
			animated[ channel.sid ] = channel;

		}

		var matrix = new THREE.Matrix4();

		for ( i = 0; i < node.transforms.length; i ++ ) {

			var transform = node.transforms[i];
			var channel = animated[transform.sid];

			if ( channel !== undefined ) {

				var sampler = channel.sampler;
				var value;

				for ( var j = 0; j < sampler.input.length - 1; j ++ ) {

					if ( sampler.input[j+1] > t ) {

						value = sampler.output[j];
						//console.log(value.flatten)
						break;

					}

				}

				if ( value !== undefined ) {

					if ( value instanceof THREE.Matrix4 ) {

						matrix = matrix.multiply( matrix, value );

					} else {

						// FIXME: handle other types

						matrix = matrix.multiply( matrix, transform.matrix );

					}

				} else {

					matrix = matrix.multiply( matrix, transform.matrix );

				}

			} else {

				matrix = matrix.multiply( matrix, transform.matrix );

			}

		}

		return matrix;

	};

	function bakeAnimations ( node ) {

		if ( node.channels && node.channels.length ) {

			var frameDuration = calcFrameDuration( node );
			var t, matrix;
			var keys = [];

			for ( t = node.startTime; t < node.endTime; t += frameDuration ) {

				matrix = calcMatrixAt( node, t );

				//keys.push({time: t, mat: matrix.flatten()})

				keys.push({
					time: t,
					pos: [matrix.n14, matrix.n24, matrix.n34],
					rotq: [0, 0, 0, 1],
					scl: [1,1,1]
				});

			}

			node.keys = keys;

		}

	};

	function _Image() {

		this.id = "";
		this.init_from = "";

	};

	_Image.prototype.parse = function(element) {

		this.id = element.getAttribute('id');

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			if ( child.nodeName == 'init_from' ) {

				this.init_from = child.textContent;

			}

		}

		return this;

	};

	function Controller() {

		this.id = "";
		this.name = "";
		this.type = "";
		this.skin = null;
		this.morph = null;

	};

	Controller.prototype.parse = function( element ) {

		this.id = element.getAttribute('id');
		this.name = element.getAttribute('name');
		this.type = "none";

		for ( var i = 0; i < element.childNodes.length; i++ ) {

			var child = element.childNodes[ i ];

			switch ( child.nodeName ) {

				case 'skin':

					this.skin = (new Skin()).parse(child);
					this.type = child.nodeName;
					break;

				case 'morph':

					this.morph = (new Morph()).parse(child);
					this.type = child.nodeName;
					break;

				default:
					break;

			}
		}

		return this;

	};

	function Morph() {

		this.method = null;
		this.source = null;
		this.targets = null;
		this.weights = null;

	};

	Morph.prototype.parse = function( element ) {

		var sources = {};
		var inputs = [];
		var i;

		this.method = element.getAttribute( 'method' );
		this.source = element.getAttribute( 'source' ).replace( /^#/, '' );

		for ( i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'source':

					var source = ( new Source() ).parse( child );
					sources[ source.id ] = source;
					break;

				case 'targets':

					inputs = this.parseInputs( child );
					break;

				default:

					console.log( child.nodeName );
					break;

			}

		}

		for ( i = 0; i < inputs.length; i ++ ) {

			var input = inputs[ i ];
			var source = sources[ input.source ];

			switch ( input.semantic ) {

				case 'MORPH_TARGET':

					this.targets = source.read();
					break;

				case 'MORPH_WEIGHT':

					this.weights = source.read();
					break;

				default:
					break;

			}
		}

		return this;

	};

	Morph.prototype.parseInputs = function(element) {

		var inputs = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1) continue;

			switch ( child.nodeName ) {

				case 'input':

					inputs.push( (new Input()).parse(child) );
					break;

				default:
					break;
			}
		}

		return inputs;

	};

	function Skin() {

		this.source = "";
		this.bindShapeMatrix = null;
		this.invBindMatrices = [];
		this.joints = [];
		this.weights = [];

	};

	Skin.prototype.parse = function( element ) {

		var sources = {};
		var joints, weights;

		this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
		this.invBindMatrices = [];
		this.joints = [];
		this.weights = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'bind_shape_matrix':

					var f = _floats(child.textContent);
					this.bindShapeMatrix = new THREE.Matrix4();
					this.bindShapeMatrix.set(
						f[0], f[1], f[2], f[3],
						f[4], f[5], f[6], f[7],
						f[8], f[9], f[10], f[11],
						f[12], f[13], f[14], f[15]
						);
					break;

				case 'source':

					var src = new Source().parse(child);
					sources[ src.id ] = src;
					break;

				case 'joints':

					joints = child;
					break;

				case 'vertex_weights':

					weights = child;
					break;

				default:

					console.log( child.nodeName );
					break;

			}
		}

		this.parseJoints( joints, sources );
		this.parseWeights( weights, sources );

		return this;

	};

	Skin.prototype.parseJoints = function ( element, sources ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'input':

					var input = ( new Input() ).parse( child );
					var source = sources[ input.source ];

					if ( input.semantic == 'JOINT' ) {

						this.joints = source.read();

					} else if ( input.semantic == 'INV_BIND_MATRIX' ) {

						this.invBindMatrices = source.read();

					}

					break;

				default:
					break;
			}

		}

	};

	Skin.prototype.parseWeights = function ( element, sources ) {

		var v, vcount, inputs = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'input':

					inputs.push( ( new Input() ).parse( child ) );
					break;

				case 'v':

					v = _ints( child.textContent );
					break;

				case 'vcount':

					vcount = _ints( child.textContent );
					break;

				default:
					break;

			}

		}

		var index = 0;

		for ( var i = 0; i < vcount.length; i ++ ) {

			var numBones = vcount[i];
			var vertex_weights = [];

			for ( var j = 0; j < numBones; j++ ) {

				var influence = {};

				for ( var k = 0; k < inputs.length; k ++ ) {

					var input = inputs[ k ];
					var value = v[ index + input.offset ];

					switch ( input.semantic ) {

						case 'JOINT':

							influence.joint = value;//this.joints[value];
							break;

						case 'WEIGHT':

							influence.weight = sources[ input.source ].data[ value ];
							break;

						default:
							break;

					}

				}

				vertex_weights.push( influence );
				index += inputs.length;
			}

			for ( var j = 0; j < vertex_weights.length; j ++ ) {

				vertex_weights[ j ].index = i;

			}

			this.weights.push( vertex_weights );

		}

	};

	function VisualScene () {

		this.id = "";
		this.name = "";
		this.nodes = [];
		this.scene = new THREE.Object3D();

	};

	VisualScene.prototype.getChildById = function( id, recursive ) {

		for ( var i = 0; i < this.nodes.length; i ++ ) {

			var node = this.nodes[ i ].getChildById( id, recursive );

			if ( node ) {

				return node;

			}

		}

		return null;

	};

	VisualScene.prototype.getChildBySid = function( sid, recursive ) {

		for ( var i = 0; i < this.nodes.length; i ++ ) {

			var node = this.nodes[ i ].getChildBySid( sid, recursive );

			if ( node ) {

				return node;

			}

		}

		return null;

	};

	VisualScene.prototype.parse = function( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );
		this.nodes = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'node':

					this.nodes.push( ( new Node() ).parse( child ) );
					break;

				default:
					break;

			}

		}

		return this;

	};

	function Node() {

		this.id = "";
		this.name = "";
		this.sid = "";
		this.nodes = [];
		this.controllers = [];
		this.transforms = [];
		this.geometries = [];
		this.channels = [];
		this.matrix = new THREE.Matrix4();

	};

	Node.prototype.getChannelForTransform = function( transformSid ) {

		for ( var i = 0; i < this.channels.length; i ++ ) {

			var channel = this.channels[i];
			var parts = channel.target.split('/');
			var id = parts.shift();
			var sid = parts.shift();
			var dotSyntax = (sid.indexOf(".") >= 0);
			var arrSyntax = (sid.indexOf("(") >= 0);
			var arrIndices;
			var member;

			if ( dotSyntax ) {

				parts = sid.split(".");
				sid = parts.shift();
				member = parts.shift();

			} else if ( arrSyntax ) {

				arrIndices = sid.split("(");
				sid = arrIndices.shift();

				for ( var j = 0; j < arrIndices.length; j ++ ) {

					arrIndices[ j ] = parseInt( arrIndices[ j ].replace( /\)/, '' ) );

				}

			}

			if ( sid == transformSid ) {

				channel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };
				return channel;

			}

		}

		return null;

	};

	Node.prototype.getChildById = function ( id, recursive ) {

		if ( this.id == id ) {

			return this;

		}

		if ( recursive ) {

			for ( var i = 0; i < this.nodes.length; i ++ ) {

				var n = this.nodes[ i ].getChildById( id, recursive );

				if ( n ) {

					return n;

				}

			}

		}

		return null;

	};

	Node.prototype.getChildBySid = function ( sid, recursive ) {

		if ( this.sid == sid ) {

			return this;

		}

		if ( recursive ) {

			for ( var i = 0; i < this.nodes.length; i ++ ) {

				var n = this.nodes[ i ].getChildBySid( sid, recursive );

				if ( n ) {

					return n;

				}

			}
		}

		return null;

	};

	Node.prototype.getTransformBySid = function ( sid ) {

		for ( var i = 0; i < this.transforms.length; i ++ ) {

			if ( this.transforms[ i ].sid == sid ) return this.transforms[ i ];

		}

		return null;

	};

	Node.prototype.parse = function( element ) {

		var url;

		this.id = element.getAttribute('id');
		this.sid = element.getAttribute('sid');
		this.name = element.getAttribute('name');
		this.type = element.getAttribute('type');

		this.type = this.type == 'JOINT' ? this.type : 'NODE';

		this.nodes = [];
		this.transforms = [];
		this.geometries = [];
		this.controllers = [];
		this.matrix = new THREE.Matrix4();

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'node':

					this.nodes.push( ( new Node() ).parse( child ) );
					break;

				case 'instance_camera':

					break;

				case 'instance_controller':

					this.controllers.push( ( new InstanceController() ).parse( child ) );
					break;

				case 'instance_geometry':

					this.geometries.push( ( new InstanceGeometry() ).parse( child ) );
					break;

				case 'instance_light':

					break;

				case 'instance_node':

					url = child.getAttribute( 'url' ).replace( /^#/, '' );
					var iNode = getLibraryNode( url );

					if ( iNode ) {

						this.nodes.push( ( new Node() ).parse( iNode )) ;

					}

					break;

				case 'rotate':
				case 'translate':
				case 'scale':
				case 'matrix':
				case 'lookat':
				case 'skew':

					this.transforms.push( ( new Transform() ).parse( child ) );
					break;

				case 'extra':
					break;

				default:

					console.log( child.nodeName );
					break;

			}

		}

		this.channels = getChannelsForNode( this );
		bakeAnimations( this );

		this.updateMatrix();

		return this;

	};

	Node.prototype.updateMatrix = function () {

		this.matrix.identity();

		for ( var i = 0; i < this.transforms.length; i ++ ) {

			this.matrix.multiply( this.matrix, this.transforms[ i ].matrix );

		}

	};

	function Transform () {

		this.sid = "";
		this.type = "";
		this.data = [];
		this.matrix = new THREE.Matrix4();

	};

	Transform.prototype.parse = function ( element ) {

		this.sid = element.getAttribute( 'sid' );
		this.type = element.nodeName;
		this.data = _floats( element.textContent );

		this.updateMatrix();

		return this;

	};

	Transform.prototype.updateMatrix = function () {

		var angle = 0;

		this.matrix.identity();

		switch ( this.type ) {

			case 'matrix':

				this.matrix.set(
					this.data[0], this.data[1], this.data[2], this.data[3],
					this.data[4], this.data[5], this.data[6], this.data[7],
					this.data[8], this.data[9], this.data[10], this.data[11],
					this.data[12], this.data[13], this.data[14], this.data[15]
					);
				break;

			case 'translate':

				this.matrix.setTranslation(this.data[0], this.data[1], this.data[2]);
				break;

			case 'rotate':

				angle = this.data[3] * (Math.PI / 180.0);
				this.matrix.setRotationAxis(new THREE.Vector3(this.data[0], this.data[1], this.data[2]), angle);
				break;

			case 'scale':

				this.matrix.setScale(this.data[0], this.data[1], this.data[2]);
				break;

			default:
				break;

		}

		return this.matrix;

	};

	function InstanceController() {

		this.url = "";
		this.skeleton = [];
		this.instance_material = [];

	};

	InstanceController.prototype.parse = function ( element ) {

		this.url = element.getAttribute('url').replace(/^#/, '');
		this.skeleton = [];
		this.instance_material = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if (child.nodeType != 1) continue;

			switch ( child.nodeName ) {

				case 'skeleton':

					this.skeleton.push( child.textContent.replace(/^#/, '') );
					break;

				case 'bind_material':

					var instances = COLLADA.evaluate(".//dae:instance_material",
														child,
														_nsResolver,
														XPathResult.ORDERED_NODE_ITERATOR_TYPE,
														null);

					if ( instances ) {

						var instance = instances.iterateNext();

						while ( instance ) {

							this.instance_material.push((new InstanceMaterial()).parse(instance));
							instance = instances.iterateNext();

						}

					}

					break;

				case 'extra':
					break;

				default:
					break;

			}
		}

		return this;

	};

	function InstanceMaterial () {

		this.symbol = "";
		this.target = "";

	};

	InstanceMaterial.prototype.parse = function ( element ) {

		this.symbol = element.getAttribute('symbol');
		this.target = element.getAttribute('target').replace(/^#/, '');
		return this;

	};

	function InstanceGeometry() {

		this.url = "";
		this.instance_material = [];

	};

	InstanceGeometry.prototype.parse = function ( element ) {

		this.url = element.getAttribute('url').replace(/^#/, '');
		this.instance_material = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1 ) continue;

			if ( child.nodeName == 'bind_material' ) {

				var instances = COLLADA.evaluate(".//dae:instance_material",
					child,
					_nsResolver,
					XPathResult.ORDERED_NODE_ITERATOR_TYPE,
					null);

				if ( instances ) {

					var instance = instances.iterateNext();

					while ( instance ) {

						this.instance_material.push( (new InstanceMaterial()).parse(instance) );
						instance = instances.iterateNext();

					}

				}

				break;

			}

		}

		return this;

	};

	function Geometry() {

		this.id = "";
		this.mesh = null;

	};

	Geometry.prototype.parse = function ( element ) {

		this.id = element.getAttribute('id');

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];

			switch ( child.nodeName ) {

				case 'mesh':

					this.mesh = (new Mesh(this)).parse(child);
					break;

				case 'extra':

					// console.log( child );
					break;

				default:
					break;
			}
		}

		return this;

	};

	function Mesh( geometry ) {

		this.geometry = geometry.id;
		this.primitives = [];
		this.vertices = null;
		this.geometry3js = null;

	};

	Mesh.prototype.parse = function( element ) {

		this.primitives = [];

		var i, j;

		for ( i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			switch ( child.nodeName ) {

				case 'source':

					_source( child );
					break;

				case 'vertices':

					this.vertices = ( new Vertices() ).parse( child );
					break;

				case 'triangles':

					this.primitives.push( ( new Triangles().parse( child ) ) );
					break;

				case 'polygons':

					console.warn( 'polygon holes not yet supported!' );

				case 'polylist':

					this.primitives.push( ( new Polylist().parse( child ) ) );
					break;

				default:
					break;

			}

		}

		var vertex_store = {};

		function get_vertex ( v, index )  {

			var hash = _hash_vector3( v.position );

			if ( vertex_store[ hash ] === undefined ) {

				vertex_store[ hash ] = { v: v, index: index };

			}

			return vertex_store[ hash ];

		}

		this.geometry3js = new THREE.Geometry();

		var vertexData = sources[ this.vertices.input['POSITION'].source ].data;

		for ( i = 0, j = 0; i < vertexData.length; i += 3, j ++ ) {

			var v = new THREE.Vertex( new THREE.Vector3( vertexData[ i ], vertexData[ i + 1 ], vertexData[ i + 2 ] ) );
			get_vertex( v, j );
			this.geometry3js.vertices.push( v );

		}

		for ( i = 0; i < this.primitives.length; i ++ ) {

			var primitive = this.primitives[ i ];
			primitive.setVertices( this.vertices );
			this.handlePrimitive( primitive, this.geometry3js, vertex_store );

		}

		this.geometry3js.computeCentroids();
		this.geometry3js.computeFaceNormals();
		this.geometry3js.computeVertexNormals();
		this.geometry3js.computeBoundingBox();

		return this;

	};

	Mesh.prototype.handlePrimitive = function( primitive, geom, vertex_store ) {

		var i = 0, j, k, p = primitive.p, inputs = primitive.inputs;
		var input, index, idx32;
		var source, numParams;
		var vcIndex = 0, vcount = 3;
		var texture_sets = [];

		for ( j = 0; j < inputs.length; j ++ ) {

			input = inputs[ j ];

			switch ( input.semantic ) {

				case 'TEXCOORD':
					texture_sets.push( input.set );
					break;

			}

		}

		while ( i < p.length ) {

			var vs = [];
			var ns = [];
			var ts = {};
			var cs = [];

			if ( primitive.vcount ) {

				vcount = primitive.vcount[ vcIndex ++ ];

			}

			for ( j = 0; j < vcount; j ++ ) {

				for ( k = 0; k < inputs.length; k ++ ) {

					input = inputs[ k ];
					source = sources[ input.source ];

					index = p[ i + ( j * inputs.length ) + input.offset ];
					numParams = source.accessor.params.length;
					idx32 = index * numParams;

					switch ( input.semantic ) {

						case 'VERTEX':

							var hash = _hash_vector3( geom.vertices[ index ].position );
							vs.push( vertex_store[ hash ].index );

							break;

						case 'NORMAL':

							ns.push( new THREE.Vector3( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );

							break;

						case 'TEXCOORD':

							if ( ts[ input.set ] === undefined ) ts[ input.set ] = [];
							ts[ input.set ].push( new THREE.UV( source.data[ idx32 ], source.data[ idx32 + 1 ] ) );

							break;

						case 'COLOR':

							cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );

							break;

						default:
							break;

					}

				}

			}


			var face, uv;

			if ( vcount == 3 ) {

				face = new THREE.Face3( vs[0], vs[1], vs[2], [ ns[0], ns[1], ns[2] ], cs.length ? cs : new THREE.Color() );

			} else if ( vcount == 4 ) {

				face = new THREE.Face4( vs[0], vs[1], vs[2], vs[3], [ ns[0], ns[1], ns[2], ns[3] ], cs.length ? cs : new THREE.Color() );

			}

			face.daeMaterial = primitive.material;
			geom.faces.push( face );

			for ( k = 0; k < texture_sets.length; k ++ ) {

				uv = ts[ texture_sets[ k ] ];
				geom.faceVertexUvs[ k ].push( [ uv[0], uv[1], uv[2] ] );

			}

			i += inputs.length * vcount;

		}

	};


	function Polylist () {
	};

	Polylist.prototype = new Triangles();
	Polylist.prototype.constructor = Polylist;

	function Triangles( flip_uv ) {

		this.material = "";
		this.count = 0;
		this.inputs = [];
		this.vcount = null;
		this.p = [];
		this.geometry = new THREE.Geometry();

	};

	Triangles.prototype.setVertices = function ( vertices ) {

		for ( var i = 0; i < this.inputs.length; i ++ ) {

			if ( this.inputs[ i ].source == vertices.id ) {

				this.inputs[ i ].source = vertices.input[ 'POSITION' ].source;

			}

		}

	};

	Triangles.prototype.parse = function ( element ) {

		this.inputs = [];
		this.material = element.getAttribute( 'material' );
		this.count = _attr_as_int( element, 'count', 0 );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			switch ( child.nodeName ) {

				case 'input':

					this.inputs.push( ( new Input() ).parse( element.childNodes[ i ] ) );
					break;

				case 'vcount':

					this.vcount = _ints( child.textContent );
					break;

				case 'p':

					this.p = _ints( child.textContent );
					break;

				default:
					break;

			}

		}

		return this;

	};

	function Accessor() {

		this.source = "";
		this.count = 0;
		this.stride = 0;
		this.params = [];

	};

	Accessor.prototype.parse = function ( element ) {

		this.params = [];
		this.source = element.getAttribute( 'source' );
		this.count = _attr_as_int( element, 'count', 0 );
		this.stride = _attr_as_int( element, 'stride', 0 );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			if ( child.nodeName == 'param' ) {

				var param = {};
				param[ 'name' ] = child.getAttribute( 'name' );
				param[ 'type' ] = child.getAttribute( 'type' );
				this.params.push( param );

			}

		}

		return this;

	};

	function Vertices() {

		this.input = {};

	};

	Vertices.prototype.parse = function ( element ) {

		this.id = element.getAttribute('id');

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			if ( element.childNodes[i].nodeName == 'input' ) {

				var input = ( new Input() ).parse( element.childNodes[ i ] );
				this.input[ input.semantic ] = input;

			}

		}

		return this;

	};

	function Input () {

		this.semantic = "";
		this.offset = 0;
		this.source = "";
		this.set = 0;

	};

	Input.prototype.parse = function ( element ) {

		this.semantic = element.getAttribute('semantic');
		this.source = element.getAttribute('source').replace(/^#/, '');
		this.set = _attr_as_int(element, 'set', -1);
		this.offset = _attr_as_int(element, 'offset', 0);

		if ( this.semantic == 'TEXCOORD' && this.set < 0 ) {

			this.set = 0;

		}

		return this;

	};

	function Source ( id ) {

		this.id = id;
		this.type = null;

	};

	Source.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];

			switch ( child.nodeName ) {

				case 'bool_array':

					this.data = _bools( child.textContent );
					this.type = child.nodeName;
					break;

				case 'float_array':

					this.data = _floats( child.textContent );
					this.type = child.nodeName;
					break;

				case 'int_array':

					this.data = _ints( child.textContent );
					this.type = child.nodeName;
					break;

				case 'IDREF_array':
				case 'Name_array':

					this.data = _strings( child.textContent );
					this.type = child.nodeName;
					break;

				case 'technique_common':

					for ( var j = 0; j < child.childNodes.length; j ++ ) {

						if ( child.childNodes[ j ].nodeName == 'accessor' ) {

							this.accessor = ( new Accessor() ).parse( child.childNodes[ j ] );
							break;

						}
					}
					break;

				default:
					// console.log(child.nodeName);
					break;

			}

		}

		return this;

	};

	Source.prototype.read = function () {

		var result = [];

		//for (var i = 0; i < this.accessor.params.length; i++) {

			var param = this.accessor.params[ 0 ];

			//console.log(param.name + " " + param.type);

			switch ( param.type ) {

				case 'IDREF':
				case 'Name': case 'name':
				case 'float':

					return this.data;

				case 'float4x4':

					for ( var j = 0; j < this.data.length; j += 16 ) {

						var s = this.data.slice( j, j + 16 );
						var m = new THREE.Matrix4();
						m.set(
							s[0], s[1], s[2], s[3],
							s[4], s[5], s[6], s[7],
							s[8], s[9], s[10], s[11],
							s[12], s[13], s[14], s[15]
							);
						result.push( m );
					}

					break;

				default:

					console.log( 'ColladaLoader: Source: Read dont know how to read ' + param.type + '.' );
					break;

			}

		//}

		return result;

	};

	function Material () {

		this.id = "";
		this.name = "";
		this.instance_effect = null;

	};

	Material.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			if ( element.childNodes[ i ].nodeName == 'instance_effect' ) {

				this.instance_effect = ( new InstanceEffect() ).parse( element.childNodes[ i ] );
				break;

			}

		}

		return this;

	};

	function ColorOrTexture () {

		this.color = new THREE.Color( 0 );
		this.color.setRGB( Math.random(), Math.random(), Math.random() );
		this.color.a = 1.0;

		this.texture = null;
		this.texcoord = null;

	};

	ColorOrTexture.prototype.isColor = function () {

		return ( this.texture == null );

	};

	ColorOrTexture.prototype.isTexture = function () {

		return ( this.texture != null );

	};

	ColorOrTexture.prototype.parse = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'color':

					var rgba = _floats( child.textContent );
					this.color = new THREE.Color(0);
					this.color.setRGB( rgba[0], rgba[1], rgba[2] );
					this.color.a = rgba[3];
					break;

				case 'texture':

					this.texture = child.getAttribute('texture');
					this.texcoord = child.getAttribute('texcoord');
					break;

				default:
					break;

			}

		}

		return this;

	};

	function Shader ( type, effect ) {

		this.type = type;
		this.effect = effect;
		this.material = null;

	};

	Shader.prototype.parse = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'ambient':
				case 'emission':
				case 'diffuse':
				case 'specular':
				case 'transparent':

					this[ child.nodeName ] = ( new ColorOrTexture() ).parse( child );
					break;

				case 'shininess':
				case 'reflectivity':
				case 'transparency':

					var f = evaluateXPath( child, ".//dae:float" );

					if ( f.length > 0 )
						this[ child.nodeName ] = parseFloat( f[ 0 ].textContent );

					break;

				default:
					break;

			}

		}

		this.create();
		return this;

	};

	Shader.prototype.create = function() {

		var props = {};
		var transparent = ( this['transparency'] !== undefined && this['transparency'] < 1.0 );

		for ( var prop in this ) {

			switch ( prop ) {

				case 'ambient':
				case 'emission':
				case 'diffuse':
				case 'specular':

					var cot = this[prop];

					if ( cot instanceof ColorOrTexture ) {

						if ( cot.isTexture() ) {

							if ( this.effect.sampler && this.effect.surface ) {

								if ( this.effect.sampler.source == this.effect.surface.sid ) {

									var image = images[this.effect.surface.init_from];

									if ( image ) {

										props['map'] = THREE.ImageUtils.loadTexture(baseUrl + image.init_from);
										props['map'].wrapS = THREE.RepeatWrapping;
										props['map'].wrapT = THREE.RepeatWrapping;
										props['map'].repeat.x = 1;
										props['map'].repeat.y = -1;

									}

								}

							}

						} else {

							if ( prop == 'diffuse' ) {

								props[ 'color' ] = cot.color.getHex();

							} else if ( !transparent ) {

								props[ prop ] = cot.color.getHex();

							}

						}

					}

					break;

				case 'shininess':
				case 'reflectivity':

					props[ prop ] = this[ prop ];
					break;

				case 'transparency':

					if ( transparent ) {

						props[ 'transparent' ] = true;
						props[ 'opacity' ] = this[ prop ];
						transparent = true;

					}

					break;

				default:
					break;

			}

		}

		props[ 'shading' ] = preferredShading;
		this.material = new THREE.MeshLambertMaterial( props );

		switch ( this.type ) {

			case 'constant':
			case 'lambert':
				break;

			case 'phong':
			case 'blinn':

			default:

				/*
				if ( !transparent ) {

				//	this.material = new THREE.MeshPhongMaterial(props);

				}
				*/

				break;

		}

		return this.material;

	};

	function Surface ( effect ) {

		this.effect = effect;
		this.init_from = null;
		this.format = null;

	};

	Surface.prototype.parse = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'init_from':

					this.init_from = child.textContent;
					break;

				case 'format':

					this.format = child.textContent;
					break;

				default:

					console.log( "unhandled Surface prop: " + child.nodeName );
					break;

			}

		}

		return this;

	};

	function Sampler2D ( effect ) {

		this.effect = effect;
		this.source = null;
		this.wrap_s = null;
		this.wrap_t = null;
		this.minfilter = null;
		this.magfilter = null;
		this.mipfilter = null;

	};

	Sampler2D.prototype.parse = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'source':

					this.source = child.textContent;
					break;

				case 'minfilter':

					this.minfilter = child.textContent;
					break;

				case 'magfilter':

					this.magfilter = child.textContent;
					break;

				case 'mipfilter':

					this.mipfilter = child.textContent;
					break;

				case 'wrap_s':

					this.wrap_s = child.textContent;
					break;

				case 'wrap_t':

					this.wrap_t = child.textContent;
					break;

				default:

					console.log( "unhandled Sampler2D prop: " + child.nodeName );
					break;

			}

		}

		return this;

	};

	function Effect () {

		this.id = "";
		this.name = "";
		this.shader = null;
		this.surface = null;
		this.sampler = null;

	};

	Effect.prototype.create = function () {

		if ( this.shader == null ) {

			return null;

		}

	};

	Effect.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );
		this.shader = null;

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'profile_COMMON':

					this.parseTechnique( this.parseProfileCOMMON( child ) );
					break;

				default:
					break;

			}

		}

		return this;

	};

	Effect.prototype.parseNewparam = function ( element ) {

		var sid = element.getAttribute( 'sid' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'surface':

					this.surface = ( new Surface( this ) ).parse( child );
					this.surface.sid = sid;
					break;

				case 'sampler2D':

					this.sampler = ( new Sampler2D( this ) ).parse( child );
					this.sampler.sid = sid;
					break;

				case 'extra':

					break;

				default:

					console.log( child.nodeName );
					break;

			}

		}

	};

	Effect.prototype.parseProfileCOMMON = function ( element ) {

		var technique;

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'profile_COMMON':

					this.parseProfileCOMMON( child );
					break;

				case 'technique':

					technique = child;
					break;

				case 'newparam':

					this.parseNewparam( child );
					break;

				case 'extra':
					break;

				default:

					console.log( child.nodeName );
					break;

			}

		}

		return technique;

	};

	Effect.prototype.parseTechnique= function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'lambert':
				case 'blinn':
				case 'phong':

					this.shader = ( new Shader( child.nodeName, this ) ).parse( child );
					break;

				default:
					break;

			}

		}

	};

	function InstanceEffect () {

		this.url = "";

	};

	InstanceEffect.prototype.parse = function ( element ) {

		this.url = element.getAttribute( 'url' ).replace( /^#/, '' );
		return this;

	};

	function Animation() {

		this.id = "";
		this.name = "";
		this.source = {};
		this.sampler = [];
		this.channel = [];

	};

	Animation.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );
		this.source = {};

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'source':

					var src = ( new Source() ).parse( child );
					this.source[ src.id ] = src;
					break;

				case 'sampler':

					this.sampler.push( ( new Sampler( this ) ).parse( child ) );
					break;

				case 'channel':

					this.channel.push( ( new Channel( this ) ).parse( child ) );
					break;

				default:
					break;

			}

		}

		return this;

	};

	function Channel( animation ) {

		this.animation = animation;
		this.source = "";
		this.target = "";
		this.sid = null;
		this.dotSyntax = null;
		this.arrSyntax = null;
		this.arrIndices = null;
		this.member = null;

	};

	Channel.prototype.parse = function ( element ) {

		this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
		this.target = element.getAttribute( 'target' );

		var parts = this.target.split( '/' );

		var id = parts.shift();
		var sid = parts.shift();

		var dotSyntax = ( sid.indexOf(".") >= 0 );
		var arrSyntax = ( sid.indexOf("(") >= 0 );

		var arrIndices;
		var member;

		if ( dotSyntax ) {

			parts = sid.split(".");
			sid = parts.shift();
			member = parts.shift();

		} else if ( arrSyntax ) {

			arrIndices = sid.split("(");
			sid = arrIndices.shift();

			for (var j = 0; j < arrIndices.length; j ++ ) {

				arrIndices[j] = parseInt( arrIndices[j].replace(/\)/, '') );

			}

		}

		this.sid = sid;
		this.dotSyntax = dotSyntax;
		this.arrSyntax = arrSyntax;
		this.arrIndices = arrIndices;
		this.member = member;

		return this;

	};

	function Sampler ( animation ) {

		this.id = "";
		this.animation = animation;
		this.inputs = [];
		this.input = null;
		this.output = null;
		this.interpolation = null;
		this.startTime = null;
		this.endTime = null;
		this.duration = 0;

	};

	Sampler.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.inputs = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'input':

					this.inputs.push( (new Input()).parse( child ) );
					break;

				default:
					break;

			}

		}

		return this;

	};

	Sampler.prototype.create = function () {

		for ( var i = 0; i < this.inputs.length; i ++ ) {

			var input = this.inputs[ i ];
			var source = this.animation.source[ input.source ];

			switch ( input.semantic ) {

				case 'INPUT':

					this.input = source.read();
					break;

				case 'OUTPUT':

					this.output = source.read();
					break;

				case 'INTERPOLATION':

					this.interpolation = source.read();
					break;

				case 'IN_TANGENT':

					break;

				case 'OUT_TANGENT':

					break;

				default:

					console.log(input.semantic);
					break;

			}

		}

		this.startTime = 0;
		this.endTime = 0;
		this.duration = 0;

		if ( this.input.length ) {

			this.startTime = 100000000;
			this.endTime = -100000000;

			for ( var i = 0; i < this.input.length; i ++ ) {

				this.startTime = Math.min( this.startTime, this.input[ i ] );
				this.endTime = Math.max( this.endTime, this.input[ i ] );

			}

			this.duration = this.endTime - this.startTime;

		}

	};

	function _source ( element ) {

		var id = element.getAttribute( 'id' );

		if ( sources[ id ] != undefined ) {

			return sources[ id ];

		}

		sources[ id ] = ( new Source(id )).parse( element );
		return sources[ id ];

	};

	function _nsResolver ( nsPrefix ) {

		if ( nsPrefix == "dae" ) {

			return "http://www.collada.org/2005/11/COLLADASchema";

		}

		return null;

	};

	function _bools ( str ) {

		var raw = _strings( str );
		var data = [];

		for ( var i = 0; i < raw.length; i ++ ) {

			data.push( (raw[i] == 'true' || raw[i] == '1') ? true : false );

		}

		return data;

	};

	function _floats ( str ) {

		var raw = _strings(str);
		var data = [];

		for ( var i = 0; i < raw.length; i ++ ) {

			data.push( parseFloat( raw[ i ] ) );

		}

		return data;

	};

	function _ints ( str ) {

		var raw = _strings( str );
		var data = [];

		for ( var i = 0; i < raw.length; i ++ ) {

			data.push( parseInt( raw[ i ], 10 ) );

		}

		return data;

	};

	function _strings ( str ) {

		return _trimString( str ).split( /\s+/ );

	};

	function _trimString ( str ) {

		return str.replace( /^\s+/, "" ).replace( /\s+$/, "" );

	};

	function _attr_as_float ( element, name, defaultValue ) {

		if ( element.hasAttribute( name ) ) {

			return parseFloat( element.getAttribute( name ) );

		} else {

			return defaultValue;

		}

	};

	function _attr_as_int ( element, name, defaultValue ) {

		if ( element.hasAttribute( name ) ) {

			return parseInt( element.getAttribute( name ), 10) ;

		} else {

			return defaultValue;

		}

	};

	function _attr_as_string ( element, name, defaultValue ) {

		if ( element.hasAttribute( name ) ) {

			return element.getAttribute( name );

		} else {

			return defaultValue;

		}

	};

	function _format_float ( f, num ) {

		if ( f === undefined ) {

			var s = '0.';

			while ( s.length < num + 2 ) {

				s += '0';

			}

			return s;

		}

		num = num || 2;

		var parts = f.toString().split( '.' );
		parts[ 1 ] = parts.length > 1 ? parts[ 1 ].substr( 0, num ) : "0";

		while( parts[ 1 ].length < num ) {

			parts[ 1 ] += '0';

		}

		return parts.join( '.' );

	};

	function _hash_vertex ( v, n, t0, t1, precision ) {

		precision = precision || 2;

		var s = v instanceof THREE.Vertex ? _hash_vector3( v.position, precision ) : _hash_vector3( v, precision );

		if ( n === undefined ) {

			s += '_0.00,0.00,0.00';

		} else {

			s += '_' + _hash_vector3( n, precision );

		}

		if ( t0 === undefined ) {

			s += '_0.00,0.00';

		} else {

			s += '_' + _hash_uv( t0, precision );

		}

		if ( t1 === undefined ) {

			s += '_0.00,0.00';

		} else {

			s += '_' + _hash_uv( t1, precision );

		}

		return s;

	};

	function _hash_uv ( uv, num ) {

		var s = '';

		s += _format_float( uv.u, num ) + ',';
		s += _format_float( uv.v, num );

		return s;

	};

	function _hash_vector3 ( vec, num ) {

		var s = '';

		s += _format_float( vec.x, num ) + ',';
		s += _format_float( vec.y, num ) + ',';
		s += _format_float( vec.z, num );

		return s;

	};

	function evaluateXPath ( node, query ) {

		var instances = COLLADA.evaluate(query,
			node,
			_nsResolver,
			XPathResult.ORDERED_NODE_ITERATOR_TYPE,
			null);

		var inst = instances.iterateNext();
		var result = [];

		while ( inst ) {

			result.push( inst );
			inst = instances.iterateNext();

		}

		return result;

	};

	return {

		load: load,
		parse: parse,
		setPreferredShading: setPreferredShading,
		applySkin: applySkin,
		geometries : geometries

	};

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

};

THREE.JSONLoader.prototype = new THREE.Loader();
THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;
THREE.JSONLoader.prototype.supr = THREE.Loader.prototype;

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var worker, scope = this;

	if ( url instanceof Object ) {

		console.warn( 'DEPRECATED: JSONLoader( parameters ) is now JSONLoader( url, callback, texturePath ).' );

		var parameters = url;

		url = parameters.model;
		callback = parameters.callback;
		texturePath = parameters.texture_path;

	}

	texturePath = texturePath ? texturePath : this.extractUrlbase( url ),

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function() {

		if ( xhr.readyState == 4 ) {

			if ( xhr.status == 200 || xhr.status == 0 ) {

				try {

					var jsonObject = JSON.parse( xhr.responseText );

					context.createModel( jsonObject, callback, texturePath );
					context.onLoadComplete();

				} catch ( error ) {

					console.error( error );
					console.warn( "DEPRECATED: [" + url + "] seems to be using old model format" );

				}

			} else {

				console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState == 3 ) {

			if ( callbackProgress ) {

				if ( length == 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState == 2 ) {

			length = xhr.getResponseHeader( "Content-Length" );

		}

	};

	xhr.open( "GET", url, true );
	xhr.overrideMimeType( "text/plain; charset=x-user-defined" );
	xhr.setRequestHeader( "Content-Type", "text/plain" );
	xhr.send( null );

};

THREE.JSONLoader.prototype.createModel = function ( json, callback, texture_path ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	this.initMaterials( geometry, json.materials, texture_path );

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeCentroids();
	geometry.computeFaceNormals();

	if ( this.hasNormals( geometry ) ) geometry.computeTangents();


	function parseModel( scale ) {

		if ( json.metadata === undefined || json.metadata.formatVersion === undefined || json.metadata.formatVersion !== 3 ) {

			console.error( 'Deprecated file format.' );
			return;

		}

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		};

		var i, j, fi,

		offset, zLength, nVertices,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceUv, hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, color, normal,

		uvLayer, uvs, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		// disregard empty arrays

		for ( i = 0; i < json.uvs.length; i++ ) {

			if ( json.uvs[ i ].length ) nUvLayers ++;

		}

		for ( i = 0; i < nUvLayers; i++ ) {

			geometry.faceUvs[ i ] = [];
			geometry.faceVertexUvs[ i ] = [];

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vertex();

			vertex.position.x = vertices[ offset ++ ] * scale;
			vertex.position.y = vertices[ offset ++ ] * scale;
			vertex.position.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad          	= isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceUv           = isBitSet( type, 2 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	    = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			//console.log("type", type, "bits", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				face = new THREE.Face4();

				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];
				face.d = faces[ offset ++ ];

				nVertices = 4;

			} else {

				face = new THREE.Face3();

				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				nVertices = 3;

			}

			if ( hasMaterial ) {

				materialIndex = faces[ offset ++ ];
				face.materialIndex = materialIndex;

			}

			// to get face <=> uv index correspondence

			fi = geometry.faces.length;

			if ( hasFaceUv ) {

				for ( i = 0; i < nUvLayers; i++ ) {

					uvLayer = json.uvs[ i ];

					uvIndex = faces[ offset ++ ];

					u = uvLayer[ uvIndex * 2 ];
					v = uvLayer[ uvIndex * 2 + 1 ];

					geometry.faceUvs[ i ][ fi ] = new THREE.UV( u, v );

				}

			}

			if ( hasFaceVertexUv ) {

				for ( i = 0; i < nUvLayers; i++ ) {

					uvLayer = json.uvs[ i ];

					uvs = [];

					for ( j = 0; j < nVertices; j ++ ) {

						uvIndex = faces[ offset ++ ];

						u = uvLayer[ uvIndex * 2 ];
						v = uvLayer[ uvIndex * 2 + 1 ];

						uvs[ j ] = new THREE.UV( u, v );

					}

					geometry.faceVertexUvs[ i ][ fi ] = uvs;

				}

			}

			if ( hasFaceNormal ) {

				normalIndex = faces[ offset ++ ] * 3;

				normal = new THREE.Vector3();

				normal.x = normals[ normalIndex ++ ];
				normal.y = normals[ normalIndex ++ ];
				normal.z = normals[ normalIndex ];

				face.normal = normal;

			}

			if ( hasFaceVertexNormal ) {

				for ( i = 0; i < nVertices; i++ ) {

					normalIndex = faces[ offset ++ ] * 3;

					normal = new THREE.Vector3();

					normal.x = normals[ normalIndex ++ ];
					normal.y = normals[ normalIndex ++ ];
					normal.z = normals[ normalIndex ];

					face.vertexNormals.push( normal );

				}

			}


			if ( hasFaceColor ) {

				colorIndex = faces[ offset ++ ];

				color = new THREE.Color( colors[ colorIndex ] );
				face.color = color;

			}


			if ( hasFaceVertexColor ) {

				for ( i = 0; i < nVertices; i++ ) {

					colorIndex = faces[ offset ++ ];

					color = new THREE.Color( colors[ colorIndex ] );
					face.vertexColors.push( color );

				}

			}

			geometry.faces.push( face );

		}

	};

	function parseSkin() {

		var i, l, x, y, z, w, a, b, c, d;

		if ( json.skinWeights ) {

			for ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

				x = json.skinWeights[ i     ];
				y = json.skinWeights[ i + 1 ];
				z = 0;
				w = 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

				a = json.skinIndices[ i     ];
				b = json.skinIndices[ i + 1 ];
				c = 0;
				d = 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;
		geometry.animation = json.animation;

	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, x, y, z, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					x = srcVertices[ v ] * scale;
					y = srcVertices[ v + 1 ] * scale;
					z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( new THREE.Vertex( new THREE.Vector3( x, y, z ) ) );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	callback( geometry );

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneLoader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};

	this.callbackSync = function () {};
	this.callbackProgress = function () {};

};

THREE.SceneLoader.prototype.constructor = THREE.SceneLoader;

THREE.SceneLoader.prototype.load = function( url, callbackFinished ) {

	var context = this;

	var xhr = new XMLHttpRequest();

	xhr.onreadystatechange = function() {

		if ( xhr.readyState == 4 ) {

			if ( xhr.status == 200 || xhr.status == 0 ) {

				try {

					var json = JSON.parse( xhr.responseText );

					if ( json.metadata === undefined || json.metadata.formatVersion === undefined || json.metadata.formatVersion !== 3 ) {

						console.error( 'Deprecated file format.' );
						return;

					}

					context.createScene( json, callbackFinished, url );

				} catch ( error ) {

					console.error( error );
					console.warn( "DEPRECATED: [" + url + "] seems to be using old model format" );

				}

			} else {

				console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.overrideMimeType( "text/plain; charset=x-user-defined" );
	xhr.setRequestHeader( "Content-Type", "text/plain" );
	xhr.send( null );

};

THREE.SceneLoader.prototype.createScene = function ( json, callbackFinished, url ) {

	var scope = this;

	var urlBase = THREE.Loader.prototype.extractUrlbase( url );

	var dg, dm, dd, dl, dc, df, dt,
		g, o, m, l, d, p, r, q, s, c, t, f, tt, pp,
		geometry, material, camera, fog,
		texture, images,
		materials, light,
		data, binLoader, jsonLoader,
		counter_models, counter_textures,
		total_models, total_textures,
		result;

	data = json;

	binLoader = new THREE.BinaryLoader();
	jsonLoader = new THREE.JSONLoader();

	counter_models = 0;
	counter_textures = 0;

	result = {

		scene: new THREE.Scene(),
		geometries: {},
		materials: {},
		textures: {},
		objects: {},
		cameras: {},
		lights: {},
		fogs: {},
		triggers: {},
		empties: {}

	};

	// find out if there are some colliders

	var hasColliders = false;

	for( dd in data.objects ) {

		o = data.objects[ dd ];

		if ( o.meshCollider )  {

			hasColliders = true;
			break;

		}

	}

	if ( hasColliders ) {

		result.scene.collisions = new THREE.CollisionSystem();

	}

	if ( data.transform ) {

		var position = data.transform.position,
			rotation = data.transform.rotation,
			scale = data.transform.scale;

		if ( position )
			result.scene.position.set( position[ 0 ], position[ 1 ], position [ 2 ] );

		if ( rotation )
			result.scene.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation [ 2 ] );

		if ( scale )
			result.scene.scale.set( scale[ 0 ], scale[ 1 ], scale [ 2 ] );

		if ( position || rotation || scale )
			result.scene.updateMatrix();

	}

	function get_url( source_url, url_type ) {

		if ( url_type == "relativeToHTML" ) {

			return source_url;

		} else {

			return urlBase + "/" + source_url;

		}

	};

	function handle_objects() {

		var object;

		for( dd in data.objects ) {

			if ( !result.objects[ dd ] ) {

				o = data.objects[ dd ];

				if ( o.geometry !== undefined ) {

					geometry = result.geometries[ o.geometry ];

					// geometry already loaded

					if ( geometry ) {

						var hasNormals = false;

						// not anymore support for multiple materials
						// shouldn't really be array

						for( i = 0; i < o.materials.length; i ++ ) {

							materials = result.materials[ o.materials[ i ] ];

							hasNormals = materials instanceof THREE.ShaderMaterial;

						}

						if ( hasNormals ) {

							geometry.computeTangents();

						}

						p = o.position;
						r = o.rotation;
						q = o.quaternion;
						s = o.scale;

						// turn off quaternions, for the moment

						q = 0;

						if ( materials.length == 0 ) {

							materials = new THREE.MeshFaceMaterial();

						}

						// dirty hack to handle meshes with multiple materials
						// just use face materials defined in model

						if ( materials.length > 1 ) {

							materials = new THREE.MeshFaceMaterial();

						}

						object = new THREE.Mesh( geometry, materials );
						object.name = dd;
						object.position.set( p[0], p[1], p[2] );

						if ( q ) {

							object.quaternion.set( q[0], q[1], q[2], q[3] );
							object.useQuaternion = true;

						} else {

							object.rotation.set( r[0], r[1], r[2] );

						}

						object.scale.set( s[0], s[1], s[2] );
						object.visible = o.visible;

						result.scene.add( object );

						result.objects[ dd ] = object;

						if ( o.meshCollider ) {

							var meshCollider = THREE.CollisionUtils.MeshColliderWBox( object );
							result.scene.collisions.colliders.push( meshCollider );

						}

						if ( o.castsShadow ) {

							//object.visible = true;
							//object.materials = [ new THREE.MeshBasicMaterial( { color: 0xff0000 } ) ];

							var shadow = new THREE.ShadowVolume( geometry )
							result.scene.add( shadow );

							shadow.position = object.position;
							shadow.rotation = object.rotation;
							shadow.scale = object.scale;

						}

						if ( o.trigger && o.trigger.toLowerCase() != "none" ) {

							var trigger = {
							"type" 		: o.trigger,
							"object"	: o
							};

							result.triggers[ object.name ] = trigger;

						}

					}

				// pure Object3D

				} else {

					p = o.position;
					r = o.rotation;
					q = o.quaternion;
					s = o.scale;

					// turn off quaternions, for the moment

					q = 0;

					object = new THREE.Object3D();
					object.name = dd;
					object.position.set( p[0], p[1], p[2] );

					if ( q ) {

						object.quaternion.set( q[0], q[1], q[2], q[3] );
						object.useQuaternion = true;

					} else {

						object.rotation.set( r[0], r[1], r[2] );

					}

					object.scale.set( s[0], s[1], s[2] );
					object.visible = ( o.visible !== undefined ) ? o.visible : false;

					result.scene.add( object );

					result.objects[ dd ] = object;
					result.empties[ dd ] = object;

					if ( o.trigger && o.trigger.toLowerCase() != "none" ) {

						var trigger = {
						"type" 		: o.trigger,
						"object"	: o
						};

						result.triggers[ object.name ] = trigger;

					}

				}

			}

		}

	};

	function handle_mesh( geo, id ) {

		result.geometries[ id ] = geo;
		handle_objects();

	};

	function create_callback( id ) {

		return function( geo ) {

			handle_mesh( geo, id );

			counter_models -= 1;

			scope.onLoadComplete();

			async_callback_gate();

		}

	};

	function create_callback_embed( id ) {

		return function( geo ) {

			result.geometries[ id ] = geo;

		}

	};

	function async_callback_gate() {

		var progress = {

			totalModels		: total_models,
			totalTextures	: total_textures,
			loadedModels	: total_models - counter_models,
			loadedTextures	: total_textures - counter_textures

		};

		scope.callbackProgress( progress, result );

		scope.onLoadProgress();

		if( counter_models == 0 && counter_textures == 0 ) {

			callbackFinished( result );

		}

	};

	var callbackTexture = function( images ) {

		counter_textures -= 1;
		async_callback_gate();

		scope.onLoadComplete();

	};

	// first go synchronous elements

	// cameras

	for( dc in data.cameras ) {

		c = data.cameras[ dc ];

		if ( c.type == "perspective" ) {

			camera = new THREE.PerspectiveCamera( c.fov, c.aspect, c.near, c.far );

		} else if ( c.type == "ortho" ) {

			camera = new THREE.OrthographicCamera( c.left, c.right, c.top, c.bottom, c.near, c.far );

		}

		p = c.position;
		t = c.target;
		camera.position.set( p[0], p[1], p[2] );
		camera.target = new THREE.Vector3( t[0], t[1], t[2] );

		result.cameras[ dc ] = camera;

	}

	// lights

	var hex, intensity;

	for ( dl in data.lights ) {

		l = data.lights[ dl ];

		hex = ( l.color !== undefined ) ? l.color : 0xffffff;
		intensity = ( l.intensity !== undefined ) ? l.intensity : 1;

		if ( l.type == "directional" ) {

			p = l.direction;

			light = new THREE.DirectionalLight( hex, intensity );
			light.position.set( p[0], p[1], p[2] );
			light.position.normalize();

		} else if ( l.type == "point" ) {

			p = l.position;
			d = l.distance;

			light = new THREE.PointLight( hex, intensity, d );
			light.position.set( p[0], p[1], p[2] );

		} else if ( l.type == "ambient" ) {

			light = new THREE.AmbientLight( hex );

		}

		result.scene.add( light );

		result.lights[ dl ] = light;

	}

	// fogs

	for( df in data.fogs ) {

		f = data.fogs[ df ];

		if ( f.type == "linear" ) {

			fog = new THREE.Fog( 0x000000, f.near, f.far );

		} else if ( f.type == "exp2" ) {

			fog = new THREE.FogExp2( 0x000000, f.density );

		}

		c = f.color;
		fog.color.setRGB( c[0], c[1], c[2] );

		result.fogs[ df ] = fog;

	}

	// defaults

	if ( result.cameras && data.defaults.camera ) {

		result.currentCamera = result.cameras[ data.defaults.camera ];

	}

	if ( result.fogs && data.defaults.fog ) {

		result.scene.fog = result.fogs[ data.defaults.fog ];

	}

	c = data.defaults.bgcolor;
	result.bgColor = new THREE.Color();
	result.bgColor.setRGB( c[0], c[1], c[2] );

	result.bgColorAlpha = data.defaults.bgalpha;

	// now come potentially asynchronous elements

	// geometries

	// count how many models will be loaded asynchronously

	for( dg in data.geometries ) {

		g = data.geometries[ dg ];

		if ( g.type == "bin_mesh" || g.type == "ascii_mesh" ) {

			counter_models += 1;

			scope.onLoadStart();

		}

	}

	total_models = counter_models;

	for ( dg in data.geometries ) {

		g = data.geometries[ dg ];

		if ( g.type == "cube" ) {

			geometry = new THREE.CubeGeometry( g.width, g.height, g.depth, g.segmentsWidth, g.segmentsHeight, g.segmentsDepth, null, g.flipped, g.sides );
			result.geometries[ dg ] = geometry;

		} else if ( g.type == "plane" ) {

			geometry = new THREE.PlaneGeometry( g.width, g.height, g.segmentsWidth, g.segmentsHeight );
			result.geometries[ dg ] = geometry;

		} else if ( g.type == "sphere" ) {

			geometry = new THREE.SphereGeometry( g.radius, g.segmentsWidth, g.segmentsHeight );
			result.geometries[ dg ] = geometry;

		} else if ( g.type == "cylinder" ) {

			geometry = new THREE.CylinderGeometry( g.topRad, g.botRad, g.height, g.radSegs, g.heightSegs );
			result.geometries[ dg ] = geometry;

		} else if ( g.type == "torus" ) {

			geometry = new THREE.TorusGeometry( g.radius, g.tube, g.segmentsR, g.segmentsT );
			result.geometries[ dg ] = geometry;

		} else if ( g.type == "icosahedron" ) {

			geometry = new THREE.IcosahedronGeometry( g.subdivisions );
			result.geometries[ dg ] = geometry;

		} else if ( g.type == "bin_mesh" ) {

			binLoader.load( get_url( g.url, data.urlBaseType ), create_callback( dg ) );

		} else if ( g.type == "ascii_mesh" ) {

			jsonLoader.load( get_url( g.url, data.urlBaseType ), create_callback( dg ) );

		} else if ( g.type == "embedded_mesh" ) {

			var modelJson = data.embeds[ g.id ],
				texture_path = "";

			if ( modelJson ) {

				jsonLoader.createModel( modelJson, create_callback_embed( dg ), texture_path );

			}

		}

	}

	// textures

	// count how many textures will be loaded asynchronously

	for( dt in data.textures ) {

		tt = data.textures[ dt ];

		if( tt.url instanceof Array ) {

			counter_textures += tt.url.length;

			for( var n = 0; n < tt.url.length; n ++ ) {

				scope.onLoadStart();

			}

		} else {

			counter_textures += 1;

			scope.onLoadStart();

		}

	}

	total_textures = counter_textures;

	for( dt in data.textures ) {

		tt = data.textures[ dt ];

		if ( tt.mapping != undefined && THREE[ tt.mapping ] != undefined  ) {

			tt.mapping = new THREE[ tt.mapping ]();

		}

		if( tt.url instanceof Array ) {

			var url_array = [];

			for( var i = 0; i < tt.url.length; i ++ ) {

				url_array[ i ] = get_url( tt.url[ i ], data.urlBaseType );

			}

			texture = THREE.ImageUtils.loadTextureCube( url_array, tt.mapping, callbackTexture );

		} else {

			texture = THREE.ImageUtils.loadTexture( get_url( tt.url, data.urlBaseType ), tt.mapping, callbackTexture );

			if ( THREE[ tt.minFilter ] != undefined )
				texture.minFilter = THREE[ tt.minFilter ];

			if ( THREE[ tt.magFilter ] != undefined )
				texture.magFilter = THREE[ tt.magFilter ];


			if ( tt.repeat ) {

				texture.repeat.set( tt.repeat[ 0 ], tt.repeat[ 1 ] );

				if ( tt.repeat[ 0 ] != 1 ) texture.wrapS = THREE.RepeatWrapping;
				if ( tt.repeat[ 1 ] != 1 ) texture.wrapT = THREE.RepeatWrapping;

			}

			if ( tt.offset ) {

				texture.offset.set( tt.offset[ 0 ], tt.offset[ 1 ] );

			}

			// handle wrap after repeat so that default repeat can be overriden

			if ( tt.wrap ) {

				var wrapMap = {
				"repeat" 	: THREE.RepeatWrapping,
				"mirror"	: THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ tt.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ tt.wrap[ 0 ] ];
				if ( wrapMap[ tt.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ tt.wrap[ 1 ] ];

			}

		}

		result.textures[ dt ] = texture;

	}

	// materials

	for ( dm in data.materials ) {

		m = data.materials[ dm ];

		for ( pp in m.parameters ) {

			if ( pp == "envMap" || pp == "map" || pp == "lightMap" ) {

				m.parameters[ pp ] = result.textures[ m.parameters[ pp ] ];

			} else if ( pp == "shading" ) {

				m.parameters[ pp ] = ( m.parameters[ pp ] == "flat" ) ? THREE.FlatShading : THREE.SmoothShading;

			} else if ( pp == "blending" ) {

				m.parameters[ pp ] = THREE[ m.parameters[ pp ] ] ? THREE[ m.parameters[ pp ] ] : THREE.NormalBlending;

			} else if ( pp == "combine" ) {

				m.parameters[ pp ] = ( m.parameters[ pp ] == "MixOperation" ) ? THREE.MixOperation : THREE.MultiplyOperation;

			} else if ( pp == "vertexColors" ) {

				if ( m.parameters[ pp ] == "face" ) {

					m.parameters[ pp ] = THREE.FaceColors;

				// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false

				} else if ( m.parameters[ pp ] )   {

					m.parameters[ pp ] = THREE.VertexColors;

				}

			}

		}

		if ( m.parameters.opacity !== undefined && m.parameters.opacity < 1.0 ) {

			m.parameters.transparent = true;

		}

		if ( m.parameters.normalMap ) {

			var shader = THREE.ShaderUtils.lib[ "normal" ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			var diffuse = m.parameters.color;
			var specular = m.parameters.specular;
			var ambient = m.parameters.ambient;
			var shininess = m.parameters.shininess;

			uniforms[ "tNormal" ].texture = result.textures[ m.parameters.normalMap ];

			if ( m.parameters.normalMapFactor ) {

				uniforms[ "uNormalScale" ].value = m.parameters.normalMapFactor;

			}

			if ( m.parameters.map ) {

				uniforms[ "tDiffuse" ].texture = m.parameters.map;
				uniforms[ "enableDiffuse" ].value = true;

			}

			if ( m.parameters.lightMap ) {

				uniforms[ "tAO" ].texture = m.parameters.lightMap;
				uniforms[ "enableAO" ].value = true;

			}

			if ( m.parameters.specularMap ) {

				uniforms[ "tSpecular" ].texture = result.textures[ m.parameters.specularMap ];
				uniforms[ "enableSpecular" ].value = true;

			}

			uniforms[ "uDiffuseColor" ].value.setHex( diffuse );
			uniforms[ "uSpecularColor" ].value.setHex( specular );
			uniforms[ "uAmbientColor" ].value.setHex( ambient );

			uniforms[ "uShininess" ].value = shininess;

			if ( m.parameters.opacity ) {

				uniforms[ "uOpacity" ].value = m.parameters.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };

			material = new THREE.ShaderMaterial( parameters );

		} else {

			material = new THREE[ m.type ]( m.parameters );

		}

		result.materials[ dm ] = material;

	}

	// objects ( synchronous init of procedural primitives )

	handle_objects();

	// synchronous callback

	scope.callbackSync( result );

	// just in case there are no async elements:
	async_callback_gate();


};
/**
 * Loader for UTF8 encoded models generated by:
 *	http://code.google.com/p/webgl-loader/
 *
 * Limitations:
 *  - number of vertices < 65536 (this is after optimizations in compressor, input OBJ may have even less)
 *	- models must have normals and texture coordinates
 *  - texture coordinates must be only from <0,1>
 *  - no materials support yet
 *  - models are scaled and offset (copy numbers from compressor and use them as parameters in UTF8Loader.load() )
 *
 * @author alteredq / http://alteredqualia.com/
 * @author won3d / http://twitter.com/won3d
 */

THREE.UTF8Loader = function ( ) {

};

THREE.UTF8Loader.prototype = new THREE.UTF8Loader();
THREE.UTF8Loader.prototype.constructor = THREE.UTF8Loader;


// Load UTF8 compressed models generated by objcompress
//  - parameters
//		- url (required)
//		- callback (required)
//		- metaData (optional)

THREE.UTF8Loader.prototype.load = function( url, callback, metaData ) {

	if ( url instanceof Object ) {

		console.warn( 'DEPRECATED: UTF8Loader( parameters ) is now UTF8Loader( url, callback, metaData ).' );

		var parameters = url;

		url = parameters.model;
		callback = parameters.callback;
		metaData = { scale: parameters.scale, offsetX: parameters.offsetX, offsetY: parameters.offsetY, offsetZ: parameters.offsetZ };

	}

	var xhr = new XMLHttpRequest(),
		callbackProgress = null,

		scale = metaData.scale !== undefined ? metaData.scale : 1,
		offsetX = metaData.offsetX !== undefined ? metaData.offsetX : 0,
		offsetY = metaData.offsetY !== undefined ? metaData.offsetY : 0,
		offsetZ = metaData.offsetZ !== undefined ? metaData.offsetZ : 0;

	var length = 0;

	xhr.onreadystatechange = function() {

		if ( xhr.readyState == 4 ) {

			if ( xhr.status == 200 || xhr.status == 0 ) {

				THREE.UTF8Loader.prototype.createModel( xhr.responseText, callback, scale, offsetX, offsetY, offsetZ );

			} else {

				alert( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState == 3 ) {

			if ( callbackProgress ) {

				if ( length == 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState == 2 ) {

			length = xhr.getResponseHeader( "Content-Length" );

		}

	}

	xhr.open( "GET", url, true );
	xhr.send( null );

};

// UTF-8 decoder from webgl-loader
// http://code.google.com/p/webgl-loader/

// Copyright 2011 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License. You
// may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

THREE.UTF8Loader.prototype.decompressMesh = function ( str ) {

	var num_verts = str.charCodeAt( 0 );

	if ( num_verts >= 0xE000 ) {

		num_verts -= 0x0800;

	}

	num_verts ++;

	var attribs_out = new Float32Array( 8 * num_verts );

	var offset = 1;

	for ( var i = 0; i < 8; i ++ ) {

		var prev_attrib = 0;

		for ( var j = 0; j < num_verts; ++ j ) {

			var code = str.charCodeAt( j + offset );

			prev_attrib += ( code >> 1 ) ^ ( - ( code & 1 ) );

			attribs_out[ 8 * j + i ] = prev_attrib;

		}

		offset += num_verts;

	}

	var num_indices = str.length - offset;

	var indices_out = new Uint16Array( num_indices );

	var index_high_water_mark = 0;

	for ( var i = 0; i < num_indices; i ++ ) {

		var code = str.charCodeAt( i + offset );

		indices_out[ i ] = index_high_water_mark - code;

		if ( code == 0 ) {

			index_high_water_mark ++;

		}

	}

	return [ attribs_out, indices_out ];

};

THREE.UTF8Loader.prototype.createModel = function ( data, callback, scale, offsetX, offsetY, offsetZ ) {

	var Model = function ( texture_path ) {

		//var s = (new Date).getTime();

		var scope = this;

		scope.materials = [];

		THREE.Geometry.call( this );

		var buffers = THREE.UTF8Loader.prototype.decompressMesh( data );

		var normals = [],
			uvs = [];

		init_vertices( buffers[ 0 ], 8, 0 );
		init_uvs( buffers[ 0 ], 8, 3 );
		init_normals( buffers[ 0 ], 8, 5 );

		init_faces( buffers[ 1 ] );

		this.computeCentroids();
		this.computeFaceNormals();
		//this.computeTangents();

		//var e = (new Date).getTime();

		//console.log( "utf8 data parse time: " + (e-s) + " ms" );

		function init_vertices( data, stride, offset ) {

			var i, x, y, z,
				end = data.length;

			for( i = offset; i < end; i += stride ) {

				x = data[ i ];
				y = data[ i + 1 ];
				z = data[ i + 2 ];

				// fix scale and offsets

				x = ( x / 16383 ) * scale;
				y = ( y / 16383 ) * scale;
				z = ( z / 16383 ) * scale;

				x += offsetX;
				y += offsetY;
				z += offsetZ;

				vertex( scope, x, y, z );

			}

		};

		function init_normals( data, stride, offset ) {

			var i, x, y, z,
				end = data.length;

			for( i = offset; i < end; i += stride ) {

				x = data[ i ];
				y = data[ i + 1 ];
				z = data[ i + 2 ];

				// normalize to <-1,1>

				x = ( x - 512 ) / 511;
				y = ( y - 512 ) / 511;
				z = ( z - 512 ) / 511;

				normals.push( x, y, z );

			}

		};

		function init_uvs( data, stride, offset ) {

			var i, u, v,
				end = data.length;

			for( i = offset; i < end; i += stride ) {

				u = data[ i ];
				v = data[ i + 1 ];

				// normalize to <0,1>

				u /= 1023;
				v /= 1023;

				uvs.push( u, 1 - v );

			}

		};

		function init_faces( indices ) {

			var i,
				a, b, c,
				u1, v1, u2, v2, u3, v3,
				m,
				end = indices.length;

			m = 0; // all faces defaulting to material 0

			for( i = 0; i < end; i += 3 ) {

				a = indices[ i ];
				b = indices[ i + 1 ];
				c = indices[ i + 2 ];

				f3n( scope, normals, a, b, c, m, a, b, c );

				u1 = uvs[ a * 2 ];
				v1 = uvs[ a * 2 + 1 ];

				u2 = uvs[ b * 2 ];
				v2 = uvs[ b * 2 + 1 ];

				u3 = uvs[ c * 2 ];
				v3 = uvs[ c * 2 + 1 ];

				uv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );

			}


		}

	};

	function vertex ( scope, x, y, z ) {

		scope.vertices.push( new THREE.Vertex( new THREE.Vector3( x, y, z ) ) );

	};

	function f3n ( scope, normals, a, b, c, mi, na, nb, nc ) {

		var material = scope.materials[ mi ],

			nax = normals[ na * 3     ],
			nay = normals[ na * 3 + 1 ],
			naz = normals[ na * 3 + 2 ],

			nbx = normals[ nb * 3     ],
			nby = normals[ nb * 3 + 1 ],
			nbz = normals[ nb * 3 + 2 ],

			ncx = normals[ nc * 3     ],
			ncy = normals[ nc * 3 + 1 ],
			ncz = normals[ nc * 3 + 2 ];

		var na = new THREE.Vector3( nax, nay, naz ),
			nb = new THREE.Vector3( nbx, nby, nbz ),
			nc = new THREE.Vector3( ncx, ncy, ncz );

		scope.faces.push( new THREE.Face3( a, b, c, [ na, nb, nc ], null, material ) );

	};

	function uv3 ( where, u1, v1, u2, v2, u3, v3 ) {

		var uv = [];
		uv.push( new THREE.UV( u1, v1 ) );
		uv.push( new THREE.UV( u2, v2 ) );
		uv.push( new THREE.UV( u3, v3 ) );
		where.push( uv );

	};


	Model.prototype = new THREE.Geometry();
	Model.prototype.constructor = Model;

	callback( new Model() );

};
/**
 * @author sroucheray / http://sroucheray.org/
 * @author mr.doob / http://mrdoob.com/
 */

THREE.Axes = function () {

	THREE.Object3D.call( this );

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vertex() );
	lineGeometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 0, 100, 0 ) ) );

	var coneGeometry = new THREE.CylinderGeometry( 0, 5, 25, 5, 1 );

	// x

	var line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0xff0000 } ) );
	line.rotation.z = - Math.PI / 2;
	this.add( line );

	var cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color : 0xff0000 } ) );
	cone.position.x = 100;
	cone.rotation.z = - Math.PI / 2;
	this.add( cone );

	// y

	var line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0x00ff00 } ) );
	this.add( line );

	var cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color : 0x00ff00 } ) );
	cone.position.y = 100;
	this.add( cone );

	// z

	var line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color : 0x0000ff } ) );
	line.rotation.x = Math.PI / 2;
	this.add( line );

	var cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color : 0x0000ff } ) );
	cone.position.z = 100;
	cone.rotation.x = Math.PI / 2;
	this.add( cone );

};

THREE.Axes.prototype = new THREE.Object3D();
THREE.Axes.prototype.constructor = THREE.Axes;
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Port of greggman's ThreeD version of marching cubes to Three.js
 * http://webglsamples.googlecode.com/hg/blob/blob.html
 */

// do not crash if somebody includes the file in oldie browser

THREE.MarchingCubes = function ( resolution, materials ) {

	THREE.Object3D.call( this );

	this.materials = materials instanceof Array ? materials : [ materials ];

	// functions have to be object properties
	// prototype functions kill performance
	// (tested and it was 4x slower !!!)

	this.init = function( resolution ) {

		// parameters

		this.isolation = 80.0;

		// size of field, 32 is pushing it in Javascript :)

		this.size = resolution;
		this.size2 = this.size * this.size;
		this.size3 = this.size2 * this.size;
		this.halfsize = this.size / 2.0;

		// deltas

		this.delta = 2.0 / this.size;
		this.yd = this.size;
		this.zd = this.size2;

		this.field = new Float32Array( this.size3 );
		this.normal_cache = new Float32Array( this.size3 * 3 );

		// temp buffers used in polygonize

		this.vlist = new Float32Array( 12 * 3 );
		this.nlist = new Float32Array( 12 * 3 );

		this.firstDraw = true;

		// immediate render mode simulator

		this.maxCount = 4096; // TODO: find the fastest size for this buffer
		this.count = 0;
		this.hasPos = false;
		this.hasNormal = false;

		this.positionArray = new Float32Array( this.maxCount * 3 );
		this.normalArray   = new Float32Array( this.maxCount * 3 );

	};

	///////////////////////
	// Polygonization
	///////////////////////

	this.lerp = function( a, b, t ) { return a + ( b - a ) * t; };

	this.VIntX = function( q, pout, nout, offset, isol, x, y, z, valp1, valp2 ) {

		var mu = ( isol - valp1 ) / ( valp2 - valp1 ),
		nc = this.normal_cache;

		pout[ offset ] 	   = x + mu * this.delta;
		pout[ offset + 1 ] = y;
		pout[ offset + 2 ] = z;

		nout[ offset ] 	   = this.lerp( nc[ q ],     nc[ q + 3 ], mu );
		nout[ offset + 1 ] = this.lerp( nc[ q + 1 ], nc[ q + 4 ], mu );
		nout[ offset + 2 ] = this.lerp( nc[ q + 2 ], nc[ q + 5 ], mu );

	};

	this.VIntY = function( q, pout, nout, offset, isol, x, y, z, valp1, valp2 ) {

		var mu = ( isol - valp1 ) / ( valp2 - valp1 ),
		nc = this.normal_cache;

		pout[ offset ] 	   = x;
		pout[ offset + 1 ] = y + mu * this.delta;
		pout[ offset + 2 ] = z;

		var q2 = q + this.yd * 3;

		nout[ offset ] 	   = this.lerp( nc[ q ],     nc[ q2 ],     mu );
		nout[ offset + 1 ] = this.lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );
		nout[ offset + 2 ] = this.lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );

	};

	this.VIntZ = function( q, pout, nout, offset, isol, x, y, z, valp1, valp2 ) {

		var mu = ( isol - valp1 ) / ( valp2 - valp1 ),
		nc = this.normal_cache;

		pout[ offset ] 	   = x;
		pout[ offset + 1 ] = y;
		pout[ offset + 2 ] = z + mu * this.delta;

		var q2 = q + this.zd * 3;

		nout[ offset ] 	   = this.lerp( nc[ q ],     nc[ q2 ],     mu );
		nout[ offset + 1 ] = this.lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );
		nout[ offset + 2 ] = this.lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );

	};

	this.compNorm = function( q ) {

		var q3 = q * 3;

		if ( this.normal_cache [ q3 ] === 0.0 ) {

			this.normal_cache[ q3     ] = this.field[ q - 1  ] 	    - this.field[ q + 1 ];
			this.normal_cache[ q3 + 1 ] = this.field[ q - this.yd ] - this.field[ q + this.yd ];
			this.normal_cache[ q3 + 2 ] = this.field[ q - this.zd ] - this.field[ q + this.zd ];

		}

	};

	// Returns total number of triangles. Fills triangles.
	// (this is where most of time is spent - it's inner work of O(n3) loop )

	this.polygonize = function( fx, fy, fz, q, isol, render_callback ) {

		// cache indices
		var q1 = q + 1,
			qy = q + this.yd,
			qz = q + this.zd,
			q1y = q1 + this.yd,
			q1z = q1 + this.zd,
			qyz = q + this.yd + this.zd,
			q1yz = q1 + this.yd + this.zd;

		var cubeindex = 0,
			field0 = this.field[ q ],
			field1 = this.field[ q1 ],
			field2 = this.field[ qy ],
			field3 = this.field[ q1y ],
			field4 = this.field[ qz ],
			field5 = this.field[ q1z ],
			field6 = this.field[ qyz ],
			field7 = this.field[ q1yz ];

		if ( field0 < isol ) cubeindex |= 1;
		if ( field1 < isol ) cubeindex |= 2;
		if ( field2 < isol ) cubeindex |= 8;
		if ( field3 < isol ) cubeindex |= 4;
		if ( field4 < isol ) cubeindex |= 16;
		if ( field5 < isol ) cubeindex |= 32;
		if ( field6 < isol ) cubeindex |= 128;
		if ( field7 < isol ) cubeindex |= 64;

		// if cube is entirely in/out of the surface - bail, nothing to draw

		var bits = THREE.edgeTable[ cubeindex ];
		if ( bits === 0 ) return 0;

		var d = this.delta,
			fx2 = fx + d,
			fy2 = fy + d,
			fz2 = fz + d;

		// top of the cube

		if ( bits & 1 ) {

			this.compNorm( q );
			this.compNorm( q1 );
			this.VIntX( q * 3, this.vlist, this.nlist, 0, isol, fx, fy, fz, field0, field1 );

		};

		if ( bits & 2 ) {

			this.compNorm( q1 );
			this.compNorm( q1y );
			this.VIntY( q1 * 3, this.vlist, this.nlist, 3, isol, fx2, fy, fz, field1, field3 );

		};

		if ( bits & 4 ) {

			this.compNorm( qy );
			this.compNorm( q1y );
			this.VIntX( qy * 3, this.vlist, this.nlist, 6, isol, fx, fy2, fz, field2, field3 );

		};

		if ( bits & 8 ) {

			this.compNorm( q );
			this.compNorm( qy );
			this.VIntY( q * 3, this.vlist, this.nlist, 9, isol, fx, fy, fz, field0, field2 );

		};

		// bottom of the cube

		if ( bits & 16 )  {

			this.compNorm( qz );
			this.compNorm( q1z );
			this.VIntX( qz * 3, this.vlist, this.nlist, 12, isol, fx, fy, fz2, field4, field5 );

		};

		if ( bits & 32 )  {

			this.compNorm( q1z );
			this.compNorm( q1yz );
			this.VIntY( q1z * 3,  this.vlist, this.nlist, 15, isol, fx2, fy, fz2, field5, field7 );

		};

		if ( bits & 64 ) {

			this.compNorm( qyz );
			this.compNorm( q1yz );
			this.VIntX( qyz * 3, this.vlist, this.nlist, 18, isol, fx, fy2, fz2, field6, field7 );

		};

		if ( bits & 128 ) {

			this.compNorm( qz );
			this.compNorm( qyz );
			this.VIntY( qz * 3,  this.vlist, this.nlist, 21, isol, fx, fy, fz2, field4, field6 );

		};

		// vertical lines of the cube

		if ( bits & 256 ) {

			this.compNorm( q );
			this.compNorm( qz );
			this.VIntZ( q * 3, this.vlist, this.nlist, 24, isol, fx, fy, fz, field0, field4 );

		};

		if ( bits & 512 ) {

			this.compNorm( q1 );
			this.compNorm( q1z );
			this.VIntZ( q1 * 3,  this.vlist, this.nlist, 27, isol, fx2, fy,  fz, field1, field5 );

		};

		if ( bits & 1024 ) {

			this.compNorm( q1y );
			this.compNorm( q1yz );
			this.VIntZ( q1y * 3, this.vlist, this.nlist, 30, isol, fx2, fy2, fz, field3, field7 );

		};

		if ( bits & 2048 ) {

			this.compNorm( qy );
			this.compNorm( qyz );
			this.VIntZ( qy * 3, this.vlist, this.nlist, 33, isol, fx,  fy2, fz, field2, field6 );

		};

		cubeindex <<= 4;  // re-purpose cubeindex into an offset into triTable

		var o1, o2, o3, numtris = 0, i = 0;

		// here is where triangles are created

		while ( THREE.triTable[ cubeindex + i ] != -1 ) {

			o1 = cubeindex + i;
			o2 = o1 + 1;
			o3 = o1 + 2;

			this.posnormtriv( this.vlist, this.nlist,
							  3 * THREE.triTable[ o1 ],
							  3 * THREE.triTable[ o2 ],
							  3 * THREE.triTable[ o3 ],
							  render_callback );

			i += 3;
			numtris ++;

		}

		return numtris;

	};

	/////////////////////////////////////
	// Immediate render mode simulator
	/////////////////////////////////////

	this.posnormtriv = function( pos, norm, o1, o2, o3, render_callback ) {

		var c = this.count * 3;

		this.positionArray[ c ] = pos[ o1 ];
		this.positionArray[ c + 1 ] = pos[ o1 + 1 ];
		this.positionArray[ c + 2 ] = pos[ o1 + 2 ];

		this.positionArray[ c + 3 ] = pos[ o2 ];
		this.positionArray[ c + 4 ] = pos[ o2 + 1 ];
		this.positionArray[ c + 5 ] = pos[ o2 + 2 ];

		this.positionArray[ c + 6 ] = pos[ o3 ];
		this.positionArray[ c + 7 ] = pos[ o3 + 1 ];
		this.positionArray[ c + 8 ] = pos[ o3 + 2 ];

		this.normalArray[ c ] = norm[ o1 ];
		this.normalArray[ c + 1 ] = norm[ o1 + 1 ];
		this.normalArray[ c + 2 ] = norm[ o1 + 2 ];

		this.normalArray[ c + 3 ] = norm[ o2 ];
		this.normalArray[ c + 4 ] = norm[ o2 + 1 ];
		this.normalArray[ c + 5 ] = norm[ o2 + 2 ];

		this.normalArray[ c + 6 ] = norm[ o3 ];
		this.normalArray[ c + 7 ] = norm[ o3 + 1 ];
		this.normalArray[ c + 8 ] = norm[ o3 + 2 ];

		this.hasPos = true;
		this.hasNormal = true;

		this.count += 3;

		if ( this.count >= this.maxCount - 3 ) {

			render_callback( this );

		}

	};

	this.begin = function( ) {

		this.count = 0;
		this.hasPos = false;
		this.hasNormal = false;

	};

	this.end = function( render_callback ) {

		if ( this.count === 0 )
			return;

		for ( var i = this.count * 3; i < this.positionArray.length; i++ )
			this.positionArray[ i ] = 0.0;

		render_callback( this );

	};

	/////////////////////////////////////
	// Metaballs
	/////////////////////////////////////

	// Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after
	// a fixed distance, determined by strength and subtract.

	this.addBall = function( ballx, bally, ballz, strength, subtract ) {

		// Let's solve the equation to find the radius:
		// 1.0 / (0.000001 + radius^2) * strength - subtract = 0
		// strength / (radius^2) = subtract
		// strength = subtract * radius^2
		// radius^2 = strength / subtract
		// radius = sqrt(strength / subtract)

		var radius = this.size * Math.sqrt( strength / subtract ),
			zs = ballz * this.size,
			ys = bally * this.size,
			xs = ballx * this.size;

		var min_z = Math.floor( zs - radius ); if ( min_z < 1 ) min_z = 1;
		var max_z = Math.floor( zs + radius ); if ( max_z > this.size - 1 ) max_z = this.size - 1;
		var min_y = Math.floor( ys - radius ); if ( min_y < 1 ) min_y = 1;
		var max_y = Math.floor( ys + radius ); if ( max_y > this.size - 1 ) max_y = this.size - 1;
		var min_x = Math.floor( xs - radius ); if ( min_x < 1  ) min_x = 1;
		var max_x = Math.floor( xs + radius ); if ( max_x > this.size - 1 ) max_x = this.size - 1;


		// Don't polygonize in the outer layer because normals aren't
		// well-defined there.

		var x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;

		for ( z = min_z; z < max_z; z++ ) {

			z_offset = this.size2 * z,
			fz = z / this.size - ballz,
			fz2 = fz * fz;

			for ( y = min_y; y < max_y; y++ ) {

				y_offset = z_offset + this.size * y;
				fy = y / this.size - bally;
				fy2 = fy * fy;

				for ( x = min_x; x < max_x; x++ ) {

					fx = x / this.size - ballx;
					val = strength / ( 0.000001 + fx*fx + fy2 + fz2 ) - subtract;
					if ( val > 0.0 ) this.field[ y_offset + x ] += val;

				}

			}

		}

	};

	this.addPlaneX = function( strength, subtract ) {

		var x, y, z, xx, val, xdiv, cxy,

			// cache attribute lookups
			size = this.size,
			yd = this.yd,
			zd = this.zd,
			field = this.field,

			dist = size * Math.sqrt( strength / subtract );

		if ( dist > size ) dist = size;

		for ( x = 0; x < dist; x++ ) {

			xdiv = x / size;
			xx = xdiv * xdiv;
			val = strength / ( 0.0001 + xx ) - subtract;

			if ( val > 0.0 ) {

				for ( y = 0; y < size; y++ ) {

					cxy = x + y * yd;

					for ( z = 0; z < size; z++ ) {

						field[ zd * z + cxy ] += val;

					}

				}

			}

		}

	};

	this.addPlaneY = function( strength, subtract ) {

		var x, y, z, yy, val, ydiv, cy, cxy,

			// cache attribute lookups
			size = this.size,
			yd = this.yd,
			zd = this.zd,
			field = this.field,

			dist = size * Math.sqrt( strength / subtract );

		if ( dist > size ) dist = size;

		for ( y = 0; y < dist; y++ ) {

			ydiv = y / size;
			yy = ydiv * ydiv;
			val = strength / ( 0.0001 + yy ) - subtract;

			if ( val > 0.0 ) {

				cy = y * yd;

				for ( x = 0; x < size; x++ ) {

					cxy = cy + x;

					for ( z = 0; z < size; z++ )
						field[ zd * z + cxy ] += val;

				}

			}

		}

	};

	this.addPlaneZ = function( strength, subtract ) {

		var x, y, z, zz, val, zdiv, cz, cyz,

			// cache attribute lookups
			size = this.size,
			yd = this.yd,
			zd = this.zd,
			field = this.field,

			dist = size * Math.sqrt( strength / subtract );

		if ( dist > size ) dist = size;

		for ( z = 0; z < dist; z++ ) {

			zdiv = z / size;
			zz = zdiv * zdiv;
			val = strength / ( 0.0001 + zz ) - subtract;
			if ( val > 0.0 ) {

				cz = zd * z;

				for ( y = 0; y < size; y++ ) {

						cyz = cz + y * yd;

						for ( x = 0; x < size; x++ )
							field[ cyz + x ] += val;

				}

			}

		}

	};

	/////////////////////////////////////
	// Updates
	/////////////////////////////////////

	this.reset = function() {

		var i;

		// wipe the normal cache

		for ( i = 0; i < this.size3; i++ ) {

			this.normal_cache[ i * 3 ] = 0.0;
			this.field[ i ] = 0.0;

		}

	};

	this.render = function( render_callback ) {

		this.begin();

		// Triangulate. Yeah, this is slow.

		var q, x, y, z, fx, fy, fz, y_offset, z_offset, smin2 = this.size - 2;

		for ( z = 1; z < smin2; z++ ) {

			z_offset = this.size2 * z;
			fz = ( z - this.halfsize ) / this.halfsize; //+ 1

			for ( y = 1; y < smin2; y++ ) {

				y_offset = z_offset + this.size * y;
				fy = ( y - this.halfsize ) / this.halfsize; //+ 1

				for ( x = 1; x < smin2; x++ ) {

					fx = ( x - this.halfsize ) / this.halfsize; //+ 1
					q = y_offset + x;

					this.polygonize( fx, fy, fz, q, this.isolation, render_callback );

				}

			}

		}

		this.end( render_callback );

	};

	this.generateGeometry = function() {

		var start = 0, geo = new THREE.Geometry();
		var normals = [];

		var geo_callback = function( object ) {

			var i, x, y, z, vertex, position, normal,
				face, a, b, c, na, nb, nc, nfaces;


			for ( i = 0; i < object.count; i++ ) {

				a = i * 3;
				b = a + 1;
				c = a + 2;

				x = object.positionArray[ a ];
				y = object.positionArray[ b ];
				z = object.positionArray[ c ];
				position = new THREE.Vector3( x, y, z );

				x = object.normalArray[ a ];
				y = object.normalArray[ b ];
				z = object.normalArray[ c ];
				normal = new THREE.Vector3( x, y, z );
				normal.normalize();

				vertex = new THREE.Vertex( position );

				geo.vertices.push( vertex );
				normals.push( normal );

			}

			nfaces = object.count / 3;

			for ( i = 0; i < nfaces; i++ ) {

				a = ( start + i ) * 3;
				b = a + 1;
				c = a + 2;

				na = normals[ a ];
				nb = normals[ b ];
				nc = normals[ c ];

				face = new THREE.Face3( a, b, c, [ na, nb, nc ] );

				geo.faces.push( face );

			}

			start += nfaces;
			object.count = 0;

		};

		this.render( geo_callback );

		// console.log( "generated " + geo.faces.length + " triangles" );

		return geo;

	};

	this.init( resolution );

};

THREE.MarchingCubes.prototype = new THREE.Object3D();
THREE.MarchingCubes.prototype.constructor = THREE.MarchingCubes;


/////////////////////////////////////
// Marching cubes lookup tables
/////////////////////////////////////

// These tables are straight from Paul Bourke's page:
// http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/
// who in turn got them from Cory Gene Bloyd.

THREE.edgeTable = new Int32Array([
0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0])

THREE.triTable = new Int32Array([
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1,
3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1,
3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1,
3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1,
9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1,
9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1,
8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1,
9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1,
3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1,
1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1,
4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1,
4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1,
9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1,
2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1,
9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1,
10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1,
4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1,
5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1,
5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1,
9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1,
0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1,
1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1,
10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1,
8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1,
2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1,
7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1,
9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1,
2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1,
11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1,
9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1,
5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1,
11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1,
11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1,
9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1,
5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1,
2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1,
6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1,
0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1,
3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1,
6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1,
5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1,
1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1,
6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1,
1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1,
8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1,
7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1,
3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1,
0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1,
9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1,
8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1,
5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1,
0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1,
6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,
10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1,
10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1,
8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1,
3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1,
0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,
10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1,
0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1,
3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1,
6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1,
9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1,
8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1,
3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1,
6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1,
0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1,
10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1,
10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1,
1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1,
2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1,
7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1,
7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1,
2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1,
1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1,
11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1,
8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1,
0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1,
7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1,
7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1,
2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1,
1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1,
10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1,
10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1,
0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1,
7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1,
6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1,
8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1,
9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1,
6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1,
4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1,
10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1,
8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1,
0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1,
1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,
8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1,
10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1,
4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1,
10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1,
9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1,
7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1,
3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1,
7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1,
9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1,
3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1,
6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1,
9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1,
1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1,
4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1,
7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1,
6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1,
3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1,
0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1,
6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1,
0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1,
11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1,
6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1,
5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1,
9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1,
1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1,
1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1,
10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1,
0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1,
5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1,
10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1,
11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1,
9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1,
7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1,
2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1,
8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1,
9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1,
9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1,
1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1,
9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1,
9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1,
5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1,
0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1,
10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1,
2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1,
0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1,
0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1,
9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1,
5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1,
3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1,
5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1,
8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1,
0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1,
9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1,
1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1,
3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1,
4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1,
9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1,
11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1,
11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1,
2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1,
9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1,
3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1,
1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1,
4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1,
4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1,
0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1,
3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1,
3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1,
0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1,
9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1,
1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);
/**
 * @author mrdoob / http://mrdoob.com/
 * @author marklundin / http://mark-lundin.com/
 * @author alteredq / http://alteredqualia.com/
 */

if ( THREE.WebGLRenderer ) {

	THREE.AnaglyphWebGLRenderer = function ( parameters ) {

		THREE.WebGLRenderer.call( this, parameters );

		this.autoUpdateScene = false;

		var _this = this, _setSize = this.setSize, _render = this.render;

		var _cameraL = new THREE.PerspectiveCamera(),
			_cameraR = new THREE.PerspectiveCamera();

		var eyeRight = new THREE.Matrix4(),
			eyeLeft = new THREE.Matrix4(),
			focalLength = 125,
			_aspect, _near, _far, _fov;

		_cameraL.matrixAutoUpdate = _cameraR.matrixAutoUpdate = false;

		var _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

		var _renderTargetL = new THREE.WebGLRenderTarget( 512, 512, _params ),
			_renderTargetR = new THREE.WebGLRenderTarget( 512, 512, _params );

		var _camera = new THREE.PerspectiveCamera( 53, 1, 1, 10000 );
		_camera.position.z = 2;

		var _material = new THREE.ShaderMaterial( {

			uniforms: {

				"mapLeft": { type: "t", value: 0, texture: _renderTargetL },
				"mapRight": { type: "t", value: 1, texture: _renderTargetR }

			},

			vertexShader: [

				"varying vec2 vUv;",

				"void main() {",

					"vUv = vec2( uv.x, 1.0 - uv.y );",
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform sampler2D mapLeft;",
				"uniform sampler2D mapRight;",
				"varying vec2 vUv;",

				"void main() {",

					"vec4 colorL, colorR;",
					"vec2 uv = vUv;",

					"colorL = texture2D( mapLeft, uv );",
					"colorR = texture2D( mapRight, uv );",

					// http://3dtv.at/Knowhow/AnaglyphComparison_en.aspx

					"gl_FragColor = vec4( colorL.g * 0.7 + colorL.b * 0.3, colorR.g, colorR.b, colorL.a + colorR.a ) * 1.1;",

				"}"

				].join("\n")

		} );

		var _scene = new THREE.Scene();
		_scene.add( new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), _material ) );

		_scene.add( _camera );

		this.setSize = function ( width, height ) {

			_setSize.call( _this, width, height );

			_renderTargetL.width = width;
			_renderTargetL.height = height;

			_renderTargetR.width = width;
			_renderTargetR.height = height;

		};

		/*
		 * Renderer now uses an asymmetric perspective projection (http://paulbourke.net/miscellaneous/stereographics/stereorender/).
		 * Each camera is offset by the eye seperation and its projection matrix is also skewed asymetrically back to converge on the same
		 * projection plane. Added a focal length parameter to, this is where the parallax is equal to 0.
		 */

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			scene.updateMatrixWorld();

			var hasCameraChanged = ( _aspect !== camera.aspect ) || ( _near !== camera.near ) || ( _far !== camera.far ) || ( _fov !== camera.fov );

			if( hasCameraChanged ) {

				_aspect = camera.aspect;
				_near = camera.near;
				_far = camera.far;
				_fov = camera.fov;

				var projectionMatrix = camera.projectionMatrix.clone(),
					eyeSep = focalLength / 30 * 0.5,
					eyeSepOnProjection = eyeSep * _near / focalLength,
					ymax = _near * Math.tan( _fov * Math.PI / 360 ),
					xmin, xmax;

				// translate xOffset

				eyeRight.n14 = eyeSep;
				eyeLeft.n14 = -eyeSep;

				// for left eye

				xmin = -ymax * _aspect + eyeSepOnProjection;
				xmax = ymax * _aspect + eyeSepOnProjection;

				projectionMatrix.n11 = 2 * _near / ( xmax - xmin );
				projectionMatrix.n13 = ( xmax + xmin ) / ( xmax - xmin );

				_cameraL.projectionMatrix.copy( projectionMatrix );

				// for right eye

				xmin = -ymax * _aspect - eyeSepOnProjection;
				xmax = ymax * _aspect - eyeSepOnProjection;

				projectionMatrix.n11 = 2 * _near / ( xmax - xmin );
				projectionMatrix.n13 = ( xmax + xmin ) / ( xmax - xmin );

				_cameraR.projectionMatrix.copy( projectionMatrix );

			}

			_cameraL.matrixWorld.copy( camera.matrixWorld ).multiplySelf( eyeLeft );
			_cameraL.position.copy( camera.position );
			_cameraL.near = camera.near;
			_cameraL.far = camera.far;

			_render.call( _this, scene, _cameraL, _renderTargetL, true );

			_cameraR.matrixWorld.copy( camera.matrixWorld ).multiplySelf( eyeRight );
			_cameraR.position.copy( camera.position );
			_cameraR.near = camera.near;
			_cameraR.far = camera.far;

			_render.call( _this, scene, _cameraR, _renderTargetR, true );

			_scene.updateMatrixWorld();
			_render.call( _this, _scene, _camera );

		};

	};

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

if ( THREE.WebGLRenderer ) {

	THREE.CrosseyedWebGLRenderer = function ( parameters ) {

		THREE.WebGLRenderer.call( this, parameters );

		this.autoClear = false;

		var _this = this, _setSize = this.setSize, _render = this.render;

		var _width, _height;

		var _cameraL = new THREE.PerspectiveCamera();
		_cameraL.target = new THREE.Vector3( 0, 0, 0 );

		var _cameraR = new THREE.PerspectiveCamera();
		_cameraR.target = new THREE.Vector3( 0, 0, 0 );

		_this.separation = 10;
		if ( parameters && parameters.separation !== undefined ) _this.separation = parameters.separation;

		var SCREEN_WIDTH  = window.innerWidth;
		var SCREEN_HEIGHT = window.innerHeight;
		var HALF_WIDTH = SCREEN_WIDTH / 2;

		this.setSize = function ( width, height ) {

			_setSize.call( _this, width, height );

			_width = width/2;
			_height = height;

		};

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			this.clear();

			_cameraL.fov = camera.fov;
			_cameraL.aspect = 0.5 * camera.aspect;
			_cameraL.near = camera.near;
			_cameraL.far = camera.far;
			_cameraL.updateProjectionMatrix();

			_cameraL.position.copy( camera.position );
			_cameraL.target.copy( camera.target );
			_cameraL.translateX( _this.separation );
			_cameraL.lookAt( _cameraL.target );

			_cameraR.projectionMatrix = _cameraL.projectionMatrix;

			_cameraR.position.copy( camera.position );
			_cameraR.target.copy( camera.target );
			_cameraR.translateX( - _this.separation );
			_cameraR.lookAt( _cameraR.target );

			this.setViewport( 0, 0, _width, _height );
			_render.call( _this, scene, _cameraL );

			this.setViewport( _width, 0, _width, _height );
			_render.call( _this, scene, _cameraR, false );

		};

	};

}

; browserify_shim__define__module__export__(typeof THREE != "undefined" ? THREE : window.THREE);

}).call(global, undefined, undefined, function defineExport(ex) { module.exports = ex; });

})(window)
},{}],1:[function(require,module,exports){
(function() {
  var $, minecraft;

  require('./lib/RequestAnimationFrame');

  require('jquery-mousewheel');

  require('jquery-hotkeys');

  $ = require('jquery');

  minecraft = require('./minecraft.coffee');

  $(minecraft);

}).call(this);


},{"jquery-mousewheel":"jquery-mousewheel","jquery-hotkeys":"jquery-hotkeys","jquery":"jquery","./minecraft.coffee":2,"./lib/RequestAnimationFrame":3}],3:[function(require,module,exports){
/**
 * Provides requestAnimationFrame in a cross browser way.
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */

if ( !window.requestAnimationFrame ) {

	window.requestAnimationFrame = ( function() {

		return window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {

			window.setTimeout( callback, 1000 / 60 );

		};

	} )();

}

},{}],2:[function(require,module,exports){
(function() {
  var $, AmbientLight, BlockSelection, Blocks, ClampToEdgeWrapping, Clock, CollisionHelper, CollisionUtils, Controls, CubeGeometry, CubeSize, Detector, DirectionalLight, Floor, Game, Grid, ImprovedNoise, Instructions, LinearMipMapLinearFilter, Matrix4, Mesh, MeshLambertMaterial, MeshNormalMaterial, MouseEvent, NearestFilter, Object3D, PerspectiveCamera, PlaneGeometry, Player, PointLight, Projector, Ray, RepeatWrapping, Scene, THREE, Texture, TextureHelper, UVMapping, Vector2, Vector3, WebGLRenderer, vec, _ref,
    __slice = [].slice;

  $ = require('jquery');

  Detector = require('detector');

  ImprovedNoise = require('improved-noise');

  THREE = require('three');

  Object3D = THREE.Object3D, Matrix4 = THREE.Matrix4, Scene = THREE.Scene, Mesh = THREE.Mesh, WebGLRenderer = THREE.WebGLRenderer, PerspectiveCamera = THREE.PerspectiveCamera;

  CubeGeometry = THREE.CubeGeometry, PlaneGeometry = THREE.PlaneGeometry, MeshLambertMaterial = THREE.MeshLambertMaterial, MeshNormalMaterial = THREE.MeshNormalMaterial;

  AmbientLight = THREE.AmbientLight, DirectionalLight = THREE.DirectionalLight, PointLight = THREE.PointLight, Ray = THREE.Ray, Vector3 = THREE.Vector3, Vector2 = THREE.Vector2;

  MeshLambertMaterial = THREE.MeshLambertMaterial, MeshNormalMaterial = THREE.MeshNormalMaterial, Projector = THREE.Projector;

  Texture = THREE.Texture, UVMapping = THREE.UVMapping, RepeatWrapping = THREE.RepeatWrapping, RepeatWrapping = THREE.RepeatWrapping, NearestFilter = THREE.NearestFilter;

  LinearMipMapLinearFilter = THREE.LinearMipMapLinearFilter, ClampToEdgeWrapping = THREE.ClampToEdgeWrapping, Clock = THREE.Clock;

  _ref = require('./camera.coffee'), MouseEvent = _ref.MouseEvent, Controls = _ref.Controls;

  CollisionUtils = require('./collision.coffee');

  vec = function(x, y, z) {
    return new Vector3(x, y, z);
  };

  CubeSize = 50;

  Blocks = ["cobblestone", "plank", "brick", "diamond", "glowstone", "obsidian", "whitewool", "bluewool", "redwool", "netherrack"];

  Player = (function() {

    Player.prototype.width = CubeSize * 0.3;

    Player.prototype.depth = CubeSize * 0.3;

    Player.prototype.height = CubeSize * 1.63;

    function Player() {
      this.halfHeight = this.height / 2;
      this.halfWidth = this.width / 2;
      this.halfDepth = this.depth / 2;
      this.pos = vec();
      this.eyesDelta = this.halfHeight * 0.9;
    }

    Player.prototype.eyesPosition = function() {
      var ret;
      ret = this.pos.clone();
      ret.y += this.eyesDelta;
      return ret;
    };

    Player.prototype.position = function(axis) {
      if (axis == null) {
        return this.pos;
      }
      return this.pos[axis];
    };

    Player.prototype.incPosition = function(axis, val) {
      this.pos[axis] += val;
    };

    Player.prototype.setPosition = function(axis, val) {
      this.pos[axis] = val;
    };

    Player.prototype.collidesWithGround = function() {
      return this.position('y') < this.halfHeight;
    };

    Player.prototype.vertex = function(vertexX, vertexY, vertexZ) {
      var vertex;
      vertex = this.position().clone();
      vertex.x += vertexX * this.halfWidth;
      vertex.y += vertexY * this.halfHeight;
      vertex.z += vertexZ * this.halfDepth;
      return vertex;
    };

    Player.prototype.boundingBox = function() {
      var vmax, vmin;
      vmin = this.vertex(-1, -1, -1);
      vmax = this.vertex(1, 1, 1);
      return {
        vmin: vmin,
        vmax: vmax
      };
    };

    return Player;

  })();

  Grid = (function() {

    function Grid(size) {
      var _this = this;
      this.size = size != null ? size : 5;
      this.matrix = [];
      this.size.times(function(i) {
        _this.matrix[i] = [];
        return _this.size.times(function(j) {
          return _this.matrix[i][j] = [];
        });
      });
    }

    Grid.prototype.insideGrid = function(x, y, z) {
      return (0 <= x && x < this.size) && (0 <= y && y < this.size) && (0 <= z && z < this.size);
    };

    Grid.prototype.get = function(x, y, z) {
      return this.matrix[x][y][z];
    };

    Grid.prototype.put = function(x, y, z, val) {
      return this.matrix[x][y][z] = val;
    };

    Grid.prototype.gridCoords = function(x, y, z) {
      x = Math.floor(x / CubeSize);
      y = Math.floor(y / CubeSize);
      z = Math.floor(z / CubeSize);
      return [x, y, z];
    };

    return Grid;

  })();

  CollisionHelper = (function() {

    function CollisionHelper(player, grid) {
      this.player = player;
      this.grid = grid;
      return;
    }

    CollisionHelper.prototype.rad = CubeSize;

    CollisionHelper.prototype.halfRad = CubeSize / 2;

    CollisionHelper.prototype.collides = function() {
      var cube, playerBox, _i, _len, _ref1;
      if (this.player.collidesWithGround()) {
        return true;
      }
      if (this.beyondBounds()) {
        return true;
      }
      playerBox = this.player.boundingBox();
      _ref1 = this.possibleCubes();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        cube = _ref1[_i];
        if (this._collideWithCube(playerBox, cube)) {
          return true;
        }
      }
      return false;
    };

    CollisionHelper.prototype.beyondBounds = function() {
      var p, x, y, z, _ref1;
      p = this.player.position();
      _ref1 = this.grid.gridCoords(p.x, p.y, p.z), x = _ref1[0], y = _ref1[1], z = _ref1[2];
      if (!this.grid.insideGrid(x, 0, z)) {
        return true;
      }
    };

    CollisionHelper.prototype._addToPosition = function(position, value) {
      var pos;
      pos = position.clone();
      pos.x += value;
      pos.y += value;
      pos.z += value;
      return pos;
    };

    CollisionHelper.prototype.collideWithCube = function(cube) {
      return this._collideWithCube(this.player.boundingBox(), cube);
    };

    CollisionHelper.prototype._collideWithCube = function(playerBox, cube) {
      var cubeBox, vmax, vmin;
      vmin = this._addToPosition(cube.position, -this.halfRad);
      vmax = this._addToPosition(cube.position, this.halfRad);
      cubeBox = {
        vmin: vmin,
        vmax: vmax
      };
      return CollisionUtils.testCubeCollision(playerBox, cubeBox);
    };

    CollisionHelper.prototype.possibleCubes = function() {
      var cubes, grid;
      cubes = [];
      grid = this.grid;
      this.withRange(function(x, y, z) {
        var cube;
        cube = grid.get(x, y, z);
        if (cube != null) {
          return cubes.push(cube);
        }
      });
      return cubes;
    };

    CollisionHelper.prototype.withRange = function(func) {
      var maxx, maxy, maxz, minx, miny, minz, vmax, vmin, x, y, z, _ref1;
      _ref1 = this.player.boundingBox(), vmin = _ref1.vmin, vmax = _ref1.vmax;
      minx = this.toGrid(vmin.x);
      miny = this.toGrid(vmin.y);
      minz = this.toGrid(vmin.z);
      maxx = this.toGrid(vmax.x + this.rad);
      maxy = this.toGrid(vmax.y + this.rad);
      maxz = this.toGrid(vmax.z + this.rad);
      x = minx;
      while (x <= maxx) {
        y = miny;
        while (y <= maxy) {
          z = minz;
          while (z <= maxz) {
            func(x, y, z);
            z++;
          }
          y++;
        }
        x++;
      }
    };

    CollisionHelper.prototype.toGrid = function(val) {
      var ret;
      ret = Math.floor(val / this.rad);
      if (ret < 0) {
        return 0;
      }
      if (ret > this.grid.size - 1) {
        return this.grid.size - 1;
      }
      return ret;
    };

    return CollisionHelper;

  })();

  TextureHelper = {
    loadTexture: function(path) {
      var image, texture;
      image = new Image();
      image.src = path;
      texture = new Texture(image, new UVMapping(), ClampToEdgeWrapping, ClampToEdgeWrapping, NearestFilter, LinearMipMapLinearFilter);
      image.onload = function() {
        return texture.needsUpdate = true;
      };
      return new THREE.MeshLambertMaterial({
        map: texture,
        ambient: 0xbbbbbb
      });
    },
    tileTexture: function(path, repeatx, repeaty) {
      var image, texture;
      image = new Image();
      image.src = path;
      texture = new Texture(image, new UVMapping(), RepeatWrapping, RepeatWrapping, NearestFilter, LinearMipMapLinearFilter);
      texture.repeat.x = repeatx;
      texture.repeat.y = repeaty;
      image.onload = function() {
        return texture.needsUpdate = true;
      };
      return new THREE.MeshLambertMaterial({
        map: texture,
        ambient: 0xbbbbbb
      });
    }
  };

  Floor = (function() {

    function Floor(width, height) {
      var material, plane, planeGeo, repeatX, repeatY;
      repeatX = width / CubeSize;
      repeatY = height / CubeSize;
      material = TextureHelper.tileTexture("./textures/bedrock.png", repeatX, repeatY);
      planeGeo = new PlaneGeometry(width, height, 1, 1);
      plane = new Mesh(planeGeo, material);
      plane.position.y = -1;
      plane.rotation.x = -Math.PI / 2;
      plane.name = 'floor';
      this.plane = plane;
    }

    Floor.prototype.addToScene = function(scene) {
      return scene.add(this.plane);
    };

    return Floor;

  })();

  Game = (function() {

    function Game() {
      this.rad = CubeSize;
      this.width = typeof window !== "undefined" && window !== null ? window.innerWidth : void 0;
      this.height = typeof window !== "undefined" && window !== null ? window.innerHeight : void 0;
      this.geo = this.createGrassGeometry();
      this.cubeBlocks = this.createBlocksGeometry();
      this.selectCubeBlock('cobblestone');
      this.move = {
        x: 0,
        z: 0,
        y: 0
      };
      this.keysDown = {};
      this.grid = new Grid(100);
      this.onGround = true;
      this.pause = false;
      this.renderer = this.createRenderer();
      this.camera = this.createCamera();
      this.canvas = this.renderer.domElement;
      this.controls = new Controls(this.camera, this.canvas);
      this.player = new Player();
      this.scene = new Scene();
      new Floor(50000, 50000).addToScene(this.scene);
      this.scene.add(this.camera);
      this.addLights(this.scene);
      this.projector = new Projector();
      this.castRay = null;
      this.moved = false;
      this.toDelete = null;
      this.collisionHelper = new CollisionHelper(this.player, this.grid);
      this.clock = new Clock();
      this.populateWorld();
      this.defineControls();
    }

    Game.prototype.createBlocksGeometry = function() {
      var b, cube, cubeBlocks, _i, _len;
      cubeBlocks = {};
      for (_i = 0, _len = Blocks.length; _i < _len; _i++) {
        b = Blocks[_i];
        cube = new THREE.CubeGeometry(this.rad, this.rad, this.rad, 1, 1, 1, this.texture(b));
        cubeBlocks[b] = cube;
      }
      return cubeBlocks;
    };

    Game.prototype.createGrassGeometry = function() {
      var dirt, grass, grass_dirt, materials, _ref1;
      _ref1 = this.textures("grass_dirt", "grass", "dirt"), grass_dirt = _ref1[0], grass = _ref1[1], dirt = _ref1[2];
      materials = [grass_dirt, grass_dirt, grass, dirt, grass_dirt, grass_dirt];
      return new THREE.CubeGeometry(this.rad, this.rad, this.rad, 1, 1, 1, materials);
    };

    Game.prototype.texture = function(name) {
      return TextureHelper.loadTexture("./textures/" + name + ".png");
    };

    Game.prototype.textures = function() {
      var name, names;
      names = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          _results.push(this.texture(name));
        }
        return _results;
      }).call(this);
    };

    Game.prototype.gridCoords = function(x, y, z) {
      return this.grid.gridCoords(x, y, z);
    };

    Game.prototype.intoGrid = function(x, y, z, val) {
      var args, _ref1;
      args = this.gridCoords(x, y, z).concat(val);
      return (_ref1 = this.grid).put.apply(_ref1, args);
    };

    Game.prototype.generateHeight = function() {
      var data, perlin, quality, size, z;
      size = 11;
      data = [];
      size.times(function(i) {
        data[i] = [];
        return size.times(function(j) {
          return data[i][j] = 0;
        });
      });
      perlin = new ImprovedNoise();
      quality = 0.05;
      z = Math.random() * 100;
      4..times(function(j) {
        size.times(function(x) {
          return size.times(function(y) {
            var noise;
            noise = perlin.noise(x / quality, y / quality, z);
            return data[x][y] += noise * quality;
          });
        });
        return quality *= 4;
      });
      return data;
    };

    Game.prototype.populateWorld = function() {
      var data, height, i, j, middle, middlePos, playerHeight, _i, _j,
        _this = this;
      middle = this.grid.size / 2;
      data = this.generateHeight();
      playerHeight = null;
      for (i = _i = -5; _i <= 5; i = ++_i) {
        for (j = _j = -5; _j <= 5; j = ++_j) {
          height = (Math.abs(Math.floor(data[i + 5][j + 5]))) + 1;
          if (i === 0 && j === 0) {
            playerHeight = (height + 1) * CubeSize;
          }
          height.times(function(k) {
            return _this.cubeAt(middle + i, k, middle + j);
          });
        }
      }
      middlePos = middle * CubeSize;
      return this.player.pos.set(middlePos, playerHeight, middlePos);
    };

    Game.prototype.cubeAt = function(x, y, z, geo, validatingFunction) {
      var halfcube, mesh;
      geo || (geo = this.geo);
      mesh = new Mesh(geo, new THREE.MeshFaceMaterial());
      mesh.geometry.dynamic = false;
      halfcube = CubeSize / 2;
      mesh.position.set(CubeSize * x, y * CubeSize + halfcube, CubeSize * z);
      mesh.name = "block";
      if (validatingFunction != null) {
        if (!validatingFunction(mesh)) {
          return;
        }
      }
      this.grid.put(x, y, z, mesh);
      this.scene.add(mesh);
      mesh.updateMatrix();
      mesh.matrixAutoUpdate = false;
    };

    Game.prototype.createCamera = function() {
      var camera;
      camera = new PerspectiveCamera(45, this.width / this.height, 1, 10000);
      camera.lookAt(vec(0, 0, 0));
      return camera;
    };

    Game.prototype.createRenderer = function() {
      var renderer;
      renderer = new WebGLRenderer({
        antialias: true
      });
      renderer.setSize(this.width, this.height);
      renderer.setClearColorHex(0xBFD1E5, 1.0);
      renderer.clear();
      $('#container').append(renderer.domElement);
      return renderer;
    };

    Game.prototype.addLights = function(scene) {
      var ambientLight, directionalLight;
      ambientLight = new AmbientLight(0xaaaaaa);
      scene.add(ambientLight);
      directionalLight = new DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 0.5);
      directionalLight.position.normalize();
      return scene.add(directionalLight);
    };

    Game.prototype.defineControls = function() {
      var bindit, key, _i, _len, _ref1,
        _this = this;
      bindit = function(key) {
        $(document).bind('keydown', key, function() {
          return _this.keysDown[key] = true;
        });
        return $(document).bind('keyup', key, function() {
          return _this.keysDown[key] = false;
        });
      };
      _ref1 = "wasd".split('').concat('space');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        key = _ref1[_i];
        bindit(key);
      }
      $(document).bind('keydown', 'p', function() {
        return _this.togglePause();
      });
      $(this.canvas).mousedown(function(e) {
        return _this.onMouseDown(e);
      });
      $(this.canvas).mouseup(function(e) {
        return _this.onMouseUp(e);
      });
      return $(this.canvas).mousemove(function(e) {
        return _this.onMouseMove(e);
      });
    };

    Game.prototype.togglePause = function() {
      this.pause = !this.pause;
      if (this.pause === false) {
        this.clock.start();
      }
    };

    Game.prototype.onMouseUp = function(event) {
      if (!this.moved && MouseEvent.isLeftButton(event)) {
        this.toDelete = [event.pageX, event.pageY];
      }
      return this.moved = false;
    };

    Game.prototype.onMouseMove = function(event) {
      return this.moved = true;
    };

    Game.prototype.onMouseDown = function(event) {
      this.moved = false;
      if (!MouseEvent.isRightButton(event)) {
        return;
      }
      return this.castRay = [event.pageX, event.pageY];
    };

    Game.prototype.deleteBlock = function() {
      var todir, vector, x, y, _ref1;
      if (this.toDelete == null) {
        return;
      }
      _ref1 = this.toDelete, x = _ref1[0], y = _ref1[1];
      x = (x / this.width) * 2 - 1;
      y = (-y / this.height) * 2 + 1;
      vector = vec(x, y, 1);
      this.projector.unprojectVector(vector, this.camera);
      todir = vector.subSelf(this.camera.position).normalize();
      this.deleteBlockInGrid(new Ray(this.camera.position, todir));
      this.toDelete = null;
    };

    Game.prototype.findBlock = function(ray) {
      var o, _i, _len, _ref1;
      _ref1 = ray.intersectScene(this.scene);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        o = _ref1[_i];
        if (o.object.name !== 'floor') {
          return o;
        }
      }
      return null;
    };

    Game.prototype.deleteBlockInGrid = function(ray) {
      var mesh, target, x, y, z, _ref1;
      target = this.findBlock(ray);
      if (target == null) {
        return;
      }
      if (!this.withinHandDistance(target.object.position)) {
        return;
      }
      mesh = target.object;
      this.scene.remove(mesh);
      _ref1 = mesh.position, x = _ref1.x, y = _ref1.y, z = _ref1.z;
      this.intoGrid(x, y, z, null);
    };

    Game.prototype.placeBlock = function() {
      var todir, vector, x, y, _ref1;
      if (this.castRay == null) {
        return;
      }
      _ref1 = this.castRay, x = _ref1[0], y = _ref1[1];
      x = (x / this.width) * 2 - 1;
      y = (-y / this.height) * 2 + 1;
      vector = vec(x, y, 1);
      this.projector.unprojectVector(vector, this.camera);
      todir = vector.subSelf(this.camera.position).normalize();
      this.placeBlockInGrid(new Ray(this.camera.position, todir));
      this.castRay = null;
    };

    Game.prototype.getAdjacentCubePosition = function(target) {
      var normal, p;
      normal = target.face.normal.clone();
      p = target.object.position.clone().addSelf(normal.multiplyScalar(CubeSize));
      return p;
    };

    Game.prototype.addHalfCube = function(p) {
      p.y += CubeSize / 2;
      p.z += CubeSize / 2;
      p.x += CubeSize / 2;
      return p;
    };

    Game.prototype.getCubeOnFloorPosition = function(ray) {
      var o, ret, t, v;
      if (ray.direction.y >= 0) {
        return null;
      }
      ret = vec();
      o = ray.origin;
      v = ray.direction;
      t = (-o.y) / v.y;
      ret.y = 0;
      ret.x = o.x + t * v.x;
      ret.z = o.z + t * v.z;
      return this.addHalfCube(ret);
    };

    Game.prototype.selectCubeBlock = function(name) {
      return this.currentCube = this.cubeBlocks[name];
    };

    Game.prototype.getNewCubePosition = function(ray) {
      var target;
      target = this.findBlock(ray);
      if (target == null) {
        return this.getCubeOnFloorPosition(ray);
      }
      return this.getAdjacentCubePosition(target);
    };

    Game.prototype.createCubeAt = function(x, y, z) {
      var _this = this;
      return this.cubeAt(x, y, z, this.currentCube, function(cube) {
        return !_this.collisionHelper.collideWithCube(cube);
      });
    };

    Game.prototype.handLength = 7;

    Game.prototype.withinHandDistance = function(pos) {
      var dist;
      dist = pos.distanceTo(this.player.position());
      return dist <= CubeSize * this.handLength;
    };

    Game.prototype.placeBlockInGrid = function(ray) {
      var gridPos, p, x, y, z;
      p = this.getNewCubePosition(ray);
      if (p == null) {
        return;
      }
      gridPos = this.gridCoords(p.x, p.y, p.z);
      x = gridPos[0], y = gridPos[1], z = gridPos[2];
      if (!this.withinHandDistance(p)) {
        return;
      }
      if (!this.grid.insideGrid(x, y, z)) {
        return;
      }
      if (this.grid.get(x, y, z) != null) {
        return;
      }
      this.createCubeAt(x, y, z);
    };

    Game.prototype.collides = function() {
      return this.collisionHelper.collides();
    };

    Game.prototype.start = function() {
      var animate,
        _this = this;
      animate = function() {
        if (!_this.pause) {
          _this.tick();
        }
        return requestAnimationFrame(animate, _this.renderer.domElement);
      };
      return animate();
    };

    Game.prototype.axes = ['x', 'y', 'z'];

    Game.prototype.iterationCount = 10;

    Game.prototype.moveCube = function(speedRatio) {
      var axis, iterationCount, originalpos, _i, _len, _ref1;
      this.defineMove();
      iterationCount = Math.round(this.iterationCount * speedRatio);
      while (iterationCount-- > 0) {
        this.applyGravity();
        _ref1 = this.axes;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          axis = _ref1[_i];
          if (!(this.move[axis] !== 0)) {
            continue;
          }
          originalpos = this.player.position(axis);
          this.player.incPosition(axis, this.move[axis]);
          if (this.collides()) {
            this.player.setPosition(axis, originalpos);
            if (axis === 'y' && this.move.y < 0) {
              this.onGround = true;
            }
          } else if (axis === 'y' && this.move.y <= 0) {
            this.onGround = false;
          }
        }
      }
    };

    Game.prototype.playerKeys = {
      w: 'z+',
      s: 'z-',
      a: 'x+',
      d: 'x-'
    };

    Game.prototype.shouldJump = function() {
      return this.keysDown.space && this.onGround;
    };

    Game.prototype.defineMove = function() {
      var action, axis, baseVel, jumpSpeed, key, operation, vel, _ref1;
      baseVel = .4;
      jumpSpeed = .8;
      this.move.x = 0;
      this.move.z = 0;
      _ref1 = this.playerKeys;
      for (key in _ref1) {
        action = _ref1[key];
        axis = action[0], operation = action[1];
        vel = operation === '-' ? -baseVel : baseVel;
        if (this.keysDown[key]) {
          this.move[axis] += vel;
        }
      }
      if (this.shouldJump()) {
        this.onGround = false;
        this.move.y = jumpSpeed;
      }
      this.garanteeXYNorm();
      this.projectMoveOnCamera();
    };

    Game.prototype.garanteeXYNorm = function() {
      var ratio;
      if (this.move.x !== 0 && this.move.z !== 0) {
        ratio = Math.cos(Math.PI / 4);
        this.move.x *= ratio;
        this.move.z *= ratio;
      }
    };

    Game.prototype.projectMoveOnCamera = function() {
      var frontDir, rightDir, x, z, _ref1;
      _ref1 = this.controls.viewDirection(), x = _ref1.x, z = _ref1.z;
      frontDir = new Vector2(x, z).normalize();
      rightDir = new Vector2(frontDir.y, -frontDir.x);
      frontDir.multiplyScalar(this.move.z);
      rightDir.multiplyScalar(this.move.x);
      this.move.x = frontDir.x + rightDir.x;
      return this.move.z = frontDir.y + rightDir.y;
    };

    Game.prototype.applyGravity = function() {
      if (!(this.move.y < -1)) {
        return this.move.y -= .005;
      }
    };

    Game.prototype.setCameraEyes = function() {
      var eyesDelta, pos;
      pos = this.player.eyesPosition();
      this.controls.move(pos);
      eyesDelta = this.controls.viewDirection().normalize().multiplyScalar(20);
      eyesDelta.y = 0;
      pos.subSelf(eyesDelta);
    };

    Game.prototype.idealSpeed = 1 / 60;

    Game.prototype.tick = function() {
      var speedRatio;
      speedRatio = this.clock.getDelta() / this.idealSpeed;
      this.placeBlock();
      this.deleteBlock();
      this.moveCube(speedRatio);
      this.renderer.clear();
      this.controls.update();
      this.setCameraEyes();
      this.renderer.render(this.scene, this.camera);
    };

    return Game;

  })();

  BlockSelection = (function() {

    function BlockSelection(game) {
      this.game = game;
      this.current = "cobblestone";
    }

    BlockSelection.prototype.blockImg = function(name) {
      return "<img width='32' height='32' src='./textures/" + name + "icon.png' id='" + name + "'/>";
    };

    BlockSelection.prototype.mousedown = function(e) {
      if (e.target === this) {
        return false;
      }
      this.select(e.target.id);
      return false;
    };

    BlockSelection.prototype.mousewheel = function(delta) {
      var dif, index;
      dif = (delta >= 0 ? 1 : -1);
      index = (Blocks.indexOf(this.current) - dif).mod(Blocks.length);
      return this.select(Blocks[index]);
    };

    BlockSelection.prototype.ligthUp = function(target) {
      return this._setOpacity(target, 0.8);
    };

    BlockSelection.prototype.lightOff = function(target) {
      return this._setOpacity(target, 1);
    };

    BlockSelection.prototype.select = function(name) {
      if (this.current === name) {
        return;
      }
      this.game.selectCubeBlock(name);
      this.ligthUp(name);
      this.lightOff(this.current);
      return this.current = name;
    };

    BlockSelection.prototype._setOpacity = function(target, val) {
      return $("#" + target).css({
        opacity: val
      });
    };

    BlockSelection.prototype.insert = function() {
      var b, blockList, domElement,
        _this = this;
      blockList = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = Blocks.length; _i < _len; _i++) {
          b = Blocks[_i];
          _results.push(this.blockImg(b));
        }
        return _results;
      }).call(this);
      domElement = $("#blocks");
      domElement.append(blockList.join(''));
      this.ligthUp(this.current);
      domElement.mousedown(function(e) {
        return _this.mousedown(e);
      });
      $(document).mousewheel(function(e, delta) {
        return _this.mousewheel(delta);
      });
      return domElement.show();
    };

    return BlockSelection;

  })();

  Instructions = (function() {

    function Instructions(callback) {
      this.callback = callback;
      this.domElement = $('#instructions');
    }

    Instructions.prototype.instructions = {
      leftclick: "Remove block",
      rightclick: "Add block",
      drag: "Drag with the left mouse clicked to move the camera",
      pause: "Pause/Unpause",
      space: "Jump",
      wasd: "WASD keys to move",
      scroll: "Scroll to change selected block"
    };

    Instructions.prototype.intructionsBody = function() {
      var _this = this;
      this.domElement.append("<div id='instructionsContent'>        <h1>Click to start</h1>        <table>" + (this.lines()) + "</table>        </div>");
      $("#instructionsContent").mousedown(function() {
        _this.domElement.hide();
        return _this.callback();
      });
    };

    Instructions.prototype.ribbon = function() {
      return '<a href="https://github.com/thlorenz/WebGLCraft" target="_blank">\
        <img style="position: fixed; top: 0; right: 0; border: 0;"\
        src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"\
        alt="Fork me on GitHub"></a>';
    };

    Instructions.prototype.insert = function() {
      var browserified, hnimage, hnlink, legal, minecraft;
      this.setBoder();
      this.intructionsBody();
      minecraft = "<a href='http://www.minecraft.net/' target='_blank'>Minecraft</a>";
      legal = "<div>Not affiliated with Mojang. " + minecraft + " is a trademark of Mojang</div>";
      hnimage = '<img class="alignnone" title="hacker news" src="http://1.gravatar.com/blavatar/96c849b03aefaf7ef9d30158754f0019?s=20" alt="" width="20" height="20" />';
      hnlink = "<div>Comment on  " + hnimage + " <a href='http://news.ycombinator.com/item?id=3376620'  target='_blank'>Hacker News</a></div>";
      browserified = "<div><p><span style='fontWeight: bold'>Note:</span> This is the browserified version with preserved sourcemaps.</p><p>Click Alt-Cmd-J to debug the original CoffeeScript.</p><p>(needs sourcemaps enabled in your browser)</p></div>";
      this.domElement.append(legal + hnlink + browserified + this.ribbon());
      return this.domElement.show();
    };

    Instructions.prototype.lines = function() {
      var inst, ret;
      ret = (function() {
        var _results;
        _results = [];
        for (inst in this.instructions) {
          _results.push(this.line(inst));
        }
        return _results;
      }).call(this);
      return ret.join(' ');
    };

    Instructions.prototype.line = function(name) {
      var inst;
      inst = this.instructions[name];
      return "<tr><td class='image'>" + (this.img(name)) + "</td>        <td class='label'>" + inst + "</td></tr>";
    };

    Instructions.prototype.setBoder = function() {
      var prefix, _i, _len, _ref1;
      _ref1 = ['-webkit-', '-moz-', '-o-', '-ms-', ''];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        prefix = _ref1[_i];
        this.domElement.css(prefix + 'border-radius', '10px');
      }
    };

    Instructions.prototype.img = function(name) {
      return "<img src='./instructions/" + name + ".png'/>";
    };

    return Instructions;

  })();

  module.exports = function() {
    var startGame;
    console.log('initializing minecraft');
    $("#blocks").hide();
    $('#instructions').hide();
    $(document).bind("contextmenu", function() {
      return false;
    });
    if (!Detector.webgl) {
      return Detector.addGetWebGLMessage();
    }
    startGame = function() {
      var game;
      game = new Game();
      new BlockSelection(game).insert();
      return game.start();
    };
    return new Instructions(startGame).insert();
  };

}).call(this);


},{"jquery":"jquery","detector":"detector","improved-noise":"improved-noise","three":"three","./camera.coffee":4,"./collision.coffee":5}],5:[function(require,module,exports){
(function() {
  var CollisionUtils;

  CollisionUtils = {
    testIntervalCollision: function(s1, f1, s2, f2) {
      return !(s2 > f1 || s1 > f2);
    },
    testCubeCollision: function(cube1, cube2) {
      var axis, collides, fcol, _i, _len, _ref;
      fcol = CollisionUtils.testIntervalCollision;
      _ref = ['x', 'y', 'z'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        axis = _ref[_i];
        collides = fcol(cube1.vmin[axis], cube1.vmax[axis], cube2.vmin[axis], cube2.vmax[axis]);
        if (!collides) {
          return false;
        }
      }
      return true;
    }
  };

  module.exports = CollisionUtils;

}).call(this);


},{}],4:[function(require,module,exports){
(function() {
  var $, Controls, MouseEvent, THREE, assoc;

  $ = require('jquery');

  THREE = require('three');

  assoc = require('./coreExtensions.coffee').assoc;

  MouseEvent = {
    isLeftButton: function(event) {
      return event.which === 1;
    },
    isRightButton: function(event) {
      return event.which === 3;
    },
    isLeftButtonDown: function(event) {
      return event.button === 0 && this.isLeftButton(event);
    }
  };

  Controls = (function() {

    function Controls(object, domElement) {
      this.object = object;
      this.target = new THREE.Vector3(0, 0, 0);
      this.domElement = domElement || document;
      this.lookSpeed = 0.20;
      this.mouseX = 0;
      this.mouseY = 0;
      this.lat = 0;
      this.lon = 0;
      this.mouseDragOn = false;
      this.anchorx = null;
      this.anchory = null;
      this.defineBindings();
    }

    Controls.prototype.defineBindings = function() {
      var _this = this;
      $(this.domElement).mousemove(function(e) {
        return _this.onMouseMove(e);
      });
      $(this.domElement).mousedown(function(e) {
        return _this.onMouseDown(e);
      });
      $(this.domElement).mouseup(function(e) {
        return _this.onMouseUp(e);
      });
      return $(this.domElement).mouseenter(function(e) {
        return _this.onMouserEnter(e);
      });
    };

    Controls.prototype.onMouserEnter = function(event) {
      if (!MouseEvent.isLeftButtonDown(event)) {
        return this.onMouseUp(event);
      }
    };

    Controls.prototype.onMouseDown = function(event) {
      if (!MouseEvent.isLeftButton(event)) {
        return;
      }
      if (this.domElement !== document) {
        this.domElement.focus();
      }
      this.anchorx = event.pageX;
      this.anchory = event.pageY;
      this.setMouse(event);
      this.mouseDragOn = true;
      return false;
    };

    Controls.prototype.onMouseUp = function(event) {
      this.mouseDragOn = false;
      return false;
    };

    Controls.prototype.setMouse = function(event) {
      this.mouseX = event.pageX;
      return this.mouseY = event.pageY;
    };

    Controls.prototype.onMouseMove = function(event) {
      if (!this.mouseDragOn) {
        return;
      }
      this.setMouse(event);
    };

    Controls.prototype.halfCircle = Math.PI / 180;

    Controls.prototype.viewDirection = function() {
      return this.target.clone().subSelf(this.object.position);
    };

    Controls.prototype.move = function(newPosition) {
      this.object.position = newPosition;
      return this.updateLook();
    };

    Controls.prototype.updateLook = function() {
      var cos, p, phi, sin, theta;
      sin = Math.sin, cos = Math.cos;
      phi = (90 - this.lat) * this.halfCircle;
      theta = this.lon * this.halfCircle;
      p = this.object.position;
      assoc(this.target, {
        x: p.x + 100 * sin(phi) * cos(theta),
        y: p.y + 100 * cos(phi),
        z: p.z + 100 * sin(phi) * sin(theta)
      });
      this.object.lookAt(this.target);
    };

    Controls.prototype.update = function() {
      var max, min;
      if (!this.mouseDragOn) {
        return;
      }
      if (this.mouseX === this.anchorx && this.mouseY === this.anchory) {
        return;
      }
      max = Math.max, min = Math.min;
      this.lon += (this.mouseX - this.anchorx) * this.lookSpeed;
      this.lat -= (this.mouseY - this.anchory) * this.lookSpeed;
      this.anchorx = this.mouseX;
      this.anchory = this.mouseY;
      this.lat = max(-85, min(85, this.lat));
      this.updateLook();
    };

    return Controls;

  })();

  exports.MouseEvent = MouseEvent;

  exports.Controls = Controls;

}).call(this);


},{"jquery":"jquery","three":"three","./coreExtensions.coffee":6}],6:[function(require,module,exports){
(function() {
  var patch;

  patch = require('./lib/rbcoffee.coffee').patch;

  patch(Number, {
    mod: function(arg) {
      if (this >= 0) {
        return this % arg;
      }
      return (this + arg) % arg;
    },
    div: function(arg) {
      return Math.floor(this / arg);
    },
    times: function(fn) {
      var i, _results;
      i = 0;
      _results = [];
      while (i < this) {
        _results.push(fn(i++));
      }
      return _results;
    },
    toRadians: function() {
      return (this * Math.PI) / 180;
    },
    toDegrees: function() {
      return (this * 180) / Math.PI;
    }
  });

  exports.assoc = function(o, i) {
    var k, v;
    for (k in i) {
      v = i[k];
      o[k] = v;
    }
    return o;
  };

}).call(this);


},{"./lib/rbcoffee.coffee":7}],7:[function(require,module,exports){
(function() {
  var abstract_method, abstract_property, clone, define, eq, isAbstract, methods, methodsOfInstance, methodsOfInstanceWhile, methodsWhile, mixin, mixinWith, patch, puts, raise,
    __slice = [].slice;

  puts = exports.puts = function() {
    var arg, args, _i, _len;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!this["console"]) {
      return;
    }
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      console.log(arg);
    }
  };

  raise = exports.raise = function(message) {
    throw new Error(message);
  };

  abstract_method = exports.abstract_method = function() {
    return raise("Subclass responsability");
  };

  abstract_property = exports.abstract_property = function() {
    return raise("Abstract property");
  };

  clone = exports.clone = function(obj) {
    var k, ret, v;
    if (obj == null) {
      return obj;
    }
    ret = {};
    for (k in obj) {
      v = obj[k];
      ret[k] = v;
    }
    return ret;
  };

  eq = exports.eq = function(x, y) {
    return x == y;
  };

  define = exports.define = function(clas, methodName, func) {
    return clas.prototype[methodName] = func;
  };

  patch = exports.patch = function(clas, mixed) {
    var method, name;
    for (name in mixed) {
      method = mixed[name];
      define(clas, name, method);
    }
  };

  isAbstract = exports.isAbstract = function(m) {
    return m === abstract_method || m === abstract_property;
  };

  mixinWith = exports.mixinWith = function(clas, mixed) {
    var m, name;
    for (name in mixed) {
      m = mixed[name];
      if (!(isAbstract(m) || ((clas.prototype[name] != null) && !isAbstract(clas.prototype[name])))) {
        define(clas, name, m);
      }
    }
  };

  mixin = exports.mixin = function() {
    var clas, trait, traits, _i, _len;
    clas = arguments[0], traits = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = traits.length; _i < _len; _i++) {
      trait = traits[_i];
      mixinWith(clas, trait);
    }
  };

  methods = exports.methods = function(clas) {
    var c, ret;
    ret = (function() {
      var _results;
      _results = [];
      for (c in clas.prototype) {
        _results.push(c);
      }
      return _results;
    })();
    if (!clas.__super__) {
      return ret;
    }
    return ret.concat(methods(clas.__super__.constructor));
  };

  methodsWhile = exports.methodsWhile = function(clas, func) {
    var c, ret;
    if (!func(clas)) {
      return [];
    }
    ret = (function() {
      var _results;
      _results = [];
      for (c in clas.prototype) {
        _results.push(c);
      }
      return _results;
    })();
    if (!clas.__super__) {
      return ret;
    }
    return ret.concat(methodsWhile(clas.__super__.constructor, func));
  };

  methodsOfInstance = exports.methodsOfInstance = function(instance) {
    return methods(instance.constructor);
  };

  methodsOfInstanceWhile = exports.methodsOfInstanceWhile = function(instance, func) {
    return methodsWhile(instance.constructor, func);
  };

}).call(this);


},{}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvdGhsb3JlbnovZGV2L2pzL3Byb2plY3RzL19mb3Jrcy9XZWJHTENyYWZ0L3B1YmxpYy9qcXVlcnkvanF1ZXJ5LTEuNy4xLmpzIiwiL1VzZXJzL3RobG9yZW56L2Rldi9qcy9wcm9qZWN0cy9fZm9ya3MvV2ViR0xDcmFmdC9wdWJsaWMvbGliL2pxdWVyeS5ob3RrZXlzLmpzIiwiL1VzZXJzL3RobG9yZW56L2Rldi9qcy9wcm9qZWN0cy9fZm9ya3MvV2ViR0xDcmFmdC9wdWJsaWMvbGliL2pxdWVyeS5tb3VzZXdoZWVsLmpzIiwiL1VzZXJzL3RobG9yZW56L2Rldi9qcy9wcm9qZWN0cy9fZm9ya3MvV2ViR0xDcmFmdC9wdWJsaWMvbGliL0RldGVjdG9yLmpzIiwiL1VzZXJzL3RobG9yZW56L2Rldi9qcy9wcm9qZWN0cy9fZm9ya3MvV2ViR0xDcmFmdC9wdWJsaWMvbGliL0ltcHJvdmVkTm9pc2UuanMiLCIvVXNlcnMvdGhsb3JlbnovZGV2L2pzL3Byb2plY3RzL19mb3Jrcy9XZWJHTENyYWZ0L3B1YmxpYy9saWIvVGhyZWUuanMiLCIvcHVibGljL21haW4uY29mZmVlIiwiL1VzZXJzL3RobG9yZW56L2Rldi9qcy9wcm9qZWN0cy9fZm9ya3MvV2ViR0xDcmFmdC9wdWJsaWMvbGliL1JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIi9wdWJsaWMvbWluZWNyYWZ0LmNvZmZlZSIsIi9wdWJsaWMvY29sbGlzaW9uLmNvZmZlZSIsIi9wdWJsaWMvY2FtZXJhLmNvZmZlZSIsIi9wdWJsaWMvY29yZUV4dGVuc2lvbnMuY29mZmVlIiwiL3B1YmxpYy9saWIvcmJjb2ZmZWUuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoNjhCQTtDQUFBLEtBQUEsTUFBQTtDQUFBO0NBQUEsQ0FBQSxLQUFBLHNCQUFBOztDQUFBLENBQ0EsS0FBQSxZQUFBOztDQURBLENBRUEsS0FBQSxTQUFBOztDQUZBLENBSUEsQ0FBSSxJQUFBLENBQUE7O0NBSkosQ0FLQSxDQUFZLElBQUEsRUFBWixXQUFZOztDQUxaLENBTUEsT0FBQTtDQU5BOzs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0NBQUEsS0FBQSxzZkFBQTtLQUFBLGFBQUE7Q0FBQTtDQUFBLENBQUEsQ0FBSSxJQUFBLENBQUE7O0NBQUosQ0FDQSxDQUFXLElBQUEsQ0FBWCxFQUFXOztDQURYLENBRUEsQ0FBZ0IsSUFBQSxNQUFoQixHQUFnQjs7Q0FGaEIsQ0FJQSxDQUFRLEVBQVIsRUFBUTs7Q0FKUixDQUtDLEVBQUQsQ0FBQSxFQUFBLENBQUEsS0FBQSxJQUxBOztDQUFBLENBTUMsVUFBRCxDQUFBLEtBTkEsQ0FNQTs7Q0FOQSxDQU9DLENBQUQsSUFBQSxHQUFBLEVBQUEsSUFBQTs7Q0FQQSxDQVFDLE9BUkQsU0FRQSxDQUFBOztDQVJBLENBU0MsS0FBRCxFQUFBLElBVEEsQ0FTQTs7Q0FUQSxDQVVDLEdBVkQsY0FVQSxLQUFBOztDQVZBLENBWUEsS0FBMkIsQ0FaM0IsRUFZQSxPQUEyQjs7Q0FaM0IsQ0FhQSxDQUFpQixJQUFBLE9BQWpCLE1BQWlCOztDQWJqQixDQWdCQSxDQUFBLE1BQU87Q0FBd0IsQ0FBRyxFQUFYLEdBQUEsSUFBQTtDQWhCdkIsRUFnQk07O0NBaEJOLENBa0JBLENBQVcsS0FBWDs7Q0FsQkEsQ0FtQkEsQ0FBUyxHQUFULENBQVMsRUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztDQW5CVCxDQXNCTTtDQUNIO0NBQUEsRUFBUSxFQUFQLEdBQU87O0NBQVIsRUFDUSxFQUFQLEdBQU87O0NBRFIsRUFFUyxDQUZULEVBRUMsRUFBUTs7Q0FFSyxFQUFBLENBQUEsWUFBQTtDQUNULEVBQWMsQ0FBYixFQUFELElBQUE7Q0FBQSxFQUNhLENBQVosQ0FBWSxDQUFiLEdBQUE7Q0FEQSxFQUVhLENBQVosQ0FBWSxDQUFiLEdBQUE7Q0FGQSxFQUdBLENBQUMsRUFBRDtDQUhBLEVBSWEsQ0FBWixFQUFELEdBQUEsQ0FBYTtDQVRsQixJQUljOztDQUpkLEVBV2UsTUFBQSxHQUFkO0NBQ0ksRUFBQSxPQUFBO0NBQUEsRUFBQSxDQUFPLENBQUQsQ0FBTjtDQUFBLEVBQ0csQ0FBTSxFQUFULEdBREE7Q0FFQSxFQUFBLFVBQU87Q0FkWixJQVdlOztDQVhmLEVBaUJXLENBQUEsSUFBVixDQUFXO0NBQ1AsR0FBbUIsRUFBbkIsTUFBQTtDQUFBLEVBQUEsQ0FBUSxXQUFEO1FBQVA7Q0FDQSxFQUFZLENBQUosU0FBRDtDQW5CWixJQWlCVzs7Q0FqQlgsQ0FxQnFCLENBQVAsQ0FBQSxLQUFDLEVBQWQ7Q0FDSSxFQUFLLENBQUosRUFBRDtDQXRCTCxJQXFCYzs7Q0FyQmQsQ0F5QnFCLENBQVAsQ0FBQSxLQUFDLEVBQWQ7Q0FDSSxFQUFLLENBQUosRUFBRDtDQTFCTCxJQXlCYzs7Q0F6QmQsRUE4QnFCLE1BQUEsU0FBcEI7Q0FBd0IsRUFBRCxDQUFDLElBQUQsS0FBQTtDQTlCeEIsSUE4QnFCOztDQTlCckIsQ0FnQ21CLENBQVYsR0FBUixDQUFRLEVBQUM7Q0FDTCxLQUFBLElBQUE7Q0FBQSxFQUFTLENBQUMsQ0FBRCxDQUFULEVBQVM7Q0FBVCxFQUNzQixDQUFWLEVBQVosQ0FBWSxFQURaO0NBQUEsRUFFc0IsQ0FBVixFQUFaLENBQVksR0FGWjtDQUFBLEVBR3NCLENBQVYsRUFBWixDQUFZLEVBSFo7Q0FJQSxLQUFBLE9BQU87Q0FyQ1osSUFnQ1M7O0NBaENULEVBdUNjLE1BQUEsRUFBYjtDQUNJLFNBQUE7QUFBZ0IsQ0FBaEIsQ0FBbUIsQ0FBWixDQUFQLEVBQUE7Q0FBQSxDQUNrQixDQUFYLENBQVAsRUFBQTtDQUNBLFlBQU87Q0FBQSxDQUFPLEVBQU4sSUFBQTtDQUFELENBQW1CLEVBQU4sSUFBQTtDQUhYLE9BR1Q7Q0ExQ0wsSUF1Q2M7O0NBdkNkOztDQXZCSDs7Q0FBQSxDQW9FTTtDQUNIO0NBQWMsRUFBQSxDQUFBLFVBQUU7Q0FDWCxTQUFBLEVBQUE7Q0FBQSxFQURXLENBQUEsRUFBRDtDQUNWLENBQUEsQ0FBVSxDQUFULEVBQUQ7Q0FBQSxFQUNZLENBQVgsQ0FBRCxDQUFBLEdBQWE7Q0FDVCxDQUFBLENBQWEsRUFBWixDQUFPLEVBQVI7Q0FDQyxFQUFXLENBQVAsQ0FBSixJQUFZLE1BQWI7Q0FDSyxFQUFlLEVBQWYsQ0FBTyxXQUFSO0NBREosUUFBWTtDQUZoQixNQUFZO0NBRmpCLElBQWM7O0NBQWQsQ0FPaUIsQ0FBSixNQUFDLENBQWI7Q0FBeUIsRUFBUyxDQUFKLFNBQUw7Q0FQMUIsSUFPYTs7Q0FQYixDQVNVLENBQVQsTUFBTTtDQUFhLEdBQUEsRUFBTyxPQUFSO0NBVG5CLElBU007O0NBVE4sQ0FXVSxDQUFULE1BQU07Q0FBa0IsRUFBa0IsQ0FBbEIsRUFBTyxPQUFSO0NBWHhCLElBV007O0NBWE4sQ0FhaUIsQ0FBSixNQUFDLENBQWI7Q0FDSSxFQUFJLENBQUksQ0FBSixDQUFKLEVBQUk7Q0FBSixFQUNJLENBQUksQ0FBSixDQUFKLEVBQUk7Q0FESixFQUVJLENBQUksQ0FBSixDQUFKLEVBQUk7Q0FDSixDQUFXLFdBQUo7Q0FqQlosSUFhYTs7Q0FiYjs7Q0FyRUg7O0NBQUEsQ0F5Rk07Q0FDSDtDQUFjLENBQVcsQ0FBWCxDQUFBLEVBQUEsbUJBQUU7Q0FBaUIsRUFBakIsQ0FBQSxFQUFEO0NBQWtCLEVBQVIsQ0FBQSxFQUFEO0NBQVMsV0FBQTtDQUFqQyxJQUFjOztDQUFkLEVBQ0MsS0FERDs7Q0FBQSxFQUVVLElBQVQsQ0FBUzs7Q0FGVixFQUlXLEtBQVYsQ0FBVTtDQUNOLFNBQUEsc0JBQUE7Q0FBQSxHQUFlLEVBQWYsWUFBZTtDQUFmLEdBQUEsV0FBTztRQUFQO0NBQ0EsR0FBZSxFQUFmLE1BQWU7Q0FBZixHQUFBLFdBQU87UUFEUDtDQUFBLEVBRVksQ0FBQyxFQUFiLEdBQUEsRUFBWTtDQUNaO0NBQUEsVUFBQSxpQ0FBQTswQkFBQTtDQUNJLENBQTRDLEVBQTdCLElBQWYsQ0FBZSxPQUFBO0NBQWYsR0FBQSxhQUFPO1VBRFg7Q0FBQSxNQUhBO0NBS0EsSUFBQSxRQUFPO0NBVlosSUFJVzs7Q0FKWCxFQVllLE1BQUEsR0FBZDtDQUNJLFNBQUEsT0FBQTtDQUFBLEVBQUksQ0FBQyxFQUFMLEVBQUk7Q0FBSixDQUNrQyxFQUFyQixFQUFiLEVBQVksRUFBQTtBQUNPLENBQW5CLENBQXVDLEVBQXZDLEVBQUEsSUFBbUI7Q0FBbkIsR0FBQSxXQUFPO1FBSEc7Q0FaZixJQVllOztDQVpmLENBa0I0QixDQUFYLEVBQUEsR0FBQSxDQUFDLEtBQWpCO0NBQ0ksRUFBQSxPQUFBO0NBQUEsRUFBQSxFQUFNLENBQU4sRUFBYztDQUFkLEVBQ0csQ0FBTSxDQURULENBQ0E7Q0FEQSxFQUVHLENBQU0sQ0FGVCxDQUVBO0NBRkEsRUFHRyxDQUFNLENBSFQsQ0FHQTtDQUNBLEVBQUEsVUFBTztDQXZCWixJQWtCaUI7O0NBbEJqQixFQXlCa0IsQ0FBQSxLQUFDLE1BQWxCO0NBQTRCLENBQXdDLEVBQXhDLEVBQXdCLEtBQVAsRUFBbEIsR0FBQTtDQXpCNUIsSUF5QmtCOztDQXpCbEIsQ0EyQitCLENBQVosQ0FBQSxLQUFDLE9BQW5CO0NBQ0ksU0FBQSxTQUFBO0FBQXVDLENBQXZDLENBQXNDLENBQS9CLENBQVAsRUFBQSxDQUFPLENBQUEsTUFBQTtDQUFQLENBQ3NDLENBQS9CLENBQVAsRUFBQSxDQUFPLENBQUEsTUFBQTtDQURQLEVBRVUsR0FBVixDQUFBO0NBQVUsQ0FBQyxFQUFELElBQUM7Q0FBRCxDQUFPLEVBQVAsSUFBTztDQUZqQixPQUFBO0NBR0EsQ0FBbUQsS0FBNUMsRUFBQSxJQUFBLENBQWMsR0FBZDtDQS9CWixJQTJCbUI7O0NBM0JuQixFQWlDZ0IsTUFBQSxJQUFmO0NBQ0ksU0FBQSxDQUFBO0NBQUEsQ0FBQSxDQUFRLEVBQVIsQ0FBQTtDQUFBLEVBQ08sQ0FBUCxFQUFBO0NBREEsQ0FFZSxDQUFKLENBQVYsRUFBRCxHQUFBO0NBQ0ksR0FBQSxRQUFBO0NBQUEsQ0FBbUIsQ0FBWixDQUFQLElBQUE7Q0FDQSxHQUFtQixJQUFuQixJQUFBO0NBQU0sR0FBTixDQUFLLFlBQUw7VUFGTztDQUFYLE1BQVc7Q0FHWCxJQUFBLFFBQU87Q0F2Q1osSUFpQ2dCOztDQWpDaEIsRUF5Q1ksQ0FBQSxLQUFYO0NBQ0ksU0FBQSxvREFBQTtDQUFBLENBQUMsRUFBZSxFQUFoQixFQUFlLEdBQUE7Q0FBZixFQUNPLENBQVAsRUFBQTtDQURBLEVBRU8sQ0FBUCxFQUFBO0NBRkEsRUFHTyxDQUFQLEVBQUE7Q0FIQSxFQUtPLENBQVAsRUFBQTtDQUxBLEVBTU8sQ0FBUCxFQUFBO0NBTkEsRUFPTyxDQUFQLEVBQUE7Q0FQQSxFQVFJLENBUkosRUFRQTtDQUNBLEVBQUEsQ0FBVyxTQUFMO0NBQ0YsRUFBSSxDQUFKLElBQUE7Q0FDQSxFQUFBLENBQVcsV0FBTDtDQUNGLEVBQUksQ0FBSixNQUFBO0NBQ0EsRUFBQSxDQUFXLGFBQUw7Q0FDRixDQUFRLEVBQVIsUUFBQTtBQUNBLENBREEsQ0FBQSxVQUNBO0NBSEosVUFDQTtBQUdBLENBSkEsQ0FBQSxRQUlBO0NBTkosUUFDQTtBQU1BLENBUEEsQ0FBQSxNQU9BO0NBbEJHLE1BVVA7Q0FuREwsSUF5Q1k7O0NBekNaLEVBOERTLEdBQVIsR0FBUztDQUNMLEVBQUEsT0FBQTtDQUFBLEVBQUEsQ0FBVSxDQUFKLENBQU47Q0FDQSxFQUFZLENBQUEsRUFBWjtDQUFBLGNBQU87UUFEUDtDQUVBLEVBQXlCLENBQUEsRUFBekI7Q0FBQSxFQUFvQixDQUFaLFdBQUQ7UUFGUDtDQUdBLEVBQUEsVUFBTztDQWxFWixJQThEUzs7Q0E5RFQ7O0NBMUZIOztDQUFBLENBK0pBLENBQ0csVUFESDtDQUNHLENBQWMsQ0FBQSxDQUFiLEtBQWMsRUFBZDtDQUNJLFNBQUEsSUFBQTtDQUFBLEVBQVksQ0FBQSxDQUFaLENBQUE7Q0FBQSxFQUNBLENBREEsQ0FDSyxDQUFMO0NBREEsQ0FFaUMsQ0FBbkIsQ0FBQSxDQUFBLENBQWQsQ0FBQSxFQUFpQyxJQUFuQixNQUFBLEtBQUE7Q0FGZCxFQUdlLEVBQVYsQ0FBTCxHQUFlO0NBQVcsRUFBYyxJQUFmLElBQVAsSUFBQTtDQUhsQixNQUdlO0NBQ0wsR0FBTixDQUFLLFFBQUwsTUFBQTtDQUF5QixDQUFNLENBQUwsSUFBRCxDQUFDO0NBQUQsQ0FBd0IsS0FBVCxDQUFBO0NBTG5DLE9BS0w7Q0FMVCxJQUFjO0NBQWQsQ0FRYyxDQUFBLENBQWIsR0FBYSxFQUFDLEVBQWQ7Q0FDSSxTQUFBLElBQUE7Q0FBQSxFQUFZLENBQUEsQ0FBWixDQUFBO0NBQUEsRUFDQSxDQURBLENBQ0ssQ0FBTDtDQURBLENBRWlDLENBQW5CLENBQUEsQ0FBQSxDQUFkLENBQUEsRUFBaUMsSUFBbkIsQ0FBQSxVQUFBO0NBRmQsRUFJbUIsR0FBbkIsQ0FBTztDQUpQLEVBS21CLEdBQW5CLENBQU87Q0FMUCxFQU1lLEVBQVYsQ0FBTCxHQUFlO0NBQVcsRUFBYyxJQUFmLElBQVAsSUFBQTtDQU5sQixNQU1lO0NBQ0wsR0FBTixDQUFLLFFBQUwsTUFBQTtDQUF5QixDQUFNLENBQUwsSUFBRCxDQUFDO0NBQUQsQ0FBd0IsS0FBVCxDQUFBO0NBUm5DLE9BUUw7Q0FoQlQsSUFRYztDQXhLakIsR0FBQTs7Q0FBQSxDQW9MTTtDQUNIO0NBQWMsQ0FBUSxDQUFSLENBQUEsQ0FBQSxDQUFBLFNBQUM7Q0FDVixTQUFBLGlDQUFBO0NBQUEsRUFBVSxFQUFBLENBQVYsQ0FBQSxDQUFBO0NBQUEsRUFDVSxHQUFWLENBQUEsQ0FEQTtDQUFBLENBRStELENBQXBELEdBQVgsQ0FBVyxDQUFYLEdBQVcsRUFBYSxXQUFiO0NBRlgsQ0FHb0MsQ0FBckIsQ0FBQSxDQUFBLENBQWYsRUFBQSxLQUFlO0NBSGYsQ0FJMkIsQ0FBZixDQUFBLENBQVosQ0FBQSxFQUFZO0FBQ1EsQ0FMcEIsRUFLbUIsRUFBZCxDQUFMLEVBQWM7QUFDTSxDQU5wQixDQU1tQixDQUFBLENBQUssQ0FBbkIsQ0FBTCxFQUFjO0NBTmQsRUFPYSxDQUFiLENBQUssQ0FBTCxDQVBBO0NBQUEsRUFRUyxDQUFSLENBQUQsQ0FBQTtDQVRMLElBQWM7O0NBQWQsRUFXYSxFQUFBLElBQUMsQ0FBYjtDQUE2QixFQUFOLENBQVcsQ0FBTixRQUFMO0NBWHhCLElBV2E7O0NBWGI7O0NBckxIOztDQUFBLENBbU1NO0NBQ0g7Q0FBYyxFQUFBLENBQUEsVUFBQTtDQUNULEVBQUEsQ0FBQyxFQUFELEVBQUE7Q0FBQSxFQUNTLENBQVIsQ0FBRCxDQUFBO0NBREEsRUFFVSxDQUFULEVBQUQ7Q0FGQSxFQUdBLENBQUMsRUFBRCxhQUFPO0NBSFAsRUFJYyxDQUFiLEVBQUQsSUFBQSxVQUFjO0NBSmQsR0FLQyxFQUFELE9BQUEsRUFBQTtDQUxBLEVBTVEsQ0FBUCxFQUFEO0NBQVEsQ0FBSSxNQUFIO0NBQUQsQ0FBVSxNQUFIO0NBQVAsQ0FBZ0IsTUFBSDtDQU5yQixPQUFBO0NBQUEsQ0FBQSxDQU9ZLENBQVgsRUFBRCxFQUFBO0NBUEEsRUFRWSxDQUFYLEVBQUQ7Q0FSQSxFQVNZLENBQVgsRUFBRCxFQUFBO0NBVEEsRUFVUyxDQUFSLENBQUQsQ0FBQTtDQVZBLEVBV1ksQ0FBWCxFQUFELEVBQUEsTUFBWTtDQVhaLEVBWVUsQ0FBVCxFQUFELE1BQVU7Q0FaVixFQWFVLENBQVQsRUFBRCxFQUFtQixFQWJuQjtDQUFBLENBY2tDLENBQWxCLENBQWYsRUFBRCxFQUFBO0NBZEEsRUFlYyxDQUFiLEVBQUQ7Q0FmQSxFQWdCYSxDQUFaLENBQUQsQ0FBQTtDQWhCQSxDQWlCaUIsRUFBYixDQUFBLENBQUEsSUFBQTtDQWpCSixFQWtCQSxDQUFDLENBQUssQ0FBTjtDQWxCQSxHQW1CQyxDQUFELENBQUEsR0FBQTtDQW5CQSxFQW9CaUIsQ0FBaEIsRUFBRCxHQUFBO0NBcEJBLEVBcUJXLENBQVYsRUFBRCxDQUFBO0NBckJBLEVBc0JTLENBQVIsQ0FBRCxDQUFBO0NBdEJBLEVBdUJZLENBQVgsRUFBRCxFQUFBO0NBdkJBLENBd0JnRCxDQUF6QixDQUF0QixFQUFELFNBQUE7Q0F4QkEsRUF5QmEsQ0FBWixDQUFELENBQUE7Q0F6QkEsR0EwQkMsRUFBRCxPQUFBO0NBMUJBLEdBMkJDLEVBQUQsUUFBQTtDQTVCTCxJQUFjOztDQUFkLEVBOEJ1QixNQUFBLFdBQXRCO0NBQ0ksU0FBQSxtQkFBQTtDQUFBLENBQUEsQ0FBYSxHQUFiLElBQUE7QUFDQSxDQUFBLFVBQUEsa0NBQUE7d0JBQUE7Q0FDSSxDQUFvQyxDQUF6QixDQUFYLENBQWdCLEVBQXlDLENBQXpELElBQVc7Q0FBWCxFQUNnQixDQURoQixJQUNBLEVBQVc7Q0FGZixNQURBO0NBSUEsU0FBQSxHQUFPO0NBbkNaLElBOEJ1Qjs7Q0E5QnZCLEVBcUNzQixNQUFBLFVBQXJCO0NBQ0ksU0FBQSwrQkFBQTtDQUFBLENBQW9ELEVBQXZCLEVBQTdCLENBQTRCLENBQUEsSUFBQTtDQUE1QixDQUVJLENBRFEsQ0FBQSxDQUFBLENBQVosR0FBQSxDQUFZO0NBTUYsQ0FBb0IsQ0FBMUIsQ0FBQSxDQUFLLElBQUwsR0FBQSxDQUFBO0NBN0NULElBcUNzQjs7Q0FyQ3RCLEVBK0NVLENBQUEsR0FBVCxFQUFVO0NBQXVCLEVBQXlCLENBQVosRUFBM0IsS0FBQSxFQUFBO0NBL0NwQixJQStDVTs7Q0EvQ1YsRUFpRFcsS0FBVixDQUFVO0NBQWMsU0FBQSxDQUFBO0NBQUEsS0FBYixpREFBYTtDQUFBOztBQUFRLENBQUE7Y0FBQSw4QkFBQTs0QkFBQTtDQUFBLEdBQUMsR0FBRDtDQUFBOztDQUFSO0NBakR6QixJQWlEVzs7Q0FqRFgsQ0FtRGlCLENBQUosTUFBQyxDQUFiO0NBQTBCLENBQW1CLEVBQW5CLE1BQUQsR0FBQTtDQW5EMUIsSUFtRGE7O0NBbkRiLENBc0RlLENBQUosS0FBVixDQUFXO0NBQ1AsU0FBQSxDQUFBO0NBQUEsQ0FBc0IsQ0FBZixDQUFQLEVBQUEsSUFBTztDQUNQLEVBQU8sQ0FBQyxLQUFELElBQUEsQ0FBVTtDQXhEdEIsSUFzRFc7O0NBdERYLEVBMkRpQixNQUFBLEtBQWhCO0NBQ0ksU0FBQSxvQkFBQTtDQUFBLENBQUEsQ0FBTyxDQUFQLEVBQUE7Q0FBQSxDQUFBLENBQ08sQ0FBUCxFQUFBO0NBREEsRUFFVyxDQUFQLENBQUosQ0FBQSxHQUFZO0NBQ1IsQ0FBQSxDQUFVLENBQUwsSUFBTDtDQUNLLEVBQU0sQ0FBUCxDQUFKLElBQVksTUFBWjtDQUNTLEVBQVEsQ0FBUixhQUFMO0NBREosUUFBVztDQUZmLE1BQVc7Q0FGWCxFQU1hLENBQUEsRUFBYixPQUFhO0NBTmIsRUFPVSxDQVBWLEVBT0EsQ0FBQTtDQVBBLEVBUUksQ0FBSSxFQUFSO0NBUkEsRUFTUSxFQUFSLENBQUEsR0FBUztDQUNMLEVBQVcsQ0FBUCxDQUFKLEdBQUEsQ0FBWTtDQUNILEVBQU0sQ0FBUCxDQUFKLElBQVksUUFBWjtDQUNJLElBQUEsV0FBQTtDQUFBLENBQWtDLENBQTFCLEVBQVIsQ0FBYyxDQUFOLEtBQVI7Q0FDSyxFQUFpQixDQUFqQixDQUFTLGNBQWQ7Q0FGSixVQUFXO0NBRGYsUUFBVztDQURQLEdBS08sR0FBWCxRQUFBO0NBTEosTUFBUTtDQVZJLFlBZ0JaO0NBM0VMLElBMkRpQjs7Q0EzRGpCLEVBOEVnQixNQUFBLElBQWY7Q0FDSSxTQUFBLGlEQUFBO1NBQUEsR0FBQTtDQUFBLEVBQVMsQ0FBQyxFQUFWO0NBQUEsRUFDTyxDQUFQLEVBQUEsUUFBTztDQURQLEVBRWUsQ0FGZixFQUVBLE1BQUE7QUFDQSxDQUFBLEVBQUEsUUFBUyxtQkFBVDtBQUNJLENBQUEsRUFBQSxVQUFTLGlCQUFUO0NBQ0ksRUFBUSxDQUFLLENBQUssQ0FBbEIsSUFBQTtDQUNBLEdBQTBDLENBQUssS0FBL0M7Q0FBQSxFQUFlLEdBQUMsRUFBaEIsSUFBQTtZQURBO0NBQUEsRUFFYSxFQUFiLENBQU0sR0FBUSxDQUFkO0NBQXFCLENBQW9CLENBQUosRUFBaEIsQ0FBRCxhQUFBO0NBQXBCLFVBQWE7Q0FIakIsUUFESjtDQUFBLE1BSEE7Q0FBQSxFQVFZLEdBQVosRUFSQSxDQVFBO0NBQ0MsQ0FBMEIsQ0FBaEIsQ0FBVixFQUFNLEdBQVAsR0FBQSxDQUFBO0NBeEZMLElBOEVnQjs7Q0E5RWhCLENBMEZhLENBQUosR0FBUixHQUFTLFNBQUQ7Q0FDSixTQUFBLElBQUE7Q0FBQSxFQUFPLENBQUMsRUFBUjtDQUFBLENBQ3lCLENBQWQsQ0FBWCxDQUE4QixDQUE5QixVQUF5QjtDQUR6QixFQUV3QixDQUFwQixDQUZKLENBRUEsQ0FBQSxDQUFhO0NBRmIsRUFHVyxHQUFYLEVBQUE7Q0FIQSxDQUlnQyxDQUFoQyxDQUFJLEVBQUosRUFBYTtDQUpiLEVBS1ksQ0FBUixFQUFKLENBTEE7Q0FNQSxHQUFHLEVBQUgsb0JBQUE7QUFDa0IsQ0FBZCxHQUFBLElBQUEsVUFBYztDQUFkLGVBQUE7VUFESjtRQU5BO0NBQUEsQ0FRYSxDQUFiLENBQUMsRUFBRDtDQVJBLEVBU0EsQ0FBQyxDQUFLLENBQU47Q0FUQSxHQVVJLEVBQUosTUFBQTtDQVZBLEVBV3dCLENBQXBCLENBWEosQ0FXQSxVQUFBO0NBdEdMLElBMEZTOztDQTFGVCxFQXlHZSxNQUFBLEdBQWQ7Q0FDSSxLQUFBLElBQUE7Q0FBQSxDQUFhLENBQUEsQ0FBQSxDQUFzQixDQUFuQyxXQUFhO0NBQWIsQ0FDcUIsQ0FBUCxHQUFkO0NBRlUsWUFHVjtDQTVHTCxJQXlHZTs7Q0F6R2YsRUE4R2lCLE1BQUEsS0FBaEI7Q0FDSSxPQUFBLEVBQUE7Q0FBQSxFQUFlLENBQUEsRUFBZixFQUFBLEtBQWU7Q0FBYSxDQUFZLEVBQVosSUFBQyxDQUFBO0NBQTdCLE9BQWU7Q0FBZixDQUN5QixFQUFQLENBQWxCLENBQUEsQ0FBQSxDQUFRO0NBRFIsQ0FFb0MsQ0FBcEMsR0FBQSxFQUFRLFFBQVI7Q0FGQSxJQUdBLENBQUEsRUFBUTtDQUhSLEtBSUEsRUFBK0IsRUFBL0IsRUFBQTtDQUxZLFlBTVo7Q0FwSEwsSUE4R2lCOztDQTlHakIsRUFzSFksRUFBQSxJQUFYO0NBQ0ksU0FBQSxvQkFBQTtDQUFBLEVBQW1CLENBQUEsRUFBbkIsRUFBbUIsSUFBbkI7Q0FBQSxFQUNBLEVBQUssQ0FBTCxNQUFBO0NBREEsQ0FFa0QsQ0FBM0IsQ0FBQSxFQUF2QixFQUF1QixRQUF2QjtDQUZBLENBR2lDLENBQWpDLEdBQUEsRUFBeUIsUUFBVDtDQUhoQixLQUlBLEVBQXlCLENBQXpCLE9BQWdCO0NBQ1YsRUFBTixFQUFLLFFBQUwsR0FBQTtDQTVITCxJQXNIWTs7Q0F0SFosRUE4SGlCLE1BQUEsS0FBaEI7Q0FDSSxTQUFBLGtCQUFBO1NBQUEsR0FBQTtDQUFBLEVBQVMsR0FBVCxHQUFVO0NBQ04sQ0FBNEIsQ0FBNUIsQ0FBQSxJQUFBLENBQUE7Q0FBcUMsRUFBUyxFQUFULEdBQVMsU0FBVjtDQUFwQyxRQUFpQztDQUNqQyxDQUEwQixDQUExQixDQUFBLEdBQUEsQ0FBQSxDQUErQixNQUEvQjtDQUFtQyxFQUFTLEVBQVQsR0FBUyxTQUFWO0NBQWxDLFFBQStCO0NBRm5DLE1BQVM7Q0FHVDtDQUFBLFVBQUEsaUNBQUE7eUJBQUE7Q0FDSSxFQUFBLEdBQUEsRUFBQTtDQURKLE1BSEE7Q0FBQSxDQUs0QixDQUE1QixDQUFBLEVBQUEsRUFBQSxDQUFBO0NBQXFDLElBQUEsTUFBRCxJQUFBO0NBQXBDLE1BQWlDO0NBTGpDLEVBTXFCLENBQWxCLEVBQUgsR0FBQTtDQUE2QixJQUFBLE1BQUQsSUFBQTtDQUE1QixNQUFxQjtDQU5yQixFQU9tQixDQUFoQixFQUFILENBQUEsRUFBb0I7Q0FBTyxJQUFBLElBQUQsTUFBQTtDQUExQixNQUFtQjtDQUNuQixFQUFxQixDQUFsQixFQUFILEdBQUEsSUFBQTtDQUE2QixJQUFBLE1BQUQsSUFBQTtDQUE1QixNQUFxQjtDQXZJMUIsSUE4SGlCOztDQTlIakIsRUF5SWMsTUFBQSxFQUFiO0FBQ2MsQ0FBVixFQUFTLENBQVIsQ0FBRCxDQUFBO0NBQ0EsR0FBa0IsQ0FBQSxDQUFsQjtDQUFBLEdBQUMsQ0FBSyxHQUFOO1FBRlM7Q0F6SWQsSUF5SWM7O0NBeklkLEVBOElZLEVBQUEsSUFBWDtBQUNXLENBQVAsR0FBRyxDQUFBLENBQUgsSUFBNEIsRUFBVjtDQUNkLENBQTBCLENBQWQsQ0FBWCxDQUFpQixHQUFsQjtRQURKO0NBRUMsRUFBUSxDQUFSLENBQUQsUUFBQTtDQWpKTCxJQThJWTs7Q0E5SVosRUFtSmMsRUFBQSxJQUFDLEVBQWQ7Q0FBeUIsRUFBUSxDQUFSLENBQUQsUUFBQTtDQW5KekIsSUFtSmM7O0NBbkpkLEVBcUpjLEVBQUEsSUFBQyxFQUFkO0NBQ0ksRUFBUyxDQUFSLENBQUQsQ0FBQTtBQUNjLENBQWQsR0FBQSxDQUFjLENBQWQsSUFBd0IsR0FBVjtDQUFkLGFBQUE7UUFEQTtDQUVDLENBQXdCLENBQWQsQ0FBVixDQUFnQixFQUFqQixNQUFBO0NBeEpMLElBcUpjOztDQXJKZCxFQTBKYyxNQUFBLEVBQWI7Q0FDSSxTQUFBLGdCQUFBO0NBQUEsR0FBYyxFQUFkLGVBQUE7Q0FBQSxhQUFBO1FBQUE7Q0FBQSxDQUNDLEVBQVMsRUFBVixFQUFTO0NBRFQsRUFFSSxDQUFNLENBQU4sQ0FBSjtBQUNNLENBSE4sRUFHSSxDQUFPLEVBQVg7Q0FIQSxDQUlnQixDQUFQLEdBQVQ7Q0FKQSxDQUttQyxFQUFsQyxFQUFELEdBQVUsTUFBVjtDQUxBLEVBTVEsQ0FBZ0IsQ0FBeEIsQ0FBQSxDQUFRLENBQUEsQ0FBQTtDQU5SLENBTzZDLENBQXRCLENBQXRCLENBQXNCLENBQXZCLEVBQXVCLFNBQXZCO0NBUEEsRUFRWSxDQUFYLEVBQUQsRUFBQTtDQW5LTCxJQTBKYzs7Q0ExSmQsRUFzS1ksTUFBWDtDQUNJLFNBQUEsUUFBQTtDQUFBO0NBQUEsVUFBQSxpQ0FBQTt1QkFBQTtDQUNJLEdBQWdCLENBQWlCLENBQVQsQ0FBeEIsQ0FBQTtDQUFBLGdCQUFPO1VBRFg7Q0FBQSxNQUFBO0NBRUEsR0FBQSxTQUFPO0NBektaLElBc0tZOztDQXRLWixFQTRLb0IsTUFBQyxRQUFwQjtDQUNJLFNBQUEsa0JBQUE7Q0FBQSxFQUFTLENBQUMsRUFBVixHQUFTO0NBQ1QsR0FBYyxFQUFkLFFBQUE7Q0FBQSxhQUFBO1FBREE7QUFFYyxDQUFkLEdBQUEsRUFBQSxFQUFjLFVBQUE7Q0FBZCxhQUFBO1FBRkE7Q0FBQSxFQUdPLENBQVAsRUFBQTtDQUhBLEdBSUMsQ0FBSyxDQUFOO0NBSkEsQ0FLQyxFQUFlLEVBQWhCLEVBQVk7Q0FMWixDQU1hLEVBQVosRUFBRCxFQUFBO0NBbkxMLElBNEtvQjs7Q0E1S3BCLEVBdUxhLE1BQUEsQ0FBWjtDQUNJLFNBQUEsZ0JBQUE7Q0FBQSxHQUFjLEVBQWQsY0FBQTtDQUFBLGFBQUE7UUFBQTtDQUFBLENBQ0MsRUFBUyxFQUFWLENBQUEsQ0FBUztDQURULEVBRUksQ0FBTSxDQUFOLENBQUo7QUFDTSxDQUhOLEVBR0ksQ0FBTyxFQUFYO0NBSEEsQ0FJZ0IsQ0FBUCxHQUFUO0NBSkEsQ0FLbUMsRUFBbEMsRUFBRCxHQUFVLE1BQVY7Q0FMQSxFQU1RLENBQWdCLENBQXhCLENBQUEsQ0FBUSxDQUFBLENBQUE7Q0FOUixDQU80QyxDQUF0QixDQUFyQixDQUFxQixDQUF0QixFQUFzQixRQUF0QjtDQVBBLEVBUVcsQ0FBVixFQUFELENBQUE7Q0FoTUwsSUF1TGE7O0NBdkxiLEVBbU0wQixHQUFBLEdBQUMsY0FBMUI7Q0FDSSxRQUFBLENBQUE7Q0FBQSxFQUFTLENBQVcsQ0FBWCxDQUFUO0NBQUEsRUFDSSxFQUFBLENBQUosQ0FBSSxDQUFzQixNQUFpQjtDQUMzQyxZQUFPO0NBdE1aLElBbU0wQjs7Q0FuTTFCLEVBd01jLE1BQUMsRUFBZDtDQUNJLEVBQWtCLENBQVgsRUFBUCxFQUFPO0NBQVAsRUFDa0IsQ0FBWCxFQUFQLEVBQU87Q0FEUCxFQUVrQixDQUFYLEVBQVAsRUFBTztDQUNQLFlBQU87Q0E1TVosSUF3TWM7O0NBeE1kLEVBOE15QixNQUFDLGFBQXpCO0NBQ0ksU0FBQSxFQUFBO0NBQUEsRUFBa0IsQ0FBSCxFQUFmLEdBQTRCO0NBQTVCLEdBQUEsV0FBTztRQUFQO0NBQUEsRUFDQSxHQUFBO0NBREEsRUFFSSxHQUFKO0NBRkEsRUFHSSxHQUFKLEdBSEE7QUFJTSxDQUpOLEVBSUksR0FBSjtDQUpBLEVBS0csR0FBSDtDQUxBLEVBTUcsR0FBSDtDQU5BLEVBT0csR0FBSDtDQUNBLEVBQU8sQ0FBQyxPQUFELEVBQUE7Q0F2TlosSUE4TXlCOztDQTlNekIsRUF5TmtCLENBQUEsS0FBQyxNQUFsQjtDQUNLLEVBQWMsQ0FBZCxNQUEwQixDQUEzQixFQUFBO0NBMU5MLElBeU5rQjs7Q0F6TmxCLEVBNE5xQixNQUFDLFNBQXJCO0NBQ0ksS0FBQSxJQUFBO0NBQUEsRUFBUyxDQUFDLEVBQVYsR0FBUztDQUNULEdBQTBDLEVBQTFDLFFBQUE7Q0FBQSxFQUFPLENBQUMsV0FBRCxPQUFBO1FBRFA7Q0FFQSxHQUFRLEVBQUQsT0FBQSxVQUFBO0NBL05aLElBNE5xQjs7Q0E1TnJCLENBaU9tQixDQUFKLE1BQUMsR0FBZjtDQUNJLFNBQUEsRUFBQTtDQUFDLENBQVUsQ0FBb0IsQ0FBOUIsRUFBRCxHQUFnQyxFQUFoQyxFQUFBO0FBQTZDLENBQUosR0FBSSxDQUFDLFVBQUw7Q0FBekMsTUFBK0I7Q0FsT3BDLElBaU9lOztDQWpPZixFQW9PYSxPQUFaOztDQXBPRCxFQXNPcUIsTUFBQyxTQUFyQjtDQUNJLEdBQUEsTUFBQTtDQUFBLEVBQU8sQ0FBUCxFQUFBLEVBQXNCLEVBQWY7Q0FDUCxFQUEwQixDQUFuQixJQUFRLEVBQWYsR0FBTztDQXhPWixJQXNPcUI7O0NBdE9yQixFQTBPbUIsTUFBQyxPQUFuQjtDQUNJLFNBQUEsU0FBQTtDQUFBLEVBQUksQ0FBQyxFQUFMLFlBQUk7Q0FDSixHQUFjLEVBQWQsR0FBQTtDQUFBLGFBQUE7UUFEQTtDQUFBLENBRTJCLENBQWpCLENBQUMsRUFBWCxDQUFBLEdBQVU7Q0FGVixDQUdJLElBQUg7QUFDYSxDQUFkLEdBQUEsRUFBQSxZQUFjO0NBQWQsYUFBQTtRQUpBO0FBS2MsQ0FBZCxDQUFrQyxFQUFsQyxFQUFBLElBQWM7Q0FBZCxhQUFBO1FBTEE7Q0FNQSxHQUFVLEVBQVYsd0JBQUE7Q0FBQSxhQUFBO1FBTkE7Q0FBQSxDQU9pQixFQUFoQixFQUFELE1BQUE7Q0FsUEwsSUEwT21COztDQTFPbkIsRUFzUFcsS0FBVixDQUFVO0NBQUksR0FBQSxJQUFELEtBQUEsRUFBZ0I7Q0F0UDlCLElBc1BXOztDQXRQWCxFQXdQUSxFQUFQLElBQU87Q0FDSCxNQUFBLEdBQUE7U0FBQSxHQUFBO0NBQUEsRUFBVSxHQUFWLENBQUEsRUFBVTtBQUNTLENBQWYsR0FBQSxDQUFnQixHQUFoQjtDQUFBLEdBQUEsQ0FBQyxLQUFEO1VBQUE7Q0FDc0IsQ0FBUyxHQUFDLEVBQWhDLENBQXdDLEVBQXhDLEtBQUEsTUFBQTtDQUZKLE1BQVU7Q0FHVixNQUFBLE1BQUE7Q0E1UEwsSUF3UFE7O0NBeFBSLENBOFBhLENBQU4sQ0FBTjs7Q0E5UEQsQ0FBQSxDQStQaUIsV0FBaEI7O0NBL1BELEVBaVFXLEtBQVYsQ0FBVyxDQUFEO0NBQ04sU0FBQSx3Q0FBQTtDQUFBLEdBQUMsRUFBRCxJQUFBO0NBQUEsRUFDaUIsQ0FBSSxDQUFKLENBQWpCLElBQWlCLElBQWpCO0FBQ00sQ0FBTixDQUFNLENBQW1CLFVBQW5CLENBQUE7Q0FDRixHQUFDLElBQUQsSUFBQTtDQUNBO0NBQUEsWUFBQSwrQkFBQTs0QkFBQTtDQUF1QixHQUFDLENBQWdCOztZQUNwQztDQUFBLEVBQWMsQ0FBQyxFQUFNLEVBQVAsRUFBZCxDQUFBO0NBQUEsQ0FDMEIsRUFBekIsRUFBTSxJQUFQLENBQUE7Q0FDQSxHQUFHLElBQUEsRUFBSDtDQUNJLENBQTBCLEVBQXpCLEVBQU0sS0FBUCxDQUFBO0NBQ0EsRUFBb0IsQ0FBQSxDQUFRLE9BQTVCO0NBQUEsRUFBWSxDQUFYLElBQUQsTUFBQTtjQUZKO0NBR3lCLEVBQWpCLENBQUEsQ0FBUSxDQUhoQixNQUFBO0NBSUksRUFBWSxDQUFYLENBQUQsR0FBQSxJQUFBO1lBUFI7Q0FBQSxRQUZKO0NBSE0sTUFHTjtDQXBRTCxJQWlRVzs7Q0FqUVgsRUFrUkksT0FESDtDQUNHLENBQUksRUFBSixFQUFDO0NBQUQsQ0FDSSxFQURKLEVBQ0M7Q0FERCxDQUVJLEVBRkosRUFFQztDQUZELENBR0ksRUFISixFQUdDO0NBclJMLEtBQUE7O0NBQUEsRUF1UmEsTUFBQSxDQUFaO0NBQWdCLEdBQUEsQ0FBRCxHQUFTLEtBQVQ7Q0F2UmhCLElBdVJhOztDQXZSYixFQXlSYSxNQUFBLENBQVo7Q0FDSSxTQUFBLGtEQUFBO0NBQUEsQ0FBQSxDQUFVLEdBQVYsQ0FBQTtDQUFBLENBQUEsQ0FDWSxHQUFaLEdBQUE7Q0FEQSxFQUVVLENBQVQsRUFBRDtDQUZBLEVBR1UsQ0FBVCxFQUFEO0NBQ0E7Q0FBQSxVQUFBLENBQUE7NkJBQUE7Q0FDSSxDQUFPLE1BQU47QUFDK0IsQ0FEaEMsRUFDQSxFQUFzQixFQUFoQixDQUFOLENBQVM7Q0FDVCxFQUFnQyxDQUFWLElBQXRCO0NBQUEsRUFBQSxDQUFDLE1BQUQ7VUFISjtDQUFBLE1BSkE7Q0FRQSxHQUFHLEVBQUgsSUFBRztDQUNDLEVBQVksQ0FBWCxDQUFELEdBQUE7Q0FBQSxFQUNVLENBQVQsSUFBRCxDQURBO1FBVEo7Q0FBQSxHQVdDLEVBQUQsUUFBQTtDQVhBLEdBWUMsRUFBRCxhQUFBO0NBdFNMLElBeVJhOztDQXpSYixFQXlTaUIsTUFBQSxLQUFoQjtDQUNJLElBQUEsS0FBQTtDQUFBLEdBQUcsQ0FBVyxDQUFkO0NBQ0ksQ0FBaUIsQ0FBVCxDQUFJLENBQVosR0FBQTtDQUFBLEdBQ0MsQ0FERCxHQUNBO0NBREEsR0FFQyxDQUZELEdBRUE7UUFKUTtDQXpTakIsSUF5U2lCOztDQXpTakIsRUFnVHNCLE1BQUEsVUFBckI7Q0FDSSxTQUFBLHFCQUFBO0NBQUEsQ0FBQyxFQUFTLEVBQVYsRUFBUyxLQUFBO0NBQVQsQ0FDMEIsQ0FBWCxDQUFBLEVBQWYsQ0FBZSxDQUFmLENBQWU7QUFDcUIsQ0FGcEMsQ0FFbUMsQ0FBcEIsQ0FBQSxFQUFmLENBQWUsQ0FBZjtDQUZBLEdBR3lCLEVBQXpCLEVBQVEsTUFBUjtDQUhBLEdBSXlCLEVBQXpCLEVBQVEsTUFBUjtDQUpBLEVBS1UsQ0FBVCxFQUFELEVBQWtCO0NBQ2pCLEVBQVMsQ0FBVCxJQUFpQixLQUFsQjtDQXZUTCxJQWdUc0I7O0NBaFR0QixFQTBUZSxNQUFBLEdBQWQ7QUFBaUIsQ0FBQSxFQUFpQyxDQUFqQyxFQUFBO0NBQUMsR0FBQSxXQUFEO1FBQUg7Q0ExVGYsSUEwVGU7O0NBMVRmLEVBNFRnQixNQUFBLElBQWY7Q0FDSSxTQUFBLElBQUE7Q0FBQSxFQUFBLENBQU8sRUFBUCxNQUFNO0NBQU4sRUFDQSxDQUFDLEVBQUQsRUFBUztDQURULENBRVksQ0FBQSxDQUFDLEVBQWIsRUFBcUIsQ0FBckIsSUFBWSxDQUFBO0NBRlosRUFHYyxHQUFkLEdBQVM7Q0FIVCxFQUlHLEdBQUgsQ0FBQSxFQUFBO0NBalVMLElBNFRnQjs7Q0E1VGhCLENBQUEsQ0FvVWEsT0FBWjs7Q0FwVUQsRUFzVU8sQ0FBTixLQUFNO0NBQ0YsU0FBQTtDQUFBLEVBQWEsQ0FBQyxDQUFLLENBQW5CLEVBQWEsRUFBYjtDQUFBLEdBQ0MsRUFBRCxJQUFBO0NBREEsR0FFQyxFQUFELEtBQUE7Q0FGQSxHQUdDLEVBQUQsRUFBQSxFQUFBO0NBSEEsR0FJQyxDQUFELENBQUEsRUFBUztDQUpULEdBS0MsRUFBRCxFQUFTO0NBTFQsR0FNQyxFQUFELE9BQUE7Q0FOQSxDQU95QixFQUF4QixDQUFELENBQUEsRUFBUztDQTlVZCxJQXNVTzs7Q0F0VVA7O0NBcE1IOztDQUFBLENBcWhCTTtDQUNIO0NBQWMsRUFBQSxDQUFBLG9CQUFFO0NBQ1gsRUFEVyxDQUFBLEVBQUQ7Q0FDVixFQUFXLENBQVYsRUFBRCxDQUFBLE1BQUE7Q0FETCxJQUFjOztDQUFkLEVBR1csQ0FBQSxJQUFWLENBQVc7Q0FBRCxFQUN3QyxDQUE3QyxTQUFBLEdBQUEsOEJBQUE7Q0FKTixJQUdXOztDQUhYLEVBTVksTUFBWDtDQUNJLEdBQWdCLENBQVksQ0FBNUI7Q0FBQSxJQUFBLFVBQU87UUFBUDtDQUFBLENBQ0EsRUFBQyxFQUFEO0NBQ0EsSUFBQSxRQUFPO0NBVFosSUFNWTs7Q0FOWixFQVdhLEVBQUEsSUFBQyxDQUFiO0NBQ0ksU0FBQTtBQUFrQyxDQUFsQyxFQUFBLENBQW1CLENBQVQsQ0FBVjtDQUFBLEVBQ1EsQ0FBaUIsQ0FBekIsQ0FBQSxDQUFTO0NBQ1IsR0FBQSxDQUFjLENBQWYsT0FBQTtDQWRMLElBV2E7O0NBWGIsRUFnQlUsR0FBQSxDQUFULEVBQVU7Q0FBWSxDQUFvQixDQUFyQixDQUFDLEVBQUQsS0FBQSxFQUFBO0NBaEJ0QixJQWdCVTs7Q0FoQlYsRUFpQlksR0FBQSxFQUFYLENBQVk7Q0FBWSxDQUFvQixFQUFwQixFQUFELEtBQUEsRUFBQTtDQWpCeEIsSUFpQlk7O0NBakJaLEVBbUJTLENBQUEsRUFBUixHQUFTO0NBQ0wsR0FBVSxDQUFZLENBQXRCLENBQVU7Q0FBVixhQUFBO1FBQUE7Q0FBQSxHQUNDLEVBQUQsU0FBQTtDQURBLEdBRUMsRUFBRCxDQUFBO0NBRkEsR0FHQyxFQUFELENBQUEsQ0FBQTtDQUNDLEVBQVUsQ0FBVixHQUFELE1BQUE7Q0F4QkwsSUFtQlM7O0NBbkJULENBMEJ1QixDQUFULEdBQUEsR0FBQyxFQUFkO0NBQThCLEVBQUUsR0FBRixPQUFBO0NBQW1CLENBQVUsQ0FBVixJQUFDLENBQUE7Q0FBckMsT0FBaUI7Q0ExQi9CLElBMEJjOztDQTFCZCxFQTRCUyxHQUFSLEdBQVE7Q0FDSixTQUFBLGNBQUE7U0FBQSxHQUFBO0NBQUEsS0FBQSxHQUFBOztBQUFhLENBQUE7Y0FBQSwrQkFBQTswQkFBQTtDQUFBLEdBQUMsSUFBRDtDQUFBOztDQUFiO0NBQUEsRUFDYSxHQUFiLEdBQWEsQ0FBYjtDQURBLENBRWtCLEVBQUEsRUFBbEIsR0FBMkIsQ0FBakI7Q0FGVixHQUdDLEVBQUQsQ0FBQTtDQUhBLEVBSXFCLEdBQXJCLEdBQUEsQ0FBVTtDQUFtQixJQUFBLElBQUQsTUFBQTtDQUE1QixNQUFxQjtDQUpyQixDQUsyQixDQUFKLEVBQUEsQ0FBdkIsRUFBQSxDQUF3QixDQUF4QjtDQUFzQyxJQUFBLEtBQUQsS0FBQTtDQUFyQyxNQUF1QjtDQUNaLEdBQVgsTUFBVSxHQUFWO0NBbkNMLElBNEJTOztDQTVCVDs7Q0F0aEJIOztDQUFBLENBMmpCTTtDQUNIO0NBQWMsRUFBQSxDQUFBLElBQUEsY0FBRTtDQUNYLEVBRFcsQ0FBQSxFQUFELEVBQ1Y7Q0FBQSxFQUFjLENBQWIsRUFBRCxJQUFBLEtBQWM7Q0FEbkIsSUFBYzs7Q0FBZCxFQUlJLFNBREg7Q0FDRyxDQUFZLElBQVgsR0FBQSxLQUFEO0NBQUEsQ0FDYSxJQUFaLElBQUEsQ0FERDtDQUFBLENBRU8sRUFBTixFQUFBLCtDQUZEO0NBQUEsQ0FHUSxHQUFQLENBQUEsU0FIRDtDQUFBLENBSVEsR0FBUCxDQUFBO0NBSkQsQ0FLTyxFQUFOLEVBQUEsYUFMRDtDQUFBLENBTVMsSUFBUiwyQkFORDtDQUpKLEtBQUE7O0NBQUEsRUFZa0IsTUFBQSxNQUFqQjtDQUNJLFNBQUEsRUFBQTtDQUFBLEVBRVEsQ0FGUCxDQUVPLENBRlIsSUFBVyxjQUFYLHNEQUFvQjtDQUFwQixFQUlvQyxHQUFwQyxHQUFBLGFBQUE7Q0FDSSxHQUFBLENBQUMsR0FBRCxFQUFXO0NBQ1YsSUFBQSxHQUFELE9BQUE7Q0FGSixNQUFvQztDQWpCekMsSUFZa0I7O0NBWmxCLEVBc0JTLEdBQVIsR0FBUTthQUNKOzs7Q0FESTtDQXRCVCxJQXNCUzs7Q0F0QlQsRUE0QlMsR0FBUixHQUFRO0NBQ0osU0FBQSxxQ0FBQTtDQUFBLEdBQUMsRUFBRCxFQUFBO0NBQUEsR0FDQyxFQUFELFNBQUE7Q0FEQSxFQUVZLEdBQVosR0FBQSwwREFGQTtDQUFBLEVBR1MsRUFBVCxDQUFBLEdBQVMsd0JBSFQsRUFHUztDQUhULEVBSVUsR0FBVixDQUFBLGlKQUpBO0NBQUEsRUFLVSxHQUFWLENBQVUsWUFBQSw0RUFMVjtDQUFBLEVBTWUsR0FBZixNQUFBLDBOQU5BO0NBQUEsRUFPMkIsQ0FBMUIsQ0FBa0IsQ0FBbkIsSUFBVyxFQUFRO0NBQ2xCLEdBQUEsTUFBVSxHQUFYO0NBckNMLElBNEJTOztDQTVCVCxFQXVDUSxFQUFQLElBQU87Q0FDSCxRQUFBLENBQUE7Q0FBQSxFQUFBLEdBQUE7O0FBQU8sQ0FBQTtHQUFBLFdBQUEsV0FBQTtDQUFBLEdBQUM7Q0FBRDs7Q0FBUDtDQUNJLEVBQUQsQ0FBSCxTQUFBO0NBekNMLElBdUNROztDQXZDUixFQTJDTyxDQUFOLEtBQU87Q0FDSCxHQUFBLE1BQUE7Q0FBQSxFQUFPLENBQVAsRUFBQSxNQUFxQjtDQUNHLEVBQUEsQ0FBQyxTQUF4QixXQUFBLFNBQUE7Q0E3Q04sSUEyQ087O0NBM0NQLEVBZ0RXLEtBQVYsQ0FBVTtDQUNOLFNBQUEsYUFBQTtDQUFBO0NBQUEsVUFBQSxpQ0FBQTs0QkFBQTtDQUNJLENBQTBDLENBQTFDLENBQUMsRUFBZSxFQUFoQixFQUFXLEtBQVg7Q0FESixNQURNO0NBaERYLElBZ0RXOztDQWhEWCxFQXFEQyxDQUFLLEtBQUM7Q0FBRCxFQUFxQyxDQUExQixTQUFBLGNBQUE7Q0FyRGpCLElBcURNOztDQXJETjs7Q0E1akJIOztDQUFBLENBc25CQSxDQUFpQixHQUFYLENBQU4sRUFBaUI7Q0FDYixPQUFBLENBQUE7Q0FBQSxFQUFBLENBQUEsR0FBTyxpQkFBUDtDQUFBLEdBQ0EsS0FBQTtDQURBLEdBRUEsV0FBQTtDQUZBLENBR2dDLENBQUEsQ0FBaEMsSUFBQSxDQUFnQyxJQUFoQztDQUFnQyxZQUFHO0NBQW5DLElBQWdDO0FBQ1ksQ0FBNUMsR0FBQSxDQUFBLEdBQW9EO0NBQXBELE9BQWUsS0FBUixLQUFBO01BSlA7Q0FBQSxFQUtZLENBQVosS0FBQTtDQUNJLEdBQUEsTUFBQTtDQUFBLEVBQVcsQ0FBWCxFQUFBO0NBQUEsR0FDSSxFQUFBLFFBQUE7Q0FDQyxHQUFELENBQUosUUFBQTtDQVJKLElBS1k7Q0FJSyxHQUFiLEVBQUEsR0FBQSxFQUFBLENBQUE7Q0Fob0JSLEVBc25CaUI7Q0F0bkJqQjs7Ozs7QUNEQTtDQUFBLEtBQUEsUUFBQTtDQUFBO0NBQUEsQ0FBQSxDQUVHLFdBRkg7Q0FFRyxDQUF3QixDQUFBLENBQXZCLEtBQXdCLFlBQXhCO0FBQTRDLENBQUQsQ0FBRSxDQUFLLENBQU0sU0FBYjtDQUE1QyxJQUF3QjtDQUF4QixDQUlvQixDQUFBLENBQW5CLENBQW1CLElBQUMsUUFBcEI7Q0FDSSxTQUFBLDBCQUFBO0NBQUEsRUFBTyxDQUFQLEVBQUEsUUFBcUIsT0FBckI7Q0FDQTtDQUFBLFVBQUEsZ0NBQUE7eUJBQUE7Q0FDSSxDQUFrQyxDQUF2QixDQUFBLENBQVUsR0FBckI7QUFFb0IsQ0FBcEIsR0FBQSxJQUFBO0NBQUEsSUFBQSxZQUFPO1VBSFg7Q0FBQSxNQURBO0NBS0EsR0FBQSxTQUFPO0NBVlosSUFJb0I7Q0FOdkIsR0FBQTs7Q0FBQSxDQWNBLENBQWlCLEdBQVgsQ0FBTixPQWRBO0NBQUE7Ozs7O0FDQUE7Q0FBQSxLQUFBLCtCQUFBO0NBQUE7Q0FBQSxDQUFBLENBQUksSUFBQSxDQUFBOztDQUFKLENBQ0EsQ0FBUSxFQUFSLEVBQVE7O0NBRFIsQ0FFRSxDQUFVLEVBRlosRUFFWSxrQkFBQTs7Q0FGWixDQUlBLENBQ0csT0FESDtDQUNHLENBQWUsQ0FBQSxDQUFkLENBQWMsSUFBQyxHQUFmO0NBQStCLElBQUQsUUFBTDtDQUExQixJQUFlO0NBQWYsQ0FDZ0IsQ0FBQSxDQUFmLENBQWUsSUFBQyxJQUFoQjtDQUFnQyxJQUFELFFBQUw7Q0FEM0IsSUFDZ0I7Q0FEaEIsQ0FHbUIsQ0FBQSxDQUFsQixDQUFrQixJQUFDLE9BQW5CO0NBQW1DLEdBQWdCLENBQWpCLENBQUwsTUFBc0IsQ0FBdEI7Q0FIOUIsSUFHbUI7Q0FSdEIsR0FBQTs7Q0FBQSxDQVVNO0NBQ0g7Q0FBYyxDQUFTLENBQVQsQ0FBQSxFQUFBLElBQUEsUUFBQztDQUNWLEVBQVUsQ0FBVCxFQUFEO0NBQUEsQ0FDK0IsQ0FBakIsQ0FBYixDQUFrQixDQUFuQixDQUFjO0NBRGQsRUFFYyxDQUFiLEVBQUQsRUFGQSxFQUVBO0NBRkEsRUFHYSxDQUFaLEVBQUQsR0FBQTtDQUhBLEVBSVUsQ0FBVCxFQUFEO0NBSkEsRUFLVSxDQUFULEVBQUQ7Q0FMQSxFQU1BLENBQUMsRUFBRDtDQU5BLEVBT0EsQ0FBQyxFQUFEO0NBUEEsRUFRZSxDQUFkLENBUkQsQ0FRQSxLQUFBO0NBUkEsRUFTVyxDQUFWLEVBQUQsQ0FBQTtDQVRBLEVBVVcsQ0FBVixFQUFELENBQUE7Q0FWQSxHQVdDLEVBQUQsUUFBQTtDQVpMLElBQWM7O0NBQWQsRUFjaUIsTUFBQSxLQUFoQjtDQUNJLFNBQUEsRUFBQTtDQUFBLEVBQXlCLENBQXRCLEVBQUgsR0FBQSxDQUFBO0NBQWlDLElBQUEsTUFBRCxJQUFBO0NBQWhDLE1BQXlCO0NBQXpCLEVBQ3lCLENBQXRCLEVBQUgsR0FBQSxDQUFBO0NBQWlDLElBQUEsTUFBRCxJQUFBO0NBQWhDLE1BQXlCO0NBRHpCLEVBRXVCLENBQXBCLEVBQUgsQ0FBQSxFQUF3QixDQUF4QjtDQUErQixJQUFBLElBQUQsTUFBQTtDQUE5QixNQUF1QjtDQUN2QixFQUEwQixDQUF2QixLQUF3QixDQUEzQixHQUFBO0NBQWtDLElBQUEsUUFBRCxFQUFBO0NBQWpDLE1BQTBCO0NBbEIvQixJQWNpQjs7Q0FkakIsRUFvQmdCLEVBQUEsSUFBQyxJQUFoQjtBQUM2QixDQUF6QixHQUFBLENBQXlCLENBQXpCLElBQW1DLE1BQVY7Q0FBeEIsR0FBQSxDQUFELElBQUEsTUFBQTtRQURXO0NBcEJoQixJQW9CZ0I7O0NBcEJoQixFQXVCYyxFQUFBLElBQUMsRUFBZDtBQUNrQixDQUFkLEdBQUEsQ0FBYyxDQUFkLElBQXdCLEVBQVY7Q0FBZCxhQUFBO1FBQUE7Q0FDQSxHQUF1QixDQUFpQixDQUF4QyxFQUFBLEVBQXVCO0NBQXZCLEdBQUMsQ0FBRCxHQUFBLEVBQVc7UUFEWDtDQUFBLEVBRVcsQ0FBVixDQUFlLENBQWhCLENBQUE7Q0FGQSxFQUdXLENBQVYsQ0FBZSxDQUFoQixDQUFBO0NBSEEsR0FJQyxDQUFELENBQUEsRUFBQTtDQUpBLEVBS2UsQ0FBZCxFQUFELEtBQUE7Q0FDQSxJQUFBLFFBQU87Q0E5QlosSUF1QmM7O0NBdkJkLEVBZ0NZLEVBQUEsSUFBWDtDQUNJLEVBQWUsQ0FBZCxDQUFELENBQUEsS0FBQTtDQUNBLElBQUEsUUFBTztDQWxDWixJQWdDWTs7Q0FoQ1osRUFvQ1csRUFBQSxHQUFWLENBQVc7Q0FDUCxFQUFVLENBQVQsQ0FBYyxDQUFmO0NBQ0MsRUFBUyxDQUFULENBQWMsQ0FBZixPQUFBO0NBdENMLElBb0NXOztDQXBDWCxFQXdDYyxFQUFBLElBQUMsRUFBZDtBQUNrQixDQUFkLEdBQUEsRUFBQSxLQUFBO0NBQUEsYUFBQTtRQUFBO0NBQUEsR0FDQyxDQUFELENBQUEsRUFBQTtDQTFDTCxJQXdDYzs7Q0F4Q2QsQ0E2Q2MsQ0FBQSxDQUFJLE1BQWpCOztDQTdDRCxFQStDZ0IsTUFBQSxJQUFmO0NBQW1CLEdBQUEsQ0FBRCxDQUFPLENBQVAsQ0FBQSxLQUFBO0NBL0NuQixJQStDZ0I7O0NBL0NoQixFQWlETyxDQUFOLEtBQU8sRUFBRDtDQUNGLEVBQW1CLENBQWxCLEVBQUQsRUFBQSxHQUFBO0NBQ0MsR0FBQSxNQUFELEdBQUE7Q0FuREwsSUFpRE87O0NBakRQLEVBcURhLE1BQUEsQ0FBWjtDQUNJLFNBQUEsYUFBQTtDQUFBLENBQU0sQ0FBTixHQUFDO0NBQUQsQ0FDTyxDQUFQLENBQWEsRUFBYixJQURBO0NBQUEsRUFFUSxDQUFDLENBQVQsQ0FBQSxJQUZBO0NBQUEsRUFHSSxDQUFDLEVBQUwsRUFIQTtDQUFBLENBS0csRUFESSxDQUFQLENBQUE7Q0FDRyxDQUFJLENBQU0sRUFBaUIsR0FBMUI7Q0FBRCxDQUNJLENBQU0sS0FBVDtDQURELENBRUksQ0FBTSxFQUFpQixHQUExQjtDQVBKLE9BSUE7Q0FKQSxHQVFDLEVBQUQ7Q0E5REwsSUFxRGE7O0NBckRiLEVBaUVTLEdBQVIsR0FBUTtDQUNKLE9BQUEsRUFBQTtBQUFjLENBQWQsR0FBQSxFQUFBLEtBQUE7Q0FBQSxhQUFBO1FBQUE7Q0FDQSxHQUFVLENBQVcsQ0FBckIsQ0FBVTtDQUFWLGFBQUE7UUFEQTtDQUFBLENBRU0sQ0FBTixHQUFDO0NBRkQsRUFHQSxDQUFDLEVBQUQsQ0FBUSxFQUhSO0NBQUEsRUFJQSxDQUFDLEVBQUQsQ0FBUSxFQUpSO0NBQUEsRUFLVyxDQUFWLEVBQUQsQ0FBQTtDQUxBLEVBTVcsQ0FBVixFQUFELENBQUE7QUFDWSxDQVBaLENBT08sQ0FBUCxDQUFDLEVBQUQ7Q0FQQSxHQVFDLEVBQUQsSUFBQTtDQTFFTCxJQWlFUzs7Q0FqRVQ7O0NBWEg7O0NBQUEsQ0EyRkEsQ0FBcUIsSUFBZCxHQUFQOztDQTNGQSxDQTRGQSxDQUFtQixJQUFaLENBQVA7Q0E1RkE7Ozs7O0FDQUE7Q0FBQSxJQUFBLENBQUE7Q0FBQTtDQUFBLENBQUUsQ0FBVSxFQUFaLEVBQVksZ0JBQUE7O0NBQVosQ0FFQSxHQUFBLENBQUE7Q0FDRyxDQUFNLENBQUwsQ0FBQSxLQUFNO0NBQ0YsR0FBa0IsRUFBbEI7Q0FBQSxFQUFXLENBQUosV0FBQTtRQUFQO0NBQ0EsRUFBWSxDQUFKLFNBQUQ7Q0FGWixJQUFNO0NBQU4sQ0FJTSxDQUFMLENBQUEsS0FBTTtDQUFRLEVBQXNCLENBQVgsQ0FBSixRQUFBO0NBSnRCLElBSU07Q0FKTixDQU9RLENBQUEsQ0FBUCxDQUFBLElBQVE7Q0FDSixTQUFBLENBQUE7Q0FBQSxFQUFJLEdBQUo7Q0FDQTtDQUFNLEVBQUksQ0FBVixVQUFNO0FBQ0MsQ0FBSCxDQUFBO0NBREosTUFBQTt1QkFGRztDQVBSLElBT1E7Q0FQUixDQVlZLENBQUEsQ0FBWCxLQUFBO0NBQWUsQ0FBRCxDQUFLLENBQUosU0FBRDtDQVpmLElBWVk7Q0FaWixDQWNZLENBQUEsQ0FBWCxLQUFBO0NBQWdCLEVBQUksQ0FBSixTQUFEO0NBZGhCLElBY1k7Q0FqQmYsR0FFQTs7Q0FGQSxDQW9CQSxDQUFnQixFQUFoQixFQUFPLEVBQVU7Q0FDYixHQUFBLElBQUE7QUFBQSxDQUFBLEtBQUEsR0FBQTtnQkFBQTtDQUFBLEVBQVEsR0FBUDtDQUFELElBQUE7Q0FDQSxVQUFPO0NBdEJYLEVBb0JnQjtDQXBCaEI7Ozs7O0FDQ0E7Q0FBQSxLQUFBLG1LQUFBO0tBQUEsYUFBQTtDQUFBO0NBQUEsQ0FBQSxDQUFPLENBQVAsR0FBYyxFQUFRO0NBQ2xCLE9BQUEsV0FBQTtDQUFBLEdBRG1CLG1EQUNuQjtBQUFjLENBQWQsR0FBQSxLQUFnQjtDQUFoQixXQUFBO01BQUE7QUFDQSxDQUFBLFFBQUEsa0NBQUE7c0JBQUE7Q0FDSSxFQUFBLEdBQUEsQ0FBTztDQURYLElBRmtCO0NBQXRCLEVBQXNCOztDQUF0QixDQUtBLENBQVEsRUFBUixFQUFlLEVBQVU7Q0FBWSxHQUFVLENBQUEsRUFBQSxHQUFBO0NBTC9DLEVBS3dCOztDQUx4QixDQU1BLENBQWtCLElBQU8sRUFBbUIsTUFBNUM7Q0FBcUQsSUFBTixNQUFBLGNBQUE7Q0FOL0MsRUFNNEM7O0NBTjVDLENBT0EsQ0FBb0IsSUFBTyxFQUFxQixRQUFoRDtDQUF5RCxJQUFOLE1BQUEsUUFBQTtDQVBuRCxFQU9nRDs7Q0FQaEQsQ0FVQSxDQUFRLEVBQVIsRUFBZSxFQUFVO0NBQ3JCLE9BQUEsQ0FBQTtDQUFBLEdBQUEsT0FBQTtDQUFBLEVBQUEsVUFBTztNQUFQO0NBQUEsQ0FBQSxDQUNBLENBQUE7QUFDQSxDQUFBLE9BQUEsQ0FBQTtrQkFBQTtDQUNJLEVBQUksR0FBSjtDQURKLElBRkE7Q0FJQSxFQUFBLFFBQU87Q0FmWCxFQVV3Qjs7Q0FWeEIsQ0FrQkEsQ0FBSyxJQUFPLEVBQU87Q0FBUyxLQUFBLEtBQU87Q0FsQm5DLEVBa0JrQjs7Q0FsQmxCLENBcUJBLENBQVMsQ0FBaUIsRUFBMUIsQ0FBZ0IsRUFBVyxDQUFEO0NBQWlDLEVBQXdCLENBQXpCLEtBQVcsQ0FBQSxDQUFmO0NBckJ0RCxFQXFCMEI7O0NBckIxQixDQXdCQSxDQUFRLENBQWdCLENBQXhCLEVBQWUsRUFBVTtDQUNyQixPQUFBLElBQUE7QUFBQSxDQUFBLFFBQUEsSUFBQTs0QkFBQTtDQUFBLENBQWMsRUFBYixFQUFBO0NBQUQsSUFEb0I7Q0F4QnhCLEVBd0J3Qjs7Q0F4QnhCLENBNkJBLENBQWEsSUFBTyxFQUFlLENBQW5DO0NBQXlDLEdBQXdCLENBQW5CLE1BQUwsSUFBQTtDQTdCekMsRUE2QmtDOztDQTdCbEMsQ0FpQ0EsQ0FBWSxDQUFvQixDQUFBLEVBQWIsRUFBbkI7Q0FDSSxNQUFBLENBQUE7QUFBQSxDQUFBLFFBQUEsSUFBQTt1QkFBQTtBQUNJLENBQUEsR0FBQSxFQUFBLEdBQ3lELENBRGxELG9CQUNOO0NBQ0csQ0FBYSxFQUFiLEVBQUEsRUFBQTtRQUhSO0NBQUEsSUFENEI7Q0FqQ2hDLEVBaUNnQzs7Q0FqQ2hDLENBeUNBLENBQVEsRUFBUixFQUFlLEVBQVM7Q0FDcEIsT0FBQSxxQkFBQTtDQUFBLENBRDJCLEVBQU4sbURBQ3JCO0FBQUEsQ0FBQSxRQUFBLG9DQUFBOzBCQUFBO0NBQ0ksQ0FBZ0IsRUFBaEIsQ0FBQSxDQUFBLEdBQUE7Q0FESixJQURvQjtDQXpDeEIsRUF5Q3dCOztDQXpDeEIsQ0ErQ0EsQ0FBVSxDQUFrQixHQUE1QixFQUE2QjtDQUN6QixLQUFBLEVBQUE7Q0FBQSxFQUFBLENBQUE7O0FBQU8sQ0FBQTtHQUFBLFNBQUEsT0FBQTtDQUFBO0NBQUE7O0NBQVA7QUFDa0IsQ0FBbEIsR0FBQSxLQUFBO0NBQUEsRUFBQSxVQUFPO01BRFA7Q0FFSSxFQUFELENBQW9CLEVBQXZCLENBQVcsRUFBc0IsRUFBakM7Q0FsREosRUErQzRCOztDQS9DNUIsQ0FxREEsQ0FBZSxDQUF1QixHQUFoQixFQUFpQixHQUF2QztDQUNJLEtBQUEsRUFBQTtBQUFpQixDQUFqQixHQUFBO0NBQUEsQ0FBQSxXQUFPO01BQVA7Q0FBQSxFQUNBLENBQUE7O0FBQU8sQ0FBQTtHQUFBLFNBQUEsT0FBQTtDQUFBO0NBQUE7O0NBRFA7QUFFa0IsQ0FBbEIsR0FBQSxLQUFBO0NBQUEsRUFBQSxVQUFPO01BRlA7Q0FHSSxDQUFnRCxDQUFqRCxDQUF5QixFQUE1QixHQUFzQyxFQUF0QyxDQUFXO0NBekRmLEVBcURzQzs7Q0FyRHRDLENBNERBLENBQW9CLElBQU8sQ0FBcUIsQ0FBQyxRQUFqRDtDQUFzRSxNQUFSLENBQWdCLEdBQWhCO0NBNUQ5RCxFQTREZ0Q7O0NBNURoRCxDQStEQSxDQUF5QixDQUFpQyxHQUExQixDQUEwQixDQUFDLGFBQTNEO0NBQTJGLENBQXNCLEVBQW5DLElBQXFCLEdBQXJCLENBQUE7Q0EvRDlFLEVBK0QwRDtDQS9EMUQiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZ2xvYmFsKXsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuNy4xXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgSm9obiBSZXNpZ1xuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICogQ29weXJpZ2h0IDIwMTEsIFRoZSBEb2pvIEZvdW5kYXRpb25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQsIEJTRCwgYW5kIEdQTCBMaWNlbnNlcy5cbiAqXG4gKiBEYXRlOiBNb24gTm92IDIxIDIxOjExOjAzIDIwMTEgLTA1MDBcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuLy8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuXHRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXHRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbnZhciBqUXVlcnkgPSAoZnVuY3Rpb24oKSB7XG5cbi8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG52YXIgalF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5ICk7XG5cdH0sXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQsXG5cblx0Ly8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG5cdHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Mgb3IgSUQgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdHF1aWNrRXhwciA9IC9eKD86W14jPF0qKDxbXFx3XFxXXSs+KVtePl0qJHwjKFtcXHdcXC1dKikkKS8sXG5cblx0Ly8gQ2hlY2sgaWYgYSBzdHJpbmcgaGFzIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGluIGl0XG5cdHJub3R3aGl0ZSA9IC9cXFMvLFxuXG5cdC8vIFVzZWQgZm9yIHRyaW1taW5nIHdoaXRlc3BhY2Vcblx0dHJpbUxlZnQgPSAvXlxccysvLFxuXHR0cmltUmlnaHQgPSAvXFxzKyQvLFxuXG5cdC8vIE1hdGNoIGEgc3RhbmRhbG9uZSB0YWdcblx0cnNpbmdsZVRhZyA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+KT8kLyxcblxuXHQvLyBKU09OIFJlZ0V4cFxuXHRydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvLFxuXHRydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLFxuXHRydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXG5cdHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZyxcblxuXHQvLyBVc2VyYWdlbnQgUmVnRXhwXG5cdHJ3ZWJraXQgPSAvKHdlYmtpdClbIFxcL10oW1xcdy5dKykvLFxuXHRyb3BlcmEgPSAvKG9wZXJhKSg/Oi4qdmVyc2lvbik/WyBcXC9dKFtcXHcuXSspLyxcblx0cm1zaWUgPSAvKG1zaWUpIChbXFx3Ll0rKS8sXG5cdHJtb3ppbGxhID0gLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKykpPy8sXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XXxbMC05XSkvaWcsXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiAoIGxldHRlciArIFwiXCIgKS50b1VwcGVyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIEtlZXAgYSBVc2VyQWdlbnQgc3RyaW5nIGZvciB1c2Ugd2l0aCBqUXVlcnkuYnJvd3NlclxuXHR1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXG5cdC8vIEZvciBtYXRjaGluZyB0aGUgZW5naW5lIGFuZCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyXG5cdGJyb3dzZXJNYXRjaCxcblxuXHQvLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcblx0cmVhZHlMaXN0LFxuXG5cdC8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyXG5cdERPTUNvbnRlbnRMb2FkZWQsXG5cblx0Ly8gU2F2ZSBhIHJlZmVyZW5jZSB0byBzb21lIGNvcmUgbWV0aG9kc1xuXHR0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG5cdHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaCxcblx0c2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdHRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0sXG5cdGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZixcblxuXHQvLyBbW0NsYXNzXV0gLT4gdHlwZSBwYWlyc1xuXHRjbGFzczJ0eXBlID0ge307XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cdGluaXQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdGpRdWVyeSApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW0sIHJldCwgZG9jO1xuXG5cdFx0Ly8gSGFuZGxlICQoXCJcIiksICQobnVsbCksIG9yICQodW5kZWZpbmVkKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlICQoRE9NRWxlbWVudClcblx0XHRpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGJvZHkgZWxlbWVudCBvbmx5IGV4aXN0cyBvbmNlLCBvcHRpbWl6ZSBmaW5kaW5nIGl0XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gXCJib2R5XCIgJiYgIWNvbnRleHQgJiYgZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0dGhpc1swXSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHQvLyBBcmUgd2UgZGVhbGluZyB3aXRoIEhUTUwgc3RyaW5nIG9yIGFuIElEP1xuXHRcdFx0aWYgKCBzZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiPFwiICYmIHNlbGVjdG9yLmNoYXJBdCggc2VsZWN0b3IubGVuZ3RoIC0gMSApID09PSBcIj5cIiAmJiBzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFZlcmlmeSBhIG1hdGNoLCBhbmQgdGhhdCBubyBjb250ZXh0IHdhcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cdFx0XHRcdFx0ZG9jID0gKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCApO1xuXG5cdFx0XHRcdFx0Ly8gSWYgYSBzaW5nbGUgc3RyaW5nIGlzIHBhc3NlZCBpbiBhbmQgaXQncyBhIHNpbmdsZSB0YWdcblx0XHRcdFx0XHQvLyBqdXN0IGRvIGEgY3JlYXRlRWxlbWVudCBhbmQgc2tpcCB0aGUgcmVzdFxuXHRcdFx0XHRcdHJldCA9IHJzaW5nbGVUYWcuZXhlYyggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0XHRzZWxlY3RvciA9IFsgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggcmV0WzFdICkgXTtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZuLmF0dHIuY2FsbCggc2VsZWN0b3IsIGNvbnRleHQsIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VsZWN0b3IgPSBbIGRvYy5jcmVhdGVFbGVtZW50KCByZXRbMV0gKSBdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBbIG1hdGNoWzFdIF0sIFsgZG9jIF0gKTtcblx0XHRcdFx0XHRcdHNlbGVjdG9yID0gKCByZXQuY2FjaGVhYmxlID8galF1ZXJ5LmNsb25lKHJldC5mcmFnbWVudCkgOiByZXQuZnJhZ21lbnQgKS5jaGlsZE5vZGVzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIHRoaXMsIHNlbGVjdG9yICk7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKFwiI2lkXCIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSBhbmQgT3BlcmEgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCAhPT0gbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByb290alF1ZXJ5LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgd2UgaW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdHRoaXNbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdGpRdWVyeSApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdGpRdWVyeS5yZWFkeSggc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IFwiMS43LjFcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdC8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdHNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcywgMCApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gPT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBhICdjbGVhbicgYXJyYXlcblx0XHRcdHRoaXMudG9BcnJheSgpIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9iamVjdFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgdGhpcy5sZW5ndGggKyBudW0gXSA6IHRoaXNbIG51bSBdICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMsIG5hbWUsIHNlbGVjdG9yICkge1xuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IHRoaXMuY29uc3RydWN0b3IoKTtcblxuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGVsZW1zICkgKSB7XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsIGVsZW1zICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdGlmICggbmFtZSA9PT0gXCJmaW5kXCIgKSB7XG5cdFx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yICsgKCB0aGlzLnNlbGVjdG9yID8gXCIgXCIgOiBcIlwiICkgKyBzZWxlY3Rvcjtcblx0XHR9IGVsc2UgaWYgKCBuYW1lICkge1xuXHRcdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArIFwiLlwiICsgbmFtZSArIFwiKFwiICsgc2VsZWN0b3IgKyBcIilcIjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0Ly8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcblx0Ly8gb25seSB1c2VkIGludGVybmFsbHkuKVxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjaywgYXJncyApO1xuXHR9LFxuXG5cdHJlYWR5OiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0Ly8gQXR0YWNoIHRoZSBsaXN0ZW5lcnNcblx0XHRqUXVlcnkuYmluZFJlYWR5KCk7XG5cblx0XHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdFx0cmVhZHlMaXN0LmFkZCggZm4gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHRpID0gK2k7XG5cdFx0cmV0dXJuIGkgPT09IC0xID9cblx0XHRcdHRoaXMuc2xpY2UoIGkgKSA6XG5cdFx0XHR0aGlzLnNsaWNlKCBpLCBpICsgMSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSxcblx0XHRcdFwic2xpY2VcIiwgc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIsXCIpICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9KSk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogW10uc29ydCxcblx0c3BsaWNlOiBbXS5zcGxpY2Vcbn07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmpRdWVyeS5mbi5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG5cdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdGkgPSAyO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGxlbmd0aCA9PT0gaSApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdC0taTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0bm9Db25mbGljdDogZnVuY3Rpb24oIGRlZXAgKSB7XG5cdFx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdFx0d2luZG93LiQgPSBfJDtcblx0XHR9XG5cblx0XHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSxcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblx0XHQvLyBFaXRoZXIgYSByZWxlYXNlZCBob2xkIG9yIGFuIERPTXJlYWR5L2xvYWQgZXZlbnQgYW5kIG5vdCB5ZXQgcmVhZHlcblx0XHRpZiAoICh3YWl0ID09PSB0cnVlICYmICEtLWpRdWVyeS5yZWFkeVdhaXQpIHx8ICh3YWl0ICE9PSB0cnVlICYmICFqUXVlcnkuaXNSZWFkeSkgKSB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuXG5cdFx0XHRpZiAoICFkb2N1bWVudC5ib2R5ICkge1xuXHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5LCAxICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdFx0cmVhZHlMaXN0LmZpcmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXIgKSB7XG5cdFx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VyKCBcInJlYWR5XCIgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRiaW5kUmVhZHk6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggcmVhZHlMaXN0ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlXG5cdFx0Ly8gYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSwgMSApO1xuXHRcdH1cblxuXHRcdC8vIE1vemlsbGEsIE9wZXJhIGFuZCB3ZWJraXQgbmlnaHRsaWVzIGN1cnJlbnRseSBzdXBwb3J0IHRoaXMgZXZlbnRcblx0XHRpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgRE9NQ29udGVudExvYWRlZCwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgalF1ZXJ5LnJlYWR5LCBmYWxzZSApO1xuXG5cdFx0Ly8gSWYgSUUgZXZlbnQgbW9kZWwgaXMgdXNlZFxuXHRcdH0gZWxzZSBpZiAoIGRvY3VtZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0Ly8gZW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLFxuXHRcdFx0Ly8gbWF5YmUgbGF0ZSBidXQgc2FmZSBhbHNvIGZvciBpZnJhbWVzXG5cdFx0XHRkb2N1bWVudC5hdHRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgRE9NQ29udGVudExvYWRlZCApO1xuXG5cdFx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KCBcIm9ubG9hZFwiLCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdFx0Ly8gSWYgSUUgYW5kIG5vdCBhIGZyYW1lXG5cdFx0XHQvLyBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWR5XG5cdFx0XHR2YXIgdG9wbGV2ZWwgPSBmYWxzZTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dG9wbGV2ZWwgPSB3aW5kb3cuZnJhbWVFbGVtZW50ID09IG51bGw7XG5cdFx0XHR9IGNhdGNoKGUpIHt9XG5cblx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICYmIHRvcGxldmVsICkge1xuXHRcdFx0XHRkb1Njcm9sbENoZWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFNlZSB0ZXN0L3VuaXQvY29yZS5qcyBmb3IgZGV0YWlscyBjb25jZXJuaW5nIGlzRnVuY3Rpb24uXG5cdC8vIFNpbmNlIHZlcnNpb24gMS4zLCBET00gbWV0aG9kcyBhbmQgZnVuY3Rpb25zIGxpa2UgYWxlcnRcblx0Ly8gYXJlbid0IHN1cHBvcnRlZC4gVGhleSByZXR1cm4gZmFsc2Ugb24gSUUgKCMyOTY4KS5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJhcnJheVwiO1xuXHR9LFxuXG5cdC8vIEEgY3J1ZGUgd2F5IG9mIGRldGVybWluaW5nIGlmIGFuIG9iamVjdCBpcyBhIHdpbmRvd1xuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgXCJzZXRJbnRlcnZhbFwiIGluIG9iajtcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdChvYmopICkgJiYgaXNGaW5pdGUoIG9iaiApO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiA9PSBudWxsID9cblx0XHRcdFN0cmluZyggb2JqICkgOlxuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIjtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIE11c3QgYmUgYW4gT2JqZWN0LlxuXHRcdC8vIEJlY2F1c2Ugb2YgSUUsIHdlIGFsc28gaGF2ZSB0byBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5LlxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IERPTSBub2RlcyBhbmQgd2luZG93IG9iamVjdHMgZG9uJ3QgcGFzcyB0aHJvdWdoLCBhcyB3ZWxsXG5cdFx0aWYgKCAhb2JqIHx8IGpRdWVyeS50eXBlKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0XHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0Ly8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzICM5ODk3XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdFx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cblx0XHR2YXIga2V5O1xuXHRcdGZvciAoIGtleSBpbiBvYmogKSB7fVxuXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGtleSApO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdHBhcnNlSlNPTjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAhZGF0YSApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZCAoSUUgY2FuJ3QgaGFuZGxlIGl0KVxuXHRcdGRhdGEgPSBqUXVlcnkudHJpbSggZGF0YSApO1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG5cdFx0aWYgKCB3aW5kb3cuSlNPTiAmJiB3aW5kb3cuSlNPTi5wYXJzZSApIHtcblx0XHRcdHJldHVybiB3aW5kb3cuSlNPTi5wYXJzZSggZGF0YSApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgaW5jb21pbmcgZGF0YSBpcyBhY3R1YWwgSlNPTlxuXHRcdC8vIExvZ2ljIGJvcnJvd2VkIGZyb20gaHR0cDovL2pzb24ub3JnL2pzb24yLmpzXG5cdFx0aWYgKCBydmFsaWRjaGFycy50ZXN0KCBkYXRhLnJlcGxhY2UoIHJ2YWxpZGVzY2FwZSwgXCJAXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJ2YWxpZHRva2VucywgXCJdXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJ2YWxpZGJyYWNlcywgXCJcIikpICkge1xuXG5cdFx0XHRyZXR1cm4gKCBuZXcgRnVuY3Rpb24oIFwicmV0dXJuIFwiICsgZGF0YSApICkoKTtcblxuXHRcdH1cblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBKU09OOiBcIiArIGRhdGEgKTtcblx0fSxcblxuXHQvLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5cdHBhcnNlWE1MOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHR2YXIgeG1sLCB0bXA7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICggd2luZG93LkRPTVBhcnNlciApIHsgLy8gU3RhbmRhcmRcblx0XHRcdFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0XHR4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKCBkYXRhICwgXCJ0ZXh0L3htbFwiICk7XG5cdFx0XHR9IGVsc2UgeyAvLyBJRVxuXHRcdFx0XHR4bWwgPSBuZXcgQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MRE9NXCIgKTtcblx0XHRcdFx0eG1sLmFzeW5jID0gXCJmYWxzZVwiO1xuXHRcdFx0XHR4bWwubG9hZFhNTCggZGF0YSApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdFx0fVxuXHRcdHJldHVybiB4bWw7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHQvLyBXb3JrYXJvdW5kcyBiYXNlZCBvbiBmaW5kaW5ncyBieSBKaW0gRHJpc2NvbGxcblx0Ly8gaHR0cDovL3dlYmxvZ3MuamF2YS5uZXQvYmxvZy9kcmlzY29sbC9hcmNoaXZlLzIwMDkvMDkvMDgvZXZhbC1qYXZhc2NyaXB0LWdsb2JhbC1jb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdGlmICggZGF0YSAmJiBybm90d2hpdGUudGVzdCggZGF0YSApICkge1xuXHRcdFx0Ly8gV2UgdXNlIGV4ZWNTY3JpcHQgb24gSW50ZXJuZXQgRXhwbG9yZXJcblx0XHRcdC8vIFdlIHVzZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gc28gdGhhdCBjb250ZXh0IGlzIHdpbmRvd1xuXHRcdFx0Ly8gcmF0aGVyIHRoYW4galF1ZXJ5IGluIEZpcmVmb3hcblx0XHRcdCggd2luZG93LmV4ZWNTY3JpcHQgfHwgZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdHdpbmRvd1sgXCJldmFsXCIgXS5jYWxsKCB3aW5kb3csIGRhdGEgKTtcblx0XHRcdH0gKSggZGF0YSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5hbWUudG9VcHBlckNhc2UoKTtcblx0fSxcblxuXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmplY3QsIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciBuYW1lLCBpID0gMCxcblx0XHRcdGxlbmd0aCA9IG9iamVjdC5sZW5ndGgsXG5cdFx0XHRpc09iaiA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0Z1bmN0aW9uKCBvYmplY3QgKTtcblxuXHRcdGlmICggYXJncyApIHtcblx0XHRcdGlmICggaXNPYmogKSB7XG5cdFx0XHRcdGZvciAoIG5hbWUgaW4gb2JqZWN0ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suYXBwbHkoIG9iamVjdFsgbmFtZSBdLCBhcmdzICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suYXBwbHkoIG9iamVjdFsgaSsrIF0sIGFyZ3MgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaXNPYmogKSB7XG5cdFx0XHRcdGZvciAoIG5hbWUgaW4gb2JqZWN0ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqZWN0WyBuYW1lIF0sIG5hbWUsIG9iamVjdFsgbmFtZSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqZWN0WyBpIF0sIGksIG9iamVjdFsgaSsrIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXHR9LFxuXG5cdC8vIFVzZSBuYXRpdmUgU3RyaW5nLnRyaW0gZnVuY3Rpb24gd2hlcmV2ZXIgcG9zc2libGVcblx0dHJpbTogdHJpbSA/XG5cdFx0ZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdHRyaW0uY2FsbCggdGV4dCApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHVzZSBvdXIgb3duIHRyaW1taW5nIGZ1bmN0aW9uYWxpdHlcblx0XHRmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0dGV4dC50b1N0cmluZygpLnJlcGxhY2UoIHRyaW1MZWZ0LCBcIlwiICkucmVwbGFjZSggdHJpbVJpZ2h0LCBcIlwiICk7XG5cdFx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFycmF5LCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnJheSAhPSBudWxsICkge1xuXHRcdFx0Ly8gVGhlIHdpbmRvdywgc3RyaW5ncyAoYW5kIGZ1bmN0aW9ucykgYWxzbyBoYXZlICdsZW5ndGgnXG5cdFx0XHQvLyBUd2Vha2VkIGxvZ2ljIHNsaWdodGx5IHRvIGhhbmRsZSBCbGFja2JlcnJ5IDQuNyBSZWdFeHAgaXNzdWVzICM2OTMwXG5cdFx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBhcnJheSApO1xuXG5cdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA9PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGUgPT09IFwicmVnZXhwXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBhcnJheSApICkge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyYXkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LCBhcnJheSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFycmF5LCBpICkge1xuXHRcdHZhciBsZW47XG5cblx0XHRpZiAoIGFycmF5ICkge1xuXHRcdFx0aWYgKCBpbmRleE9mICkge1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBhcnJheSwgZWxlbSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRsZW4gPSBhcnJheS5sZW5ndGg7XG5cdFx0XHRpID0gaSA/IGkgPCAwID8gTWF0aC5tYXgoIDAsIGxlbiArIGkgKSA6IGkgOiAwO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Ly8gU2tpcCBhY2Nlc3NpbmcgaW4gc3BhcnNlIGFycmF5c1xuXHRcdFx0XHRpZiAoIGkgaW4gYXJyYXkgJiYgYXJyYXlbIGkgXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGkgPSBmaXJzdC5sZW5ndGgsXG5cdFx0XHRqID0gMDtcblxuXHRcdGlmICggdHlwZW9mIHNlY29uZC5sZW5ndGggPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRmb3IgKCB2YXIgbCA9IHNlY29uZC5sZW5ndGg7IGogPCBsOyBqKysgKSB7XG5cdFx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHdoaWxlICggc2Vjb25kW2pdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnYgKSB7XG5cdFx0dmFyIHJldCA9IFtdLCByZXRWYWw7XG5cdFx0aW52ID0gISFpbnY7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbmd0aCA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0cmV0VmFsID0gISFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBpbnYgIT09IHJldFZhbCApIHtcblx0XHRcdFx0cmV0LnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgdmFsdWUsIGtleSwgcmV0ID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdC8vIGpxdWVyeSBvYmplY3RzIGFyZSB0cmVhdGVkIGFzIGFycmF5c1xuXHRcdFx0aXNBcnJheSA9IGVsZW1zIGluc3RhbmNlb2YgalF1ZXJ5IHx8IGxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgKCAoIGxlbmd0aCA+IDAgJiYgZWxlbXNbIDAgXSAmJiBlbGVtc1sgbGVuZ3RoIC0xIF0gKSB8fCBsZW5ndGggPT09IDAgfHwgalF1ZXJ5LmlzQXJyYXkoIGVsZW1zICkgKSA7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXJcblx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldFsgcmV0Lmxlbmd0aCBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGtleSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGtleSBdLCBrZXksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXRbIHJldC5sZW5ndGggXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiByZXQuY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dmFyIHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKSxcblx0XHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCwgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgcHJveHkuZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdC8vIE11dGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgdG8gYSBjb2xsZWN0aW9uXG5cdC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBlbGVtcywga2V5LCB2YWx1ZSwgZXhlYywgZm4sIHBhc3MgKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdC8vIFNldHRpbmcgbWFueSBhdHRyaWJ1dGVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Zm9yICggdmFyIGsgaW4ga2V5ICkge1xuXHRcdFx0XHRqUXVlcnkuYWNjZXNzKCBlbGVtcywgaywga2V5W2tdLCBleGVjLCBmbiwgdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBlbGVtcztcblx0XHR9XG5cblx0XHQvLyBTZXR0aW5nIG9uZSBhdHRyaWJ1dGVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBPcHRpb25hbGx5LCBmdW5jdGlvbiB2YWx1ZXMgZ2V0IGV4ZWN1dGVkIGlmIGV4ZWMgaXMgdHJ1ZVxuXHRcdFx0ZXhlYyA9ICFwYXNzICYmIGV4ZWMgJiYgalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Zm4oIGVsZW1zW2ldLCBrZXksIGV4ZWMgPyB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApIDogdmFsdWUsIHBhc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1zO1xuXHRcdH1cblxuXHRcdC8vIEdldHRpbmcgYW4gYXR0cmlidXRlXG5cdFx0cmV0dXJuIGxlbmd0aCA/IGZuKCBlbGVtc1swXSwga2V5ICkgOiB1bmRlZmluZWQ7XG5cdH0sXG5cblx0bm93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpO1xuXHR9LFxuXG5cdC8vIFVzZSBvZiBqUXVlcnkuYnJvd3NlciBpcyBmcm93bmVkIHVwb24uXG5cdC8vIE1vcmUgZGV0YWlsczogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VdGlsaXRpZXMvalF1ZXJ5LmJyb3dzZXJcblx0dWFNYXRjaDogZnVuY3Rpb24oIHVhICkge1xuXHRcdHVhID0gdWEudG9Mb3dlckNhc2UoKTtcblxuXHRcdHZhciBtYXRjaCA9IHJ3ZWJraXQuZXhlYyggdWEgKSB8fFxuXHRcdFx0cm9wZXJhLmV4ZWMoIHVhICkgfHxcblx0XHRcdHJtc2llLmV4ZWMoIHVhICkgfHxcblx0XHRcdHVhLmluZGV4T2YoXCJjb21wYXRpYmxlXCIpIDwgMCAmJiBybW96aWxsYS5leGVjKCB1YSApIHx8XG5cdFx0XHRbXTtcblxuXHRcdHJldHVybiB7IGJyb3dzZXI6IG1hdGNoWzFdIHx8IFwiXCIsIHZlcnNpb246IG1hdGNoWzJdIHx8IFwiMFwiIH07XG5cdH0sXG5cblx0c3ViOiBmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBqUXVlcnlTdWIoIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdFx0cmV0dXJuIG5ldyBqUXVlcnlTdWIuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgalF1ZXJ5U3ViLCB0aGlzICk7XG5cdFx0alF1ZXJ5U3ViLnN1cGVyY2xhc3MgPSB0aGlzO1xuXHRcdGpRdWVyeVN1Yi5mbiA9IGpRdWVyeVN1Yi5wcm90b3R5cGUgPSB0aGlzKCk7XG5cdFx0alF1ZXJ5U3ViLmZuLmNvbnN0cnVjdG9yID0galF1ZXJ5U3ViO1xuXHRcdGpRdWVyeVN1Yi5zdWIgPSB0aGlzLnN1Yjtcblx0XHRqUXVlcnlTdWIuZm4uaW5pdCA9IGZ1bmN0aW9uIGluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCBjb250ZXh0ICYmIGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgJiYgIShjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5U3ViKSApIHtcblx0XHRcdFx0Y29udGV4dCA9IGpRdWVyeVN1YiggY29udGV4dCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZuLmluaXQuY2FsbCggdGhpcywgc2VsZWN0b3IsIGNvbnRleHQsIHJvb3RqUXVlcnlTdWIgKTtcblx0XHR9O1xuXHRcdGpRdWVyeVN1Yi5mbi5pbml0LnByb3RvdHlwZSA9IGpRdWVyeVN1Yi5mbjtcblx0XHR2YXIgcm9vdGpRdWVyeVN1YiA9IGpRdWVyeVN1Yihkb2N1bWVudCk7XG5cdFx0cmV0dXJuIGpRdWVyeVN1Yjtcblx0fSxcblxuXHRicm93c2VyOiB7fVxufSk7XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0XCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbmJyb3dzZXJNYXRjaCA9IGpRdWVyeS51YU1hdGNoKCB1c2VyQWdlbnQgKTtcbmlmICggYnJvd3Nlck1hdGNoLmJyb3dzZXIgKSB7XG5cdGpRdWVyeS5icm93c2VyWyBicm93c2VyTWF0Y2guYnJvd3NlciBdID0gdHJ1ZTtcblx0alF1ZXJ5LmJyb3dzZXIudmVyc2lvbiA9IGJyb3dzZXJNYXRjaC52ZXJzaW9uO1xufVxuXG4vLyBEZXByZWNhdGVkLCB1c2UgalF1ZXJ5LmJyb3dzZXIud2Via2l0IGluc3RlYWRcbmlmICggalF1ZXJ5LmJyb3dzZXIud2Via2l0ICkge1xuXHRqUXVlcnkuYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xufVxuXG4vLyBJRSBkb2Vzbid0IG1hdGNoIG5vbi1icmVha2luZyBzcGFjZXMgd2l0aCBcXHNcbmlmICggcm5vdHdoaXRlLnRlc3QoIFwiXFx4QTBcIiApICkge1xuXHR0cmltTGVmdCA9IC9eW1xcc1xceEEwXSsvO1xuXHR0cmltUmlnaHQgPSAvW1xcc1xceEEwXSskLztcbn1cblxuLy8gQWxsIGpRdWVyeSBvYmplY3RzIHNob3VsZCBwb2ludCBiYWNrIHRvIHRoZXNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KGRvY3VtZW50KTtcblxuLy8gQ2xlYW51cCBmdW5jdGlvbnMgZm9yIHRoZSBkb2N1bWVudCByZWFkeSBtZXRob2RcbmlmICggZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0RE9NQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBET01Db250ZW50TG9hZGVkLCBmYWxzZSApO1xuXHRcdGpRdWVyeS5yZWFkeSgpO1xuXHR9O1xuXG59IGVsc2UgaWYgKCBkb2N1bWVudC5hdHRhY2hFdmVudCApIHtcblx0RE9NQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIE1ha2Ugc3VyZSBib2R5IGV4aXN0cywgYXQgbGVhc3QsIGluIGNhc2UgSUUgZ2V0cyBhIGxpdHRsZSBvdmVyemVhbG91cyAodGlja2V0ICM1NDQzKS5cblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRcdGRvY3VtZW50LmRldGFjaEV2ZW50KCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBET01Db250ZW50TG9hZGVkICk7XG5cdFx0XHRqUXVlcnkucmVhZHkoKTtcblx0XHR9XG5cdH07XG59XG5cbi8vIFRoZSBET00gcmVhZHkgY2hlY2sgZm9yIEludGVybmV0IEV4cGxvcmVyXG5mdW5jdGlvbiBkb1Njcm9sbENoZWNrKCkge1xuXHRpZiAoIGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0Ly8gSWYgSUUgaXMgdXNlZCwgdXNlIHRoZSB0cmljayBieSBEaWVnbyBQZXJpbmlcblx0XHQvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkL1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbChcImxlZnRcIik7XG5cdH0gY2F0Y2goZSkge1xuXHRcdHNldFRpbWVvdXQoIGRvU2Nyb2xsQ2hlY2ssIDEgKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBhbmQgZXhlY3V0ZSBhbnkgd2FpdGluZyBmdW5jdGlvbnNcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbnJldHVybiBqUXVlcnk7XG5cbn0pKCk7XG5cblxuLy8gU3RyaW5nIHRvIE9iamVjdCBmbGFncyBmb3JtYXQgY2FjaGVcbnZhciBmbGFnc0NhY2hlID0ge307XG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBmbGFncyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lcyBhbmQgc3RvcmUgaW4gY2FjaGVcbmZ1bmN0aW9uIGNyZWF0ZUZsYWdzKCBmbGFncyApIHtcblx0dmFyIG9iamVjdCA9IGZsYWdzQ2FjaGVbIGZsYWdzIF0gPSB7fSxcblx0XHRpLCBsZW5ndGg7XG5cdGZsYWdzID0gZmxhZ3Muc3BsaXQoIC9cXHMrLyApO1xuXHRmb3IgKCBpID0gMCwgbGVuZ3RoID0gZmxhZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0b2JqZWN0WyBmbGFnc1tpXSBdID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdGZsYWdzOlx0YW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgZmxhZ3MgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlc1xuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgZmxhZ3M6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggZmxhZ3MgKSB7XG5cblx0Ly8gQ29udmVydCBmbGFncyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdGZsYWdzID0gZmxhZ3MgPyAoIGZsYWdzQ2FjaGVbIGZsYWdzIF0gfHwgY3JlYXRlRmxhZ3MoIGZsYWdzICkgKSA6IHt9O1xuXG5cdHZhciAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblx0XHQvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0c3RhY2sgPSBbXSxcblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgKGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHMpXG5cdFx0bWVtb3J5LFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cdFx0Ly8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXG5cdFx0ZmlyaW5nU3RhcnQsXG5cdFx0Ly8gRW5kIG9mIHRoZSBsb29wIHdoZW4gZmlyaW5nXG5cdFx0ZmlyaW5nTGVuZ3RoLFxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IHJlbW92ZSBpZiBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXgsXG5cdFx0Ly8gQWRkIG9uZSBvciBzZXZlcmFsIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBhcmdzICkge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdGxlbmd0aCxcblx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0YWN0dWFsO1xuXHRcdFx0Zm9yICggaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSBhcmdzWyBpIF07XG5cdFx0XHRcdHR5cGUgPSBqUXVlcnkudHlwZSggZWxlbSApO1xuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYXJyYXlcIiApIHtcblx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0YWRkKCBlbGVtICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0XHQvLyBBZGQgaWYgbm90IGluIHVuaXF1ZSBtb2RlIGFuZCBjYWxsYmFjayBpcyBub3QgaW5cblx0XHRcdFx0XHRpZiAoICFmbGFncy51bmlxdWUgfHwgIXNlbGYuaGFzKCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRtZW1vcnkgPSAhZmxhZ3MubWVtb3J5IHx8IFsgY29udGV4dCwgYXJncyBdO1xuXHRcdFx0ZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcblx0XHRcdGZpcmluZ1N0YXJ0ID0gMDtcblx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGNvbnRleHQsIGFyZ3MgKSA9PT0gZmFsc2UgJiYgZmxhZ3Muc3RvcE9uRmFsc2UgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gdHJ1ZTsgLy8gTWFyayBhcyBoYWx0ZWRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggIWZsYWdzLm9uY2UgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdGFjayAmJiBzdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBzdGFjay5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0c2VsZi5maXJlV2l0aCggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0dmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdGFkZCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5LCB1bmxlc3MgcHJldmlvdXNcblx0XHRcdFx0XHQvLyBmaXJpbmcgd2FzIGhhbHRlZCAoc3RvcE9uRmFsc2UpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICYmIG1lbW9yeSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdGZpcmluZ1N0YXJ0ID0gbGVuZ3RoO1xuXHRcdFx0XHRcdFx0ZmlyZSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdGFyZ0luZGV4ID0gMCxcblx0XHRcdFx0XHRcdGFyZ0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoIDsgYXJnSW5kZXggPCBhcmdMZW5ndGggOyBhcmdJbmRleCsrICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBhcmdzWyBhcmdJbmRleCBdID09PSBsaXN0WyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZ0luZGV4IGFuZCBmaXJpbmdMZW5ndGhcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaSA8PSBmaXJpbmdMZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aC0tO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGkgPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaS0tLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBzb21lIHVuaWNpdHkgcHJvcGVydHkgdGhlblxuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGZsYWdzLnVuaXF1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDb250cm9sIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3Rcblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRcdFx0bGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGZuID09PSBsaXN0WyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBkaXNhYmxlZD9cblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblx0XHRcdC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdGFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCAhbWVtb3J5IHx8IG1lbW9yeSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBsb2NrZWQ/XG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIXN0YWNrO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCBzdGFjayApIHtcblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGlmICggIWZsYWdzLm9uY2UgKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWNrLnB1c2goIFsgY29udGV4dCwgYXJncyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggZmxhZ3Mub25jZSAmJiBtZW1vcnkgKSApIHtcblx0XHRcdFx0XHRcdGZpcmUoIGNvbnRleHQsIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIW1lbW9yeTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5cblxudmFyIC8vIFN0YXRpYyByZWZlcmVuY2UgdG8gc2xpY2Vcblx0c2xpY2VEZWZlcnJlZCA9IFtdLnNsaWNlO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIGRvbmVMaXN0ID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRmYWlsTGlzdCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0cHJvZ3Jlc3NMaXN0ID0galF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdGxpc3RzID0ge1xuXHRcdFx0XHRyZXNvbHZlOiBkb25lTGlzdCxcblx0XHRcdFx0cmVqZWN0OiBmYWlsTGlzdCxcblx0XHRcdFx0bm90aWZ5OiBwcm9ncmVzc0xpc3Rcblx0XHRcdH0sXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRkb25lOiBkb25lTGlzdC5hZGQsXG5cdFx0XHRcdGZhaWw6IGZhaWxMaXN0LmFkZCxcblx0XHRcdFx0cHJvZ3Jlc3M6IHByb2dyZXNzTGlzdC5hZGQsXG5cblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBEZXByZWNhdGVkXG5cdFx0XHRcdGlzUmVzb2x2ZWQ6IGRvbmVMaXN0LmZpcmVkLFxuXHRcdFx0XHRpc1JlamVjdGVkOiBmYWlsTGlzdC5maXJlZCxcblxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggZG9uZUNhbGxiYWNrcywgZmFpbENhbGxiYWNrcywgcHJvZ3Jlc3NDYWxsYmFja3MgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggZG9uZUNhbGxiYWNrcyApLmZhaWwoIGZhaWxDYWxsYmFja3MgKS5wcm9ncmVzcyggcHJvZ3Jlc3NDYWxsYmFja3MgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lLmFwcGx5KCBkZWZlcnJlZCwgYXJndW1lbnRzICkuZmFpbC5hcHBseSggZGVmZXJyZWQsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCgge1xuXHRcdFx0XHRcdFx0XHRkb25lOiBbIGZuRG9uZSwgXCJyZXNvbHZlXCIgXSxcblx0XHRcdFx0XHRcdFx0ZmFpbDogWyBmbkZhaWwsIFwicmVqZWN0XCIgXSxcblx0XHRcdFx0XHRcdFx0cHJvZ3Jlc3M6IFsgZm5Qcm9ncmVzcywgXCJub3RpZnlcIiBdXG5cdFx0XHRcdFx0XHR9LCBmdW5jdGlvbiggaGFuZGxlciwgZGF0YSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gZGF0YVsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdGFjdGlvbiA9IGRhdGFbIDEgXSxcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZDtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgaGFuZGxlciBdKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKS50aGVuKCBuZXdEZWZlci5yZXNvbHZlLCBuZXdEZWZlci5yZWplY3QsIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIGFjdGlvbiArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gbmV3RGVmZXIgOiB0aGlzLCBbIHJldHVybmVkIF0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgaGFuZGxlciBdKCBuZXdEZWZlclsgYWN0aW9uIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0b2JqID0gcHJvbWlzZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBwcm9taXNlICkge1xuXHRcdFx0XHRcdFx0XHRvYmpbIGtleSBdID0gcHJvbWlzZVsga2V5IF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHByb21pc2UucHJvbWlzZSh7fSksXG5cdFx0XHRrZXk7XG5cblx0XHRmb3IgKCBrZXkgaW4gbGlzdHMgKSB7XG5cdFx0XHRkZWZlcnJlZFsga2V5IF0gPSBsaXN0c1sga2V5IF0uZmlyZTtcblx0XHRcdGRlZmVycmVkWyBrZXkgKyBcIldpdGhcIiBdID0gbGlzdHNbIGtleSBdLmZpcmVXaXRoO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdGRlZmVycmVkLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3RhdGUgPSBcInJlc29sdmVkXCI7XG5cdFx0fSwgZmFpbExpc3QuZGlzYWJsZSwgcHJvZ3Jlc3NMaXN0LmxvY2sgKS5mYWlsKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0YXRlID0gXCJyZWplY3RlZFwiO1xuXHRcdH0sIGRvbmVMaXN0LmRpc2FibGUsIHByb2dyZXNzTGlzdC5sb2NrICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBmaXJzdFBhcmFtICkge1xuXHRcdHZhciBhcmdzID0gc2xpY2VEZWZlcnJlZC5jYWxsKCBhcmd1bWVudHMsIDAgKSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gYXJncy5sZW5ndGgsXG5cdFx0XHRwVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKSxcblx0XHRcdGNvdW50ID0gbGVuZ3RoLFxuXHRcdFx0cENvdW50ID0gbGVuZ3RoLFxuXHRcdFx0ZGVmZXJyZWQgPSBsZW5ndGggPD0gMSAmJiBmaXJzdFBhcmFtICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBmaXJzdFBhcmFtLnByb21pc2UgKSA/XG5cdFx0XHRcdGZpcnN0UGFyYW0gOlxuXHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZUZ1bmMoIGkgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlRGVmZXJyZWQuY2FsbCggYXJndW1lbnRzLCAwICkgOiB2YWx1ZTtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGRlZmVycmVkLCBhcmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHByb2dyZXNzRnVuYyggaSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHBWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2VEZWZlcnJlZC5jYWxsKCBhcmd1bWVudHMsIDAgKSA6IHZhbHVlO1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBwcm9taXNlLCBwVmFsdWVzICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhcmdzWyBpIF0gJiYgYXJnc1sgaSBdLnByb21pc2UgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZ3NbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0YXJnc1sgaSBdLnByb21pc2UoKS50aGVuKCByZXNvbHZlRnVuYyhpKSwgZGVmZXJyZWQucmVqZWN0LCBwcm9ncmVzc0Z1bmMoaSkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLWNvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjb3VudCApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGRlZmVycmVkLCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggZGVmZXJyZWQgIT09IGZpcnN0UGFyYW0gKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZGVmZXJyZWQsIGxlbmd0aCA/IFsgZmlyc3RQYXJhbSBdIDogW10gKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cbn0pO1xuXG5cblxuXG5qUXVlcnkuc3VwcG9ydCA9IChmdW5jdGlvbigpIHtcblxuXHR2YXIgc3VwcG9ydCxcblx0XHRhbGwsXG5cdFx0YSxcblx0XHRzZWxlY3QsXG5cdFx0b3B0LFxuXHRcdGlucHV0LFxuXHRcdG1hcmdpbkRpdixcblx0XHRmcmFnbWVudCxcblx0XHR0ZHMsXG5cdFx0ZXZlbnRzLFxuXHRcdGV2ZW50TmFtZSxcblx0XHRpLFxuXHRcdGlzU3VwcG9ydGVkLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gUHJlbGltaW5hcnkgdGVzdHNcblx0ZGl2LnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiLCBcInRcIik7XG5cdGRpdi5pbm5lckhUTUwgPSBcIiAgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYScgc3R5bGU9J3RvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41NTsnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cblx0YWxsID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApO1xuXHRhID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImFcIiApWyAwIF07XG5cblx0Ly8gQ2FuJ3QgZ2V0IGJhc2ljIHRlc3Qgc3VwcG9ydFxuXHRpZiAoICFhbGwgfHwgIWFsbC5sZW5ndGggfHwgIWEgKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cblx0Ly8gRmlyc3QgYmF0Y2ggb2Ygc3VwcG9ydHMgdGVzdHNcblx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApO1xuXHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikgKTtcblx0aW5wdXQgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiaW5wdXRcIiApWyAwIF07XG5cblx0c3VwcG9ydCA9IHtcblx0XHQvLyBJRSBzdHJpcHMgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZW4gLmlubmVySFRNTCBpcyB1c2VkXG5cdFx0bGVhZGluZ1doaXRlc3BhY2U6ICggZGl2LmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMgKSxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRib2R5IGVsZW1lbnRzIGFyZW4ndCBhdXRvbWF0aWNhbGx5IGluc2VydGVkXG5cdFx0Ly8gSUUgd2lsbCBpbnNlcnQgdGhlbSBpbnRvIGVtcHR5IHRhYmxlc1xuXHRcdHRib2R5OiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIikubGVuZ3RoLFxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MXG5cdFx0Ly8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuXHRcdGh0bWxTZXJpYWxpemU6ICEhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlua1wiKS5sZW5ndGgsXG5cblx0XHQvLyBHZXQgdGhlIHN0eWxlIGluZm9ybWF0aW9uIGZyb20gZ2V0QXR0cmlidXRlXG5cdFx0Ly8gKElFIHVzZXMgLmNzc1RleHQgaW5zdGVhZClcblx0XHRzdHlsZTogL3RvcC8udGVzdCggYS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSApLFxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgVVJMcyBhcmVuJ3QgbWFuaXB1bGF0ZWRcblx0XHQvLyAoSUUgbm9ybWFsaXplcyBpdCBieSBkZWZhdWx0KVxuXHRcdGhyZWZOb3JtYWxpemVkOiAoIGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIvYVwiICksXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBlbGVtZW50IG9wYWNpdHkgZXhpc3RzXG5cdFx0Ly8gKElFIHVzZXMgZmlsdGVyIGluc3RlYWQpXG5cdFx0Ly8gVXNlIGEgcmVnZXggdG8gd29yayBhcm91bmQgYSBXZWJLaXQgaXNzdWUuIFNlZSAjNTE0NVxuXHRcdG9wYWNpdHk6IC9eMC41NS8udGVzdCggYS5zdHlsZS5vcGFjaXR5ICksXG5cblx0XHQvLyBWZXJpZnkgc3R5bGUgZmxvYXQgZXhpc3RlbmNlXG5cdFx0Ly8gKElFIHVzZXMgc3R5bGVGbG9hdCBpbnN0ZWFkIG9mIGNzc0Zsb2F0KVxuXHRcdGNzc0Zsb2F0OiAhIWEuc3R5bGUuY3NzRmxvYXQsXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBpZiBubyB2YWx1ZSBpcyBzcGVjaWZpZWQgZm9yIGEgY2hlY2tib3hcblx0XHQvLyB0aGF0IGl0IGRlZmF1bHRzIHRvIFwib25cIi5cblx0XHQvLyAoV2ViS2l0IGRlZmF1bHRzIHRvIFwiXCIgaW5zdGVhZClcblx0XHRjaGVja09uOiAoIGlucHV0LnZhbHVlID09PSBcIm9uXCIgKSxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGEgc2VsZWN0ZWQtYnktZGVmYXVsdCBvcHRpb24gaGFzIGEgd29ya2luZyBzZWxlY3RlZCBwcm9wZXJ0eS5cblx0XHQvLyAoV2ViS2l0IGRlZmF1bHRzIHRvIGZhbHNlIGluc3RlYWQgb2YgdHJ1ZSwgSUUgdG9vLCBpZiBpdCdzIGluIGFuIG9wdGdyb3VwKVxuXHRcdG9wdFNlbGVjdGVkOiBvcHQuc2VsZWN0ZWQsXG5cblx0XHQvLyBUZXN0IHNldEF0dHJpYnV0ZSBvbiBjYW1lbENhc2UgY2xhc3MuIElmIGl0IHdvcmtzLCB3ZSBuZWVkIGF0dHJGaXhlcyB3aGVuIGRvaW5nIGdldC9zZXRBdHRyaWJ1dGUgKGllNi83KVxuXHRcdGdldFNldEF0dHJpYnV0ZTogZGl2LmNsYXNzTmFtZSAhPT0gXCJ0XCIsXG5cblx0XHQvLyBUZXN0cyBmb3IgZW5jdHlwZSBzdXBwb3J0IG9uIGEgZm9ybSgjNjc0Mylcblx0XHRlbmN0eXBlOiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLmVuY3R5cGUsXG5cblx0XHQvLyBNYWtlcyBzdXJlIGNsb25pbmcgYW4gaHRtbDUgZWxlbWVudCBkb2VzIG5vdCBjYXVzZSBwcm9ibGVtc1xuXHRcdC8vIFdoZXJlIG91dGVySFRNTCBpcyB1bmRlZmluZWQsIHRoaXMgc3RpbGwgd29ya3Ncblx0XHRodG1sNUNsb25lOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibmF2XCIpLmNsb25lTm9kZSggdHJ1ZSApLm91dGVySFRNTCAhPT0gXCI8Om5hdj48LzpuYXY+XCIsXG5cblx0XHQvLyBXaWxsIGJlIGRlZmluZWQgbGF0ZXJcblx0XHRzdWJtaXRCdWJibGVzOiB0cnVlLFxuXHRcdGNoYW5nZUJ1YmJsZXM6IHRydWUsXG5cdFx0Zm9jdXNpbkJ1YmJsZXM6IGZhbHNlLFxuXHRcdGRlbGV0ZUV4cGFuZG86IHRydWUsXG5cdFx0bm9DbG9uZUV2ZW50OiB0cnVlLFxuXHRcdGlubGluZUJsb2NrTmVlZHNMYXlvdXQ6IGZhbHNlLFxuXHRcdHNocmlua1dyYXBCbG9ja3M6IGZhbHNlLFxuXHRcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IHRydWVcblx0fTtcblxuXHQvLyBNYWtlIHN1cmUgY2hlY2tlZCBzdGF0dXMgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gaW5wdXQuY2xvbmVOb2RlKCB0cnVlICkuY2hlY2tlZDtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgb3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmVuJ3QgbWFya2VkIGFzIGRpc2FibGVkXG5cdC8vIChXZWJLaXQgbWFya3MgdGhlbSBhcyBkaXNhYmxlZClcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gVGVzdCB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkZWxldGUgYW4gZXhwYW5kbyBmcm9tIGFuIGVsZW1lbnRcblx0Ly8gRmFpbHMgaW4gSW50ZXJuZXQgRXhwbG9yZXJcblx0dHJ5IHtcblx0XHRkZWxldGUgZGl2LnRlc3Q7XG5cdH0gY2F0Y2goIGUgKSB7XG5cdFx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gZmFsc2U7XG5cdH1cblxuXHRpZiAoICFkaXYuYWRkRXZlbnRMaXN0ZW5lciAmJiBkaXYuYXR0YWNoRXZlbnQgJiYgZGl2LmZpcmVFdmVudCApIHtcblx0XHRkaXYuYXR0YWNoRXZlbnQoIFwib25jbGlja1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIENsb25pbmcgYSBub2RlIHNob3VsZG4ndCBjb3B5IG92ZXIgYW55XG5cdFx0XHQvLyBib3VuZCBldmVudCBoYW5kbGVycyAoSUUgZG9lcyB0aGlzKVxuXHRcdFx0c3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTtcblx0XHR9KTtcblx0XHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuZmlyZUV2ZW50KCBcIm9uY2xpY2tcIiApO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYSByYWRpbyBtYWludGFpbnMgaXRzIHZhbHVlXG5cdC8vIGFmdGVyIGJlaW5nIGFwcGVuZGVkIHRvIHRoZSBET01cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJyYWRpb1wiKTtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xuXG5cdGlucHV0LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIpO1xuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRmcmFnbWVudC5hcHBlbmRDaGlsZCggZGl2Lmxhc3RDaGlsZCApO1xuXG5cdC8vIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBmcmFnbWVudC5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBDaGVjayBpZiBhIGRpc2Nvbm5lY3RlZCBjaGVja2JveCB3aWxsIHJldGFpbiBpdHMgY2hlY2tlZFxuXHQvLyB2YWx1ZSBvZiB0cnVlIGFmdGVyIGFwcGVuZGVkIHRvIHRoZSBET00gKElFNi83KVxuXHRzdXBwb3J0LmFwcGVuZENoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuXG5cdGZyYWdtZW50LnJlbW92ZUNoaWxkKCBpbnB1dCApO1xuXHRmcmFnbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cblx0Ly8gQ2hlY2sgaWYgZGl2IHdpdGggZXhwbGljaXQgd2lkdGggYW5kIG5vIG1hcmdpbi1yaWdodCBpbmNvcnJlY3RseVxuXHQvLyBnZXRzIGNvbXB1dGVkIG1hcmdpbi1yaWdodCBiYXNlZCBvbiB3aWR0aCBvZiBjb250YWluZXIuIEZvciBtb3JlXG5cdC8vIGluZm8gc2VlIGJ1ZyAjMzMzM1xuXHQvLyBGYWlscyBpbiBXZWJLaXQgYmVmb3JlIEZlYiAyMDExIG5pZ2h0bGllc1xuXHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0XHRtYXJnaW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdFx0bWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCIwXCI7XG5cdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIycHhcIjtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIG1hcmdpbkRpdiApO1xuXHRcdHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCA9XG5cdFx0XHQoIHBhcnNlSW50KCAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBtYXJnaW5EaXYsIG51bGwgKSB8fCB7IG1hcmdpblJpZ2h0OiAwIH0gKS5tYXJnaW5SaWdodCwgMTAgKSB8fCAwICkgPT09IDA7XG5cdH1cblxuXHQvLyBUZWNobmlxdWUgZnJvbSBKdXJpeSBaYXl0c2V2XG5cdC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2RldGVjdGluZy1ldmVudC1zdXBwb3J0LXdpdGhvdXQtYnJvd3Nlci1zbmlmZmluZy9cblx0Ly8gV2Ugb25seSBjYXJlIGFib3V0IHRoZSBjYXNlIHdoZXJlIG5vbi1zdGFuZGFyZCBldmVudCBzeXN0ZW1zXG5cdC8vIGFyZSB1c2VkLCBuYW1lbHkgaW4gSUUuIFNob3J0LWNpcmN1aXRpbmcgaGVyZSBoZWxwcyB1cyB0b1xuXHQvLyBhdm9pZCBhbiBldmFsIGNhbGwgKGluIHNldEF0dHJpYnV0ZSkgd2hpY2ggY2FuIGNhdXNlIENTUFxuXHQvLyB0byBnbyBoYXl3aXJlLiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NlY3VyaXR5L0NTUFxuXHRpZiAoIGRpdi5hdHRhY2hFdmVudCApIHtcblx0XHRmb3IoIGkgaW4ge1xuXHRcdFx0c3VibWl0OiAxLFxuXHRcdFx0Y2hhbmdlOiAxLFxuXHRcdFx0Zm9jdXNpbjogMVxuXHRcdH0pIHtcblx0XHRcdGV2ZW50TmFtZSA9IFwib25cIiArIGk7XG5cdFx0XHRpc1N1cHBvcnRlZCA9ICggZXZlbnROYW1lIGluIGRpdiApO1xuXHRcdFx0aWYgKCAhaXNTdXBwb3J0ZWQgKSB7XG5cdFx0XHRcdGRpdi5zZXRBdHRyaWJ1dGUoIGV2ZW50TmFtZSwgXCJyZXR1cm47XCIgKTtcblx0XHRcdFx0aXNTdXBwb3J0ZWQgPSAoIHR5cGVvZiBkaXZbIGV2ZW50TmFtZSBdID09PSBcImZ1bmN0aW9uXCIgKTtcblx0XHRcdH1cblx0XHRcdHN1cHBvcnRbIGkgKyBcIkJ1YmJsZXNcIiBdID0gaXNTdXBwb3J0ZWQ7XG5cdFx0fVxuXHR9XG5cblx0ZnJhZ21lbnQucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXG5cdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUVcblx0ZnJhZ21lbnQgPSBzZWxlY3QgPSBvcHQgPSBtYXJnaW5EaXYgPSBkaXYgPSBpbnB1dCA9IG51bGw7XG5cblx0Ly8gUnVuIHRlc3RzIHRoYXQgbmVlZCBhIGJvZHkgYXQgZG9jIHJlYWR5XG5cdGpRdWVyeShmdW5jdGlvbigpIHtcblx0XHR2YXIgY29udGFpbmVyLCBvdXRlciwgaW5uZXIsIHRhYmxlLCB0ZCwgb2Zmc2V0U3VwcG9ydCxcblx0XHRcdGNvbk1hcmdpblRvcCwgcHRsbSwgdmIsIHN0eWxlLCBodG1sLFxuXHRcdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcblxuXHRcdGlmICggIWJvZHkgKSB7XG5cdFx0XHQvLyBSZXR1cm4gZm9yIGZyYW1lc2V0IGRvY3MgdGhhdCBkb24ndCBoYXZlIGEgYm9keVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbk1hcmdpblRvcCA9IDE7XG5cdFx0cHRsbSA9IFwicG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4O21hcmdpbjowO1wiO1xuXHRcdHZiID0gXCJ2aXNpYmlsaXR5OmhpZGRlbjtib3JkZXI6MDtcIjtcblx0XHRzdHlsZSA9IFwic3R5bGU9J1wiICsgcHRsbSArIFwiYm9yZGVyOjVweCBzb2xpZCAjMDAwO3BhZGRpbmc6MDsnXCI7XG5cdFx0aHRtbCA9IFwiPGRpdiBcIiArIHN0eWxlICsgXCI+PGRpdj48L2Rpdj48L2Rpdj5cIiArXG5cdFx0XHRcIjx0YWJsZSBcIiArIHN0eWxlICsgXCIgY2VsbHBhZGRpbmc9JzAnIGNlbGxzcGFjaW5nPScwJz5cIiArXG5cdFx0XHRcIjx0cj48dGQ+PC90ZD48L3RyPjwvdGFibGU+XCI7XG5cblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gdmIgKyBcIndpZHRoOjA7aGVpZ2h0OjA7cG9zaXRpb246c3RhdGljO3RvcDowO21hcmdpbi10b3A6XCIgKyBjb25NYXJnaW5Ub3AgKyBcInB4XCI7XG5cdFx0Ym9keS5pbnNlcnRCZWZvcmUoIGNvbnRhaW5lciwgYm9keS5maXJzdENoaWxkICk7XG5cblx0XHQvLyBDb25zdHJ1Y3QgdGhlIHRlc3QgZWxlbWVudFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdC8vIENoZWNrIGlmIHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdGhleSBhcmUgc2V0XG5cdFx0Ly8gdG8gZGlzcGxheTpub25lIGFuZCB0aGVyZSBhcmUgc3RpbGwgb3RoZXIgdmlzaWJsZSB0YWJsZSBjZWxscyBpbiBhXG5cdFx0Ly8gdGFibGUgcm93OyBpZiBzbywgb2Zmc2V0V2lkdGgvSGVpZ2h0IGFyZSBub3QgcmVsaWFibGUgZm9yIHVzZSB3aGVuXG5cdFx0Ly8gZGV0ZXJtaW5pbmcgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBoaWRkZW4gZGlyZWN0bHkgdXNpbmdcblx0XHQvLyBkaXNwbGF5Om5vbmUgKGl0IGlzIHN0aWxsIHNhZmUgdG8gdXNlIG9mZnNldHMgaWYgYSBwYXJlbnQgZWxlbWVudCBpc1xuXHRcdC8vIGhpZGRlbjsgZG9uIHNhZmV0eSBnb2dnbGVzIGFuZCBzZWUgYnVnICM0NTEyIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cblx0XHQvLyAob25seSBJRSA4IGZhaWxzIHRoaXMgdGVzdClcblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8dGFibGU+PHRyPjx0ZCBzdHlsZT0ncGFkZGluZzowO2JvcmRlcjowO2Rpc3BsYXk6bm9uZSc+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPlwiO1xuXHRcdHRkcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0ZFwiICk7XG5cdFx0aXNTdXBwb3J0ZWQgPSAoIHRkc1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMCApO1xuXG5cdFx0dGRzWyAwIF0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0dGRzWyAxIF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgZW1wdHkgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHRcblx0XHQvLyAoSUUgPD0gOCBmYWlsIHRoaXMgdGVzdClcblx0XHRzdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyA9IGlzU3VwcG9ydGVkICYmICggdGRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwICk7XG5cblx0XHQvLyBGaWd1cmUgb3V0IGlmIHRoZSBXM0MgYm94IG1vZGVsIHdvcmtzIGFzIGV4cGVjdGVkXG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIxcHhcIjtcblx0XHRqUXVlcnkuYm94TW9kZWwgPSBzdXBwb3J0LmJveE1vZGVsID0gZGl2Lm9mZnNldFdpZHRoID09PSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHQvLyBDaGVjayBpZiBuYXRpdmVseSBibG9jay1sZXZlbCBlbGVtZW50cyBhY3QgbGlrZSBpbmxpbmUtYmxvY2tcblx0XHRcdC8vIGVsZW1lbnRzIHdoZW4gc2V0dGluZyB0aGVpciBkaXNwbGF5IHRvICdpbmxpbmUnIGFuZCBnaXZpbmdcblx0XHRcdC8vIHRoZW0gbGF5b3V0XG5cdFx0XHQvLyAoSUUgPCA4IGRvZXMgdGhpcylcblx0XHRcdGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmVcIjtcblx0XHRcdGRpdi5zdHlsZS56b29tID0gMTtcblx0XHRcdHN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCA9ICggZGl2Lm9mZnNldFdpZHRoID09PSAyICk7XG5cblx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnRzIHdpdGggbGF5b3V0IHNocmluay13cmFwIHRoZWlyIGNoaWxkcmVuXG5cdFx0XHQvLyAoSUUgNiBkb2VzIHRoaXMpXG5cdFx0XHRkaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IHN0eWxlPSd3aWR0aDo0cHg7Jz48L2Rpdj5cIjtcblx0XHRcdHN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcyA9ICggZGl2Lm9mZnNldFdpZHRoICE9PSAyICk7XG5cdFx0fVxuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBwdGxtICsgdmI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IGh0bWw7XG5cblx0XHRvdXRlciA9IGRpdi5maXJzdENoaWxkO1xuXHRcdGlubmVyID0gb3V0ZXIuZmlyc3RDaGlsZDtcblx0XHR0ZCA9IG91dGVyLm5leHRTaWJsaW5nLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZDtcblxuXHRcdG9mZnNldFN1cHBvcnQgPSB7XG5cdFx0XHRkb2VzTm90QWRkQm9yZGVyOiAoIGlubmVyLm9mZnNldFRvcCAhPT0gNSApLFxuXHRcdFx0ZG9lc0FkZEJvcmRlckZvclRhYmxlQW5kQ2VsbHM6ICggdGQub2Zmc2V0VG9wID09PSA1IClcblx0XHR9O1xuXG5cdFx0aW5uZXIuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG5cdFx0aW5uZXIuc3R5bGUudG9wID0gXCIyMHB4XCI7XG5cblx0XHQvLyBzYWZhcmkgc3VidHJhY3RzIHBhcmVudCBib3JkZXIgd2lkdGggaGVyZSB3aGljaCBpcyA1cHhcblx0XHRvZmZzZXRTdXBwb3J0LmZpeGVkUG9zaXRpb24gPSAoIGlubmVyLm9mZnNldFRvcCA9PT0gMjAgfHwgaW5uZXIub2Zmc2V0VG9wID09PSAxNSApO1xuXHRcdGlubmVyLnN0eWxlLnBvc2l0aW9uID0gaW5uZXIuc3R5bGUudG9wID0gXCJcIjtcblxuXHRcdG91dGVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRvdXRlci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblxuXHRcdG9mZnNldFN1cHBvcnQuc3VidHJhY3RzQm9yZGVyRm9yT3ZlcmZsb3dOb3RWaXNpYmxlID0gKCBpbm5lci5vZmZzZXRUb3AgPT09IC01ICk7XG5cdFx0b2Zmc2V0U3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCA9ICggYm9keS5vZmZzZXRUb3AgIT09IGNvbk1hcmdpblRvcCApO1xuXG5cdFx0Ym9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdFx0ZGl2ICA9IGNvbnRhaW5lciA9IG51bGw7XG5cblx0XHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCBvZmZzZXRTdXBwb3J0ICk7XG5cdH0pO1xuXG5cdHJldHVybiBzdXBwb3J0O1xufSkoKTtcblxuXG5cblxudmFyIHJicmFjZSA9IC9eKD86XFx7LipcXH18XFxbLipcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2FjaGU6IHt9LFxuXG5cdC8vIFBsZWFzZSB1c2Ugd2l0aCBjYXV0aW9uXG5cdHV1aWQ6IDAsXG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdC8vIE5vbi1kaWdpdHMgcmVtb3ZlZCB0byBtYXRjaCByaW5saW5lalF1ZXJ5XG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIGpRdWVyeS5mbi5qcXVlcnkgKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gVGhlIGZvbGxvd2luZyBlbGVtZW50cyB0aHJvdyB1bmNhdGNoYWJsZSBleGNlcHRpb25zIGlmIHlvdVxuXHQvLyBhdHRlbXB0IHRvIGFkZCBleHBhbmRvIHByb3BlcnRpZXMgdG8gdGhlbS5cblx0bm9EYXRhOiB7XG5cdFx0XCJlbWJlZFwiOiB0cnVlLFxuXHRcdC8vIEJhbiBhbGwgb2JqZWN0cyBleGNlcHQgZm9yIEZsYXNoICh3aGljaCBoYW5kbGUgZXhwYW5kb3MpXG5cdFx0XCJvYmplY3RcIjogXCJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDBcIixcblx0XHRcImFwcGxldFwiOiB0cnVlXG5cdH0sXG5cblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0ZWxlbSA9IGVsZW0ubm9kZVR5cGUgPyBqUXVlcnkuY2FjaGVbIGVsZW1balF1ZXJ5LmV4cGFuZG9dIF0gOiBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdO1xuXHRcdHJldHVybiAhIWVsZW0gJiYgIWlzRW1wdHlEYXRhT2JqZWN0KCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEsIHB2dCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0XHRpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwcml2YXRlQ2FjaGUsIHRoaXNDYWNoZSwgcmV0LFxuXHRcdFx0aW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbyxcblx0XHRcdGdldEJ5TmFtZSA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiLFxuXG5cdFx0XHQvLyBXZSBoYXZlIHRvIGhhbmRsZSBET00gbm9kZXMgYW5kIEpTIG9iamVjdHMgZGlmZmVyZW50bHkgYmVjYXVzZSBJRTYtN1xuXHRcdFx0Ly8gY2FuJ3QgR0Mgb2JqZWN0IHJlZmVyZW5jZXMgcHJvcGVybHkgYWNyb3NzIHRoZSBET00tSlMgYm91bmRhcnlcblx0XHRcdGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG5cblx0XHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgdGhlIGdsb2JhbCBqUXVlcnkgY2FjaGU7IEpTIG9iamVjdCBkYXRhIGlzXG5cdFx0XHQvLyBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgb2JqZWN0IHNvIEdDIGNhbiBvY2N1ciBhdXRvbWF0aWNhbGx5XG5cdFx0XHRjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG5cblx0XHRcdC8vIE9ubHkgZGVmaW5pbmcgYW4gSUQgZm9yIEpTIG9iamVjdHMgaWYgaXRzIGNhY2hlIGFscmVhZHkgZXhpc3RzIGFsbG93c1xuXHRcdFx0Ly8gdGhlIGNvZGUgdG8gc2hvcnRjdXQgb24gdGhlIHNhbWUgcGF0aCBhcyBhIERPTSBub2RlIHdpdGggbm8gY2FjaGVcblx0XHRcdGlkID0gaXNOb2RlID8gZWxlbVsgaW50ZXJuYWxLZXkgXSA6IGVsZW1bIGludGVybmFsS2V5IF0gJiYgaW50ZXJuYWxLZXksXG5cdFx0XHRpc0V2ZW50cyA9IG5hbWUgPT09IFwiZXZlbnRzXCI7XG5cblx0XHQvLyBBdm9pZCBkb2luZyBhbnkgbW9yZSB3b3JrIHRoYW4gd2UgbmVlZCB0byB3aGVuIHRyeWluZyB0byBnZXQgZGF0YSBvbiBhblxuXHRcdC8vIG9iamVjdCB0aGF0IGhhcyBubyBkYXRhIGF0IGFsbFxuXHRcdGlmICggKCFpZCB8fCAhY2FjaGVbaWRdIHx8ICghaXNFdmVudHMgJiYgIXB2dCAmJiAhY2FjaGVbaWRdLmRhdGEpKSAmJiBnZXRCeU5hbWUgJiYgZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggIWlkICkge1xuXHRcdFx0Ly8gT25seSBET00gbm9kZXMgbmVlZCBhIG5ldyB1bmlxdWUgSUQgZm9yIGVhY2ggZWxlbWVudCBzaW5jZSB0aGVpciBkYXRhXG5cdFx0XHQvLyBlbmRzIHVwIGluIHRoZSBnbG9iYWwgY2FjaGVcblx0XHRcdGlmICggaXNOb2RlICkge1xuXHRcdFx0XHRlbGVtWyBpbnRlcm5hbEtleSBdID0gaWQgPSArK2pRdWVyeS51dWlkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWQgPSBpbnRlcm5hbEtleTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFjYWNoZVsgaWQgXSApIHtcblx0XHRcdGNhY2hlWyBpZCBdID0ge307XG5cblx0XHRcdC8vIEF2b2lkcyBleHBvc2luZyBqUXVlcnkgbWV0YWRhdGEgb24gcGxhaW4gSlMgb2JqZWN0cyB3aGVuIHRoZSBvYmplY3Rcblx0XHRcdC8vIGlzIHNlcmlhbGl6ZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICggIWlzTm9kZSApIHtcblx0XHRcdFx0Y2FjaGVbIGlkIF0udG9KU09OID0galF1ZXJ5Lm5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW4gb2JqZWN0IGNhbiBiZSBwYXNzZWQgdG8galF1ZXJ5LmRhdGEgaW5zdGVhZCBvZiBhIGtleS92YWx1ZSBwYWlyOyB0aGlzIGdldHNcblx0XHQvLyBzaGFsbG93IGNvcGllZCBvdmVyIG9udG8gdGhlIGV4aXN0aW5nIGNhY2hlXG5cdFx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0aWYgKCBwdnQgKSB7XG5cdFx0XHRcdGNhY2hlWyBpZCBdID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0sIG5hbWUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhY2hlWyBpZCBdLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXS5kYXRhLCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cHJpdmF0ZUNhY2hlID0gdGhpc0NhY2hlID0gY2FjaGVbIGlkIF07XG5cblx0XHQvLyBqUXVlcnkgZGF0YSgpIGlzIHN0b3JlZCBpbiBhIHNlcGFyYXRlIG9iamVjdCBpbnNpZGUgdGhlIG9iamVjdCdzIGludGVybmFsIGRhdGFcblx0XHQvLyBjYWNoZSBpbiBvcmRlciB0byBhdm9pZCBrZXkgY29sbGlzaW9ucyBiZXR3ZWVuIGludGVybmFsIGRhdGEgYW5kIHVzZXItZGVmaW5lZFxuXHRcdC8vIGRhdGEuXG5cdFx0aWYgKCAhcHZ0ICkge1xuXHRcdFx0aWYgKCAhdGhpc0NhY2hlLmRhdGEgKSB7XG5cdFx0XHRcdHRoaXNDYWNoZS5kYXRhID0ge307XG5cdFx0XHR9XG5cblx0XHRcdHRoaXNDYWNoZSA9IHRoaXNDYWNoZS5kYXRhO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXSA9IGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlcnMgc2hvdWxkIG5vdCBhdHRlbXB0IHRvIGluc3BlY3QgdGhlIGludGVybmFsIGV2ZW50cyBvYmplY3QgdXNpbmcgalF1ZXJ5LmRhdGEsXG5cdFx0Ly8gaXQgaXMgdW5kb2N1bWVudGVkIGFuZCBzdWJqZWN0IHRvIGNoYW5nZS4gQnV0IGRvZXMgYW55b25lIGxpc3Rlbj8gTm8uXG5cdFx0aWYgKCBpc0V2ZW50cyAmJiAhdGhpc0NhY2hlWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXR1cm4gcHJpdmF0ZUNhY2hlLmV2ZW50cztcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgYm90aCBjb252ZXJ0ZWQtdG8tY2FtZWwgYW5kIG5vbi1jb252ZXJ0ZWQgZGF0YSBwcm9wZXJ0eSBuYW1lc1xuXHRcdC8vIElmIGEgZGF0YSBwcm9wZXJ0eSB3YXMgc3BlY2lmaWVkXG5cdFx0aWYgKCBnZXRCeU5hbWUgKSB7XG5cblx0XHRcdC8vIEZpcnN0IFRyeSB0byBmaW5kIGFzLWlzIHByb3BlcnR5IGRhdGFcblx0XHRcdHJldCA9IHRoaXNDYWNoZVsgbmFtZSBdO1xuXG5cdFx0XHQvLyBUZXN0IGZvciBudWxsfHVuZGVmaW5lZCBwcm9wZXJ0eSBkYXRhXG5cdFx0XHRpZiAoIHJldCA9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFRyeSB0byBmaW5kIHRoZSBjYW1lbENhc2VkIHByb3BlcnR5XG5cdFx0XHRcdHJldCA9IHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IHRoaXNDYWNoZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBwdnQgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0aWYgKCAhalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGhpc0NhY2hlLCBpLCBsLFxuXG5cdFx0XHQvLyBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZGF0YSBjYWNoZSBrZXlcblx0XHRcdGludGVybmFsS2V5ID0galF1ZXJ5LmV4cGFuZG8sXG5cblx0XHRcdGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG5cblx0XHRcdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRcdFx0Y2FjaGUgPSBpc05vZGUgPyBqUXVlcnkuY2FjaGUgOiBlbGVtLFxuXG5cdFx0XHQvLyBTZWUgalF1ZXJ5LmRhdGEgZm9yIG1vcmUgaW5mb3JtYXRpb25cblx0XHRcdGlkID0gaXNOb2RlID8gZWxlbVsgaW50ZXJuYWxLZXkgXSA6IGludGVybmFsS2V5O1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBubyBjYWNoZSBlbnRyeSBmb3IgdGhpcyBvYmplY3QsIHRoZXJlIGlzIG5vXG5cdFx0Ly8gcHVycG9zZSBpbiBjb250aW51aW5nXG5cdFx0aWYgKCAhY2FjaGVbIGlkIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuYW1lICkge1xuXG5cdFx0XHR0aGlzQ2FjaGUgPSBwdnQgPyBjYWNoZVsgaWQgXSA6IGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHRcdGlmICggdGhpc0NhY2hlICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBuYW1lcyBmb3IgZGF0YSBrZXlzXG5cdFx0XHRcdGlmICggIWpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0XHQvLyB0cnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRcdGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gWyBuYW1lIF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3BsaXQgdGhlIGNhbWVsIGNhc2VkIHZlcnNpb24gYnkgc3BhY2VzIHVubGVzcyBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzXG5cdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBuYW1lIGluIHRoaXNDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IFsgbmFtZSBdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpc0NhY2hlWyBuYW1lW2ldIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBkYXRhIGxlZnQgaW4gdGhlIGNhY2hlLCB3ZSB3YW50IHRvIGNvbnRpbnVlXG5cdFx0XHRcdC8vIGFuZCBsZXQgdGhlIGNhY2hlIG9iamVjdCBpdHNlbGYgZ2V0IGRlc3Ryb3llZFxuXHRcdFx0XHRpZiAoICEoIHB2dCA/IGlzRW1wdHlEYXRhT2JqZWN0IDogalF1ZXJ5LmlzRW1wdHlPYmplY3QgKSggdGhpc0NhY2hlICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG5cdFx0aWYgKCAhcHZ0ICkge1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHRcdC8vIERvbid0IGRlc3Ryb3kgdGhlIHBhcmVudCBjYWNoZSB1bmxlc3MgdGhlIGludGVybmFsIGRhdGEgb2JqZWN0XG5cdFx0XHQvLyBoYWQgYmVlbiB0aGUgb25seSB0aGluZyBsZWZ0IGluIGl0XG5cdFx0XHRpZiAoICFpc0VtcHR5RGF0YU9iamVjdChjYWNoZVsgaWQgXSkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBCcm93c2VycyB0aGF0IGZhaWwgZXhwYW5kbyBkZWxldGlvbiBhbHNvIHJlZnVzZSB0byBkZWxldGUgZXhwYW5kb3Mgb25cblx0XHQvLyB0aGUgd2luZG93LCBidXQgaXQgd2lsbCBhbGxvdyBpdCBvbiBhbGwgb3RoZXIgSlMgb2JqZWN0czsgb3RoZXIgYnJvd3NlcnNcblx0XHQvLyBkb24ndCBjYXJlXG5cdFx0Ly8gRW5zdXJlIHRoYXQgYGNhY2hlYCBpcyBub3QgYSB3aW5kb3cgb2JqZWN0ICMxMDA4MFxuXHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuZGVsZXRlRXhwYW5kbyB8fCAhY2FjaGUuc2V0SW50ZXJ2YWwgKSB7XG5cdFx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhY2hlWyBpZCBdID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBXZSBkZXN0cm95ZWQgdGhlIGNhY2hlIGFuZCBuZWVkIHRvIGVsaW1pbmF0ZSB0aGUgZXhwYW5kbyBvbiB0aGUgbm9kZSB0byBhdm9pZFxuXHRcdC8vIGZhbHNlIGxvb2t1cHMgaW4gdGhlIGNhY2hlIGZvciBlbnRyaWVzIHRoYXQgbm8gbG9uZ2VyIGV4aXN0XG5cdFx0aWYgKCBpc05vZGUgKSB7XG5cdFx0XHQvLyBJRSBkb2VzIG5vdCBhbGxvdyB1cyB0byBkZWxldGUgZXhwYW5kbyBwcm9wZXJ0aWVzIGZyb20gbm9kZXMsXG5cdFx0XHQvLyBub3IgZG9lcyBpdCBoYXZlIGEgcmVtb3ZlQXR0cmlidXRlIGZ1bmN0aW9uIG9uIERvY3VtZW50IG5vZGVzO1xuXHRcdFx0Ly8gd2UgbXVzdCBoYW5kbGUgYWxsIG9mIHRoZXNlIGNhc2VzXG5cdFx0XHRpZiAoIGpRdWVyeS5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8gKSB7XG5cdFx0XHRcdGRlbGV0ZSBlbGVtWyBpbnRlcm5hbEtleSBdO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5yZW1vdmVBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBpbnRlcm5hbEtleSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgaW50ZXJuYWxLZXkgXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgdHJ1ZSApO1xuXHR9LFxuXG5cdC8vIEEgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIERPTSBub2RlIGNhbiBoYW5kbGUgdGhlIGRhdGEgZXhwYW5kb1xuXHRhY2NlcHREYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZU5hbWUgKSB7XG5cdFx0XHR2YXIgbWF0Y2ggPSBqUXVlcnkubm9EYXRhWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuICEobWF0Y2ggPT09IHRydWUgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc2lkXCIpICE9PSBtYXRjaCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHBhcnRzLCBhdHRyLCBuYW1lLFxuXHRcdFx0ZGF0YSA9IG51bGw7XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0galF1ZXJ5LmRhdGEoIHRoaXNbMF0gKTtcblxuXHRcdFx0XHRpZiAoIHRoaXNbMF0ubm9kZVR5cGUgPT09IDEgJiYgIWpRdWVyeS5fZGF0YSggdGhpc1swXSwgXCJwYXJzZWRBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0YXR0ciA9IHRoaXNbMF0uYXR0cmlidXRlcztcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyW2ldLm5hbWU7XG5cblx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc3Vic3RyaW5nKDUpICk7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIHRoaXNbMF0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIHRoaXNbMF0sIFwicGFyc2VkQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kYXRhKCB0aGlzLCBrZXkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHBhcnRzID0ga2V5LnNwbGl0KFwiLlwiKTtcblx0XHRwYXJ0c1sxXSA9IHBhcnRzWzFdID8gXCIuXCIgKyBwYXJ0c1sxXSA6IFwiXCI7XG5cblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkYXRhID0gdGhpcy50cmlnZ2VySGFuZGxlcihcImdldERhdGFcIiArIHBhcnRzWzFdICsgXCIhXCIsIFtwYXJ0c1swXV0pO1xuXG5cdFx0XHQvLyBUcnkgdG8gZmV0Y2ggYW55IGludGVybmFsbHkgc3RvcmVkIGRhdGEgZmlyc3Rcblx0XHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0galF1ZXJ5LmRhdGEoIHRoaXNbMF0sIGtleSApO1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIHRoaXNbMF0sIGtleSwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkICYmIHBhcnRzWzFdID9cblx0XHRcdFx0dGhpcy5kYXRhKCBwYXJ0c1swXSApIDpcblx0XHRcdFx0ZGF0YTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRcdGFyZ3MgPSBbIHBhcnRzWzBdLCB2YWx1ZSBdO1xuXG5cdFx0XHRcdHNlbGYudHJpZ2dlckhhbmRsZXIoIFwic2V0RGF0YVwiICsgcGFydHNbMV0gKyBcIiFcIiwgYXJncyApO1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHRzZWxmLnRyaWdnZXJIYW5kbGVyKCBcImNoYW5nZURhdGFcIiArIHBhcnRzWzFdICsgXCIhXCIsIGFyZ3MgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggdGhpcywga2V5ICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0dmFyIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNOdW1lcmljKCBkYXRhICkgPyBwYXJzZUZsb2F0KCBkYXRhICkgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRqUXVlcnkuZGF0YSggZWxlbSwga2V5LCBkYXRhICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuLy8gY2hlY2tzIGEgY2FjaGUgb2JqZWN0IGZvciBlbXB0aW5lc3NcbmZ1bmN0aW9uIGlzRW1wdHlEYXRhT2JqZWN0KCBvYmogKSB7XG5cdGZvciAoIHZhciBuYW1lIGluIG9iaiApIHtcblxuXHRcdC8vIGlmIHRoZSBwdWJsaWMgZGF0YSBvYmplY3QgaXMgZW1wdHksIHRoZSBwcml2YXRlIGlzIHN0aWxsIGVtcHR5XG5cdFx0aWYgKCBuYW1lID09PSBcImRhdGFcIiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb2JqW25hbWVdICkgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCBuYW1lICE9PSBcInRvSlNPTlwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5cblxuXG5mdW5jdGlvbiBoYW5kbGVRdWV1ZU1hcmtEZWZlciggZWxlbSwgdHlwZSwgc3JjICkge1xuXHR2YXIgZGVmZXJEYXRhS2V5ID0gdHlwZSArIFwiZGVmZXJcIixcblx0XHRxdWV1ZURhdGFLZXkgPSB0eXBlICsgXCJxdWV1ZVwiLFxuXHRcdG1hcmtEYXRhS2V5ID0gdHlwZSArIFwibWFya1wiLFxuXHRcdGRlZmVyID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBkZWZlckRhdGFLZXkgKTtcblx0aWYgKCBkZWZlciAmJlxuXHRcdCggc3JjID09PSBcInF1ZXVlXCIgfHwgIWpRdWVyeS5fZGF0YShlbGVtLCBxdWV1ZURhdGFLZXkpICkgJiZcblx0XHQoIHNyYyA9PT0gXCJtYXJrXCIgfHwgIWpRdWVyeS5fZGF0YShlbGVtLCBtYXJrRGF0YUtleSkgKSApIHtcblx0XHQvLyBHaXZlIHJvb20gZm9yIGhhcmQtY29kZWQgY2FsbGJhY2tzIHRvIGZpcmUgZmlyc3Rcblx0XHQvLyBhbmQgZXZlbnR1YWxseSBtYXJrL3F1ZXVlIHNvbWV0aGluZyBlbHNlIG9uIHRoZSBlbGVtZW50XG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFqUXVlcnkuX2RhdGEoIGVsZW0sIHF1ZXVlRGF0YUtleSApICYmXG5cdFx0XHRcdCFqUXVlcnkuX2RhdGEoIGVsZW0sIG1hcmtEYXRhS2V5ICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBkZWZlckRhdGFLZXksIHRydWUgKTtcblx0XHRcdFx0ZGVmZXIuZmlyZSgpO1xuXHRcdFx0fVxuXHRcdH0sIDAgKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHRfbWFyazogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwibWFya1wiO1xuXHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCAoalF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlICkgfHwgMCkgKyAxICk7XG5cdFx0fVxuXHR9LFxuXG5cdF91bm1hcms6IGZ1bmN0aW9uKCBmb3JjZSwgZWxlbSwgdHlwZSApIHtcblx0XHRpZiAoIGZvcmNlICE9PSB0cnVlICkge1xuXHRcdFx0dHlwZSA9IGVsZW07XG5cdFx0XHRlbGVtID0gZm9yY2U7XG5cdFx0XHRmb3JjZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0XHR2YXIga2V5ID0gdHlwZSArIFwibWFya1wiLFxuXHRcdFx0XHRjb3VudCA9IGZvcmNlID8gMCA6ICggKGpRdWVyeS5fZGF0YSggZWxlbSwga2V5ICkgfHwgMSkgLSAxICk7XG5cdFx0XHRpZiAoIGNvdW50ICkge1xuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIGtleSwgY291bnQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBrZXksIHRydWUgKTtcblx0XHRcdFx0aGFuZGxlUXVldWVNYXJrRGVmZXIoIGVsZW0sIHR5cGUsIFwibWFya1wiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXEgfHwgalF1ZXJ5LmlzQXJyYXkoZGF0YSkgKSB7XG5cdFx0XHRcdFx0cSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHEucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IHt9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlICsgXCIucnVuXCIsIGhvb2tzICk7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH0sIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhcXVldWUubGVuZ3RoICkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIHR5cGUgKyBcInF1ZXVlIFwiICsgdHlwZSArIFwiLnJ1blwiLCB0cnVlICk7XG5cdFx0XHRoYW5kbGVRdWV1ZU1hcmtEZWZlciggZWxlbSwgdHlwZSwgXCJxdWV1ZVwiICk7XG5cdFx0fVxuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1swXSwgdHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSk7XG5cdH0sXG5cdC8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cblx0Ly8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xuXHRkZWxheTogZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdFx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqZWN0ICkge1xuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmplY3QgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdHZhciBkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IGVsZW1lbnRzLmxlbmd0aCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyRGF0YUtleSA9IHR5cGUgKyBcImRlZmVyXCIsXG5cdFx0XHRxdWV1ZURhdGFLZXkgPSB0eXBlICsgXCJxdWV1ZVwiLFxuXHRcdFx0bWFya0RhdGFLZXkgPSB0eXBlICsgXCJtYXJrXCIsXG5cdFx0XHR0bXA7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSggaS0tICkge1xuXHRcdFx0aWYgKCggdG1wID0galF1ZXJ5LmRhdGEoIGVsZW1lbnRzWyBpIF0sIGRlZmVyRGF0YUtleSwgdW5kZWZpbmVkLCB0cnVlICkgfHxcblx0XHRcdFx0XHQoIGpRdWVyeS5kYXRhKCBlbGVtZW50c1sgaSBdLCBxdWV1ZURhdGFLZXksIHVuZGVmaW5lZCwgdHJ1ZSApIHx8XG5cdFx0XHRcdFx0XHRqUXVlcnkuZGF0YSggZWxlbWVudHNbIGkgXSwgbWFya0RhdGFLZXksIHVuZGVmaW5lZCwgdHJ1ZSApICkgJiZcblx0XHRcdFx0XHRqUXVlcnkuZGF0YSggZWxlbWVudHNbIGkgXSwgZGVmZXJEYXRhS2V5LCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgdHJ1ZSApICkpIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoKTtcblx0fVxufSk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcblxcdFxccl0vZyxcblx0cnNwYWNlID0gL1xccysvLFxuXHRycmV0dXJuID0gL1xcci9nLFxuXHRydHlwZSA9IC9eKD86YnV0dG9ufGlucHV0KSQvaSxcblx0cmZvY3VzYWJsZSA9IC9eKD86YnV0dG9ufGlucHV0fG9iamVjdHxzZWxlY3R8dGV4dGFyZWEpJC9pLFxuXHRyY2xpY2thYmxlID0gL15hKD86cmVhKT8kL2ksXG5cdHJib29sZWFuID0gL14oPzphdXRvZm9jdXN8YXV0b3BsYXl8YXN5bmN8Y2hlY2tlZHxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZHxzZWxlY3RlZCkkL2ksXG5cdGdldFNldEF0dHJpYnV0ZSA9IGpRdWVyeS5zdXBwb3J0LmdldFNldEF0dHJpYnV0ZSxcblx0bm9kZUhvb2ssIGJvb2xIb29rLCBmaXhTcGVjaWZpZWQ7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIG5hbWUsIHZhbHVlLCB0cnVlLCBqUXVlcnkuYXR0ciApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgbmFtZSwgdmFsdWUsIHRydWUsIGpRdWVyeS5wcm9wICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gdHJ5L2NhdGNoIGhhbmRsZXMgY2FzZXMgd2hlcmUgSUUgYmFsa3MgKHN1Y2ggYXMgcmVtb3ZpbmcgYSBwcm9wZXJ0eSBvbiB3aW5kb3cpXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzWyBuYW1lIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzWyBuYW1lIF07XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblx0XHR9KTtcblx0fSxcblxuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBpLCBsLCBlbGVtLFxuXHRcdFx0c2V0Q2xhc3MsIGMsIGNsO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQoIHJzcGFjZSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRpZiAoICFlbGVtLmNsYXNzTmFtZSAmJiBjbGFzc05hbWVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gdmFsdWU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2V0Q2xhc3MgPSBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IGNsYXNzTmFtZXMubGVuZ3RoOyBjIDwgY2w7IGMrKyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhfnNldENsYXNzLmluZGV4T2YoIFwiIFwiICsgY2xhc3NOYW1lc1sgYyBdICsgXCIgXCIgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRDbGFzcyArPSBjbGFzc05hbWVzWyBjIF0gKyBcIiBcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBqUXVlcnkudHJpbSggc2V0Q2xhc3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBpLCBsLCBlbGVtLCBjbGFzc05hbWUsIGMsIGNsO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y2xhc3NOYW1lcyA9ICggdmFsdWUgfHwgXCJcIiApLnNwbGl0KCByc3BhY2UgKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgZWxlbS5jbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSA9IChcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblx0XHRcdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IGNsYXNzTmFtZXMubGVuZ3RoOyBjIDwgY2w7IGMrKyApIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UoXCIgXCIgKyBjbGFzc05hbWVzWyBjIF0gKyBcIiBcIiwgXCIgXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBqUXVlcnkudHJpbSggY2xhc3NOYW1lICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBcIlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNCb29sID0gdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIjtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gdG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVZhbCxcblx0XHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQoIHJzcGFjZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcblx0XHRcdFx0XHQvLyBjaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwZXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRzdGF0ZSA9IGlzQm9vbCA/IHN0YXRlIDogIXNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdHNlbGZbIHN0YXRlID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiIF0oIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5jbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0Ly8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0b2dnbGUgd2hvbGUgY2xhc3NOYW1lXG5cdFx0XHRcdHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWzBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHQvLyBoYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdFx0cmV0LnJlcGxhY2UocnJldHVybiwgXCJcIikgOlxuXHRcdFx0XHRcdC8vIGhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSwgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBzZWxmLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKHZhbCwgZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdC8vIGF0dHJpYnV0ZXMudmFsdWUgaXMgdW5kZWZpbmVkIGluIEJsYWNrYmVycnkgNC43IGJ1dFxuXHRcdFx0XHQvLyB1c2VzIC52YWx1ZS4gU2VlICM2OTMyXG5cdFx0XHRcdHZhciB2YWwgPSBlbGVtLmF0dHJpYnV0ZXMudmFsdWU7XG5cdFx0XHRcdHJldHVybiAhdmFsIHx8IHZhbC5zcGVjaWZpZWQgPyBlbGVtLnZhbHVlIDogZWxlbS50ZXh0O1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGksIG1heCwgb3B0aW9uLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdHZhbHVlcyA9IFtdLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIjtcblxuXHRcdFx0XHQvLyBOb3RoaW5nIHdhcyBzZWxlY3RlZFxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCAmJiAoalF1ZXJ5LnN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09PSBudWxsKSAmJlxuXHRcdFx0XHRcdFx0XHQoIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGaXhlcyBCdWcgIzI1NTEgLS0gc2VsZWN0LnZhbCgpIGJyb2tlbiBpbiBJRSBhZnRlciBmb3JtLnJlc2V0KClcblx0XHRcdFx0aWYgKCBvbmUgJiYgIXZhbHVlcy5sZW5ndGggJiYgb3B0aW9ucy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeSggb3B0aW9uc1sgaW5kZXggXSApLnZhbCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHRqUXVlcnkoZWxlbSkuZmluZChcIm9wdGlvblwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KHRoaXMpLnZhbCgpLCB2YWx1ZXMgKSA+PSAwO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoICF2YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJGbjoge1xuXHRcdHZhbDogdHJ1ZSxcblx0XHRjc3M6IHRydWUsXG5cdFx0aHRtbDogdHJ1ZSxcblx0XHR0ZXh0OiB0cnVlLFxuXHRcdGRhdGE6IHRydWUsXG5cdFx0d2lkdGg6IHRydWUsXG5cdFx0aGVpZ2h0OiB0cnVlLFxuXHRcdG9mZnNldDogdHJ1ZVxuXHR9LFxuXG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgcGFzcyApIHtcblx0XHR2YXIgcmV0LCBob29rcywgbm90eG1sLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBwYXNzICYmIG5hbWUgaW4galF1ZXJ5LmF0dHJGbiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKVsgbmFtZSBdKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0bm90eG1sID0gblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApO1xuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5vdHhtbCApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fCAoIHJib29sZWFuLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiBub3R4bWwgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIFwiXCIgKyB2YWx1ZSApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIG5vdHhtbCAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmV0ID09PSBudWxsID9cblx0XHRcdFx0dW5kZWZpbmVkIDpcblx0XHRcdFx0cmV0O1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3BOYW1lLCBhdHRyTmFtZXMsIG5hbWUsIGwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggdmFsdWUgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkuc3BsaXQoIHJzcGFjZSApO1xuXHRcdFx0bCA9IGF0dHJOYW1lcy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bmFtZSA9IGF0dHJOYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggbmFtZSApIHtcblx0XHRcdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblxuXHRcdFx0XHRcdC8vIFNlZSAjOTY5OSBmb3IgZXhwbGFuYXRpb24gb2YgdGhpcyBhcHByb2FjaCAoc2V0dGluZyBmaXJzdCwgdGhlbiByZW1vdmFsKVxuXHRcdFx0XHRcdGpRdWVyeS5hdHRyKCBlbGVtLCBuYW1lLCBcIlwiICk7XG5cdFx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGdldFNldEF0dHJpYnV0ZSA/IG5hbWUgOiBwcm9wTmFtZSApO1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuXHRcdFx0XHRcdGlmICggcmJvb2xlYW4udGVzdCggbmFtZSApICYmIHByb3BOYW1lIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHQvLyBXZSBjYW4ndCBhbGxvdyB0aGUgdHlwZSBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkIChzaW5jZSBpdCBjYXVzZXMgcHJvYmxlbXMgaW4gSUUpXG5cdFx0XHRcdGlmICggcnR5cGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXJyb3IoIFwidHlwZSBwcm9wZXJ0eSBjYW4ndCBiZSBjaGFuZ2VkXCIgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggIWpRdWVyeS5zdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJiBqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJpbnB1dFwiKSApIHtcblx0XHRcdFx0XHQvLyBTZXR0aW5nIHRoZSB0eXBlIG9uIGEgcmFkaW8gYnV0dG9uIGFmdGVyIHRoZSB2YWx1ZSByZXNldHMgdGhlIHZhbHVlIGluIElFNi05XG5cdFx0XHRcdFx0Ly8gUmVzZXQgdmFsdWUgdG8gaXQncyBkZWZhdWx0IGluIGNhc2UgdHlwZSBpcyBzZXQgYWZ0ZXIgdmFsdWVcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGZvciBlbGVtZW50IGNyZWF0aW9uXG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBVc2UgdGhlIHZhbHVlIHByb3BlcnR5IGZvciBiYWNrIGNvbXBhdFxuXHRcdC8vIFVzZSB0aGUgbm9kZUhvb2sgZm9yIGJ1dHRvbiBlbGVtZW50cyBpbiBJRTYvNyAoIzE5NTQpXG5cdFx0dmFsdWU6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0XHRcdGlmICggbm9kZUhvb2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVIb29rLmdldCggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuYW1lIGluIGVsZW0gP1xuXHRcdFx0XHRcdGVsZW0udmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0XHRcdGlmICggbm9kZUhvb2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVIb29rLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBEb2VzIG5vdCByZXR1cm4gc28gdGhhdCBzZXRBdHRyaWJ1dGUgaXMgYWxzbyB1c2VkXG5cdFx0XHRcdGVsZW0udmFsdWUgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG5cdFx0cmVhZG9ubHk6IFwicmVhZE9ubHlcIixcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG5cdFx0bWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuXHRcdGNlbGxzcGFjaW5nOiBcImNlbGxTcGFjaW5nXCIsXG5cdFx0Y2VsbHBhZGRpbmc6IFwiY2VsbFBhZGRpbmdcIixcblx0XHRyb3dzcGFuOiBcInJvd1NwYW5cIixcblx0XHRjb2xzcGFuOiBcImNvbFNwYW5cIixcblx0XHR1c2VtYXA6IFwidXNlTWFwXCIsXG5cdFx0ZnJhbWVib3JkZXI6IFwiZnJhbWVCb3JkZXJcIixcblx0XHRjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCJcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIGRvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlTm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcInRhYmluZGV4XCIpO1xuXG5cdFx0XHRcdHJldHVybiBhdHRyaWJ1dGVOb2RlICYmIGF0dHJpYnV0ZU5vZGUuc3BlY2lmaWVkID9cblx0XHRcdFx0XHRwYXJzZUludCggYXR0cmlidXRlTm9kZS52YWx1ZSwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgcmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEFkZCB0aGUgdGFiSW5kZXggcHJvcEhvb2sgdG8gYXR0ckhvb2tzIGZvciBiYWNrLWNvbXBhdCAoZGlmZmVyZW50IGNhc2UgaXMgaW50ZW50aW9uYWwpXG5qUXVlcnkuYXR0ckhvb2tzLnRhYmluZGV4ID0galF1ZXJ5LnByb3BIb29rcy50YWJJbmRleDtcblxuLy8gSG9vayBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHQvLyBBbGlnbiBib29sZWFuIGF0dHJpYnV0ZXMgd2l0aCBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcblx0XHQvLyBGYWxsIGJhY2sgdG8gYXR0cmlidXRlIHByZXNlbmNlIHdoZXJlIHNvbWUgYm9vbGVhbnMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHR2YXIgYXR0ck5vZGUsXG5cdFx0XHRwcm9wZXJ0eSA9IGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lICk7XG5cdFx0cmV0dXJuIHByb3BlcnR5ID09PSB0cnVlIHx8IHR5cGVvZiBwcm9wZXJ0eSAhPT0gXCJib29sZWFuXCIgJiYgKCBhdHRyTm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSApICYmIGF0dHJOb2RlLm5vZGVWYWx1ZSAhPT0gZmFsc2UgP1xuXHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0dmFyIHByb3BOYW1lO1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdmFsdWUgaXMgdHJ1ZSBzaW5jZSB3ZSBrbm93IGF0IHRoaXMgcG9pbnQgaXQncyB0eXBlIGJvb2xlYW4gYW5kIG5vdCBmYWxzZVxuXHRcdFx0Ly8gU2V0IGJvb2xlYW4gYXR0cmlidXRlcyB0byB0aGUgc2FtZSBuYW1lIGFuZCBzZXQgdGhlIERPTSBwcm9wZXJ0eVxuXHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRpZiAoIHByb3BOYW1lIGluIGVsZW0gKSB7XG5cdFx0XHRcdC8vIE9ubHkgc2V0IHRoZSBJREwgc3BlY2lmaWNhbGx5IGlmIGl0IGFscmVhZHkgZXhpc3RzIG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG4vLyBJRTYvNyBkbyBub3Qgc3VwcG9ydCBnZXR0aW5nL3NldHRpbmcgc29tZSBhdHRyaWJ1dGVzIHdpdGggZ2V0L3NldEF0dHJpYnV0ZVxuaWYgKCAhZ2V0U2V0QXR0cmlidXRlICkge1xuXG5cdGZpeFNwZWNpZmllZCA9IHtcblx0XHRuYW1lOiB0cnVlLFxuXHRcdGlkOiB0cnVlXG5cdH07XG5cblx0Ly8gVXNlIHRoaXMgZm9yIGFueSBhdHRyaWJ1dGUgaW4gSUU2Lzdcblx0Ly8gVGhpcyBmaXhlcyBhbG1vc3QgZXZlcnkgSUU2LzcgaXNzdWVcblx0bm9kZUhvb2sgPSBqUXVlcnkudmFsSG9va3MuYnV0dG9uID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0XHR2YXIgcmV0O1xuXHRcdFx0cmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XG5cdFx0XHRyZXR1cm4gcmV0ICYmICggZml4U3BlY2lmaWVkWyBuYW1lIF0gPyByZXQubm9kZVZhbHVlICE9PSBcIlwiIDogcmV0LnNwZWNpZmllZCApID9cblx0XHRcdFx0cmV0Lm5vZGVWYWx1ZSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0Ly8gU2V0IHRoZSBleGlzdGluZyBvciBjcmVhdGUgYSBuZXcgYXR0cmlidXRlIG5vZGVcblx0XHRcdHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcblx0XHRcdGlmICggIXJldCApIHtcblx0XHRcdFx0cmV0ID0gZG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlTm9kZSggcmV0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKCByZXQubm9kZVZhbHVlID0gdmFsdWUgKyBcIlwiICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEFwcGx5IHRoZSBub2RlSG9vayB0byB0YWJpbmRleFxuXHRqUXVlcnkuYXR0ckhvb2tzLnRhYmluZGV4LnNldCA9IG5vZGVIb29rLnNldDtcblxuXHQvLyBTZXQgd2lkdGggYW5kIGhlaWdodCB0byBhdXRvIGluc3RlYWQgb2YgMCBvbiBlbXB0eSBzdHJpbmcoIEJ1ZyAjODE1MCApXG5cdC8vIFRoaXMgaXMgZm9yIHJlbW92YWxzXG5cdGpRdWVyeS5lYWNoKFsgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSwge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIFwiYXV0b1wiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdC8vIFNldCBjb250ZW50ZWRpdGFibGUgdG8gZmFsc2Ugb24gcmVtb3ZhbHMoIzEwNDI5KVxuXHQvLyBTZXR0aW5nIHRvIGVtcHR5IHN0cmluZyB0aHJvd3MgYW4gZXJyb3IgYXMgYW4gaW52YWxpZCB2YWx1ZVxuXHRqUXVlcnkuYXR0ckhvb2tzLmNvbnRlbnRlZGl0YWJsZSA9IHtcblx0XHRnZXQ6IG5vZGVIb29rLmdldCxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gXCJmYWxzZVwiO1xuXHRcdFx0fVxuXHRcdFx0bm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApO1xuXHRcdH1cblx0fTtcbn1cblxuXG4vLyBTb21lIGF0dHJpYnV0ZXMgcmVxdWlyZSBhIHNwZWNpYWwgY2FsbCBvbiBJRVxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuaHJlZk5vcm1hbGl6ZWQgKSB7XG5cdGpRdWVyeS5lYWNoKFsgXCJocmVmXCIsIFwic3JjXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHRqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0sIHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgMiApO1xuXHRcdFx0XHRyZXR1cm4gcmV0ID09PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuc3R5bGUgKSB7XG5cdGpRdWVyeS5hdHRySG9va3Muc3R5bGUgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIFJldHVybiB1bmRlZmluZWQgaW4gdGhlIGNhc2Ugb2YgZW1wdHkgc3RyaW5nXG5cdFx0XHQvLyBOb3JtYWxpemUgdG8gbG93ZXJjYXNlIHNpbmNlIElFIHVwcGVyY2FzZXMgY3NzIHByb3BlcnR5IG5hbWVzXG5cdFx0XHRyZXR1cm4gZWxlbS5zdHlsZS5jc3NUZXh0LnRvTG93ZXJDYXNlKCkgfHwgdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtLnN0eWxlLmNzc1RleHQgPSBcIlwiICsgdmFsdWUgKTtcblx0XHR9XG5cdH07XG59XG5cbi8vIFNhZmFyaSBtaXMtcmVwb3J0cyB0aGUgZGVmYXVsdCBzZWxlY3RlZCBwcm9wZXJ0eSBvZiBhbiBvcHRpb25cbi8vIEFjY2Vzc2luZyB0aGUgcGFyZW50J3Mgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBmaXhlcyBpdFxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBpdCBhbHNvIHdvcmtzIHdpdGggb3B0Z3JvdXBzLCBzZWUgIzU3MDFcblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBJRTYvNyBjYWxsIGVuY3R5cGUgZW5jb2RpbmdcbmlmICggIWpRdWVyeS5zdXBwb3J0LmVuY3R5cGUgKSB7XG5cdGpRdWVyeS5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCI7XG59XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5jaGVja09uICkge1xuXHRqUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIGluIFdlYmtpdCBcIlwiIGlzIHJldHVybmVkIGluc3RlYWQgb2YgXCJvblwiIGlmIGEgdmFsdWUgaXNuJ3Qgc3BlY2lmaWVkXG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cbmpRdWVyeS5lYWNoKFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0sIHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KTtcblxuXG5cblxudmFyIHJmb3JtRWxlbXMgPSAvXig/OnRleHRhcmVhfGlucHV0fHNlbGVjdCkkL2ksXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW15cXC5dKik/KD86XFwuKC4rKSk/JC8sXG5cdHJob3ZlckhhY2sgPSAvXFxiaG92ZXIoXFwuXFxTKyk/XFxiLyxcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8Y29udGV4dG1lbnUpfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHJxdWlja0lzID0gL14oXFx3KikoPzojKFtcXHdcXC1dKykpPyg/OlxcLihbXFx3XFwtXSspKT8kLyxcblx0cXVpY2tQYXJzZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgcXVpY2sgPSBycXVpY2tJcy5leGVjKCBzZWxlY3RvciApO1xuXHRcdGlmICggcXVpY2sgKSB7XG5cdFx0XHQvLyAgIDAgIDEgICAgMiAgIDNcblx0XHRcdC8vIFsgXywgdGFnLCBpZCwgY2xhc3MgXVxuXHRcdFx0cXVpY2tbMV0gPSAoIHF1aWNrWzFdIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cXVpY2tbM10gPSBxdWlja1szXSAmJiBuZXcgUmVnRXhwKCBcIig/Ol58XFxcXHMpXCIgKyBxdWlja1szXSArIFwiKD86XFxcXHN8JClcIiApO1xuXHRcdH1cblx0XHRyZXR1cm4gcXVpY2s7XG5cdH0sXG5cdHF1aWNrSXMgPSBmdW5jdGlvbiggZWxlbSwgbSApIHtcblx0XHR2YXIgYXR0cnMgPSBlbGVtLmF0dHJpYnV0ZXMgfHwge307XG5cdFx0cmV0dXJuIChcblx0XHRcdCghbVsxXSB8fCBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG1bMV0pICYmXG5cdFx0XHQoIW1bMl0gfHwgKGF0dHJzLmlkIHx8IHt9KS52YWx1ZSA9PT0gbVsyXSkgJiZcblx0XHRcdCghbVszXSB8fCBtWzNdLnRlc3QoIChhdHRyc1sgXCJjbGFzc1wiIF0gfHwge30pLnZhbHVlICkpXG5cdFx0KTtcblx0fSxcblx0aG92ZXJIYWNrID0gZnVuY3Rpb24oIGV2ZW50cyApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnNwZWNpYWwuaG92ZXIgPyBldmVudHMgOiBldmVudHMucmVwbGFjZSggcmhvdmVySGFjaywgXCJtb3VzZWVudGVyJDEgbW91c2VsZWF2ZSQxXCIgKTtcblx0fTtcblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgZWxlbURhdGEsIGV2ZW50SGFuZGxlLCBldmVudHMsXG5cdFx0XHR0LCB0bnMsIHR5cGUsIG5hbWVzcGFjZXMsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZU9iakluLCBxdWljaywgaGFuZGxlcnMsIHNwZWNpYWw7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGFsbG93IHBsYWluIG9iamVjdHMgdGhvKVxuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICF0eXBlcyB8fCAhaGFuZGxlciB8fCAhKGVsZW1EYXRhID0galF1ZXJ5Ll9kYXRhKCBlbGVtICkpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzO1xuXHRcdGlmICggIWV2ZW50cyApIHtcblx0XHRcdGVsZW1EYXRhLmV2ZW50cyA9IGV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZTtcblx0XHRpZiAoICFldmVudEhhbmRsZSApIHtcblx0XHRcdGVsZW1EYXRhLmhhbmRsZSA9IGV2ZW50SGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgKCFlIHx8IGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSkgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZXZlbnRIYW5kbGUuZWxlbSwgYXJndW1lbnRzICkgOlxuXHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0XHQvLyBBZGQgZWxlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUgZm4gdG8gcHJldmVudCBhIG1lbW9yeSBsZWFrIHdpdGggSUUgbm9uLW5hdGl2ZSBldmVudHNcblx0XHRcdGV2ZW50SGFuZGxlLmVsZW0gPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHQvLyBqUXVlcnkoLi4uKS5iaW5kKFwibW91c2VvdmVyIG1vdXNlb3V0XCIsIGZuKTtcblx0XHR0eXBlcyA9IGpRdWVyeS50cmltKCBob3ZlckhhY2sodHlwZXMpICkuc3BsaXQoIFwiIFwiICk7XG5cdFx0Zm9yICggdCA9IDA7IHQgPCB0eXBlcy5sZW5ndGg7IHQrKyApIHtcblxuXHRcdFx0dG5zID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSB0bnNbMV07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bnNbMl0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCh7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiB0bnNbMV0sXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRxdWljazogcXVpY2tQYXJzZSggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXTtcblx0XHRcdGlmICggIWhhbmRsZXJzICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIvYXR0YWNoRXZlbnQgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gQmluZCB0aGUgZ2xvYmFsIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hdHRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBOdWxsaWZ5IGVsZW0gdG8gcHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcblx0XHRlbGVtID0gbnVsbDtcblx0fSxcblxuXHRnbG9iYWw6IHt9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGVsZW1EYXRhID0galF1ZXJ5Lmhhc0RhdGEoIGVsZW0gKSAmJiBqUXVlcnkuX2RhdGEoIGVsZW0gKSxcblx0XHRcdHQsIHRucywgdHlwZSwgb3JpZ1R5cGUsIG5hbWVzcGFjZXMsIG9yaWdDb3VudCxcblx0XHRcdGosIGV2ZW50cywgc3BlY2lhbCwgaGFuZGxlLCBldmVudFR5cGUsIGhhbmRsZU9iajtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSBqUXVlcnkudHJpbSggaG92ZXJIYWNrKCB0eXBlcyB8fCBcIlwiICkgKS5zcGxpdChcIiBcIik7XG5cdFx0Zm9yICggdCA9IDA7IHQgPCB0eXBlcy5sZW5ndGg7IHQrKyApIHtcblx0XHRcdHRucyA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bnNbMV07XG5cdFx0XHRuYW1lc3BhY2VzID0gdG5zWzJdO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0ZXZlbnRUeXBlID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHRvcmlnQ291bnQgPSBldmVudFR5cGUubGVuZ3RoO1xuXHRcdFx0bmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMgPyBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLnNwbGl0KFwiLlwiKS5zb3J0KCkuam9pbihcIlxcXFwuKD86LipcXFxcLik/XCIpICsgXCIoXFxcXC58JClcIikgOiBudWxsO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8IGV2ZW50VHlwZS5sZW5ndGg7IGorKyApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnRUeXBlWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCAoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCAoICFuYW1lc3BhY2VzIHx8IG5hbWVzcGFjZXMudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQgKCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGV2ZW50VHlwZS5zcGxpY2UoIGotLSwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRldmVudFR5cGUuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBldmVudFR5cGUubGVuZ3RoID09PSAwICYmIG9yaWdDb3VudCAhPT0gZXZlbnRUeXBlLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fCBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0aGFuZGxlID0gZWxlbURhdGEuaGFuZGxlO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5lbGVtID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlRGF0YSBhbHNvIGNoZWNrcyBmb3IgZW1wdGluZXNzIGFuZCBjbGVhcnMgdGhlIGV4cGFuZG8gaWYgZW1wdHlcblx0XHRcdC8vIHNvIHVzZSBpdCBpbnN0ZWFkIG9mIGRlbGV0ZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIFsgXCJldmVudHNcIiwgXCJoYW5kbGVcIiBdLCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEV2ZW50cyB0aGF0IGFyZSBzYWZlIHRvIHNob3J0LWNpcmN1aXQgaWYgbm8gaGFuZGxlcnMgYXJlIGF0dGFjaGVkLlxuXHQvLyBOYXRpdmUgRE9NIGV2ZW50cyBzaG91bGQgbm90IGJlIGFkZGVkLCB0aGV5IG1heSBoYXZlIGlubGluZSBoYW5kbGVycy5cblx0Y3VzdG9tRXZlbnQ6IHtcblx0XHRcImdldERhdGFcIjogdHJ1ZSxcblx0XHRcInNldERhdGFcIjogdHJ1ZSxcblx0XHRcImNoYW5nZURhdGFcIjogdHJ1ZVxuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtICYmIChlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDgpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEV2ZW50IG9iamVjdCBvciBldmVudCB0eXBlXG5cdFx0dmFyIHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IFtdLFxuXHRcdFx0Y2FjaGUsIGV4Y2x1c2l2ZSwgaSwgY3VyLCBvbGQsIG9udHlwZSwgc3BlY2lhbCwgaGFuZGxlLCBldmVudFBhdGgsIGJ1YmJsZVR5cGU7XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiIVwiICkgPj0gMCApIHtcblx0XHRcdC8vIEV4Y2x1c2l2ZSBldmVudHMgdHJpZ2dlciBvbmx5IGZvciB0aGUgZXhhY3QgZXZlbnQgKG5vIG5hbWVzcGFjZXMpXG5cdFx0XHR0eXBlID0gdHlwZS5zbGljZSgwLCAtMSk7XG5cdFx0XHRleGNsdXNpdmUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID49IDAgKSB7XG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCAoIWVsZW0gfHwgalF1ZXJ5LmV2ZW50LmN1c3RvbUV2ZW50WyB0eXBlIF0pICYmICFqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gKSB7XG5cdFx0XHQvLyBObyBqUXVlcnkgaGFuZGxlcnMgZm9yIHRoaXMgZXZlbnQgdHlwZSwgYW5kIGl0IGNhbid0IGhhdmUgaW5saW5lIGhhbmRsZXJzXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIEV2ZW50LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiA/XG5cdFx0XHQvLyBqUXVlcnkuRXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/IGV2ZW50IDpcblx0XHRcdC8vIE9iamVjdCBsaXRlcmFsXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCBldmVudCApIDpcblx0XHRcdC8vIEp1c3QgdGhlIGV2ZW50IHR5cGUgKHN0cmluZylcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUgKTtcblxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IHRydWU7XG5cdFx0ZXZlbnQuZXhjbHVzaXZlID0gZXhjbHVzaXZlO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5uYW1lc3BhY2VfcmUgPSBldmVudC5uYW1lc3BhY2U/IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLik/XCIpICsgXCIoXFxcXC58JClcIikgOiBudWxsO1xuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgPyBcIm9uXCIgKyB0eXBlIDogXCJcIjtcblxuXHRcdC8vIEhhbmRsZSBhIGdsb2JhbCB0cmlnZ2VyXG5cdFx0aWYgKCAhZWxlbSApIHtcblxuXHRcdFx0Ly8gVE9ETzogU3RvcCB0YXVudGluZyB0aGUgZGF0YSBjYWNoZTsgcmVtb3ZlIGdsb2JhbCBldmVudHMgYW5kIGFsd2F5cyBhdHRhY2ggdG8gZG9jdW1lbnRcblx0XHRcdGNhY2hlID0galF1ZXJ5LmNhY2hlO1xuXHRcdFx0Zm9yICggaSBpbiBjYWNoZSApIHtcblx0XHRcdFx0aWYgKCBjYWNoZVsgaSBdLmV2ZW50cyAmJiBjYWNoZVsgaSBdLmV2ZW50c1sgdHlwZSBdICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBldmVudCwgZGF0YSwgY2FjaGVbIGkgXS5oYW5kbGUuZWxlbSwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhICE9IG51bGwgPyBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgOiBbXTtcblx0XHRkYXRhLnVuc2hpZnQoIGV2ZW50ICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0ZXZlbnRQYXRoID0gW1sgZWxlbSwgc3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlIF1dO1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0Y3VyID0gcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSA/IGVsZW0gOiBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRvbGQgPSBudWxsO1xuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaChbIGN1ciwgYnViYmxlVHlwZSBdKTtcblx0XHRcdFx0b2xkID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggb2xkICYmIG9sZCA9PT0gZWxlbS5vd25lckRvY3VtZW50ICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaChbIG9sZC5kZWZhdWx0VmlldyB8fCBvbGQucGFyZW50V2luZG93IHx8IHdpbmRvdywgYnViYmxlVHlwZSBdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBldmVudFBhdGgubGVuZ3RoICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpOyBpKysgKSB7XG5cblx0XHRcdGN1ciA9IGV2ZW50UGF0aFtpXVswXTtcblx0XHRcdGV2ZW50LnR5cGUgPSBldmVudFBhdGhbaV1bMV07XG5cblx0XHRcdGhhbmRsZSA9ICggalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiYgalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm90ZSB0aGF0IHRoaXMgaXMgYSBiYXJlIEpTIGZ1bmN0aW9uIGFuZCBub3QgYSBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgJiYgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGVsZW0ub3duZXJEb2N1bWVudCwgZGF0YSApID09PSBmYWxzZSkgJiZcblx0XHRcdFx0ISh0eXBlID09PSBcImNsaWNrXCIgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImFcIiApKSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gQ2FuJ3QgdXNlIGFuIC5pc0Z1bmN0aW9uKCkgY2hlY2sgaGVyZSBiZWNhdXNlIElFNi83IGZhaWxzIHRoYXQgdGVzdC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHQvLyBJRTw5IGRpZXMgb24gZm9jdXMvYmx1ciB0byBoaWRkZW4gZWxlbWVudCAoIzE0ODYpXG5cdFx0XHRcdGlmICggb250eXBlICYmIGVsZW1bIHR5cGUgXSAmJiAoKHR5cGUgIT09IFwiZm9jdXNcIiAmJiB0eXBlICE9PSBcImJsdXJcIikgfHwgZXZlbnQudGFyZ2V0Lm9mZnNldFdpZHRoICE9PSAwKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0b2xkID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIG9sZCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIG9sZCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gb2xkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgfHwgd2luZG93LmV2ZW50ICk7XG5cblx0XHR2YXIgaGFuZGxlcnMgPSAoIChqUXVlcnkuX2RhdGEoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10pLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRhcmdzID0gW10uc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICksXG5cdFx0XHRydW5fYWxsID0gIWV2ZW50LmV4Y2x1c2l2ZSAmJiAhZXZlbnQubmFtZXNwYWNlLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRpLCBqLCBjdXIsIGpxY3VyLCByZXQsIHNlbE1hdGNoLCBtYXRjaGVkLCBtYXRjaGVzLCBoYW5kbGVPYmosIHNlbCwgcmVsYXRlZDtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1swXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVycyB0aGF0IHNob3VsZCBydW4gaWYgdGhlcmUgYXJlIGRlbGVnYXRlZCBldmVudHNcblx0XHQvLyBBdm9pZCBkaXNhYmxlZCBlbGVtZW50cyBpbiBJRSAoIzY5MTEpIGFuZCBub24tbGVmdC1jbGljayBidWJibGluZyBpbiBGaXJlZm94ICgjMzg2MSlcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgIWV2ZW50LnRhcmdldC5kaXNhYmxlZCAmJiAhKGV2ZW50LmJ1dHRvbiAmJiBldmVudC50eXBlID09PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHQvLyBQcmVnZW5lcmF0ZSBhIHNpbmdsZSBqUXVlcnkgb2JqZWN0IGZvciByZXVzZSB3aXRoIC5pcygpXG5cdFx0XHRqcWN1ciA9IGpRdWVyeSh0aGlzKTtcblx0XHRcdGpxY3VyLmNvbnRleHQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcztcblxuXHRcdFx0Zm9yICggY3VyID0gZXZlbnQudGFyZ2V0OyBjdXIgIT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblx0XHRcdFx0c2VsTWF0Y2ggPSB7fTtcblx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRqcWN1clswXSA9IGN1cjtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3I7XG5cblx0XHRcdFx0XHRpZiAoIHNlbE1hdGNoWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0c2VsTWF0Y2hbIHNlbCBdID0gKFxuXHRcdFx0XHRcdFx0XHRoYW5kbGVPYmoucXVpY2sgPyBxdWlja0lzKCBjdXIsIGhhbmRsZU9iai5xdWljayApIDoganFjdXIuaXMoIHNlbCApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNlbE1hdGNoWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIG1hdGNoZXM6IG1hdGNoZXMgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBoYW5kbGVycy5sZW5ndGggPiBkZWxlZ2F0ZUNvdW50ICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBtYXRjaGVzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0pO1xuXHRcdH1cblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBoYW5kbGVyUXVldWUubGVuZ3RoICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpOyBpKysgKSB7XG5cdFx0XHRtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpIF07XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8IG1hdGNoZWQubWF0Y2hlcy5sZW5ndGggJiYgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCk7IGorKyApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gbWF0Y2hlZC5tYXRjaGVzWyBqIF07XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGJlIG5vbi1leGNsdXNpdmUgYW5kIGhhdmUgbm8gbmFtZXNwYWNlLCBvclxuXHRcdFx0XHQvLyAyKSBoYXZlIG5hbWVzcGFjZShzKSBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCBydW5fYWxsIHx8ICghZXZlbnQubmFtZXNwYWNlICYmICFoYW5kbGVPYmoubmFtZXNwYWNlKSB8fCBldmVudC5uYW1lc3BhY2VfcmUgJiYgZXZlbnQubmFtZXNwYWNlX3JlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cblx0XHRcdFx0XHRyZXQgPSAoIChqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlciApXG5cdFx0XHRcdFx0XHRcdC5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gcmV0O1xuXHRcdFx0XHRcdFx0aWYgKCByZXQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdC8vICoqKiBhdHRyQ2hhbmdlIGF0dHJOYW1lIHJlbGF0ZWROb2RlIHNyY0VsZW1lbnQgIGFyZSBub3Qgbm9ybWFsaXplZCwgbm9uLVczQywgZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIDEuOCAqKipcblx0cHJvcHM6IFwiYXR0ckNoYW5nZSBhdHRyTmFtZSByZWxhdGVkTm9kZSBzcmNFbGVtZW50IGFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b24sXG5cdFx0XHRcdGZyb21FbGVtZW50ID0gb3JpZ2luYWwuZnJvbUVsZW1lbnQ7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICsgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCByZWxhdGVkVGFyZ2V0LCBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggIWV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZnJvbUVsZW1lbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBmcm9tRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0ID8gb3JpZ2luYWwudG9FbGVtZW50IDogZnJvbUVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0galF1ZXJ5LmV2ZW50LmZpeEhvb2tzWyBldmVudC50eXBlIF0gfHwge30sXG5cdFx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGZvciAoIGkgPSBjb3B5Lmxlbmd0aDsgaTsgKSB7XG5cdFx0XHRwcm9wID0gY29weVsgLS1pIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIEZpeCB0YXJnZXQgcHJvcGVydHksIGlmIG5lY2Vzc2FyeSAoIzE5MjUsIElFIDYvNy84ICYgU2FmYXJpMilcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsIFNhZmFyaSlcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdC8vIEZvciBtb3VzZS9rZXkgZXZlbnRzOyBhZGQgbWV0YUtleSBpZiBpdCdzIG5vdCB0aGVyZSAoIzMzNjgsIElFNi83LzgpXG5cdFx0aWYgKCBldmVudC5tZXRhS2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRldmVudC5tZXRhS2V5ID0gZXZlbnQuY3RybEtleTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXI/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdHJlYWR5OiB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhlIHJlYWR5IGV2ZW50IGlzIHNldHVwXG5cdFx0XHRzZXR1cDogalF1ZXJ5LmJpbmRSZWFkeVxuXHRcdH0sXG5cblx0XHRsb2FkOiB7XG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cblx0XHRmb2N1czoge1xuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkge1xuXHRcdFx0XHQvLyBXZSBvbmx5IHdhbnQgdG8gZG8gdGhpcyBzcGVjaWFsIGNhc2Ugb24gd2luZG93c1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggdGhpcyApICkge1xuXHRcdFx0XHRcdHRoaXMub25iZWZvcmV1bmxvYWQgPSBldmVudEhhbmRsZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9uYmVmb3JldW5sb2FkID09PSBldmVudEhhbmRsZSApIHtcblx0XHRcdFx0XHR0aGlzLm9uYmVmb3JldW5sb2FkID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lLlxuXHRcdC8vIEZha2Ugb3JpZ2luYWxFdmVudCB0byBhdm9pZCBkb25vcidzIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGlmIHRoZVxuXHRcdC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0eyB0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZSxcblx0XHRcdFx0b3JpZ2luYWxFdmVudDoge31cblx0XHRcdH1cblx0XHQpO1xuXHRcdGlmICggYnViYmxlICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmNhbGwoIGVsZW0sIGUgKTtcblx0XHR9XG5cdFx0aWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cbn07XG5cbi8vIFNvbWUgcGx1Z2lucyBhcmUgdXNpbmcsIGJ1dCBpdCdzIHVuZG9jdW1lbnRlZC9kZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQuXG4vLyBUaGUgMS43IHNwZWNpYWwgZXZlbnQgaW50ZXJmYWNlIHNob3VsZCBwcm92aWRlIGFsbCB0aGUgaG9va3MgbmVlZGVkIG5vdy5cbmpRdWVyeS5ldmVudC5oYW5kbGUgPSBqUXVlcnkuZXZlbnQuZGlzcGF0Y2g7XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgP1xuXHRmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRcdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XG5cdFx0fVxuXHR9IDpcblx0ZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblx0XHRpZiAoIGVsZW0uZGV0YWNoRXZlbnQgKSB7XG5cdFx0XHRlbGVtLmRldGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBoYW5kbGUgKTtcblx0XHR9XG5cdH07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9ICggc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHwgc3JjLnJldHVyblZhbHVlID09PSBmYWxzZSB8fFxuXHRcdFx0c3JjLmdldFByZXZlbnREZWZhdWx0ICYmIHNyYy5nZXRQcmV2ZW50RGVmYXVsdCgpICkgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCAhZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXHRcdGlmICggZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdC8vIG90aGVyd2lzZSBzZXQgdGhlIHJldHVyblZhbHVlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBmYWxzZSAoSUUpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoICFlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRpZiAoIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlIHNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byB0cnVlIChJRSlcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fSxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2Vcbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xualF1ZXJ5LmVhY2goe1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmosXG5cdFx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRyZXQ7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBJRSBzdWJtaXQgZGVsZWdhdGlvblxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuc3VibWl0QnViYmxlcyApIHtcblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExhenktYWRkIGEgc3VibWl0IGhhbmRsZXIgd2hlbiBhIGRlc2NlbmRhbnQgZm9ybSBtYXkgcG90ZW50aWFsbHkgYmUgc3VibWl0dGVkXG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gTm9kZSBuYW1lIGNoZWNrIGF2b2lkcyBhIFZNTC1yZWxhdGVkIGNyYXNoIGluIElFICgjOTgwNylcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldCxcblx0XHRcdFx0XHRmb3JtID0galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSA/IGVsZW0uZm9ybSA6IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCBmb3JtICYmICFmb3JtLl9zdWJtaXRfYXR0YWNoZWQgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZm9ybSwgXCJzdWJtaXQuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHQvLyBJZiBmb3JtIHdhcyBzdWJtaXR0ZWQgYnkgdGhlIHVzZXIsIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdGhlIHRyZWVcblx0XHRcdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJzdWJtaXRcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGZvcm0uX3N1Ym1pdF9hdHRhY2hlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBzaW5jZSB3ZSBkb24ndCBuZWVkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG5cdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJmb3JtXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZGVsZWdhdGVkIGhhbmRsZXJzOyBjbGVhbkRhdGEgZXZlbnR1YWxseSByZWFwcyBzdWJtaXQgaGFuZGxlcnMgYXR0YWNoZWQgYWJvdmVcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9zdWJtaXRcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gSUUgY2hhbmdlIGRlbGVnYXRpb24gYW5kIGNoZWNrYm94L3JhZGlvIGZpeFxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2hhbmdlQnViYmxlcyApIHtcblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbC5jaGFuZ2UgPSB7XG5cblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmICggcmZvcm1FbGVtcy50ZXN0KCB0aGlzLm5vZGVOYW1lICkgKSB7XG5cdFx0XHRcdC8vIElFIGRvZXNuJ3QgZmlyZSBjaGFuZ2Ugb24gYSBjaGVjay9yYWRpbyB1bnRpbCBibHVyOyB0cmlnZ2VyIGl0IG9uIGNsaWNrXG5cdFx0XHRcdC8vIGFmdGVyIGEgcHJvcGVydHljaGFuZ2UuIEVhdCB0aGUgYmx1ci1jaGFuZ2UgaW4gc3BlY2lhbC5jaGFuZ2UuaGFuZGxlLlxuXHRcdFx0XHQvLyBUaGlzIHN0aWxsIGZpcmVzIG9uY2hhbmdlIGEgc2Vjb25kIHRpbWUgZm9yIGNoZWNrL3JhZGlvIGFmdGVyIGJsdXIuXG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgfHwgdGhpcy50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJwcm9wZXJ0eWNoYW5nZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5wcm9wZXJ0eU5hbWUgPT09IFwiY2hlY2tlZFwiICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9qdXN0X2NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuX2p1c3RfY2hhbmdlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9qdXN0X2NoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcImNoYW5nZVwiLCB0aGlzLCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIERlbGVnYXRlZCBldmVudDsgbGF6eS1hZGQgYSBjaGFuZ2UgaGFuZGxlciBvbiBkZXNjZW5kYW50IGlucHV0c1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJiZWZvcmVhY3RpdmF0ZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGUudGFyZ2V0O1xuXG5cdFx0XHRcdGlmICggcmZvcm1FbGVtcy50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgIWVsZW0uX2NoYW5nZV9hdHRhY2hlZCApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbGVtLCBcImNoYW5nZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1NpbXVsYXRlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwiY2hhbmdlXCIsIHRoaXMucGFyZW50Tm9kZSwgZXZlbnQsIHRydWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRlbGVtLl9jaGFuZ2VfYXR0YWNoZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdFx0Ly8gU3dhbGxvdyBuYXRpdmUgY2hhbmdlIGV2ZW50cyBmcm9tIGNoZWNrYm94L3JhZGlvLCB3ZSBhbHJlYWR5IHRyaWdnZXJlZCB0aGVtIGFib3ZlXG5cdFx0XHRpZiAoIHRoaXMgIT09IGVsZW0gfHwgZXZlbnQuaXNTaW11bGF0ZWQgfHwgZXZlbnQuaXNUcmlnZ2VyIHx8IChlbGVtLnR5cGUgIT09IFwicmFkaW9cIiAmJiBlbGVtLnR5cGUgIT09IFwiY2hlY2tib3hcIikgKSB7XG5cdFx0XHRcdHJldHVybiBldmVudC5oYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9jaGFuZ2VcIiApO1xuXG5cdFx0XHRyZXR1cm4gcmZvcm1FbGVtcy50ZXN0KCB0aGlzLm5vZGVOYW1lICk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgKSB7XG5cdGpRdWVyeS5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgYXR0YWNoZXMgPSAwLFxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSwgdHJ1ZSApO1xuXHRcdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBhdHRhY2hlcysrID09PSAwICkge1xuXHRcdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAtLWF0dGFjaGVzID09PSAwICkge1xuXHRcdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG5cdFx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9uKCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXHRcdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0XHRvcmlnRm4gPSBmbjtcblx0XHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH07XG5cdFx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uLmNhbGwoIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdHZhciBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlPyBoYW5kbGVPYmoudHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai50eXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHZhciB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRsaXZlOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdGpRdWVyeSggdGhpcy5jb250ZXh0ICkub24oIHR5cGVzLCB0aGlzLnNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRkaWU6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0alF1ZXJ5KCB0aGlzLmNvbnRleHQgKS5vZmYoIHR5cGVzLCB0aGlzLnNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDE/IHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOiB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yLCBmbiApO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0pO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0aWYgKCB0aGlzWzBdICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzWzBdLCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24oIGZuICkge1xuXHRcdC8vIFNhdmUgcmVmZXJlbmNlIHRvIGFyZ3VtZW50cyBmb3IgYWNjZXNzIGluIGNsb3N1cmVcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdGd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKyssXG5cdFx0XHRpID0gMCxcblx0XHRcdHRvZ2dsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIEZpZ3VyZSBvdXQgd2hpY2ggZnVuY3Rpb24gdG8gZXhlY3V0ZVxuXHRcdFx0XHR2YXIgbGFzdFRvZ2dsZSA9ICggalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImxhc3RUb2dnbGVcIiArIGZuLmd1aWQgKSB8fCAwICkgJSBpO1xuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIHRoaXMsIFwibGFzdFRvZ2dsZVwiICsgZm4uZ3VpZCwgbGFzdFRvZ2dsZSArIDEgKTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBjbGlja3Mgc3RvcFxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdC8vIGFuZCBleGVjdXRlIHRoZSBmdW5jdGlvblxuXHRcdFx0XHRyZXR1cm4gYXJnc1sgbGFzdFRvZ2dsZSBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSB8fCBmYWxzZTtcblx0XHRcdH07XG5cblx0XHQvLyBsaW5rIGFsbCB0aGUgZnVuY3Rpb25zLCBzbyBhbnkgb2YgdGhlbSBjYW4gdW5iaW5kIHRoaXMgY2xpY2sgaGFuZGxlclxuXHRcdHRvZ2dsZXIuZ3VpZCA9IGd1aWQ7XG5cdFx0d2hpbGUgKCBpIDwgYXJncy5sZW5ndGggKSB7XG5cdFx0XHRhcmdzWyBpKysgXS5ndWlkID0gZ3VpZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jbGljayggdG9nZ2xlciApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcblxuXHRpZiAoIGpRdWVyeS5hdHRyRm4gKSB7XG5cdFx0alF1ZXJ5LmF0dHJGblsgbmFtZSBdID0gdHJ1ZTtcblx0fVxuXG5cdGlmICggcmtleUV2ZW50LnRlc3QoIG5hbWUgKSApIHtcblx0XHRqUXVlcnkuZXZlbnQuZml4SG9va3NbIG5hbWUgXSA9IGpRdWVyeS5ldmVudC5rZXlIb29rcztcblx0fVxuXG5cdGlmICggcm1vdXNlRXZlbnQudGVzdCggbmFtZSApICkge1xuXHRcdGpRdWVyeS5ldmVudC5maXhIb29rc1sgbmFtZSBdID0galF1ZXJ5LmV2ZW50Lm1vdXNlSG9va3M7XG5cdH1cbn0pO1xuXG5cblxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZVxuICogIENvcHlyaWdodCAyMDExLCBUaGUgRG9qbyBGb3VuZGF0aW9uXG4gKiAgUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCwgQlNELCBhbmQgR1BMIExpY2Vuc2VzLlxuICogIE1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKi9cbihmdW5jdGlvbigpe1xuXG52YXIgY2h1bmtlciA9IC8oKD86XFwoKD86XFwoW14oKV0rXFwpfFteKCldKykrXFwpfFxcWyg/OlxcW1teXFxbXFxdXSpcXF18WydcIl1bXidcIl0qWydcIl18W15cXFtcXF0nXCJdKykrXFxdfFxcXFwufFteID4rfiwoXFxbXFxcXF0rKSt8Wz4rfl0pKFxccyosXFxzKik/KCg/Oi58XFxyfFxcbikqKS9nLFxuXHRleHBhbmRvID0gXCJzaXpjYWNoZVwiICsgKE1hdGgucmFuZG9tKCkgKyAnJykucmVwbGFjZSgnLicsICcnKSxcblx0ZG9uZSA9IDAsXG5cdHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcblx0aGFzRHVwbGljYXRlID0gZmFsc2UsXG5cdGJhc2VIYXNEdXBsaWNhdGUgPSB0cnVlLFxuXHRyQmFja3NsYXNoID0gL1xcXFwvZyxcblx0clJldHVybiA9IC9cXHJcXG4vZyxcblx0ck5vbldvcmQgPSAvXFxXLztcblxuLy8gSGVyZSB3ZSBjaGVjayBpZiB0aGUgSmF2YVNjcmlwdCBlbmdpbmUgaXMgdXNpbmcgc29tZSBzb3J0IG9mXG4vLyBvcHRpbWl6YXRpb24gd2hlcmUgaXQgZG9lcyBub3QgYWx3YXlzIGNhbGwgb3VyIGNvbXBhcmlzaW9uXG4vLyBmdW5jdGlvbi4gSWYgdGhhdCBpcyB0aGUgY2FzZSwgZGlzY2FyZCB0aGUgaGFzRHVwbGljYXRlIHZhbHVlLlxuLy8gICBUaHVzIGZhciB0aGF0IGluY2x1ZGVzIEdvb2dsZSBDaHJvbWUuXG5bMCwgMF0uc29ydChmdW5jdGlvbigpIHtcblx0YmFzZUhhc0R1cGxpY2F0ZSA9IGZhbHNlO1xuXHRyZXR1cm4gMDtcbn0pO1xuXG52YXIgU2l6emxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIG9yaWdDb250ZXh0ID0gY29udGV4dDtcblxuXHRpZiAoIGNvbnRleHQubm9kZVR5cGUgIT09IDEgJiYgY29udGV4dC5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0XG5cdGlmICggIXNlbGVjdG9yIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdHZhciBtLCBzZXQsIGNoZWNrU2V0LCBleHRyYSwgcmV0LCBjdXIsIHBvcCwgaSxcblx0XHRwcnVuZSA9IHRydWUsXG5cdFx0Y29udGV4dFhNTCA9IFNpenpsZS5pc1hNTCggY29udGV4dCApLFxuXHRcdHBhcnRzID0gW10sXG5cdFx0c29GYXIgPSBzZWxlY3Rvcjtcblx0XG5cdC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2h1bmtlciByZWdleHAgKHN0YXJ0IGZyb20gaGVhZClcblx0ZG8ge1xuXHRcdGNodW5rZXIuZXhlYyggXCJcIiApO1xuXHRcdG0gPSBjaHVua2VyLmV4ZWMoIHNvRmFyICk7XG5cblx0XHRpZiAoIG0gKSB7XG5cdFx0XHRzb0ZhciA9IG1bM107XG5cdFx0XG5cdFx0XHRwYXJ0cy5wdXNoKCBtWzFdICk7XG5cdFx0XG5cdFx0XHRpZiAoIG1bMl0gKSB7XG5cdFx0XHRcdGV4dHJhID0gbVszXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IHdoaWxlICggbSApO1xuXG5cdGlmICggcGFydHMubGVuZ3RoID4gMSAmJiBvcmlnUE9TLmV4ZWMoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMiAmJiBFeHByLnJlbGF0aXZlWyBwYXJ0c1swXSBdICkge1xuXHRcdFx0c2V0ID0gcG9zUHJvY2VzcyggcGFydHNbMF0gKyBwYXJ0c1sxXSwgY29udGV4dCwgc2VlZCApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldCA9IEV4cHIucmVsYXRpdmVbIHBhcnRzWzBdIF0gP1xuXHRcdFx0XHRbIGNvbnRleHQgXSA6XG5cdFx0XHRcdFNpenpsZSggcGFydHMuc2hpZnQoKSwgY29udGV4dCApO1xuXG5cdFx0XHR3aGlsZSAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0c2VsZWN0b3IgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgc2VsZWN0b3IgXSApIHtcblx0XHRcdFx0XHRzZWxlY3RvciArPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRzZXQgPSBwb3NQcm9jZXNzKCBzZWxlY3Rvciwgc2V0LCBzZWVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcblx0XHQvLyAoYnV0IG5vdCBpZiBpdCdsbCBiZSBmYXN0ZXIgaWYgdGhlIGlubmVyIHNlbGVjdG9yIGlzIGFuIElEKVxuXHRcdGlmICggIXNlZWQgJiYgcGFydHMubGVuZ3RoID4gMSAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmICFjb250ZXh0WE1MICYmXG5cdFx0XHRcdEV4cHIubWF0Y2guSUQudGVzdChwYXJ0c1swXSkgJiYgIUV4cHIubWF0Y2guSUQudGVzdChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSkgKSB7XG5cblx0XHRcdHJldCA9IFNpenpsZS5maW5kKCBwYXJ0cy5zaGlmdCgpLCBjb250ZXh0LCBjb250ZXh0WE1MICk7XG5cdFx0XHRjb250ZXh0ID0gcmV0LmV4cHIgP1xuXHRcdFx0XHRTaXp6bGUuZmlsdGVyKCByZXQuZXhwciwgcmV0LnNldCApWzBdIDpcblx0XHRcdFx0cmV0LnNldFswXTtcblx0XHR9XG5cblx0XHRpZiAoIGNvbnRleHQgKSB7XG5cdFx0XHRyZXQgPSBzZWVkID9cblx0XHRcdFx0eyBleHByOiBwYXJ0cy5wb3AoKSwgc2V0OiBtYWtlQXJyYXkoc2VlZCkgfSA6XG5cdFx0XHRcdFNpenpsZS5maW5kKCBwYXJ0cy5wb3AoKSwgcGFydHMubGVuZ3RoID09PSAxICYmIChwYXJ0c1swXSA9PT0gXCJ+XCIgfHwgcGFydHNbMF0gPT09IFwiK1wiKSAmJiBjb250ZXh0LnBhcmVudE5vZGUgPyBjb250ZXh0LnBhcmVudE5vZGUgOiBjb250ZXh0LCBjb250ZXh0WE1MICk7XG5cblx0XHRcdHNldCA9IHJldC5leHByID9cblx0XHRcdFx0U2l6emxlLmZpbHRlciggcmV0LmV4cHIsIHJldC5zZXQgKSA6XG5cdFx0XHRcdHJldC5zZXQ7XG5cblx0XHRcdGlmICggcGFydHMubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0Y2hlY2tTZXQgPSBtYWtlQXJyYXkoIHNldCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcnVuZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR3aGlsZSAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdHBvcCA9IGN1cjtcblxuXHRcdFx0XHRpZiAoICFFeHByLnJlbGF0aXZlWyBjdXIgXSApIHtcblx0XHRcdFx0XHRjdXIgPSBcIlwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBvcCA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwb3AgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRwb3AgPSBjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgY3VyIF0oIGNoZWNrU2V0LCBwb3AsIGNvbnRleHRYTUwgKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGVja1NldCA9IHBhcnRzID0gW107XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhY2hlY2tTZXQgKSB7XG5cdFx0Y2hlY2tTZXQgPSBzZXQ7XG5cdH1cblxuXHRpZiAoICFjaGVja1NldCApIHtcblx0XHRTaXp6bGUuZXJyb3IoIGN1ciB8fCBzZWxlY3RvciApO1xuXHR9XG5cblx0aWYgKCB0b1N0cmluZy5jYWxsKGNoZWNrU2V0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiICkge1xuXHRcdGlmICggIXBydW5lICkge1xuXHRcdFx0cmVzdWx0cy5wdXNoLmFwcGx5KCByZXN1bHRzLCBjaGVja1NldCApO1xuXG5cdFx0fSBlbHNlIGlmICggY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0Zm9yICggaSA9IDA7IGNoZWNrU2V0W2ldICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjaGVja1NldFtpXSAmJiAoY2hlY2tTZXRbaV0gPT09IHRydWUgfHwgY2hlY2tTZXRbaV0ubm9kZVR5cGUgPT09IDEgJiYgU2l6emxlLmNvbnRhaW5zKGNvbnRleHQsIGNoZWNrU2V0W2ldKSkgKSB7XG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBzZXRbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgPSAwOyBjaGVja1NldFtpXSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2hlY2tTZXRbaV0gJiYgY2hlY2tTZXRbaV0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBzZXRbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdG1ha2VBcnJheSggY2hlY2tTZXQsIHJlc3VsdHMgKTtcblx0fVxuXG5cdGlmICggZXh0cmEgKSB7XG5cdFx0U2l6emxlKCBleHRyYSwgb3JpZ0NvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHRpZiAoIHNvcnRPcmRlciApIHtcblx0XHRoYXNEdXBsaWNhdGUgPSBiYXNlSGFzRHVwbGljYXRlO1xuXHRcdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0XHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHRcdGZvciAoIHZhciBpID0gMTsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzdWx0c1tpXSA9PT0gcmVzdWx0c1sgaSAtIDEgXSApIHtcblx0XHRcdFx0XHRyZXN1bHRzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIHNldCApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgc2V0ICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIG5vZGUsIGV4cHIgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIFtub2RlXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuZmluZCA9IGZ1bmN0aW9uKCBleHByLCBjb250ZXh0LCBpc1hNTCApIHtcblx0dmFyIHNldCwgaSwgbGVuLCBtYXRjaCwgdHlwZSwgbGVmdDtcblxuXHRpZiAoICFleHByICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGZvciAoIGkgPSAwLCBsZW4gPSBFeHByLm9yZGVyLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHR5cGUgPSBFeHByLm9yZGVyW2ldO1xuXHRcdFxuXHRcdGlmICggKG1hdGNoID0gRXhwci5sZWZ0TWF0Y2hbIHR5cGUgXS5leGVjKCBleHByICkpICkge1xuXHRcdFx0bGVmdCA9IG1hdGNoWzFdO1xuXHRcdFx0bWF0Y2guc3BsaWNlKCAxLCAxICk7XG5cblx0XHRcdGlmICggbGVmdC5zdWJzdHIoIGxlZnQubGVuZ3RoIC0gMSApICE9PSBcIlxcXFxcIiApIHtcblx0XHRcdFx0bWF0Y2hbMV0gPSAobWF0Y2hbMV0gfHwgXCJcIikucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApO1xuXHRcdFx0XHRzZXQgPSBFeHByLmZpbmRbIHR5cGUgXSggbWF0Y2gsIGNvbnRleHQsIGlzWE1MICk7XG5cblx0XHRcdFx0aWYgKCBzZXQgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRleHByID0gZXhwci5yZXBsYWNlKCBFeHByLm1hdGNoWyB0eXBlIF0sIFwiXCIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggIXNldCApIHtcblx0XHRzZXQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApIDpcblx0XHRcdFtdO1xuXHR9XG5cblx0cmV0dXJuIHsgc2V0OiBzZXQsIGV4cHI6IGV4cHIgfTtcbn07XG5cblNpenpsZS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgc2V0LCBpbnBsYWNlLCBub3QgKSB7XG5cdHZhciBtYXRjaCwgYW55Rm91bmQsXG5cdFx0dHlwZSwgZm91bmQsIGl0ZW0sIGZpbHRlciwgbGVmdCxcblx0XHRpLCBwYXNzLFxuXHRcdG9sZCA9IGV4cHIsXG5cdFx0cmVzdWx0ID0gW10sXG5cdFx0Y3VyTG9vcCA9IHNldCxcblx0XHRpc1hNTEZpbHRlciA9IHNldCAmJiBzZXRbMF0gJiYgU2l6emxlLmlzWE1MKCBzZXRbMF0gKTtcblxuXHR3aGlsZSAoIGV4cHIgJiYgc2V0Lmxlbmd0aCApIHtcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBFeHByLmxlZnRNYXRjaFsgdHlwZSBdLmV4ZWMoIGV4cHIgKSkgIT0gbnVsbCAmJiBtYXRjaFsyXSApIHtcblx0XHRcdFx0ZmlsdGVyID0gRXhwci5maWx0ZXJbIHR5cGUgXTtcblx0XHRcdFx0bGVmdCA9IG1hdGNoWzFdO1xuXG5cdFx0XHRcdGFueUZvdW5kID0gZmFsc2U7XG5cblx0XHRcdFx0bWF0Y2guc3BsaWNlKDEsMSk7XG5cblx0XHRcdFx0aWYgKCBsZWZ0LnN1YnN0ciggbGVmdC5sZW5ndGggLSAxICkgPT09IFwiXFxcXFwiICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJMb29wID09PSByZXN1bHQgKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIEV4cHIucHJlRmlsdGVyWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBFeHByLnByZUZpbHRlclsgdHlwZSBdKCBtYXRjaCwgY3VyTG9vcCwgaW5wbGFjZSwgcmVzdWx0LCBub3QsIGlzWE1MRmlsdGVyICk7XG5cblx0XHRcdFx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdFx0XHRcdGFueUZvdW5kID0gZm91bmQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2ggPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyAoaXRlbSA9IGN1ckxvb3BbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbSApIHtcblx0XHRcdFx0XHRcdFx0Zm91bmQgPSBmaWx0ZXIoIGl0ZW0sIG1hdGNoLCBpLCBjdXJMb29wICk7XG5cdFx0XHRcdFx0XHRcdHBhc3MgPSBub3QgXiBmb3VuZDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGlucGxhY2UgJiYgZm91bmQgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhc3MgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhbnlGb3VuZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VyTG9vcFtpXSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwYXNzICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBpdGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0YW55Rm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBmb3VuZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGlmICggIWlucGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRjdXJMb29wID0gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGV4cHIgPSBleHByLnJlcGxhY2UoIEV4cHIubWF0Y2hbIHR5cGUgXSwgXCJcIiApO1xuXG5cdFx0XHRcdFx0aWYgKCAhYW55Rm91bmQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbXByb3BlciBleHByZXNzaW9uXG5cdFx0aWYgKCBleHByID09PSBvbGQgKSB7XG5cdFx0XHRpZiAoIGFueUZvdW5kID09IG51bGwgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggZXhwciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGQgPSBleHByO1xuXHR9XG5cblx0cmV0dXJuIGN1ckxvb3A7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmVpdmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG52YXIgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgdmFyIGksIG5vZGUsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlLFxuXHRcdHJldCA9IFwiXCI7XG5cblx0aWYgKCBub2RlVHlwZSApIHtcblx0XHRpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0Ly8gVXNlIHRleHRDb250ZW50IHx8IGlubmVyVGV4dCBmb3IgZWxlbWVudHNcblx0XHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBlbGVtLmlubmVyVGV4dCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdC8vIFJlcGxhY2UgSUUncyBjYXJyaWFnZSByZXR1cm5zXG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVyVGV4dC5yZXBsYWNlKCByUmV0dXJuLCAnJyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVHJhdmVyc2UgaXQncyBjaGlsZHJlblxuXHRcdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xuXHRcdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdGZvciAoIGkgPSAwOyAobm9kZSA9IGVsZW1baV0pOyBpKysgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSA4ICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0O1xufTtcblxudmFyIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXHRvcmRlcjogWyBcIklEXCIsIFwiTkFNRVwiLCBcIlRBR1wiIF0sXG5cblx0bWF0Y2g6IHtcblx0XHRJRDogLyMoKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKykvLFxuXHRcdENMQVNTOiAvXFwuKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspLyxcblx0XHROQU1FOiAvXFxbbmFtZT1bJ1wiXSooKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKylbJ1wiXSpcXF0vLFxuXHRcdEFUVFI6IC9cXFtcXHMqKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspXFxzKig/OihcXFM/PSlcXHMqKD86KFsnXCJdKSguKj8pXFwzfCgjPyg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSopfCl8KVxccypcXF0vLFxuXHRcdFRBRzogL14oKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcKlxcLV18XFxcXC4pKykvLFxuXHRcdENISUxEOiAvOihvbmx5fG50aHxsYXN0fGZpcnN0KS1jaGlsZCg/OlxcKFxccyooZXZlbnxvZGR8KD86WytcXC1dP1xcZCt8KD86WytcXC1dP1xcZCopP25cXHMqKD86WytcXC1dXFxzKlxcZCspPykpXFxzKlxcKSk/Lyxcblx0XHRQT1M6IC86KG50aHxlcXxndHxsdHxmaXJzdHxsYXN0fGV2ZW58b2RkKSg/OlxcKChcXGQqKVxcKSk/KD89W15cXC1dfCQpLyxcblx0XHRQU0VVRE86IC86KCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspKD86XFwoKFsnXCJdPykoKD86XFwoW15cXCldK1xcKXxbXlxcKFxcKV0qKSspXFwyXFwpKT8vXG5cdH0sXG5cblx0bGVmdE1hdGNoOiB7fSxcblxuXHRhdHRyTWFwOiB7XG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiXG5cdH0sXG5cblx0YXR0ckhhbmRsZToge1xuXHRcdGhyZWY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApO1xuXHRcdH0sXG5cdFx0dHlwZTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCIrXCI6IGZ1bmN0aW9uKGNoZWNrU2V0LCBwYXJ0KXtcblx0XHRcdHZhciBpc1BhcnRTdHIgPSB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIixcblx0XHRcdFx0aXNUYWcgPSBpc1BhcnRTdHIgJiYgIXJOb25Xb3JkLnRlc3QoIHBhcnQgKSxcblx0XHRcdFx0aXNQYXJ0U3RyTm90VGFnID0gaXNQYXJ0U3RyICYmICFpc1RhZztcblxuXHRcdFx0aWYgKCBpc1RhZyApIHtcblx0XHRcdFx0cGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hlY2tTZXQubGVuZ3RoLCBlbGVtOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gY2hlY2tTZXRbaV0pICkge1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtLnByZXZpb3VzU2libGluZykgJiYgZWxlbS5ub2RlVHlwZSAhPT0gMSApIHt9XG5cblx0XHRcdFx0XHRjaGVja1NldFtpXSA9IGlzUGFydFN0ck5vdFRhZyB8fCBlbGVtICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gcGFydCA/XG5cdFx0XHRcdFx0XHRlbGVtIHx8IGZhbHNlIDpcblx0XHRcdFx0XHRcdGVsZW0gPT09IHBhcnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc1BhcnRTdHJOb3RUYWcgKSB7XG5cdFx0XHRcdFNpenpsZS5maWx0ZXIoIHBhcnQsIGNoZWNrU2V0LCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdFwiPlwiOiBmdW5jdGlvbiggY2hlY2tTZXQsIHBhcnQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0aXNQYXJ0U3RyID0gdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gY2hlY2tTZXQubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIGlzUGFydFN0ciAmJiAhck5vbldvcmQudGVzdCggcGFydCApICkge1xuXHRcdFx0XHRwYXJ0ID0gcGFydC50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRlbGVtID0gY2hlY2tTZXRbaV07XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0Y2hlY2tTZXRbaV0gPSBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gcGFydCA/IHBhcmVudCA6IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNoZWNrU2V0W2ldO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0Y2hlY2tTZXRbaV0gPSBpc1BhcnRTdHIgP1xuXHRcdFx0XHRcdFx0XHRlbGVtLnBhcmVudE5vZGUgOlxuXHRcdFx0XHRcdFx0XHRlbGVtLnBhcmVudE5vZGUgPT09IHBhcnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpc1BhcnRTdHIgKSB7XG5cdFx0XHRcdFx0U2l6emxlLmZpbHRlciggcGFydCwgY2hlY2tTZXQsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRcIlwiOiBmdW5jdGlvbihjaGVja1NldCwgcGFydCwgaXNYTUwpe1xuXHRcdFx0dmFyIG5vZGVDaGVjayxcblx0XHRcdFx0ZG9uZU5hbWUgPSBkb25lKyssXG5cdFx0XHRcdGNoZWNrRm4gPSBkaXJDaGVjaztcblxuXHRcdFx0aWYgKCB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAhck5vbldvcmQudGVzdCggcGFydCApICkge1xuXHRcdFx0XHRwYXJ0ID0gcGFydC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRub2RlQ2hlY2sgPSBwYXJ0O1xuXHRcdFx0XHRjaGVja0ZuID0gZGlyTm9kZUNoZWNrO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGVja0ZuKCBcInBhcmVudE5vZGVcIiwgcGFydCwgZG9uZU5hbWUsIGNoZWNrU2V0LCBub2RlQ2hlY2ssIGlzWE1MICk7XG5cdFx0fSxcblxuXHRcdFwiflwiOiBmdW5jdGlvbiggY2hlY2tTZXQsIHBhcnQsIGlzWE1MICkge1xuXHRcdFx0dmFyIG5vZGVDaGVjayxcblx0XHRcdFx0ZG9uZU5hbWUgPSBkb25lKyssXG5cdFx0XHRcdGNoZWNrRm4gPSBkaXJDaGVjaztcblxuXHRcdFx0aWYgKCB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAhck5vbldvcmQudGVzdCggcGFydCApICkge1xuXHRcdFx0XHRwYXJ0ID0gcGFydC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRub2RlQ2hlY2sgPSBwYXJ0O1xuXHRcdFx0XHRjaGVja0ZuID0gZGlyTm9kZUNoZWNrO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGVja0ZuKCBcInByZXZpb3VzU2libGluZ1wiLCBwYXJ0LCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmluZDoge1xuXHRcdElEOiBmdW5jdGlvbiggbWF0Y2gsIGNvbnRleHQsIGlzWE1MICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNYTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChtYXRjaFsxXSk7XG5cdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0cmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gW21dIDogW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdE5BTUU6IGZ1bmN0aW9uKCBtYXRjaCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHZhciByZXQgPSBbXSxcblx0XHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggbWF0Y2hbMV0gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSByZXN1bHRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIHJlc3VsdHNbaV0uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSA9PT0gbWF0Y2hbMV0gKSB7XG5cdFx0XHRcdFx0XHRyZXQucHVzaCggcmVzdWx0c1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXQubGVuZ3RoID09PSAwID8gbnVsbCA6IHJldDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0VEFHOiBmdW5jdGlvbiggbWF0Y2gsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggbWF0Y2hbMV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHByZUZpbHRlcjoge1xuXHRcdENMQVNTOiBmdW5jdGlvbiggbWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90LCBpc1hNTCApIHtcblx0XHRcdG1hdGNoID0gXCIgXCIgKyBtYXRjaFsxXS5yZXBsYWNlKCByQmFja3NsYXNoLCBcIlwiICkgKyBcIiBcIjtcblxuXHRcdFx0aWYgKCBpc1hNTCApIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gY3VyTG9vcFtpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBub3QgXiAoZWxlbS5jbGFzc05hbWUgJiYgKFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZSgvW1xcdFxcblxccl0vZywgXCIgXCIpLmluZGV4T2YobWF0Y2gpID49IDApICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhaW5wbGFjZSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlucGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRjdXJMb29wW2ldID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0SUQ6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBtYXRjaFsxXS5yZXBsYWNlKCByQmFja3NsYXNoLCBcIlwiICk7XG5cdFx0fSxcblxuXHRcdFRBRzogZnVuY3Rpb24oIG1hdGNoLCBjdXJMb29wICkge1xuXHRcdFx0cmV0dXJuIG1hdGNoWzFdLnJlcGxhY2UoIHJCYWNrc2xhc2gsIFwiXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH0sXG5cblx0XHRDSElMRDogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0aWYgKCBtYXRjaFsxXSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFsyXS5yZXBsYWNlKC9eXFwrfFxccyovZywgJycpO1xuXG5cdFx0XHRcdC8vIHBhcnNlIGVxdWF0aW9ucyBsaWtlICdldmVuJywgJ29kZCcsICc1JywgJzJuJywgJzNuKzInLCAnNG4tMScsICctbis2J1xuXHRcdFx0XHR2YXIgdGVzdCA9IC8oLT8pKFxcZCopKD86bihbK1xcLV0/XFxkKikpPy8uZXhlYyhcblx0XHRcdFx0XHRtYXRjaFsyXSA9PT0gXCJldmVuXCIgJiYgXCIyblwiIHx8IG1hdGNoWzJdID09PSBcIm9kZFwiICYmIFwiMm4rMVwiIHx8XG5cdFx0XHRcdFx0IS9cXEQvLnRlc3QoIG1hdGNoWzJdICkgJiYgXCIwbitcIiArIG1hdGNoWzJdIHx8IG1hdGNoWzJdKTtcblxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgdGhlIG51bWJlcnMgKGZpcnN0KW4rKGxhc3QpIGluY2x1ZGluZyBpZiB0aGV5IGFyZSBuZWdhdGl2ZVxuXHRcdFx0XHRtYXRjaFsyXSA9ICh0ZXN0WzFdICsgKHRlc3RbMl0gfHwgMSkpIC0gMDtcblx0XHRcdFx0bWF0Y2hbM10gPSB0ZXN0WzNdIC0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUT0RPOiBNb3ZlIHRvIG5vcm1hbCBjYWNoaW5nIHN5c3RlbVxuXHRcdFx0bWF0Y2hbMF0gPSBkb25lKys7XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0QVRUUjogZnVuY3Rpb24oIG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCwgaXNYTUwgKSB7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApO1xuXHRcdFx0XG5cdFx0XHRpZiAoICFpc1hNTCAmJiBFeHByLmF0dHJNYXBbbmFtZV0gKSB7XG5cdFx0XHRcdG1hdGNoWzFdID0gRXhwci5hdHRyTWFwW25hbWVdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgaWYgYW4gdW4tcXVvdGVkIHZhbHVlIHdhcyB1c2VkXG5cdFx0XHRtYXRjaFs0XSA9ICggbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJCYWNrc2xhc2gsIFwiXCIgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFs0XSA9IFwiIFwiICsgbWF0Y2hbNF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBtYXRjaCwgY3VyTG9vcCwgaW5wbGFjZSwgcmVzdWx0LCBub3QgKSB7XG5cdFx0XHRpZiAoIG1hdGNoWzFdID09PSBcIm5vdFwiICkge1xuXHRcdFx0XHQvLyBJZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBjb21wbGV4IGV4cHJlc3Npb24sIG9yIGEgc2ltcGxlIG9uZVxuXHRcdFx0XHRpZiAoICggY2h1bmtlci5leGVjKG1hdGNoWzNdKSB8fCBcIlwiICkubGVuZ3RoID4gMSB8fCAvXlxcdy8udGVzdChtYXRjaFszXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hbM10gPSBTaXp6bGUobWF0Y2hbM10sIG51bGwsIG51bGwsIGN1ckxvb3ApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IFNpenpsZS5maWx0ZXIobWF0Y2hbM10sIGN1ckxvb3AsIGlucGxhY2UsIHRydWUgXiBub3QpO1xuXG5cdFx0XHRcdFx0aWYgKCAhaW5wbGFjZSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoLmFwcGx5KCByZXN1bHQsIHJldCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBFeHByLm1hdGNoLlBPUy50ZXN0KCBtYXRjaFswXSApIHx8IEV4cHIubWF0Y2guQ0hJTEQudGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0UE9TOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaC51bnNoaWZ0KCB0cnVlICk7XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9XG5cdH0sXG5cdFxuXHRmaWx0ZXJzOiB7XG5cdFx0ZW5hYmxlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgZWxlbS50eXBlICE9PSBcImhpZGRlblwiO1xuXHRcdH0sXG5cblx0XHRkaXNhYmxlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Y2hlY2tlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5jaGVja2VkID09PSB0cnVlO1xuXHRcdH0sXG5cdFx0XG5cdFx0c2VsZWN0ZWQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhIWVsZW0uZmlyc3RDaGlsZDtcblx0XHR9LFxuXG5cdFx0ZW1wdHk6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFlbGVtLmZpcnN0Q2hpbGQ7XG5cdFx0fSxcblxuXHRcdGhhczogZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuICEhU2l6emxlKCBtYXRjaFszXSwgZWxlbSApLmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0aGVhZGVyOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoL2hcXGQvaSkudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHR0ZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICksIHR5cGUgPSBlbGVtLnR5cGU7XG5cdFx0XHQvLyBJRTYgYW5kIDcgd2lsbCBtYXAgZWxlbS50eXBlIHRvICd0ZXh0JyBmb3IgbmV3IEhUTUw1IHR5cGVzIChzZWFyY2gsIGV0YykgXG5cdFx0XHQvLyB1c2UgZ2V0QXR0cmlidXRlIGluc3RlYWQgdG8gdGVzdCB0aGlzIGNhc2Vcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcInRleHRcIiA9PT0gdHlwZSAmJiAoIGF0dHIgPT09IHR5cGUgfHwgYXR0ciA9PT0gbnVsbCApO1xuXHRcdH0sXG5cblx0XHRyYWRpbzogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJyYWRpb1wiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblxuXHRcdGNoZWNrYm94OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcImNoZWNrYm94XCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0ZmlsZTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJmaWxlXCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0cGFzc3dvcmQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmIFwicGFzc3dvcmRcIiA9PT0gZWxlbS50eXBlO1xuXHRcdH0sXG5cblx0XHRzdWJtaXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBcInN1Ym1pdFwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblxuXHRcdGltYWdlOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcImltYWdlXCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBcInJlc2V0XCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0YnV0dG9uOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBcImJ1dHRvblwiID09PSBlbGVtLnR5cGUgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0aW5wdXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbi9pKS50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdGZvY3VzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBlbGVtLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0XHR9XG5cdH0sXG5cdHNldEZpbHRlcnM6IHtcblx0XHRmaXJzdDogZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSA9PT0gMDtcblx0XHR9LFxuXG5cdFx0bGFzdDogZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoLCBhcnJheSApIHtcblx0XHRcdHJldHVybiBpID09PSBhcnJheS5sZW5ndGggLSAxO1xuXHRcdH0sXG5cblx0XHRldmVuOiBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMiA9PT0gMDtcblx0XHR9LFxuXG5cdFx0b2RkOiBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMiA9PT0gMTtcblx0XHR9LFxuXG5cdFx0bHQ6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBpIDwgbWF0Y2hbM10gLSAwO1xuXHRcdH0sXG5cblx0XHRndDogZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIGkgPiBtYXRjaFszXSAtIDA7XG5cdFx0fSxcblxuXHRcdG50aDogZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIG1hdGNoWzNdIC0gMCA9PT0gaTtcblx0XHR9LFxuXG5cdFx0ZXE6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBtYXRjaFszXSAtIDAgPT09IGk7XG5cdFx0fVxuXHR9LFxuXHRmaWx0ZXI6IHtcblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCwgaSwgYXJyYXkgKSB7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzFdLFxuXHRcdFx0XHRmaWx0ZXIgPSBFeHByLmZpbHRlcnNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCBmaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybiBmaWx0ZXIoIGVsZW0sIGksIG1hdGNoLCBhcnJheSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSBcImNvbnRhaW5zXCIgKSB7XG5cdFx0XHRcdHJldHVybiAoZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KFsgZWxlbSBdKSB8fCBcIlwiKS5pbmRleE9mKG1hdGNoWzNdKSA+PSAwO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSBcIm5vdFwiICkge1xuXHRcdFx0XHR2YXIgbm90ID0gbWF0Y2hbM107XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBsID0gbm90Lmxlbmd0aDsgaiA8IGw7IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIG5vdFtqXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdENISUxEOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZmlyc3QsIGxhc3QsXG5cdFx0XHRcdGRvbmVOYW1lLCBwYXJlbnQsIGNhY2hlLFxuXHRcdFx0XHRjb3VudCwgZGlmZixcblx0XHRcdFx0dHlwZSA9IG1hdGNoWzFdLFxuXHRcdFx0XHRub2RlID0gZWxlbTtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblx0XHRcdFx0Y2FzZSBcIm9ubHlcIjpcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSApXHQge1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICkgeyBcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZmlyc3RcIiApIHsgXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTsgXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cblx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcblx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZS5uZXh0U2libGluZykgKVx0IHtcblx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSApIHsgXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y2FzZSBcIm50aFwiOlxuXHRcdFx0XHRcdGZpcnN0ID0gbWF0Y2hbMl07XG5cdFx0XHRcdFx0bGFzdCA9IG1hdGNoWzNdO1xuXG5cdFx0XHRcdFx0aWYgKCBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGRvbmVOYW1lID0gbWF0Y2hbMF07XG5cdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcblx0XHRcdFx0XHRpZiAoIHBhcmVudCAmJiAocGFyZW50WyBleHBhbmRvIF0gIT09IGRvbmVOYW1lIHx8ICFlbGVtLm5vZGVJbmRleCkgKSB7XG5cdFx0XHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvciAoIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVJbmRleCA9ICsrY291bnQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gXG5cblx0XHRcdFx0XHRcdHBhcmVudFsgZXhwYW5kbyBdID0gZG9uZU5hbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGRpZmYgPSBlbGVtLm5vZGVJbmRleCAtIGxhc3Q7XG5cblx0XHRcdFx0XHRpZiAoIGZpcnN0ID09PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IDA7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRJRDogZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFRBRzogZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIChtYXRjaCA9PT0gXCIqXCIgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkgfHwgISFlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbWF0Y2g7XG5cdFx0fSxcblx0XHRcblx0XHRDTEFTUzogZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIChcIiBcIiArIChlbGVtLmNsYXNzTmFtZSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSArIFwiIFwiKVxuXHRcdFx0XHQuaW5kZXhPZiggbWF0Y2ggKSA+IC0xO1xuXHRcdH0sXG5cblx0XHRBVFRSOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2ggKSB7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzFdLFxuXHRcdFx0XHRyZXN1bHQgPSBTaXp6bGUuYXR0ciA/XG5cdFx0XHRcdFx0U2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKSA6XG5cdFx0XHRcdFx0RXhwci5hdHRySGFuZGxlWyBuYW1lIF0gP1xuXHRcdFx0XHRcdEV4cHIuYXR0ckhhbmRsZVsgbmFtZSBdKCBlbGVtICkgOlxuXHRcdFx0XHRcdGVsZW1bIG5hbWUgXSAhPSBudWxsID9cblx0XHRcdFx0XHRcdGVsZW1bIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApLFxuXHRcdFx0XHR2YWx1ZSA9IHJlc3VsdCArIFwiXCIsXG5cdFx0XHRcdHR5cGUgPSBtYXRjaFsyXSxcblx0XHRcdFx0Y2hlY2sgPSBtYXRjaFs0XTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdCA9PSBudWxsID9cblx0XHRcdFx0dHlwZSA9PT0gXCIhPVwiIDpcblx0XHRcdFx0IXR5cGUgJiYgU2l6emxlLmF0dHIgP1xuXHRcdFx0XHRyZXN1bHQgIT0gbnVsbCA6XG5cdFx0XHRcdHR5cGUgPT09IFwiPVwiID9cblx0XHRcdFx0dmFsdWUgPT09IGNoZWNrIDpcblx0XHRcdFx0dHlwZSA9PT0gXCIqPVwiID9cblx0XHRcdFx0dmFsdWUuaW5kZXhPZihjaGVjaykgPj0gMCA6XG5cdFx0XHRcdHR5cGUgPT09IFwifj1cIiA/XG5cdFx0XHRcdChcIiBcIiArIHZhbHVlICsgXCIgXCIpLmluZGV4T2YoY2hlY2spID49IDAgOlxuXHRcdFx0XHQhY2hlY2sgP1xuXHRcdFx0XHR2YWx1ZSAmJiByZXN1bHQgIT09IGZhbHNlIDpcblx0XHRcdFx0dHlwZSA9PT0gXCIhPVwiID9cblx0XHRcdFx0dmFsdWUgIT09IGNoZWNrIDpcblx0XHRcdFx0dHlwZSA9PT0gXCJePVwiID9cblx0XHRcdFx0dmFsdWUuaW5kZXhPZihjaGVjaykgPT09IDAgOlxuXHRcdFx0XHR0eXBlID09PSBcIiQ9XCIgP1xuXHRcdFx0XHR2YWx1ZS5zdWJzdHIodmFsdWUubGVuZ3RoIC0gY2hlY2subGVuZ3RoKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHR0eXBlID09PSBcInw9XCIgP1xuXHRcdFx0XHR2YWx1ZSA9PT0gY2hlY2sgfHwgdmFsdWUuc3Vic3RyKDAsIGNoZWNrLmxlbmd0aCArIDEpID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0ZmFsc2U7XG5cdFx0fSxcblxuXHRcdFBPUzogZnVuY3Rpb24oIGVsZW0sIG1hdGNoLCBpLCBhcnJheSApIHtcblx0XHRcdHZhciBuYW1lID0gbWF0Y2hbMl0sXG5cdFx0XHRcdGZpbHRlciA9IEV4cHIuc2V0RmlsdGVyc1sgbmFtZSBdO1xuXG5cdFx0XHRpZiAoIGZpbHRlciApIHtcblx0XHRcdFx0cmV0dXJuIGZpbHRlciggZWxlbSwgaSwgbWF0Y2gsIGFycmF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgb3JpZ1BPUyA9IEV4cHIubWF0Y2guUE9TLFxuXHRmZXNjYXBlID0gZnVuY3Rpb24oYWxsLCBudW0pe1xuXHRcdHJldHVybiBcIlxcXFxcIiArIChudW0gLSAwICsgMSk7XG5cdH07XG5cbmZvciAoIHZhciB0eXBlIGluIEV4cHIubWF0Y2ggKSB7XG5cdEV4cHIubWF0Y2hbIHR5cGUgXSA9IG5ldyBSZWdFeHAoIEV4cHIubWF0Y2hbIHR5cGUgXS5zb3VyY2UgKyAoLyg/IVteXFxbXSpcXF0pKD8hW15cXChdKlxcKSkvLnNvdXJjZSkgKTtcblx0RXhwci5sZWZ0TWF0Y2hbIHR5cGUgXSA9IG5ldyBSZWdFeHAoIC8oXig/Oi58XFxyfFxcbikqPykvLnNvdXJjZSArIEV4cHIubWF0Y2hbIHR5cGUgXS5zb3VyY2UucmVwbGFjZSgvXFxcXChcXGQrKS9nLCBmZXNjYXBlKSApO1xufVxuXG52YXIgbWFrZUFycmF5ID0gZnVuY3Rpb24oIGFycmF5LCByZXN1bHRzICkge1xuXHRhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcnJheSwgMCApO1xuXG5cdGlmICggcmVzdWx0cyApIHtcblx0XHRyZXN1bHRzLnB1c2guYXBwbHkoIHJlc3VsdHMsIGFycmF5ICk7XG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblx0XG5cdHJldHVybiBhcnJheTtcbn07XG5cbi8vIFBlcmZvcm0gYSBzaW1wbGUgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2Zcbi8vIGNvbnZlcnRpbmcgYSBOb2RlTGlzdCB0byBhbiBhcnJheSB1c2luZyBidWlsdGluIG1ldGhvZHMuXG4vLyBBbHNvIHZlcmlmaWVzIHRoYXQgdGhlIHJldHVybmVkIGFycmF5IGhvbGRzIERPTSBub2Rlc1xuLy8gKHdoaWNoIGlzIG5vdCB0aGUgY2FzZSBpbiB0aGUgQmxhY2tiZXJyeSBicm93c2VyKVxudHJ5IHtcblx0QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzLCAwIClbMF0ubm9kZVR5cGU7XG5cbi8vIFByb3ZpZGUgYSBmYWxsYmFjayBtZXRob2QgaWYgaXQgZG9lcyBub3Qgd29ya1xufSBjYXRjaCggZSApIHtcblx0bWFrZUFycmF5ID0gZnVuY3Rpb24oIGFycmF5LCByZXN1bHRzICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIHRvU3RyaW5nLmNhbGwoYXJyYXkpID09PSBcIltvYmplY3QgQXJyYXldXCIgKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggcmV0LCBhcnJheSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdHlwZW9mIGFycmF5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0Zm9yICggdmFyIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIGFycmF5W2ldICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggOyBhcnJheVtpXTsgaSsrICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCBhcnJheVtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn1cblxudmFyIHNvcnRPcmRlciwgc2libGluZ0NoZWNrO1xuXG5pZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApIHtcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdGlmICggIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gfHwgIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XG5cdFx0XHRyZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/IC0xIDogMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDQgPyAtMSA6IDE7XG5cdH07XG5cbn0gZWxzZSB7XG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIFRoZSBub2RlcyBhcmUgaWRlbnRpY2FsLCB3ZSBjYW4gZXhpdCBlYXJseVxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdC8vIEZhbGxiYWNrIHRvIHVzaW5nIHNvdXJjZUluZGV4IChpbiBJRSkgaWYgaXQncyBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRcdH0gZWxzZSBpZiAoIGEuc291cmNlSW5kZXggJiYgYi5zb3VyY2VJbmRleCApIHtcblx0XHRcdHJldHVybiBhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblx0XHR9XG5cblx0XHR2YXIgYWwsIGJsLFxuXHRcdFx0YXAgPSBbXSxcblx0XHRcdGJwID0gW10sXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRjdXIgPSBhdXA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzIChvciBpZGVudGljYWwpIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0aWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblxuXHRcdC8vIElmIG5vIHBhcmVudHMgd2VyZSBmb3VuZCB0aGVuIHRoZSBub2RlcyBhcmUgZGlzY29ubmVjdGVkXG5cdFx0fSBlbHNlIGlmICggIWF1cCApIHtcblx0XHRcdHJldHVybiAtMTtcblxuXHRcdH0gZWxzZSBpZiAoICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UgdGhleSdyZSBzb21ld2hlcmUgZWxzZSBpbiB0aGUgdHJlZSBzbyB3ZSBuZWVkXG5cdFx0Ly8gdG8gYnVpbGQgdXAgYSBmdWxsIGxpc3Qgb2YgdGhlIHBhcmVudE5vZGVzIGZvciBjb21wYXJpc29uXG5cdFx0d2hpbGUgKCBjdXIgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGN1ciA9IGJ1cDtcblxuXHRcdHdoaWxlICggY3VyICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRhbCA9IGFwLmxlbmd0aDtcblx0XHRibCA9IGJwLmxlbmd0aDtcblxuXHRcdC8vIFN0YXJ0IHdhbGtpbmcgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYWwgJiYgaSA8IGJsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFwW2ldICE9PSBicFtpXSApIHtcblx0XHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZW5kZWQgc29tZXBsYWNlIHVwIHRoZSB0cmVlIHNvIGRvIGEgc2libGluZyBjaGVja1xuXHRcdHJldHVybiBpID09PSBhbCA/XG5cdFx0XHRzaWJsaW5nQ2hlY2soIGEsIGJwW2ldLCAtMSApIDpcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGIsIDEgKTtcblx0fTtcblxuXHRzaWJsaW5nQ2hlY2sgPSBmdW5jdGlvbiggYSwgYiwgcmV0ICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0dmFyIGN1ciA9IGEubmV4dFNpYmxpbmc7XG5cblx0XHR3aGlsZSAoIGN1ciApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdGN1ciA9IGN1ci5uZXh0U2libGluZztcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fTtcbn1cblxuLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBicm93c2VyIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZSB3aGVuXG4vLyBxdWVyeWluZyBieSBnZXRFbGVtZW50QnlJZCAoYW5kIHByb3ZpZGUgYSB3b3JrYXJvdW5kKVxuKGZ1bmN0aW9uKCl7XG5cdC8vIFdlJ3JlIGdvaW5nIHRvIGluamVjdCBhIGZha2UgaW5wdXQgZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIG5hbWVcblx0dmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdGlkID0gXCJzY3JpcHRcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG5cdFx0cm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXHRmb3JtLmlubmVySFRNTCA9IFwiPGEgbmFtZT0nXCIgKyBpZCArIFwiJy8+XCI7XG5cblx0Ly8gSW5qZWN0IGl0IGludG8gdGhlIHJvb3QgZWxlbWVudCwgY2hlY2sgaXRzIHN0YXR1cywgYW5kIHJlbW92ZSBpdCBxdWlja2x5XG5cdHJvb3QuaW5zZXJ0QmVmb3JlKCBmb3JtLCByb290LmZpcnN0Q2hpbGQgKTtcblxuXHQvLyBUaGUgd29ya2Fyb3VuZCBoYXMgdG8gZG8gYWRkaXRpb25hbCBjaGVja3MgYWZ0ZXIgYSBnZXRFbGVtZW50QnlJZFxuXHQvLyBXaGljaCBzbG93cyB0aGluZ3MgZG93biBmb3Igb3RoZXIgYnJvd3NlcnMgKGhlbmNlIHRoZSBicmFuY2hpbmcpXG5cdGlmICggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlkICkgKSB7XG5cdFx0RXhwci5maW5kLklEID0gZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0LCBpc1hNTCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzWE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMV0pO1xuXG5cdFx0XHRcdHJldHVybiBtID9cblx0XHRcdFx0XHRtLmlkID09PSBtYXRjaFsxXSB8fCB0eXBlb2YgbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIG0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLm5vZGVWYWx1ZSA9PT0gbWF0Y2hbMV0gP1xuXHRcdFx0XHRcdFx0W21dIDpcblx0XHRcdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdFx0W107XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdEV4cHIuZmlsdGVyLklEID0gZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xuXHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlICYmIG5vZGUubm9kZVZhbHVlID09PSBtYXRjaDtcblx0XHR9O1xuXHR9XG5cblx0cm9vdC5yZW1vdmVDaGlsZCggZm9ybSApO1xuXG5cdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdHJvb3QgPSBmb3JtID0gbnVsbDtcbn0pKCk7XG5cbihmdW5jdGlvbigpe1xuXHQvLyBDaGVjayB0byBzZWUgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdC8vIHdoZW4gZG9pbmcgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpXG5cblx0Ly8gQ3JlYXRlIGEgZmFrZSBlbGVtZW50XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblxuXHQvLyBNYWtlIHN1cmUgbm8gY29tbWVudHMgYXJlIGZvdW5kXG5cdGlmICggZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGggPiAwICkge1xuXHRcdEV4cHIuZmluZC5UQUcgPSBmdW5jdGlvbiggbWF0Y2gsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIG1hdGNoWzFdICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggbWF0Y2hbMV0gPT09IFwiKlwiICkge1xuXHRcdFx0XHR2YXIgdG1wID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyByZXN1bHRzW2ldOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXN1bHRzW2ldLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIHJlc3VsdHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHRzID0gdG1wO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGFuIGF0dHJpYnV0ZSByZXR1cm5zIG5vcm1hbGl6ZWQgaHJlZiBhdHRyaWJ1dGVzXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblxuXHRpZiAoIGRpdi5maXJzdENoaWxkICYmIHR5cGVvZiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgIT09IFwiI1wiICkge1xuXG5cdFx0RXhwci5hdHRySGFuZGxlLmhyZWYgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJocmVmXCIsIDIgKTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0ZGl2ID0gbnVsbDtcbn0pKCk7XG5cbmlmICggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApIHtcblx0KGZ1bmN0aW9uKCl7XG5cdFx0dmFyIG9sZFNpenpsZSA9IFNpenpsZSxcblx0XHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRpZCA9IFwiX19zaXp6bGVfX1wiO1xuXG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPHAgY2xhc3M9J1RFU1QnPjwvcD5cIjtcblxuXHRcdC8vIFNhZmFyaSBjYW4ndCBoYW5kbGUgdXBwZXJjYXNlIG9yIHVuaWNvZGUgY2hhcmFjdGVycyB3aGVuXG5cdFx0Ly8gaW4gcXVpcmtzIG1vZGUuXG5cdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbCAmJiBkaXYucXVlcnlTZWxlY3RvckFsbChcIi5URVNUXCIpLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdFNpenpsZSA9IGZ1bmN0aW9uKCBxdWVyeSwgY29udGV4dCwgZXh0cmEsIHNlZWQgKSB7XG5cdFx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdFx0Ly8gT25seSB1c2UgcXVlcnlTZWxlY3RvckFsbCBvbiBub24tWE1MIGRvY3VtZW50c1xuXHRcdFx0Ly8gKElEIHNlbGVjdG9ycyBkb24ndCB3b3JrIGluIG5vbi1IVE1MIGRvY3VtZW50cylcblx0XHRcdGlmICggIXNlZWQgJiYgIVNpenpsZS5pc1hNTChjb250ZXh0KSApIHtcblx0XHRcdFx0Ly8gU2VlIGlmIHdlIGZpbmQgYSBzZWxlY3RvciB0byBzcGVlZCB1cFxuXHRcdFx0XHR2YXIgbWF0Y2ggPSAvXihcXHcrJCl8XlxcLihbXFx3XFwtXSskKXxeIyhbXFx3XFwtXSskKS8uZXhlYyggcXVlcnkgKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICggbWF0Y2ggJiYgKGNvbnRleHQubm9kZVR5cGUgPT09IDEgfHwgY29udGV4dC5ub2RlVHlwZSA9PT0gOSkgKSB7XG5cdFx0XHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIlRBR1wiKVxuXHRcdFx0XHRcdGlmICggbWF0Y2hbMV0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWFrZUFycmF5KCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBxdWVyeSApLCBleHRyYSApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIuQ0xBU1NcIilcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSAmJiBFeHByLmZpbmQuQ0xBU1MgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtYXRjaFsyXSApLCBleHRyYSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJib2R5XCIpXG5cdFx0XHRcdFx0Ly8gVGhlIGJvZHkgZWxlbWVudCBvbmx5IGV4aXN0cyBvbmNlLCBvcHRpbWl6ZSBmaW5kaW5nIGl0XG5cdFx0XHRcdFx0aWYgKCBxdWVyeSA9PT0gXCJib2R5XCIgJiYgY29udGV4dC5ib2R5ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggWyBjb250ZXh0LmJvZHkgXSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaCAmJiBtYXRjaFszXSApIHtcblx0XHRcdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbM10gKTtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSBhbmQgT3BlcmEgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBtYWtlQXJyYXkoIFsgZWxlbSBdLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggW10sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWFrZUFycmF5KCBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLCBleHRyYSApO1xuXHRcdFx0XHRcdH0gY2F0Y2gocXNhRXJyb3IpIHt9XG5cblx0XHRcdFx0Ly8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXG5cdFx0XHRcdC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3Rcblx0XHRcdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG5cdFx0XHRcdC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVUeXBlID09PSAxICYmIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0XHR2YXIgb2xkQ29udGV4dCA9IGNvbnRleHQsXG5cdFx0XHRcdFx0XHRvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICksXG5cdFx0XHRcdFx0XHRuaWQgPSBvbGQgfHwgaWQsXG5cdFx0XHRcdFx0XHRoYXNQYXJlbnQgPSBjb250ZXh0LnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRyZWxhdGl2ZUhpZXJhcmNoeVNlbGVjdG9yID0gL15cXHMqWyt+XS8udGVzdCggcXVlcnkgKTtcblxuXHRcdFx0XHRcdGlmICggIW9sZCApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIG5pZCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggLycvZywgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHJlbGF0aXZlSGllcmFyY2h5U2VsZWN0b3IgJiYgaGFzUGFyZW50ICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVsYXRpdmVIaWVyYXJjaHlTZWxlY3RvciB8fCBoYXNQYXJlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBtYWtlQXJyYXkoIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggXCJbaWQ9J1wiICsgbmlkICsgXCInXSBcIiArIHF1ZXJ5ICksIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGNhdGNoKHBzZXVkb0Vycm9yKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggIW9sZCApIHtcblx0XHRcdFx0XHRcdFx0b2xkQ29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFxuXHRcdFx0cmV0dXJuIG9sZFNpenpsZShxdWVyeSwgY29udGV4dCwgZXh0cmEsIHNlZWQpO1xuXHRcdH07XG5cblx0XHRmb3IgKCB2YXIgcHJvcCBpbiBvbGRTaXp6bGUgKSB7XG5cdFx0XHRTaXp6bGVbIHByb3AgXSA9IG9sZFNpenpsZVsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fSkoKTtcbn1cblxuKGZ1bmN0aW9uKCl7XG5cdHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdG1hdGNoZXMgPSBodG1sLm1hdGNoZXNTZWxlY3RvciB8fCBodG1sLm1vek1hdGNoZXNTZWxlY3RvciB8fCBodG1sLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBodG1sLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG5cdGlmICggbWF0Y2hlcyApIHtcblx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5IGZhaWxzIHRoaXMpXG5cdFx0dmFyIGRpc2Nvbm5lY3RlZE1hdGNoID0gIW1hdGNoZXMuY2FsbCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLCBcImRpdlwiICksXG5cdFx0XHRwc2V1ZG9Xb3JrcyA9IGZhbHNlO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBcIlt0ZXN0IT0nJ106c2l6emxlXCIgKTtcblx0XG5cdFx0fSBjYXRjaCggcHNldWRvRXJyb3IgKSB7XG5cdFx0XHRwc2V1ZG9Xb3JrcyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0U2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBub2RlLCBleHByICkge1xuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdFx0XHRleHByID0gZXhwci5yZXBsYWNlKC9cXD1cXHMqKFteJ1wiXFxdXSopXFxzKlxcXS9nLCBcIj0nJDEnXVwiKTtcblxuXHRcdFx0aWYgKCAhU2l6emxlLmlzWE1MKCBub2RlICkgKSB7XG5cdFx0XHRcdHRyeSB7IFxuXHRcdFx0XHRcdGlmICggcHNldWRvV29ya3MgfHwgIUV4cHIubWF0Y2guUFNFVURPLnRlc3QoIGV4cHIgKSAmJiAhLyE9Ly50ZXN0KCBleHByICkgKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBub2RlLCBleHByICk7XG5cblx0XHRcdFx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdFx0XHRcdGlmICggcmV0IHx8ICFkaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOSwgc28gY2hlY2sgZm9yIHRoYXRcblx0XHRcdFx0XHRcdFx0XHRub2RlLmRvY3VtZW50ICYmIG5vZGUuZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gU2l6emxlKGV4cHIsIG51bGwsIG51bGwsIFtub2RlXSkubGVuZ3RoID4gMDtcblx0XHR9O1xuXHR9XG59KSgpO1xuXG4oZnVuY3Rpb24oKXtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0ZGl2LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0ndGVzdCBlJz48L2Rpdj48ZGl2IGNsYXNzPSd0ZXN0Jz48L2Rpdj5cIjtcblxuXHQvLyBPcGVyYSBjYW4ndCBmaW5kIGEgc2Vjb25kIGNsYXNzbmFtZSAoaW4gOS42KVxuXHQvLyBBbHNvLCBtYWtlIHN1cmUgdGhhdCBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIGFjdHVhbGx5IGV4aXN0c1xuXHRpZiAoICFkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSB8fCBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImVcIikubGVuZ3RoID09PSAwICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFNhZmFyaSBjYWNoZXMgY2xhc3MgYXR0cmlidXRlcywgZG9lc24ndCBjYXRjaCBjaGFuZ2VzIChpbiAzLjIpXG5cdGRpdi5sYXN0Q2hpbGQuY2xhc3NOYW1lID0gXCJlXCI7XG5cblx0aWYgKCBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImVcIikubGVuZ3RoID09PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXHRcblx0RXhwci5vcmRlci5zcGxpY2UoMSwgMCwgXCJDTEFTU1wiKTtcblx0RXhwci5maW5kLkNMQVNTID0gZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0LCBpc1hNTCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtYXRjaFsxXSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdGRpdiA9IG51bGw7XG59KSgpO1xuXG5mdW5jdGlvbiBkaXJOb2RlQ2hlY2soIGRpciwgY3VyLCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwgKSB7XG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHR2YXIgZWxlbSA9IGNoZWNrU2V0W2ldO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dmFyIG1hdGNoID0gZmFsc2U7XG5cblx0XHRcdGVsZW0gPSBlbGVtW2Rpcl07XG5cblx0XHRcdHdoaWxlICggZWxlbSApIHtcblx0XHRcdFx0aWYgKCBlbGVtWyBleHBhbmRvIF0gPT09IGRvbmVOYW1lICkge1xuXHRcdFx0XHRcdG1hdGNoID0gY2hlY2tTZXRbZWxlbS5zaXpzZXRdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFpc1hNTCApe1xuXHRcdFx0XHRcdGVsZW1bIGV4cGFuZG8gXSA9IGRvbmVOYW1lO1xuXHRcdFx0XHRcdGVsZW0uc2l6c2V0ID0gaTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBjdXIgKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBlbGVtO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbSA9IGVsZW1bZGlyXTtcblx0XHRcdH1cblxuXHRcdFx0Y2hlY2tTZXRbaV0gPSBtYXRjaDtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGlyQ2hlY2soIGRpciwgY3VyLCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwgKSB7XG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHR2YXIgZWxlbSA9IGNoZWNrU2V0W2ldO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dmFyIG1hdGNoID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdGVsZW0gPSBlbGVtW2Rpcl07XG5cblx0XHRcdHdoaWxlICggZWxlbSApIHtcblx0XHRcdFx0aWYgKCBlbGVtWyBleHBhbmRvIF0gPT09IGRvbmVOYW1lICkge1xuXHRcdFx0XHRcdG1hdGNoID0gY2hlY2tTZXRbZWxlbS5zaXpzZXRdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgZXhwYW5kbyBdID0gZG9uZU5hbWU7XG5cdFx0XHRcdFx0XHRlbGVtLnNpenNldCA9IGk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgY3VyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtID09PSBjdXIgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBTaXp6bGUuZmlsdGVyKCBjdXIsIFtlbGVtXSApLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IGVsZW07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtID0gZWxlbVtkaXJdO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGVja1NldFtpXSA9IG1hdGNoO1xuXHRcdH1cblx0fVxufVxuXG5pZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyApIHtcblx0U2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0cmV0dXJuIGEgIT09IGIgJiYgKGEuY29udGFpbnMgPyBhLmNvbnRhaW5zKGIpIDogdHJ1ZSk7XG5cdH07XG5cbn0gZWxzZSBpZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApIHtcblx0U2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0cmV0dXJuICEhKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiAxNik7XG5cdH07XG5cbn0gZWxzZSB7XG5cdFNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpIFxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gKGVsZW0gPyBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSA6IDApLmRvY3VtZW50RWxlbWVudDtcblxuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxudmFyIHBvc1Byb2Nlc3MgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHNlZWQgKSB7XG5cdHZhciBtYXRjaCxcblx0XHR0bXBTZXQgPSBbXSxcblx0XHRsYXRlciA9IFwiXCIsXG5cdFx0cm9vdCA9IGNvbnRleHQubm9kZVR5cGUgPyBbY29udGV4dF0gOiBjb250ZXh0O1xuXG5cdC8vIFBvc2l0aW9uIHNlbGVjdG9ycyBtdXN0IGJlIGRvbmUgYWZ0ZXIgdGhlIGZpbHRlclxuXHQvLyBBbmQgc28gbXVzdCA6bm90KHBvc2l0aW9uYWwpIHNvIHdlIG1vdmUgYWxsIFBTRVVET3MgdG8gdGhlIGVuZFxuXHR3aGlsZSAoIChtYXRjaCA9IEV4cHIubWF0Y2guUFNFVURPLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXHRcdGxhdGVyICs9IG1hdGNoWzBdO1xuXHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSggRXhwci5tYXRjaC5QU0VVRE8sIFwiXCIgKTtcblx0fVxuXG5cdHNlbGVjdG9yID0gRXhwci5yZWxhdGl2ZVtzZWxlY3Rvcl0gPyBzZWxlY3RvciArIFwiKlwiIDogc2VsZWN0b3I7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gcm9vdC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3Rvciwgcm9vdFtpXSwgdG1wU2V0LCBzZWVkICk7XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlLmZpbHRlciggbGF0ZXIsIHRtcFNldCApO1xufTtcblxuLy8gRVhQT1NFXG4vLyBPdmVycmlkZSBzaXp6bGUgYXR0cmlidXRlIHJldHJpZXZhbFxuU2l6emxlLmF0dHIgPSBqUXVlcnkuYXR0cjtcblNpenpsZS5zZWxlY3RvcnMuYXR0ck1hcCA9IHt9O1xualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5maWx0ZXJzO1xualF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG59KSgpO1xuXG5cbnZhciBydW50aWwgPSAvVW50aWwkLyxcblx0cnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXZVbnRpbHxwcmV2QWxsKS8sXG5cdC8vIE5vdGU6IFRoaXMgUmVnRXhwIHNob3VsZCBiZSBpbXByb3ZlZCwgb3IgbGlrZWx5IHB1bGxlZCBmcm9tIFNpenpsZVxuXHRybXVsdGlzZWxlY3RvciA9IC8sLyxcblx0aXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC8sXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRQT1MgPSBqUXVlcnkuZXhwci5tYXRjaC5QT1MsXG5cdC8vIG1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0aSwgbDtcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgcmV0ID0gdGhpcy5wdXNoU3RhY2soIFwiXCIsIFwiZmluZFwiLCBzZWxlY3RvciApLFxuXHRcdFx0bGVuZ3RoLCBuLCByO1xuXG5cdFx0Zm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGxlbmd0aCA9IHJldC5sZW5ndGg7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHRoaXNbaV0sIHJldCApO1xuXG5cdFx0XHRpZiAoIGkgPiAwICkge1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcmVzdWx0cyBhcmUgdW5pcXVlXG5cdFx0XHRcdGZvciAoIG4gPSBsZW5ndGg7IG4gPCByZXQubGVuZ3RoOyBuKysgKSB7XG5cdFx0XHRcdFx0Zm9yICggciA9IDA7IHIgPCBsZW5ndGg7IHIrKyApIHtcblx0XHRcdFx0XHRcdGlmICggcmV0W3JdID09PSByZXRbbl0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldC5zcGxpY2Uobi0tLCAxKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCApO1xuXHRcdHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IsIGZhbHNlKSwgXCJub3RcIiwgc2VsZWN0b3IpO1xuXHR9LFxuXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yLCB0cnVlKSwgXCJmaWx0ZXJcIiwgc2VsZWN0b3IgKTtcblx0fSxcblxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXNlbGVjdG9yICYmICggXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbCBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdFx0UE9TLnRlc3QoIHNlbGVjdG9yICkgPyBcblx0XHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yLCB0aGlzLmNvbnRleHQgKS5pbmRleCggdGhpc1swXSApID49IDAgOlxuXHRcdFx0XHRcdGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCB0aGlzICkubGVuZ3RoID4gMCA6XG5cdFx0XHRcdHRoaXMuZmlsdGVyKCBzZWxlY3RvciApLmxlbmd0aCA+IDAgKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciByZXQgPSBbXSwgaSwgbCwgY3VyID0gdGhpc1swXTtcblx0XHRcblx0XHQvLyBBcnJheSAoZGVwcmVjYXRlZCBhcyBvZiBqUXVlcnkgMS43KVxuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0dmFyIGxldmVsID0gMTtcblxuXHRcdFx0d2hpbGUgKCBjdXIgJiYgY3VyLm93bmVyRG9jdW1lbnQgJiYgY3VyICE9PSBjb250ZXh0ICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0XHRcdGlmICggalF1ZXJ5KCBjdXIgKS5pcyggc2VsZWN0b3JzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdHJldC5wdXNoKHsgc2VsZWN0b3I6IHNlbGVjdG9yc1sgaSBdLCBlbGVtOiBjdXIsIGxldmVsOiBsZXZlbCB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdFx0bGV2ZWwrKztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHQvLyBTdHJpbmdcblx0XHR2YXIgcG9zID0gUE9TLnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0Y3VyID0gdGhpc1tpXTtcblxuXHRcdFx0d2hpbGUgKCBjdXIgKSB7XG5cdFx0XHRcdGlmICggcG9zID8gcG9zLmluZGV4KGN1cikgPiAtMSA6IGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0aWYgKCAhY3VyIHx8ICFjdXIub3duZXJEb2N1bWVudCB8fCBjdXIgPT09IGNvbnRleHQgfHwgY3VyLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldCA9IHJldC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQ7XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCwgXCJjbG9zZXN0XCIsIHNlbGVjdG9ycyApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW5cblx0Ly8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzXG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlICkgPyB0aGlzLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBpbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmluQXJyYXkoIHRoaXNbMF0sIGpRdWVyeSggZWxlbSApICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGpRdWVyeS5pbkFycmF5KFxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtLCB0aGlzICk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0dmFyIHNldCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yICYmIHNlbGVjdG9yLm5vZGVUeXBlID8gWyBzZWxlY3RvciBdIDogc2VsZWN0b3IgKSxcblx0XHRcdGFsbCA9IGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGlzRGlzY29ubmVjdGVkKCBzZXRbMF0gKSB8fCBpc0Rpc2Nvbm5lY3RlZCggYWxsWzBdICkgP1xuXHRcdFx0YWxsIDpcblx0XHRcdGpRdWVyeS51bmlxdWUoIGFsbCApICk7XG5cdH0sXG5cblx0YW5kU2VsZjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCB0aGlzLnByZXZPYmplY3QgKTtcblx0fVxufSk7XG5cbi8vIEEgcGFpbmZ1bGx5IHNpbXBsZSBjaGVjayB0byBzZWUgaWYgYW4gZWxlbWVudCBpcyBkaXNjb25uZWN0ZWRcbi8vIGZyb20gYSBkb2N1bWVudCAoc2hvdWxkIGJlIGltcHJvdmVkLCB3aGVyZSBmZWFzaWJsZSkuXG5mdW5jdGlvbiBpc0Rpc2Nvbm5lY3RlZCggbm9kZSApIHtcblx0cmV0dXJuICFub2RlIHx8ICFub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMTtcbn1cblxualF1ZXJ5LmVhY2goe1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5udGgoIGVsZW0sIDIsIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm50aCggZWxlbSwgMiwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLnBhcmVudE5vZGUuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSA/XG5cdFx0XHRlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBlbGVtLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQgOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciByZXQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggIXJ1bnRpbC50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHJldCApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMubGVuZ3RoID4gMSAmJiAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQ7XG5cblx0XHRpZiAoICh0aGlzLmxlbmd0aCA+IDEgfHwgcm11bHRpc2VsZWN0b3IudGVzdCggc2VsZWN0b3IgKSkgJiYgcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdHJldCA9IHJldC5yZXZlcnNlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQsIG5hbWUsIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLmpvaW4oXCIsXCIpICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdGZpbHRlcjogZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdFx0aWYgKCBub3QgKSB7XG5cdFx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgP1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGVsZW1zWzBdLCBleHByKSA/IFsgZWxlbXNbMF0gXSA6IFtdIDpcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoZXhwciwgZWxlbXMpO1xuXHR9LFxuXG5cdGRpcjogZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHRcdGN1ciA9IGVsZW1bIGRpciBdO1xuXG5cdFx0d2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSA5ICYmICh1bnRpbCA9PT0gdW5kZWZpbmVkIHx8IGN1ci5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5KCBjdXIgKS5pcyggdW50aWwgKSkgKSB7XG5cdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdH1cblx0XHRcdGN1ciA9IGN1cltkaXJdO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fSxcblxuXHRudGg6IGZ1bmN0aW9uKCBjdXIsIHJlc3VsdCwgZGlyLCBlbGVtICkge1xuXHRcdHJlc3VsdCA9IHJlc3VsdCB8fCAxO1xuXHRcdHZhciBudW0gPSAwO1xuXG5cdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1cltkaXJdICkge1xuXHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKytudW0gPT09IHJlc3VsdCApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1cjtcblx0fSxcblxuXHRzaWJsaW5nOiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgciA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRyLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblx0fVxufSk7XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIGtlZXAgKSB7XG5cblx0Ly8gQ2FuJ3QgcGFzcyBudWxsIG9yIHVuZGVmaW5lZCB0byBpbmRleE9mIGluIEZpcmVmb3ggNFxuXHQvLyBTZXQgdG8gMCB0byBza2lwIHN0cmluZyBjaGVja1xuXHRxdWFsaWZpZXIgPSBxdWFsaWZpZXIgfHwgMDtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0dmFyIHJldFZhbCA9ICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHRcdHJldHVybiByZXRWYWwgPT09IGtlZXA7XG5cdFx0fSk7XG5cblx0fSBlbHNlIGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSA9PT0ga2VlcDtcblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdHZhciBmaWx0ZXJlZCA9IGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCBpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZmlsdGVyZWQsICFrZWVwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBmaWx0ZXJlZCApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0cmV0dXJuICggalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHF1YWxpZmllciApID49IDAgKSA9PT0ga2VlcDtcblx0fSk7XG59XG5cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKSB7XG5cdHZhciBsaXN0ID0gbm9kZU5hbWVzLnNwbGl0KCBcInxcIiApLFxuXHRzYWZlRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRpZiAoIHNhZmVGcmFnLmNyZWF0ZUVsZW1lbnQgKSB7XG5cdFx0d2hpbGUgKCBsaXN0Lmxlbmd0aCApIHtcblx0XHRcdHNhZmVGcmFnLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdGxpc3QucG9wKClcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzYWZlRnJhZztcbn1cblxudmFyIG5vZGVOYW1lcyA9IFwiYWJicnxhcnRpY2xlfGFzaWRlfGF1ZGlvfGNhbnZhc3xkYXRhbGlzdHxkZXRhaWxzfGZpZ2NhcHRpb258ZmlndXJlfGZvb3RlcnxcIiArXG5cdFx0XCJoZWFkZXJ8aGdyb3VwfG1hcmt8bWV0ZXJ8bmF2fG91dHB1dHxwcm9ncmVzc3xzZWN0aW9ufHN1bW1hcnl8dGltZXx2aWRlb1wiLFxuXHRyaW5saW5lalF1ZXJ5ID0gLyBqUXVlcnlcXGQrPVwiKD86XFxkK3xudWxsKVwiL2csXG5cdHJsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy8sXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9pZyxcblx0cnRhZ05hbWUgPSAvPChbXFx3Ol0rKS8sXG5cdHJ0Ym9keSA9IC88dGJvZHkvaSxcblx0cmh0bWwgPSAvPHwmIz9cXHcrOy8sXG5cdHJub0lubmVyaHRtbCA9IC88KD86c2NyaXB0fHN0eWxlKS9pLFxuXHRybm9jYWNoZSA9IC88KD86c2NyaXB0fG9iamVjdHxlbWJlZHxvcHRpb258c3R5bGUpL2ksXG5cdHJub3NoaW1jYWNoZSA9IG5ldyBSZWdFeHAoXCI8KD86XCIgKyBub2RlTmFtZXMgKyBcIilcIiwgXCJpXCIpLFxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZSA9IC9cXC8oamF2YXxlY21hKXNjcmlwdC9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfFxcLVxcLSkvLFxuXHR3cmFwTWFwID0ge1xuXHRcdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXHRcdGxlZ2VuZDogWyAxLCBcIjxmaWVsZHNldD5cIiwgXCI8L2ZpZWxkc2V0PlwiIF0sXG5cdFx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdFx0Y29sOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0XHRhcmVhOiBbIDEsIFwiPG1hcD5cIiwgXCI8L21hcD5cIiBdLFxuXHRcdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxuXHR9LFxuXHRzYWZlRnJhZ21lbnQgPSBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICk7XG5cbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gSUUgY2FuJ3Qgc2VyaWFsaXplIDxsaW5rPiBhbmQgPHNjcmlwdD4gdGFncyBub3JtYWxseVxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuaHRtbFNlcmlhbGl6ZSApIHtcblx0d3JhcE1hcC5fZGVmYXVsdCA9IFsgMSwgXCJkaXY8ZGl2PlwiLCBcIjwvZGl2PlwiIF07XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKHRleHQpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cblx0XHRcdFx0c2VsZi50ZXh0KCB0ZXh0LmNhbGwodGhpcywgaSwgc2VsZi50ZXh0KCkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB0ZXh0ICE9PSBcIm9iamVjdFwiICYmIHRleHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmVtcHR5KCkuYXBwZW5kKCAodGhpc1swXSAmJiB0aGlzWzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpLmNyZWF0ZVRleHROb2RlKCB0ZXh0ICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LnRleHQoIHRoaXMgKTtcblx0fSxcblxuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0alF1ZXJ5KHRoaXMpLndyYXBBbGwoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWzBdICkge1xuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHZhciB3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQgKS5lcSgwKS5jbG9uZSh0cnVlKTtcblxuXHRcdFx0aWYgKCB0aGlzWzBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgJiYgZWxlbS5maXJzdENoaWxkLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0pLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGpRdWVyeSh0aGlzKS53cmFwSW5uZXIoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwgKTtcblx0XHR9KTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiYm9keVwiICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHRcdH1cblx0XHR9KS5lbmQoKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgdHJ1ZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIHRydWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHR0aGlzLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmYWxzZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgc2V0ID0galF1ZXJ5LmNsZWFuKCBhcmd1bWVudHMgKTtcblx0XHRcdHNldC5wdXNoLmFwcGx5KCBzZXQsIHRoaXMudG9BcnJheSgpICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNldCwgXCJiZWZvcmVcIiwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmYWxzZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgc2V0ID0gdGhpcy5wdXNoU3RhY2soIHRoaXMsIFwiYWZ0ZXJcIiwgYXJndW1lbnRzICk7XG5cdFx0XHRzZXQucHVzaC5hcHBseSggc2V0LCBqUXVlcnkuY2xlYW4oYXJndW1lbnRzKSApO1xuXHRcdFx0cmV0dXJuIHNldDtcblx0XHR9XG5cdH0sXG5cblx0Ly8ga2VlcERhdGEgaXMgZm9yIGludGVybmFsIHVzZSBvbmx5LS1kbyBub3QgZG9jdW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHRcdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoICFzZWxlY3RvciB8fCBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgWyBlbGVtIF0gKS5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgKTtcblx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQ2hpbGQoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzWzBdICYmIHRoaXNbMF0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdFx0XHR0aGlzWzBdLmlubmVySFRNTC5yZXBsYWNlKHJpbmxpbmVqUXVlcnksIFwiXCIpIDpcblx0XHRcdFx0bnVsbDtcblxuXHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHQoalF1ZXJ5LnN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgfHwgIXJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCB2YWx1ZSApKSAmJlxuXHRcdFx0IXdyYXBNYXBbIChydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocnhodG1sVGFnLCBcIjwkMT48LyQyPlwiKTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0aWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggdGhpc1tpXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgKTtcblx0XHRcdFx0XHRcdHRoaXNbaV0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbihpKXtcblx0XHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblxuXHRcdFx0XHRzZWxmLmh0bWwoIHZhbHVlLmNhbGwodGhpcywgaSwgc2VsZi5odG1sKCkpICk7XG5cdFx0XHR9KTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0aWYgKCB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBlbGVtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBET00gYmVmb3JlIHRoZXkgYXJlIGluc2VydGVkXG5cdFx0XHQvLyB0aGlzIGNhbiBoZWxwIGZpeCByZXBsYWNpbmcgYSBwYXJlbnQgd2l0aCBjaGlsZCBlbGVtZW50c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkodGhpcyksIG9sZCA9IHNlbGYuaHRtbCgpO1xuXHRcdFx0XHRcdHNlbGYucmVwbGFjZVdpdGgoIHZhbHVlLmNhbGwoIHRoaXMsIGksIG9sZCApICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIHZhbHVlICkuZGV0YWNoKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBuZXh0ID0gdGhpcy5uZXh0U2libGluZyxcblx0XHRcdFx0XHRwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlKCk7XG5cblx0XHRcdFx0aWYgKCBuZXh0ICkge1xuXHRcdFx0XHRcdGpRdWVyeShuZXh0KS5iZWZvcmUoIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0alF1ZXJ5KHBhcmVudCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMubGVuZ3RoID9cblx0XHRcdFx0dGhpcy5wdXNoU3RhY2soIGpRdWVyeShqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSgpIDogdmFsdWUpLCBcInJlcGxhY2VXaXRoXCIsIHZhbHVlICkgOlxuXHRcdFx0XHR0aGlzO1xuXHRcdH1cblx0fSxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0ZG9tTWFuaXA6IGZ1bmN0aW9uKCBhcmdzLCB0YWJsZSwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIHJlc3VsdHMsIGZpcnN0LCBmcmFnbWVudCwgcGFyZW50LFxuXHRcdFx0dmFsdWUgPSBhcmdzWzBdLFxuXHRcdFx0c2NyaXB0cyA9IFtdO1xuXG5cdFx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2hlY2tDbG9uZSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KHRoaXMpLmRvbU1hbmlwKCBhcmdzLCB0YWJsZSwgY2FsbGJhY2ssIHRydWUgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdHZhciBzZWxmID0galF1ZXJ5KHRoaXMpO1xuXHRcdFx0XHRhcmdzWzBdID0gdmFsdWUuY2FsbCh0aGlzLCBpLCB0YWJsZSA/IHNlbGYuaHRtbCgpIDogdW5kZWZpbmVkKTtcblx0XHRcdFx0c2VsZi5kb21NYW5pcCggYXJncywgdGFibGUsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbMF0gKSB7XG5cdFx0XHRwYXJlbnQgPSB2YWx1ZSAmJiB2YWx1ZS5wYXJlbnROb2RlO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBpbiBhIGZyYWdtZW50LCBqdXN0IHVzZSB0aGF0IGluc3RlYWQgb2YgYnVpbGRpbmcgYSBuZXcgb25lXG5cdFx0XHRpZiAoIGpRdWVyeS5zdXBwb3J0LnBhcmVudE5vZGUgJiYgcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMTEgJiYgcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0cmVzdWx0cyA9IHsgZnJhZ21lbnQ6IHBhcmVudCB9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRzID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXMsIHNjcmlwdHMgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnJhZ21lbnQgPSByZXN1bHRzLmZyYWdtZW50O1xuXG5cdFx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRmaXJzdCA9IGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0dGFibGUgPSB0YWJsZSAmJiBqUXVlcnkubm9kZU5hbWUoIGZpcnN0LCBcInRyXCIgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aCwgbGFzdEluZGV4ID0gbCAtIDE7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChcblx0XHRcdFx0XHRcdHRhYmxlID9cblx0XHRcdFx0XHRcdFx0cm9vdCh0aGlzW2ldLCBmaXJzdCkgOlxuXHRcdFx0XHRcdFx0XHR0aGlzW2ldLFxuXHRcdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UgZG8gbm90IGxlYWsgbWVtb3J5IGJ5IGluYWR2ZXJ0ZW50bHkgZGlzY2FyZGluZ1xuXHRcdFx0XHRcdFx0Ly8gdGhlIG9yaWdpbmFsIGZyYWdtZW50ICh3aGljaCBtaWdodCBoYXZlIGF0dGFjaGVkIGRhdGEpIGluc3RlYWQgb2Zcblx0XHRcdFx0XHRcdC8vIHVzaW5nIGl0OyBpbiBhZGRpdGlvbiwgdXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBvYmplY3QgZm9yIHRoZSBsYXN0XG5cdFx0XHRcdFx0XHQvLyBpdGVtIGluc3RlYWQgb2YgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHlcblx0XHRcdFx0XHRcdC8vIGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoQnVnICM4MDcwKS5cblx0XHRcdFx0XHRcdC8vIEZyYWdtZW50cyBmcm9tIHRoZSBmcmFnbWVudCBjYWNoZSBtdXN0IGFsd2F5cyBiZSBjbG9uZWQgYW5kIG5ldmVyIHVzZWRcblx0XHRcdFx0XHRcdC8vIGluIHBsYWNlLlxuXHRcdFx0XHRcdFx0cmVzdWx0cy5jYWNoZWFibGUgfHwgKCBsID4gMSAmJiBpIDwgbGFzdEluZGV4ICkgP1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xvbmUoIGZyYWdtZW50LCB0cnVlLCB0cnVlICkgOlxuXHRcdFx0XHRcdFx0XHRmcmFnbWVudFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIHNjcmlwdHMsIGV2YWxTY3JpcHQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbmZ1bmN0aW9uIHJvb3QoIGVsZW0sIGN1ciApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcInRhYmxlXCIpID9cblx0XHQoZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0ZWxlbS5hcHBlbmRDaGlsZChlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKSkgOlxuXHRcdGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHR5cGUsIGksIGwsXG5cdFx0b2xkRGF0YSA9IGpRdWVyeS5fZGF0YSggc3JjICksXG5cdFx0Y3VyRGF0YSA9IGpRdWVyeS5fZGF0YSggZGVzdCwgb2xkRGF0YSApLFxuXHRcdGV2ZW50cyA9IG9sZERhdGEuZXZlbnRzO1xuXG5cdGlmICggZXZlbnRzICkge1xuXHRcdGRlbGV0ZSBjdXJEYXRhLmhhbmRsZTtcblx0XHRjdXJEYXRhLmV2ZW50cyA9IHt9O1xuXG5cdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSArICggZXZlbnRzWyB0eXBlIF1bIGkgXS5uYW1lc3BhY2UgPyBcIi5cIiA6IFwiXCIgKSArIGV2ZW50c1sgdHlwZSBdWyBpIF0ubmFtZXNwYWNlLCBldmVudHNbIHR5cGUgXVsgaSBdLCBldmVudHNbIHR5cGUgXVsgaSBdLmRhdGEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBtYWtlIHRoZSBjbG9uZWQgcHVibGljIGRhdGEgb2JqZWN0IGEgY29weSBmcm9tIHRoZSBvcmlnaW5hbFxuXHRpZiAoIGN1ckRhdGEuZGF0YSApIHtcblx0XHRjdXJEYXRhLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyRGF0YS5kYXRhICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY2xvbmVGaXhBdHRyaWJ1dGVzKCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZTtcblxuXHQvLyBXZSBkbyBub3QgbmVlZCB0byBkbyBhbnl0aGluZyBmb3Igbm9uLUVsZW1lbnRzXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBjbGVhckF0dHJpYnV0ZXMgcmVtb3ZlcyB0aGUgYXR0cmlidXRlcywgd2hpY2ggd2UgZG9uJ3Qgd2FudCxcblx0Ly8gYnV0IGFsc28gcmVtb3ZlcyB0aGUgYXR0YWNoRXZlbnQgZXZlbnRzLCB3aGljaCB3ZSAqZG8qIHdhbnRcblx0aWYgKCBkZXN0LmNsZWFyQXR0cmlidXRlcyApIHtcblx0XHRkZXN0LmNsZWFyQXR0cmlidXRlcygpO1xuXHR9XG5cblx0Ly8gbWVyZ2VBdHRyaWJ1dGVzLCBpbiBjb250cmFzdCwgb25seSBtZXJnZXMgYmFjayBvbiB0aGVcblx0Ly8gb3JpZ2luYWwgYXR0cmlidXRlcywgbm90IHRoZSBldmVudHNcblx0aWYgKCBkZXN0Lm1lcmdlQXR0cmlidXRlcyApIHtcblx0XHRkZXN0Lm1lcmdlQXR0cmlidXRlcyggc3JjICk7XG5cdH1cblxuXHRub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBJRTYtOCBmYWlsIHRvIGNsb25lIGNoaWxkcmVuIGluc2lkZSBvYmplY3QgZWxlbWVudHMgdGhhdCB1c2Vcblx0Ly8gdGhlIHByb3ByaWV0YXJ5IGNsYXNzaWQgYXR0cmlidXRlIHZhbHVlIChyYXRoZXIgdGhhbiB0aGUgdHlwZVxuXHQvLyBhdHRyaWJ1dGUpIHRvIGlkZW50aWZ5IHRoZSB0eXBlIG9mIGNvbnRlbnQgdG8gZGlzcGxheVxuXHRpZiAoIG5vZGVOYW1lID09PSBcIm9iamVjdFwiICkge1xuXHRcdGRlc3Qub3V0ZXJIVE1MID0gc3JjLm91dGVySFRNTDtcblxuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIChzcmMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHNyYy50eXBlID09PSBcInJhZGlvXCIpICkge1xuXHRcdC8vIElFNi04IGZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3hcblx0XHQvLyBvciByYWRpbyBidXR0b24uIFdvcnNlLCBJRTYtNyBmYWlsIHRvIGdpdmUgdGhlIGNsb25lZCBlbGVtZW50XG5cdFx0Ly8gYSBjaGVja2VkIGFwcGVhcmFuY2UgaWYgdGhlIGRlZmF1bHRDaGVja2VkIHZhbHVlIGlzbid0IGFsc28gc2V0XG5cdFx0aWYgKCBzcmMuY2hlY2tlZCApIHtcblx0XHRcdGRlc3QuZGVmYXVsdENoZWNrZWQgPSBkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblx0XHR9XG5cblx0XHQvLyBJRTYtNyBnZXQgY29uZnVzZWQgYW5kIGVuZCB1cCBzZXR0aW5nIHRoZSB2YWx1ZSBvZiBhIGNsb25lZFxuXHRcdC8vIGNoZWNrYm94L3JhZGlvIGJ1dHRvbiB0byBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiBcIm9uXCJcblx0XHRpZiAoIGRlc3QudmFsdWUgIT09IHNyYy52YWx1ZSApIHtcblx0XHRcdGRlc3QudmFsdWUgPSBzcmMudmFsdWU7XG5cdFx0fVxuXG5cdC8vIElFNi04IGZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkXG5cdC8vIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICkge1xuXHRcdGRlc3Quc2VsZWN0ZWQgPSBzcmMuZGVmYXVsdFNlbGVjdGVkO1xuXG5cdC8vIElFNi04IGZhaWxzIHRvIHNldCB0aGUgZGVmYXVsdFZhbHVlIHRvIHRoZSBjb3JyZWN0IHZhbHVlIHdoZW5cblx0Ly8gY2xvbmluZyBvdGhlciB0eXBlcyBvZiBpbnB1dCBmaWVsZHNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxuXG5cdC8vIEV2ZW50IGRhdGEgZ2V0cyByZWZlcmVuY2VkIGluc3RlYWQgb2YgY29waWVkIGlmIHRoZSBleHBhbmRvXG5cdC8vIGdldHMgY29waWVkIHRvb1xuXHRkZXN0LnJlbW92ZUF0dHJpYnV0ZSggalF1ZXJ5LmV4cGFuZG8gKTtcbn1cblxualF1ZXJ5LmJ1aWxkRnJhZ21lbnQgPSBmdW5jdGlvbiggYXJncywgbm9kZXMsIHNjcmlwdHMgKSB7XG5cdHZhciBmcmFnbWVudCwgY2FjaGVhYmxlLCBjYWNoZXJlc3VsdHMsIGRvYyxcblx0Zmlyc3QgPSBhcmdzWyAwIF07XG5cblx0Ly8gbm9kZXMgbWF5IGNvbnRhaW4gZWl0aGVyIGFuIGV4cGxpY2l0IGRvY3VtZW50IG9iamVjdCxcblx0Ly8gYSBqUXVlcnkgY29sbGVjdGlvbiBvciBjb250ZXh0IG9iamVjdC5cblx0Ly8gSWYgbm9kZXNbMF0gY29udGFpbnMgYSB2YWxpZCBvYmplY3QgdG8gYXNzaWduIHRvIGRvY1xuXHRpZiAoIG5vZGVzICYmIG5vZGVzWzBdICkge1xuXHRcdGRvYyA9IG5vZGVzWzBdLm93bmVyRG9jdW1lbnQgfHwgbm9kZXNbMF07XG5cdH1cblxuXHQvLyBFbnN1cmUgdGhhdCBhbiBhdHRyIG9iamVjdCBkb2Vzbid0IGluY29ycmVjdGx5IHN0YW5kIGluIGFzIGEgZG9jdW1lbnQgb2JqZWN0XG5cdC8vIENocm9tZSBhbmQgRmlyZWZveCBzZWVtIHRvIGFsbG93IHRoaXMgdG8gb2NjdXIgYW5kIHdpbGwgdGhyb3cgZXhjZXB0aW9uXG5cdC8vIEZpeGVzICM4OTUwXG5cdGlmICggIWRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50ICkge1xuXHRcdGRvYyA9IGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gT25seSBjYWNoZSBcInNtYWxsXCIgKDEvMiBLQikgSFRNTCBzdHJpbmdzIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFpbiBkb2N1bWVudFxuXHQvLyBDbG9uaW5nIG9wdGlvbnMgbG9zZXMgdGhlIHNlbGVjdGVkIHN0YXRlLCBzbyBkb24ndCBjYWNoZSB0aGVtXG5cdC8vIElFIDYgZG9lc24ndCBsaWtlIGl0IHdoZW4geW91IHB1dCA8b2JqZWN0PiBvciA8ZW1iZWQ+IGVsZW1lbnRzIGluIGEgZnJhZ21lbnRcblx0Ly8gQWxzbywgV2ViS2l0IGRvZXMgbm90IGNsb25lICdjaGVja2VkJyBhdHRyaWJ1dGVzIG9uIGNsb25lTm9kZSwgc28gZG9uJ3QgY2FjaGVcblx0Ly8gTGFzdGx5LCBJRTYsNyw4IHdpbGwgbm90IGNvcnJlY3RseSByZXVzZSBjYWNoZWQgZnJhZ21lbnRzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gdW5rbm93biBlbGVtcyAjMTA1MDFcblx0aWYgKCBhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgZmlyc3QubGVuZ3RoIDwgNTEyICYmIGRvYyA9PT0gZG9jdW1lbnQgJiZcblx0XHRmaXJzdC5jaGFyQXQoMCkgPT09IFwiPFwiICYmICFybm9jYWNoZS50ZXN0KCBmaXJzdCApICYmXG5cdFx0KGpRdWVyeS5zdXBwb3J0LmNoZWNrQ2xvbmUgfHwgIXJjaGVja2VkLnRlc3QoIGZpcnN0ICkpICYmXG5cdFx0KGpRdWVyeS5zdXBwb3J0Lmh0bWw1Q2xvbmUgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCBmaXJzdCApKSApIHtcblxuXHRcdGNhY2hlYWJsZSA9IHRydWU7XG5cblx0XHRjYWNoZXJlc3VsdHMgPSBqUXVlcnkuZnJhZ21lbnRzWyBmaXJzdCBdO1xuXHRcdGlmICggY2FjaGVyZXN1bHRzICYmIGNhY2hlcmVzdWx0cyAhPT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gY2FjaGVyZXN1bHRzO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWZyYWdtZW50ICkge1xuXHRcdGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRqUXVlcnkuY2xlYW4oIGFyZ3MsIGRvYywgZnJhZ21lbnQsIHNjcmlwdHMgKTtcblx0fVxuXG5cdGlmICggY2FjaGVhYmxlICkge1xuXHRcdGpRdWVyeS5mcmFnbWVudHNbIGZpcnN0IF0gPSBjYWNoZXJlc3VsdHMgPyBmcmFnbWVudCA6IDE7XG5cdH1cblxuXHRyZXR1cm4geyBmcmFnbWVudDogZnJhZ21lbnQsIGNhY2hlYWJsZTogY2FjaGVhYmxlIH07XG59O1xuXG5qUXVlcnkuZnJhZ21lbnRzID0ge307XG5cbmpRdWVyeS5lYWNoKHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciByZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdHBhcmVudCA9IHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXNbMF0ucGFyZW50Tm9kZTtcblxuXHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMTEgJiYgcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmIGluc2VydC5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRpbnNlcnRbIG9yaWdpbmFsIF0oIHRoaXNbMF0gKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluc2VydC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdHZhciBlbGVtcyA9ICggaSA+IDAgPyB0aGlzLmNsb25lKHRydWUpIDogdGhpcyApLmdldCgpO1xuXHRcdFx0XHRqUXVlcnkoIGluc2VydFtpXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXHRcdFx0XHRyZXQgPSByZXQuY29uY2F0KCBlbGVtcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCwgbmFtZSwgaW5zZXJ0LnNlbGVjdG9yICk7XG5cdFx0fVxuXHR9O1xufSk7XG5cbmZ1bmN0aW9uIGdldEFsbCggZWxlbSApIHtcblx0aWYgKCB0eXBlb2YgZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZWxlbS5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldHVybiBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gW107XG5cdH1cbn1cblxuLy8gVXNlZCBpbiBjbGVhbiwgZml4ZXMgdGhlIGRlZmF1bHRDaGVja2VkIHByb3BlcnR5XG5mdW5jdGlvbiBmaXhEZWZhdWx0Q2hlY2tlZCggZWxlbSApIHtcblx0aWYgKCBlbGVtLnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCBlbGVtLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRlbGVtLmRlZmF1bHRDaGVja2VkID0gZWxlbS5jaGVja2VkO1xuXHR9XG59XG4vLyBGaW5kcyBhbGwgaW5wdXRzIGFuZCBwYXNzZXMgdGhlbSB0byBmaXhEZWZhdWx0Q2hlY2tlZFxuZnVuY3Rpb24gZmluZElucHV0cyggZWxlbSApIHtcblx0dmFyIG5vZGVOYW1lID0gKCBlbGVtLm5vZGVOYW1lIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgKSB7XG5cdFx0Zml4RGVmYXVsdENoZWNrZWQoIGVsZW0gKTtcblx0Ly8gU2tpcCBzY3JpcHRzLCBnZXQgb3RoZXIgY2hpbGRyZW5cblx0fSBlbHNlIGlmICggbm9kZU5hbWUgIT09IFwic2NyaXB0XCIgJiYgdHlwZW9mIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0alF1ZXJ5LmdyZXAoIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKSwgZml4RGVmYXVsdENoZWNrZWQgKTtcblx0fVxufVxuXG4vLyBEZXJpdmVkIEZyb206IGh0dHA6Ly93d3cuaWVjc3MuY29tL3NoaW1wcm92ZS9qYXZhc2NyaXB0L3NoaW1wcm92ZS4xLTAtMS5qc1xuZnVuY3Rpb24gc2hpbUNsb25lTm9kZSggZWxlbSApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0c2FmZUZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRkaXYuaW5uZXJIVE1MID0gZWxlbS5vdXRlckhUTUw7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZDtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIHNyY0VsZW1lbnRzLFxuXHRcdFx0ZGVzdEVsZW1lbnRzLFxuXHRcdFx0aSxcblx0XHRcdC8vIElFPD04IGRvZXMgbm90IHByb3Blcmx5IGNsb25lIGRldGFjaGVkLCB1bmtub3duIGVsZW1lbnQgbm9kZXNcblx0XHRcdGNsb25lID0galF1ZXJ5LnN1cHBvcnQuaHRtbDVDbG9uZSB8fCAhcm5vc2hpbWNhY2hlLnRlc3QoIFwiPFwiICsgZWxlbS5ub2RlTmFtZSApID9cblx0XHRcdFx0ZWxlbS5jbG9uZU5vZGUoIHRydWUgKSA6XG5cdFx0XHRcdHNoaW1DbG9uZU5vZGUoIGVsZW0gKTtcblxuXHRcdGlmICggKCFqUXVlcnkuc3VwcG9ydC5ub0Nsb25lRXZlbnQgfHwgIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVDaGVja2VkKSAmJlxuXHRcdFx0XHQoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiYgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSApIHtcblx0XHRcdC8vIElFIGNvcGllcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50IHdoZW4gdXNpbmcgY2xvbmVOb2RlLlxuXHRcdFx0Ly8gQ2FsbGluZyBkZXRhY2hFdmVudCBvbiB0aGUgY2xvbmUgd2lsbCBhbHNvIHJlbW92ZSB0aGUgZXZlbnRzXG5cdFx0XHQvLyBmcm9tIHRoZSBvcmlnaW5hbC4gSW4gb3JkZXIgdG8gZ2V0IGFyb3VuZCB0aGlzLCB3ZSB1c2Ugc29tZVxuXHRcdFx0Ly8gcHJvcHJpZXRhcnkgbWV0aG9kcyB0byBjbGVhciB0aGUgZXZlbnRzLiBUaGFua3MgdG8gTW9vVG9vbHNcblx0XHRcdC8vIGd1eXMgZm9yIHRoaXMgaG90bmVzcy5cblxuXHRcdFx0Y2xvbmVGaXhBdHRyaWJ1dGVzKCBlbGVtLCBjbG9uZSApO1xuXG5cdFx0XHQvLyBVc2luZyBTaXp6bGUgaGVyZSBpcyBjcmF6eSBzbG93LCBzbyB3ZSB1c2UgZ2V0RWxlbWVudHNCeVRhZ05hbWUgaW5zdGVhZFxuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0Ly8gV2VpcmQgaXRlcmF0aW9uIGJlY2F1c2UgSUUgd2lsbCByZXBsYWNlIHRoZSBsZW5ndGggcHJvcGVydHlcblx0XHRcdC8vIHdpdGggYW4gZWxlbWVudCBpZiB5b3UgYXJlIGNsb25pbmcgdGhlIGJvZHkgYW5kIG9uZSBvZiB0aGVcblx0XHRcdC8vIGVsZW1lbnRzIG9uIHRoZSBwYWdlIGhhcyBhIG5hbWUgb3IgaWQgb2YgXCJsZW5ndGhcIlxuXHRcdFx0Zm9yICggaSA9IDA7IHNyY0VsZW1lbnRzW2ldOyArK2kgKSB7XG5cdFx0XHRcdC8vIEVuc3VyZSB0aGF0IHRoZSBkZXN0aW5hdGlvbiBub2RlIGlzIG5vdCBudWxsOyBGaXhlcyAjOTU4N1xuXHRcdFx0XHRpZiAoIGRlc3RFbGVtZW50c1tpXSApIHtcblx0XHRcdFx0XHRjbG9uZUZpeEF0dHJpYnV0ZXMoIHNyY0VsZW1lbnRzW2ldLCBkZXN0RWxlbWVudHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblxuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBzcmNFbGVtZW50c1tpXTsgKytpICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzcmNFbGVtZW50cyA9IGRlc3RFbGVtZW50cyA9IG51bGw7XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW46IGZ1bmN0aW9uKCBlbGVtcywgY29udGV4dCwgZnJhZ21lbnQsIHNjcmlwdHMgKSB7XG5cdFx0dmFyIGNoZWNrU2NyaXB0VHlwZTtcblxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gIWNvbnRleHQuY3JlYXRlRWxlbWVudCBmYWlscyBpbiBJRSB3aXRoIGFuIGVycm9yIGJ1dCByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuY3JlYXRlRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdGNvbnRleHQgPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dFswXSAmJiBjb250ZXh0WzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0dmFyIHJldCA9IFtdLCBqO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRlbGVtICs9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgc3RyaW5nIGludG8gRE9NIG5vZGVzXG5cdFx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBGaXggXCJYSFRNTFwiLXN0eWxlIHRhZ3MgaW4gYWxsIGJyb3dzZXJzXG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0ucmVwbGFjZShyeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIpO1xuXG5cdFx0XHRcdFx0Ly8gVHJpbSB3aGl0ZXNwYWNlLCBvdGhlcndpc2UgaW5kZXhPZiB3b24ndCB3b3JrIGFzIGV4cGVjdGVkXG5cdFx0XHRcdFx0dmFyIHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFtcIlwiLCBcIlwiXSApWzFdLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdCxcblx0XHRcdFx0XHRcdGRlcHRoID0gd3JhcFswXSxcblx0XHRcdFx0XHRcdGRpdiA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHRcdFx0XHRcdC8vIEFwcGVuZCB3cmFwcGVyIGVsZW1lbnQgdG8gdW5rbm93biBlbGVtZW50IHNhZmUgZG9jIGZyYWdtZW50XG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0ID09PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgZnJhZ21lbnQgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGZvciB0aGlzIGRvY3VtZW50XG5cdFx0XHRcdFx0XHRzYWZlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBVc2UgYSBmcmFnbWVudCBjcmVhdGVkIHdpdGggdGhlIG93bmVyIGRvY3VtZW50XG5cdFx0XHRcdFx0XHRjcmVhdGVTYWZlRnJhZ21lbnQoIGNvbnRleHQgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gR28gdG8gaHRtbCBhbmQgYmFjaywgdGhlbiBwZWVsIG9mZiBleHRyYSB3cmFwcGVyc1xuXHRcdFx0XHRcdGRpdi5pbm5lckhUTUwgPSB3cmFwWzFdICsgZWxlbSArIHdyYXBbMl07XG5cblx0XHRcdFx0XHQvLyBNb3ZlIHRvIHRoZSByaWdodCBkZXB0aFxuXHRcdFx0XHRcdHdoaWxlICggZGVwdGgtLSApIHtcblx0XHRcdFx0XHRcdGRpdiA9IGRpdi5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIElFJ3MgYXV0b2luc2VydGVkIDx0Ym9keT4gZnJvbSB0YWJsZSBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoICFqUXVlcnkuc3VwcG9ydC50Ym9keSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3RyaW5nIHdhcyBhIDx0YWJsZT4sICptYXkqIGhhdmUgc3B1cmlvdXMgPHRib2R5PlxuXHRcdFx0XHRcdFx0dmFyIGhhc0JvZHkgPSBydGJvZHkudGVzdChlbGVtKSxcblx0XHRcdFx0XHRcdFx0dGJvZHkgPSB0YWcgPT09IFwidGFibGVcIiAmJiAhaGFzQm9keSA/XG5cdFx0XHRcdFx0XHRcdFx0ZGl2LmZpcnN0Q2hpbGQgJiYgZGl2LmZpcnN0Q2hpbGQuY2hpbGROb2RlcyA6XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgYmFyZSA8dGhlYWQ+IG9yIDx0Zm9vdD5cblx0XHRcdFx0XHRcdFx0XHR3cmFwWzFdID09PSBcIjx0YWJsZT5cIiAmJiAhaGFzQm9keSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXYuY2hpbGROb2RlcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRbXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggaiA9IHRib2R5Lmxlbmd0aCAtIDE7IGogPj0gMCA7IC0taiApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRib2R5WyBqIF0sIFwidGJvZHlcIiApICYmICF0Ym9keVsgaiBdLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdHRib2R5WyBqIF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGJvZHlbIGogXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSUUgY29tcGxldGVseSBraWxscyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiBpbm5lckhUTUwgaXMgdXNlZFxuXHRcdFx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRkaXYuaW5zZXJ0QmVmb3JlKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBybGVhZGluZ1doaXRlc3BhY2UuZXhlYyhlbGVtKVswXSApLCBkaXYuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSBkaXYuY2hpbGROb2Rlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldHMgZGVmYXVsdENoZWNrZWQgZm9yIGFueSByYWRpb3MgYW5kIGNoZWNrYm94ZXNcblx0XHRcdC8vIGFib3V0IHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBET00gaW4gSUUgNi83ICgjODA2MClcblx0XHRcdHZhciBsZW47XG5cdFx0XHRpZiAoICFqUXVlcnkuc3VwcG9ydC5hcHBlbmRDaGVja2VkICkge1xuXHRcdFx0XHRpZiAoIGVsZW1bMF0gJiYgdHlwZW9mIChsZW4gPSBlbGVtLmxlbmd0aCkgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRcdGZpbmRJbnB1dHMoIGVsZW1bal0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmluZElucHV0cyggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSApIHtcblx0XHRcdFx0cmV0LnB1c2goIGVsZW0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS5tZXJnZSggcmV0LCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmcmFnbWVudCApIHtcblx0XHRcdGNoZWNrU2NyaXB0VHlwZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gIWVsZW0udHlwZSB8fCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgKTtcblx0XHRcdH07XG5cdFx0XHRmb3IgKCBpID0gMDsgcmV0W2ldOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2NyaXB0cyAmJiBqUXVlcnkubm9kZU5hbWUoIHJldFtpXSwgXCJzY3JpcHRcIiApICYmICghcmV0W2ldLnR5cGUgfHwgcmV0W2ldLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0L2phdmFzY3JpcHRcIikgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCByZXRbaV0ucGFyZW50Tm9kZSA/IHJldFtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCByZXRbaV0gKSA6IHJldFtpXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCByZXRbaV0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR2YXIganNUYWdzID0galF1ZXJ5LmdyZXAoIHJldFtpXS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJzY3JpcHRcIiApLCBjaGVja1NjcmlwdFR5cGUgKTtcblxuXHRcdFx0XHRcdFx0cmV0LnNwbGljZS5hcHBseSggcmV0LCBbaSArIDEsIDBdLmNvbmNhdCgganNUYWdzICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIHJldFtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgaWQsXG5cdFx0XHRjYWNoZSA9IGpRdWVyeS5jYWNoZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGRlbGV0ZUV4cGFuZG8gPSBqUXVlcnkuc3VwcG9ydC5kZWxldGVFeHBhbmRvO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZU5hbWUgJiYgalF1ZXJ5Lm5vRGF0YVtlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWQgPSBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdO1xuXG5cdFx0XHRpZiAoIGlkICkge1xuXHRcdFx0XHRkYXRhID0gY2FjaGVbIGlkIF07XG5cblx0XHRcdFx0aWYgKCBkYXRhICYmIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdGZvciAoIHZhciB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE51bGwgdGhlIERPTSByZWZlcmVuY2UgdG8gYXZvaWQgSUU2LzcvOCBsZWFrICgjNzA1NClcblx0XHRcdFx0XHRpZiAoIGRhdGEuaGFuZGxlICkge1xuXHRcdFx0XHRcdFx0ZGF0YS5oYW5kbGUuZWxlbSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkZWxldGVFeHBhbmRvICkge1xuXHRcdFx0XHRcdGRlbGV0ZSBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ucmVtb3ZlQXR0cmlidXRlICkge1xuXHRcdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBqUXVlcnkuZXhwYW5kbyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBpZCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGV2YWxTY3JpcHQoIGksIGVsZW0gKSB7XG5cdGlmICggZWxlbS5zcmMgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiBlbGVtLnNyYyxcblx0XHRcdGFzeW5jOiBmYWxzZSxcblx0XHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoICggZWxlbS50ZXh0IHx8IGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lckhUTUwgfHwgXCJcIiApLnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCIvKiQwKi9cIiApICk7XG5cdH1cblxuXHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcblx0fVxufVxuXG5cblxuXG52YXIgcmFscGhhID0gL2FscGhhXFwoW14pXSpcXCkvaSxcblx0cm9wYWNpdHkgPSAvb3BhY2l0eT0oW14pXSopLyxcblx0Ly8gZml4ZWQgZm9yIElFOSwgc2VlICM4MzQ2XG5cdHJ1cHBlciA9IC8oW0EtWl18Xm1zKS9nLFxuXHRybnVtcHggPSAvXi0/XFxkKyg/OnB4KT8kL2ksXG5cdHJudW0gPSAvXi0/XFxkLyxcblx0cnJlbE51bSA9IC9eKFtcXC0rXSk9KFtcXC0rLlxcZGVdKykvLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NXaWR0aCA9IFsgXCJMZWZ0XCIsIFwiUmlnaHRcIiBdLFxuXHRjc3NIZWlnaHQgPSBbIFwiVG9wXCIsIFwiQm90dG9tXCIgXSxcblx0Y3VyQ1NTLFxuXG5cdGdldENvbXB1dGVkU3R5bGUsXG5cdGN1cnJlbnRTdHlsZTtcblxualF1ZXJ5LmZuLmNzcyA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0Ly8gU2V0dGluZyAndW5kZWZpbmVkJyBpcyBhIG5vLW9wXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIG5hbWUsIHZhbHVlLCB0cnVlLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0fSk7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIsIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uc3R5bGUub3BhY2l0eTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBFeGNsdWRlIHRoZSBmb2xsb3dpbmcgY3NzIHByb3BlcnRpZXMgdG8gYWRkIHB4XG5cdGNzc051bWJlcjoge1xuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHQvLyBub3JtYWxpemUgZmxvYXQgY3NzIHByb3BlcnR5XG5cdFx0XCJmbG9hdFwiOiBqUXVlcnkuc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCBvcmlnTmFtZTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIGNvbnZlcnQgcmVsYXRpdmUgbnVtYmVyIHN0cmluZ3MgKCs9IG9yIC09KSB0byByZWxhdGl2ZSBudW1iZXJzLiAjNzM0NVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSBycmVsTnVtLmV4ZWMoIHZhbHVlICkpICkge1xuXHRcdFx0XHR2YWx1ZSA9ICggKyggcmV0WzFdICsgMSkgKiArcmV0WzJdICkgKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBOYU4gYW5kIG51bGwgdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB0eXBlID09PSBcIm51bWJlclwiICYmIGlzTmFOKCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdICkge1xuXHRcdFx0XHR2YWx1ZSArPSBcInB4XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIFdyYXBwZWQgdG8gcHJldmVudCBJRSBmcm9tIHRocm93aW5nIGVycm9ycyB3aGVuICdpbnZhbGlkJyB2YWx1ZXMgYXJlIHByb3ZpZGVkXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjNTUwOVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXHRcdHZhciByZXQsIGhvb2tzO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0Ly8gY3NzRmxvYXQgbmVlZHMgYSBzcGVjaWFsIHRyZWF0bWVudFxuXHRcdGlmICggbmFtZSA9PT0gXCJjc3NGbG9hdFwiICkge1xuXHRcdFx0bmFtZSA9IFwiZmxvYXRcIjtcblx0XHR9XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0fSBlbHNlIGlmICggY3VyQ1NTICkge1xuXHRcdFx0cmV0dXJuIGN1ckNTUyggZWxlbSwgbmFtZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zXG5cdHN3YXA6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHR2YXIgb2xkID0ge307XG5cblx0XHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Y2FsbGJhY2suY2FsbCggZWxlbSApO1xuXG5cdFx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gREVQUkVDQVRFRCwgVXNlIGpRdWVyeS5jc3MoKSBpbnN0ZWFkXG5qUXVlcnkuY3VyQ1NTID0galF1ZXJ5LmNzcztcblxualF1ZXJ5LmVhY2goW1wiaGVpZ2h0XCIsIFwid2lkdGhcIl0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ub2Zmc2V0V2lkdGggIT09IDAgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdldFdIKCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGpRdWVyeS5zd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhbCA9IGdldFdIKCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIHJudW1weC50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHQvLyBpZ25vcmUgbmVnYXRpdmUgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgIzE1OTlcblx0XHRcdFx0dmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgPj0gMCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgKyBcInB4XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0pO1xuXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5vcGFjaXR5ICkge1xuXHRqUXVlcnkuY3NzSG9va3Mub3BhY2l0eSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdC8vIElFIHVzZXMgZmlsdGVycyBmb3Igb3BhY2l0eVxuXHRcdFx0cmV0dXJuIHJvcGFjaXR5LnRlc3QoIChjb21wdXRlZCAmJiBlbGVtLmN1cnJlbnRTdHlsZSA/IGVsZW0uY3VycmVudFN0eWxlLmZpbHRlciA6IGVsZW0uc3R5bGUuZmlsdGVyKSB8fCBcIlwiICkgP1xuXHRcdFx0XHQoIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApIC8gMTAwICkgKyBcIlwiIDpcblx0XHRcdFx0Y29tcHV0ZWQgPyBcIjFcIiA6IFwiXCI7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRcdFx0Y3VycmVudFN0eWxlID0gZWxlbS5jdXJyZW50U3R5bGUsXG5cdFx0XHRcdG9wYWNpdHkgPSBqUXVlcnkuaXNOdW1lcmljKCB2YWx1ZSApID8gXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKiAxMDAgKyBcIilcIiA6IFwiXCIsXG5cdFx0XHRcdGZpbHRlciA9IGN1cnJlbnRTdHlsZSAmJiBjdXJyZW50U3R5bGUuZmlsdGVyIHx8IHN0eWxlLmZpbHRlciB8fCBcIlwiO1xuXG5cdFx0XHQvLyBJRSBoYXMgdHJvdWJsZSB3aXRoIG9wYWNpdHkgaWYgaXQgZG9lcyBub3QgaGF2ZSBsYXlvdXRcblx0XHRcdC8vIEZvcmNlIGl0IGJ5IHNldHRpbmcgdGhlIHpvb20gbGV2ZWxcblx0XHRcdHN0eWxlLnpvb20gPSAxO1xuXG5cdFx0XHQvLyBpZiBzZXR0aW5nIG9wYWNpdHkgdG8gMSwgYW5kIG5vIG90aGVyIGZpbHRlcnMgZXhpc3QgLSBhdHRlbXB0IHRvIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICM2NjUyXG5cdFx0XHRpZiAoIHZhbHVlID49IDEgJiYgalF1ZXJ5LnRyaW0oIGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIFwiXCIgKSApID09PSBcIlwiICkge1xuXG5cdFx0XHRcdC8vIFNldHRpbmcgc3R5bGUuZmlsdGVyIHRvIG51bGwsIFwiXCIgJiBcIiBcIiBzdGlsbCBsZWF2ZSBcImZpbHRlcjpcIiBpbiB0aGUgY3NzVGV4dFxuXHRcdFx0XHQvLyBpZiBcImZpbHRlcjpcIiBpcyBwcmVzZW50IGF0IGFsbCwgY2xlYXJUeXBlIGlzIGRpc2FibGVkLCB3ZSB3YW50IHRvIGF2b2lkIHRoaXNcblx0XHRcdFx0Ly8gc3R5bGUucmVtb3ZlQXR0cmlidXRlIGlzIElFIE9ubHksIGJ1dCBzbyBhcHBhcmVudGx5IGlzIHRoaXMgY29kZSBwYXRoLi4uXG5cdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSggXCJmaWx0ZXJcIiApO1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIHRoZXJlIGlzIG5vIGZpbHRlciBzdHlsZSBhcHBsaWVkIGluIGEgY3NzIHJ1bGUsIHdlIGFyZSBkb25lXG5cdFx0XHRcdGlmICggY3VycmVudFN0eWxlICYmICFjdXJyZW50U3R5bGUuZmlsdGVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlc1xuXHRcdFx0c3R5bGUuZmlsdGVyID0gcmFscGhhLnRlc3QoIGZpbHRlciApID9cblx0XHRcdFx0ZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgb3BhY2l0eSApIDpcblx0XHRcdFx0ZmlsdGVyICsgXCIgXCIgKyBvcGFjaXR5O1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5KGZ1bmN0aW9uKCkge1xuXHQvLyBUaGlzIGhvb2sgY2Fubm90IGJlIGFkZGVkIHVudGlsIERPTSByZWFkeSBiZWNhdXNlIHRoZSBzdXBwb3J0IHRlc3Rcblx0Ly8gZm9yIGl0IGlzIG5vdCBydW4gdW50aWwgYWZ0ZXIgRE9NIHJlYWR5XG5cdGlmICggIWpRdWVyeS5zdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0XHQvLyBXb3JrIGFyb3VuZCBieSB0ZW1wb3JhcmlseSBzZXR0aW5nIGVsZW1lbnQgZGlzcGxheSB0byBpbmxpbmUtYmxvY2tcblx0XHRcdFx0dmFyIHJldDtcblx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0XHRcdHJldCA9IGN1ckNTUyggZWxlbSwgXCJtYXJnaW4tcmlnaHRcIiwgXCJtYXJnaW5SaWdodFwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldCA9IGVsZW0uc3R5bGUubWFyZ2luUmlnaHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuaWYgKCBkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRnZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0dmFyIHJldCwgZGVmYXVsdFZpZXcsIGNvbXB1dGVkU3R5bGU7XG5cblx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKCBydXBwZXIsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAoZGVmYXVsdFZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmXG5cdFx0XHRcdChjb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApKSApIHtcblx0XHRcdHJldCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApO1xuXHRcdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZWxlbSApICkge1xuXHRcdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufVxuXG5pZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUgKSB7XG5cdGN1cnJlbnRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHZhciBsZWZ0LCByc0xlZnQsIHVuY29tcHV0ZWQsXG5cdFx0XHRyZXQgPSBlbGVtLmN1cnJlbnRTdHlsZSAmJiBlbGVtLmN1cnJlbnRTdHlsZVsgbmFtZSBdLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gQXZvaWQgc2V0dGluZyByZXQgdG8gZW1wdHkgc3RyaW5nIGhlcmVcblx0XHQvLyBzbyB3ZSBkb24ndCBkZWZhdWx0IHRvIGF1dG9cblx0XHRpZiAoIHJldCA9PT0gbnVsbCAmJiBzdHlsZSAmJiAodW5jb21wdXRlZCA9IHN0eWxlWyBuYW1lIF0pICkge1xuXHRcdFx0cmV0ID0gdW5jb21wdXRlZDtcblx0XHR9XG5cblx0XHQvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG5cdFx0Ly8gaHR0cDovL2VyaWsuZWFlLm5ldC9hcmNoaXZlcy8yMDA3LzA3LzI3LzE4LjU0LjE1LyNjb21tZW50LTEwMjI5MVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG5cdFx0Ly8gYnV0IGEgbnVtYmVyIHRoYXQgaGFzIGEgd2VpcmQgZW5kaW5nLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gcGl4ZWxzXG5cdFx0aWYgKCAhcm51bXB4LnRlc3QoIHJldCApICYmIHJudW0udGVzdCggcmV0ICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdGxlZnQgPSBzdHlsZS5sZWZ0O1xuXHRcdFx0cnNMZWZ0ID0gZWxlbS5ydW50aW1lU3R5bGUgJiYgZWxlbS5ydW50aW1lU3R5bGUubGVmdDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdGVsZW0ucnVudGltZVN0eWxlLmxlZnQgPSBlbGVtLmN1cnJlbnRTdHlsZS5sZWZ0O1xuXHRcdFx0fVxuXHRcdFx0c3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiAoIHJldCB8fCAwICk7XG5cdFx0XHRyZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCI7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdGVsZW0ucnVudGltZVN0eWxlLmxlZnQgPSByc0xlZnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiYXV0b1wiIDogcmV0O1xuXHR9O1xufVxuXG5jdXJDU1MgPSBnZXRDb21wdXRlZFN0eWxlIHx8IGN1cnJlbnRTdHlsZTtcblxuZnVuY3Rpb24gZ2V0V0goIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5XG5cdHZhciB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0d2hpY2ggPSBuYW1lID09PSBcIndpZHRoXCIgPyBjc3NXaWR0aCA6IGNzc0hlaWdodCxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB3aGljaC5sZW5ndGg7XG5cblx0aWYgKCB2YWwgPiAwICkge1xuXHRcdGlmICggZXh0cmEgIT09IFwiYm9yZGVyXCIgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRcdFx0dmFsIC09IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgd2hpY2hbIGkgXSApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRcdHZhbCArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIHdoaWNoWyBpIF0gKSApIHx8IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsIC09IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyB3aGljaFsgaSBdICsgXCJXaWR0aFwiICkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbCArIFwicHhcIjtcblx0fVxuXG5cdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIG5hbWUgKTtcblx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXSB8fCAwO1xuXHR9XG5cdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGQgcGFkZGluZywgYm9yZGVyLCBtYXJnaW5cblx0aWYgKCBleHRyYSApIHtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdHZhbCArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIHdoaWNoWyBpIF0gKSApIHx8IDA7XG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyB3aGljaFsgaSBdICsgXCJXaWR0aFwiICkgKSB8fCAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgd2hpY2hbIGkgXSApICkgfHwgMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsICsgXCJweFwiO1xufVxuXG5pZiAoIGpRdWVyeS5leHByICYmIGpRdWVyeS5leHByLmZpbHRlcnMgKSB7XG5cdGpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHdpZHRoID0gZWxlbS5vZmZzZXRXaWR0aCxcblx0XHRcdGhlaWdodCA9IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuXG5cdFx0cmV0dXJuICggd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICkgfHwgKCFqUXVlcnkuc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMgJiYgKChlbGVtLnN0eWxlICYmIGVsZW0uc3R5bGUuZGlzcGxheSkgfHwgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSkgPT09IFwibm9uZVwiKTtcblx0fTtcblxuXHRqUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XG5cdH07XG59XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL21nLCAvLyBJRSBsZWF2ZXMgYW4gXFxyIGNoYXJhY3RlciBhdCBFT0xcblx0cmlucHV0ID0gL14oPzpjb2xvcnxkYXRlfGRhdGV0aW1lfGRhdGV0aW1lLWxvY2FsfGVtYWlsfGhpZGRlbnxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFuZ2V8c2VhcmNofHRlbHx0ZXh0fHRpbWV8dXJsfHdlZWspJC9pLFxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHBcXC1zdG9yYWdlfC4rXFwtZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cdHJxdWVyeSA9IC9cXD8vLFxuXHRyc2NyaXB0ID0gLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksXG5cdHJzZWxlY3RUZXh0YXJlYSA9IC9eKD86c2VsZWN0fHRleHRhcmVhKS9pLFxuXHRyc3BhY2VzQWpheCA9IC9cXHMrLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRydXJsID0gL14oW1xcd1xcK1xcLlxcLV0rOikoPzpcXC9cXC8oW15cXC8/IzpdKikoPzo6KFxcZCspKT8pPy8sXG5cblx0Ly8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxuXHRfbG9hZCA9IGpRdWVyeS5mbi5sb2FkLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIERvY3VtZW50IGxvY2F0aW9uXG5cdGFqYXhMb2NhdGlvbixcblxuXHQvLyBEb2N1bWVudCBsb2NhdGlvbiBzZWdtZW50c1xuXHRhamF4TG9jUGFydHMsXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gW1wiKi9cIl0gKyBbXCIqXCJdO1xuXG4vLyAjODEzOCwgSUUgbWF5IHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuLy8gYSBmaWVsZCBmcm9tIHdpbmRvdy5sb2NhdGlvbiBpZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gc2V0XG50cnkge1xuXHRhamF4TG9jYXRpb24gPSBsb2NhdGlvbi5ocmVmO1xufSBjYXRjaCggZSApIHtcblx0Ly8gVXNlIHRoZSBocmVmIGF0dHJpYnV0ZSBvZiBhbiBBIGVsZW1lbnRcblx0Ly8gc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cblx0YWpheExvY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0YWpheExvY2F0aW9uLmhyZWYgPSBcIlwiO1xuXHRhamF4TG9jYXRpb24gPSBhamF4TG9jYXRpb24uaHJlZjtcbn1cblxuLy8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG5hamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoIGFqYXhMb2NhdGlvbi50b0xvd2VyQ2FzZSgpICkgfHwgW107XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLnNwbGl0KCByc3BhY2VzQWpheCApLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVR5cGVzLmxlbmd0aCxcblx0XHRcdFx0ZGF0YVR5cGUsXG5cdFx0XHRcdGxpc3QsXG5cdFx0XHRcdHBsYWNlQmVmb3JlO1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkgXTtcblx0XHRcdFx0Ly8gV2UgY29udHJvbCBpZiB3ZSdyZSBhc2tlZCB0byBhZGQgYmVmb3JlXG5cdFx0XHRcdC8vIGFueSBleGlzdGluZyBlbGVtZW50XG5cdFx0XHRcdHBsYWNlQmVmb3JlID0gL15cXCsvLnRlc3QoIGRhdGFUeXBlICk7XG5cdFx0XHRcdGlmICggcGxhY2VCZWZvcmUgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zdWJzdHIoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0ID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdO1xuXHRcdFx0XHQvLyB0aGVuIHdlIGFkZCB0byB0aGUgc3RydWN0dXJlIGFjY29yZGluZ2x5XG5cdFx0XHRcdGxpc3RbIHBsYWNlQmVmb3JlID8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIiBdKCBmdW5jICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIsXG5cdFx0ZGF0YVR5cGUgLyogaW50ZXJuYWwgKi8sIGluc3BlY3RlZCAvKiBpbnRlcm5hbCAqLyApIHtcblxuXHRkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IG9wdGlvbnMuZGF0YVR5cGVzWyAwIF07XG5cdGluc3BlY3RlZCA9IGluc3BlY3RlZCB8fCB7fTtcblxuXHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXG5cdHZhciBsaXN0ID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbmd0aCA9IGxpc3QgPyBsaXN0Lmxlbmd0aCA6IDAsXG5cdFx0ZXhlY3V0ZU9ubHkgPSAoIHN0cnVjdHVyZSA9PT0gcHJlZmlsdGVycyApLFxuXHRcdHNlbGVjdGlvbjtcblxuXHRmb3IgKCA7IGkgPCBsZW5ndGggJiYgKCBleGVjdXRlT25seSB8fCAhc2VsZWN0aW9uICk7IGkrKyApIHtcblx0XHRzZWxlY3Rpb24gPSBsaXN0WyBpIF0oIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHQvLyBJZiB3ZSBnb3QgcmVkaXJlY3RlZCB0byBhbm90aGVyIGRhdGFUeXBlXG5cdFx0Ly8gd2UgdHJ5IHRoZXJlIGlmIGV4ZWN1dGluZyBvbmx5IGFuZCBub3QgZG9uZSBhbHJlYWR5XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0aW9uID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCAhZXhlY3V0ZU9ubHkgfHwgaW5zcGVjdGVkWyBzZWxlY3Rpb24gXSApIHtcblx0XHRcdFx0c2VsZWN0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggc2VsZWN0aW9uICk7XG5cdFx0XHRcdHNlbGVjdGlvbiA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKFxuXHRcdFx0XHRcdFx0c3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSLCBzZWxlY3Rpb24sIGluc3BlY3RlZCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBJZiB3ZSdyZSBvbmx5IGV4ZWN1dGluZyBvciBub3RoaW5nIHdhcyBzZWxlY3RlZFxuXHQvLyB3ZSB0cnkgdGhlIGNhdGNoYWxsIGRhdGFUeXBlIGlmIG5vdCBkb25lIGFscmVhZHlcblx0aWYgKCAoIGV4ZWN1dGVPbmx5IHx8ICFzZWxlY3Rpb24gKSAmJiAhaW5zcGVjdGVkWyBcIipcIiBdICkge1xuXHRcdHNlbGVjdGlvbiA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKFxuXHRcdFx0XHRzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIsIFwiKlwiLCBpbnNwZWN0ZWQgKTtcblx0fVxuXHQvLyB1bm5lY2Vzc2FyeSB3aGVuIG9ubHkgZXhlY3V0aW5nIChwcmVmaWx0ZXJzKVxuXHQvLyBidXQgaXQnbGwgYmUgaWdub3JlZCBieSB0aGUgY2FsbGVyIGluIHRoYXQgY2FzZVxuXHRyZXR1cm4gc2VsZWN0aW9uO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRsb2FkOiBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRcdHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHQvLyBEb24ndCBkbyBhIHJlcXVlc3QgaWYgbm8gZWxlbWVudHMgYXJlIGJlaW5nIHJlcXVlc3RlZFxuXHRcdH0gZWxzZSBpZiAoICF0aGlzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHZhciBvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblx0XHRpZiAoIG9mZiA+PSAwICkge1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gdXJsLnNsaWNlKCBvZmYsIHVybC5sZW5ndGggKTtcblx0XHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCB0byBhIEdFVCByZXF1ZXN0XG5cdFx0dmFyIHR5cGUgPSBcIkdFVFwiO1xuXG5cdFx0Ly8gSWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgd2FzIHByb3ZpZGVkXG5cdFx0aWYgKCBwYXJhbXMgKSB7XG5cdFx0XHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXHRcdFx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRwYXJhbXMgPSBqUXVlcnkucGFyYW0oIHBhcmFtcywgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbCApO1xuXHRcdFx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0Ly8gUmVxdWVzdCB0aGUgcmVtb3RlIGRvY3VtZW50XG5cdFx0alF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zLFxuXHRcdFx0Ly8gQ29tcGxldGUgY2FsbGJhY2sgKHJlc3BvbnNlVGV4dCBpcyB1c2VkIGludGVybmFsbHkpXG5cdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMsIHJlc3BvbnNlVGV4dCApIHtcblx0XHRcdFx0Ly8gU3RvcmUgdGhlIHJlc3BvbnNlIGFzIHNwZWNpZmllZCBieSB0aGUganFYSFIgb2JqZWN0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCA9IGpxWEhSLnJlc3BvbnNlVGV4dDtcblx0XHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaW5qZWN0IHRoZSBIVE1MIGludG8gYWxsIHRoZSBtYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHRcdGlmICgganFYSFIuaXNSZXNvbHZlZCgpICkge1xuXHRcdFx0XHRcdC8vICM0ODI1OiBHZXQgdGhlIGFjdHVhbCByZXNwb25zZSBpbiBjYXNlXG5cdFx0XHRcdFx0Ly8gYSBkYXRhRmlsdGVyIGlzIHByZXNlbnQgaW4gYWpheFNldHRpbmdzXG5cdFx0XHRcdFx0anFYSFIuZG9uZShmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlVGV4dCA9IHI7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gU2VlIGlmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZFxuXHRcdFx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgZHVtbXkgZGl2IHRvIGhvbGQgdGhlIHJlc3VsdHNcblx0XHRcdFx0XHRcdGpRdWVyeShcIjxkaXY+XCIpXG5cdFx0XHRcdFx0XHRcdC8vIGluamVjdCB0aGUgY29udGVudHMgb2YgdGhlIGRvY3VtZW50IGluLCByZW1vdmluZyB0aGUgc2NyaXB0c1xuXHRcdFx0XHRcdFx0XHQvLyB0byBhdm9pZCBhbnkgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnMgaW4gSUVcblx0XHRcdFx0XHRcdFx0LmFwcGVuZChyZXNwb25zZVRleHQucmVwbGFjZShyc2NyaXB0LCBcIlwiKSlcblxuXHRcdFx0XHRcdFx0XHQvLyBMb2NhdGUgdGhlIHNwZWNpZmllZCBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHQuZmluZChzZWxlY3RvcikgOlxuXG5cdFx0XHRcdFx0XHQvLyBJZiBub3QsIGp1c3QgaW5qZWN0IHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdHNlbGYuZWFjaCggY2FsbGJhY2ssIFsgcmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIHRoaXMuZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSlcblx0XHQuZmlsdGVyKGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICF0aGlzLmRpc2FibGVkICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8IHJzZWxlY3RUZXh0YXJlYS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyaW5wdXQudGVzdCggdGhpcy50eXBlICkgKTtcblx0XHR9KVxuXHRcdC5tYXAoZnVuY3Rpb24oIGksIGVsZW0gKXtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsLCBpICl7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSkuZ2V0KCk7XG5cdH1cbn0pO1xuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFwiYWpheFN0YXJ0IGFqYXhTdG9wIGFqYXhDb21wbGV0ZSBhamF4RXJyb3IgYWpheFN1Y2Nlc3MgYWpheFNlbmRcIi5zcGxpdCggXCIgXCIgKSwgZnVuY3Rpb24oIGksIG8gKXtcblx0alF1ZXJ5LmZuWyBvIF0gPSBmdW5jdGlvbiggZiApe1xuXHRcdHJldHVybiB0aGlzLm9uKCBvLCBmICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXHRcdC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFjayxcblx0XHRcdGRhdGFUeXBlOiB0eXBlXG5cdFx0fSk7XG5cdH07XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdGlmICggc2V0dGluZ3MgKSB7XG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdHNldHRpbmdzID0gdGFyZ2V0O1xuXHRcdFx0dGFyZ2V0ID0galF1ZXJ5LmFqYXhTZXR0aW5ncztcblx0XHR9XG5cdFx0YWpheEV4dGVuZCggdGFyZ2V0LCBzZXR0aW5ncyApO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH0sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiLFxuXHRcdFx0XCIqXCI6IGFsbFR5cGVzXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC94bWwvLFxuXHRcdFx0aHRtbDogL2h0bWwvLFxuXHRcdFx0anNvbjogL2pzb24vXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCJcblx0XHR9LFxuXG5cdFx0Ly8gTGlzdCBvZiBkYXRhIGNvbnZlcnRlcnNcblx0XHQvLyAxKSBrZXkgZm9ybWF0IGlzIFwic291cmNlX3R5cGUgZGVzdGluYXRpb25fdHlwZVwiIChhIHNpbmdsZSBzcGFjZSBpbi1iZXR3ZWVuKVxuXHRcdC8vIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWQgZm9yIHNvdXJjZV90eXBlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IHdpbmRvdy5TdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdGNvbnRleHQ6IHRydWUsXG5cdFx0XHR1cmw6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciAvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHNcblx0XHRcdC8vIEl0J3MgdGhlIGNhbGxiYWNrQ29udGV4dCBpZiBvbmUgd2FzIHByb3ZpZGVkIGluIHRoZSBvcHRpb25zXG5cdFx0XHQvLyBhbmQgaWYgaXQncyBhIERPTSBub2RlIG9yIGEgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IGNhbGxiYWNrQ29udGV4dCAhPT0gcyAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgKSA/XG5cdFx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDogalF1ZXJ5LmV2ZW50LFxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cdFx0XHQvLyBpZk1vZGlmaWVkIGtleVxuXHRcdFx0aWZNb2RpZmllZEtleSxcblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0Ly8gdHJhbnNwb3J0XG5cdFx0XHR0cmFuc3BvcnQsXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IFwiYWJvcnRcIjtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggc3RhdHVzVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBzdGF0dXNUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHQvLyBJdCBpcyBkZWZpbmVkIGhlcmUgYmVjYXVzZSBqc2xpbnQgY29tcGxhaW5zIGlmIGl0IGlzIGRlY2xhcmVkXG5cdFx0Ly8gYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24gKHdoaWNoIHdvdWxkIGJlIG1vcmUgbG9naWNhbCBhbmQgcmVhZGFibGUpXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHR2YXIgaXNTdWNjZXNzLFxuXHRcdFx0XHRzdWNjZXNzLFxuXHRcdFx0XHRlcnJvcixcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQsXG5cdFx0XHRcdHJlc3BvbnNlID0gcmVzcG9uc2VzID8gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRsYXN0TW9kaWZpZWQsXG5cdFx0XHRcdGV0YWc7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0ICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCAoIGxhc3RNb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBpZk1vZGlmaWVkS2V5IF0gPSBsYXN0TW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggKCBldGFnID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiRXRhZ1wiICkgKSApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBpZk1vZGlmaWVkS2V5IF0gPSBldGFnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHN1Y2Nlc3MgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcInN1Y2Nlc3NcIjtcblx0XHRcdFx0XHRcdGlzU3VjY2VzcyA9IHRydWU7XG5cdFx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBoYXZlIGEgcGFyc2VyZXJyb3Jcblx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcInBhcnNlcmVycm9yXCI7XG5cdFx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXZSBleHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dFxuXHRcdFx0XHQvLyB0aGVuIG5vcm1hbGl6ZSBzdGF0dXNUZXh0IGFuZCBzdGF0dXMgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoICFzdGF0dXNUZXh0IHx8IHN0YXR1cyApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gXCJcIiArICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICk7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFwiICsgKCBpc1N1Y2Nlc3MgPyBcIlN1Y2Nlc3NcIiA6IFwiRXJyb3JcIiApLFxuXHRcdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cdFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXHRcdGpxWEhSLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG5cblx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdGpxWEhSLnN0YXR1c0NvZGUgPSBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdHZhciB0bXA7XG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGZvciAoIHRtcCBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyB0bXAgXSA9IFsgc3RhdHVzQ29kZVt0bXBdLCBtYXBbdG1wXSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXAgPSBtYXBbIGpxWEhSLnN0YXR1cyBdO1xuXHRcdFx0XHRcdGpxWEhSLnRoZW4oIHRtcCwgdG1wICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkICgjNTg2NjogSUU3IGlzc3VlIHdpdGggcHJvdG9jb2wtbGVzcyB1cmxzKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiICkucmVwbGFjZSggcnByb3RvY29sLCBhamF4TG9jUGFydHNbIDEgXSArIFwiLy9cIiApO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLnNwbGl0KCByc3BhY2VzQWpheCApO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIGEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXJcblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHBhcnRzID0gcnVybC5leGVjKCBzLnVybC50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXG5cdFx0XHRcdCggcGFydHNbIDEgXSAhPSBhamF4TG9jUGFydHNbIDEgXSB8fCBwYXJ0c1sgMiBdICE9IGFqYXhMb2NQYXJ0c1sgMiBdIHx8XG5cdFx0XHRcdFx0KCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gODAgOiA0NDMgKSApICE9XG5cdFx0XHRcdFx0XHQoIGFqYXhMb2NQYXJ0c1sgMyBdIHx8ICggYWpheExvY1BhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IDgwIDogNDQzICkgKSApXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWxlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHRmaXJlR2xvYmFscyA9IHMuZ2xvYmFsO1xuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IGlmTW9kaWZpZWRLZXkgYmVmb3JlIGFkZGluZyB0aGUgYW50aS1jYWNoZSBwYXJhbWV0ZXJcblx0XHRcdGlmTW9kaWZpZWRLZXkgPSBzLnVybDtcblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHR2YXIgdHMgPSBqUXVlcnkubm93KCksXG5cdFx0XHRcdFx0Ly8gdHJ5IHJlcGxhY2luZyBfPSBpZiBpdCBpcyB0aGVyZVxuXHRcdFx0XHRcdHJldCA9IHMudXJsLnJlcGxhY2UoIHJ0cywgXCIkMV89XCIgKyB0cyApO1xuXG5cdFx0XHRcdC8vIGlmIG5vdGhpbmcgd2FzIHJlcGxhY2VkLCBhZGQgdGltZXN0YW1wIHRvIHRoZSBlbmRcblx0XHRcdFx0cy51cmwgPSByZXQgKyAoICggcmV0ID09PSBzLnVybCApID8gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArIHRzIDogXCJcIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZk1vZGlmaWVkS2V5ID0gaWZNb2RpZmllZEtleSB8fCBzLnVybDtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgaWZNb2RpZmllZEtleSBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGlmTW9kaWZpZWRLZXkgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgaWZNb2RpZmllZEtleSBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGlmTW9kaWZpZWRLZXkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXHRcdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5XG5cdFx0XHRcdGpxWEhSLmFib3J0KCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Ly8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcblx0Ly8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5cdHBhcmFtOiBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdFx0dmFyIHMgPSBbXSxcblx0XHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiB2YWx1ZTtcblx0XHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRcdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0XHR9XG5cblx0XHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cdFx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRcdGZvciAoIHZhciBwcmVmaXggaW4gYSApIHtcblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdFx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiBhcnJheSBpdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHNcblx0XHRcdFx0Ly8gbnVtZXJpYyBpbmRleCB0byByZXNvbHZlIGRlc2VyaWFsaXphdGlvbiBhbWJpZ3VpdHkgaXNzdWVzLlxuXHRcdFx0XHQvLyBOb3RlIHRoYXQgcmFjayAoYXMgb2YgMS4wLjApIGNhbid0IGN1cnJlbnRseSBkZXNlcmlhbGl6ZVxuXHRcdFx0XHQvLyBuZXN0ZWQgYXJyYXlzIHByb3Blcmx5LCBhbmQgYXR0ZW1wdGluZyB0byBkbyBzbyBtYXkgY2F1c2Vcblx0XHRcdFx0Ly8gYSBzZXJ2ZXIgZXJyb3IuIFBvc3NpYmxlIGZpeGVzIGFyZSB0byBtb2RpZnkgcmFjaydzXG5cdFx0XHRcdC8vIGRlc2VyaWFsaXphdGlvbiBhbGdvcml0aG0gb3IgdG8gcHJvdmlkZSBhbiBvcHRpb24gb3IgZmxhZ1xuXHRcdFx0XHQvLyB0byBmb3JjZSBhcnJheSBzZXJpYWxpemF0aW9uIHRvIGJlIHNoYWxsb3cuXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgfHwgalF1ZXJ5LmlzQXJyYXkodikgPyBpIDogXCJcIiApICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gVGhpcyBpcyBzdGlsbCBvbiB0aGUgalF1ZXJ5IG9iamVjdC4uLiBmb3Igbm93XG4vLyBXYW50IHRvIG1vdmUgdGhpcyB0byBqUXVlcnkuYWpheCBzb21lIGRheVxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9XG5cbn0pO1xuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIHNldHMgYWxsIHJlc3BvbnNlWFhYIGZpZWxkcyBhY2NvcmRpbmdseVxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMsXG5cdFx0cmVzcG9uc2VGaWVsZHMgPSBzLnJlc3BvbnNlRmllbGRzLFxuXHRcdGN0LFxuXHRcdHR5cGUsXG5cdFx0ZmluYWxEYXRhVHlwZSxcblx0XHRmaXJzdERhdGFUeXBlO1xuXG5cdC8vIEZpbGwgcmVzcG9uc2VYWFggZmllbGRzXG5cdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VGaWVsZHMgKSB7XG5cdFx0aWYgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGpxWEhSWyByZXNwb25zZUZpZWxkc1t0eXBlXSBdID0gcmVzcG9uc2VzWyB0eXBlIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiY29udGVudC10eXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vLyBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UgKSB7XG5cblx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0aWYgKCBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdH1cblxuXHR2YXIgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXHRcdGksXG5cdFx0a2V5LFxuXHRcdGxlbmd0aCA9IGRhdGFUeXBlcy5sZW5ndGgsXG5cdFx0dG1wLFxuXHRcdC8vIEN1cnJlbnQgYW5kIHByZXZpb3VzIGRhdGFUeXBlc1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXNbIDAgXSxcblx0XHRwcmV2LFxuXHRcdC8vIENvbnZlcnNpb24gZXhwcmVzc2lvblxuXHRcdGNvbnZlcnNpb24sXG5cdFx0Ly8gQ29udmVyc2lvbiBmdW5jdGlvblxuXHRcdGNvbnYsXG5cdFx0Ly8gQ29udmVyc2lvbiBmdW5jdGlvbnMgKHRyYW5zaXRpdmUgY29udmVyc2lvbilcblx0XHRjb252MSxcblx0XHRjb252MjtcblxuXHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgY2hhaW5cblx0Zm9yICggaSA9IDE7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcFxuXHRcdC8vIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdFx0aWYgKCBpID09PSAxICkge1xuXHRcdFx0Zm9yICgga2V5IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdGNvbnZlcnRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRoZSBkYXRhVHlwZXNcblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzWyBpIF07XG5cblx0XHQvLyBJZiBjdXJyZW50IGlzIGF1dG8gZGF0YVR5cGUsIHVwZGF0ZSBpdCB0byBwcmV2XG5cdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXHRcdC8vIElmIG5vIGF1dG8gYW5kIGRhdGFUeXBlcyBhcmUgYWN0dWFsbHkgZGlmZmVyZW50XG5cdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0Ly8gR2V0IHRoZSBjb252ZXJ0ZXJcblx0XHRcdGNvbnZlcnNpb24gPSBwcmV2ICsgXCIgXCIgKyBjdXJyZW50O1xuXHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnZlcnNpb24gXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdC8vIElmIHRoZXJlIGlzIG5vIGRpcmVjdCBjb252ZXJ0ZXIsIHNlYXJjaCB0cmFuc2l0aXZlbHlcblx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdGNvbnYyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKCBjb252MSBpbiBjb252ZXJ0ZXJzICkge1xuXHRcdFx0XHRcdHRtcCA9IGNvbnYxLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdGlmICggdG1wWyAwIF0gPT09IHByZXYgfHwgdG1wWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdFx0XHRcdFx0Y29udjIgPSBjb252ZXJ0ZXJzWyB0bXBbMV0gKyBcIiBcIiArIGN1cnJlbnQgXTtcblx0XHRcdFx0XHRcdGlmICggY29udjIgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnYxID0gY29udmVydGVyc1sgY29udjEgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252MSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udjI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnYyID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252MTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIHdlIGZvdW5kIG5vIGNvbnZlcnRlciwgZGlzcGF0Y2ggYW4gZXJyb3Jcblx0XHRcdGlmICggISggY29udiB8fCBjb252MiApICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgY29udmVyc2lvbi5yZXBsYWNlKFwiIFwiLFwiIHRvIFwiKSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgZm91bmQgY29udmVydGVyIGlzIG5vdCBhbiBlcXVpdmFsZW5jZVxuXHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXHRcdFx0XHQvLyBDb252ZXJ0IHdpdGggMSBvciAyIGNvbnZlcnRlcnMgYWNjb3JkaW5nbHlcblx0XHRcdFx0cmVzcG9uc2UgPSBjb252ID8gY29udiggcmVzcG9uc2UgKSA6IGNvbnYyKCBjb252MShyZXNwb25zZSkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3BvbnNlO1xufVxuXG5cblxuXG52YXIganNjID0galF1ZXJ5Lm5vdygpLFxuXHRqc3JlID0gLyhcXD0pXFw/KCZ8JCl8XFw/XFw/L2k7XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICgganNjKysgKTtcblx0fVxufSk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3REYXRhID0gcy5jb250ZW50VHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiAmJlxuXHRcdCggdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApO1xuXG5cdGlmICggcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiIHx8XG5cdFx0cy5qc29ucCAhPT0gZmFsc2UgJiYgKCBqc3JlLnRlc3QoIHMudXJsICkgfHxcblx0XHRcdFx0aW5zcGVjdERhdGEgJiYganNyZS50ZXN0KCBzLmRhdGEgKSApICkge1xuXG5cdFx0dmFyIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdFx0anNvbnBDYWxsYmFjayA9IHMuanNvbnBDYWxsYmFjayA9XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/IHMuanNvbnBDYWxsYmFjaygpIDogcy5qc29ucENhbGxiYWNrLFxuXHRcdFx0cHJldmlvdXMgPSB3aW5kb3dbIGpzb25wQ2FsbGJhY2sgXSxcblx0XHRcdHVybCA9IHMudXJsLFxuXHRcdFx0ZGF0YSA9IHMuZGF0YSxcblx0XHRcdHJlcGxhY2UgPSBcIiQxXCIgKyBqc29ucENhbGxiYWNrICsgXCIkMlwiO1xuXG5cdFx0aWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHVybCA9IHVybC5yZXBsYWNlKCBqc3JlLCByZXBsYWNlICk7XG5cdFx0XHRpZiAoIHMudXJsID09PSB1cmwgKSB7XG5cdFx0XHRcdGlmICggaW5zcGVjdERhdGEgKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGEucmVwbGFjZSgganNyZSwgcmVwbGFjZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcy5kYXRhID09PSBkYXRhICkge1xuXHRcdFx0XHRcdC8vIEFkZCBjYWxsYmFjayBtYW51YWxseVxuXHRcdFx0XHRcdHVybCArPSAoL1xcPy8udGVzdCggdXJsICkgPyBcIiZcIiA6IFwiP1wiKSArIHMuanNvbnAgKyBcIj1cIiArIGpzb25wQ2FsbGJhY2s7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzLnVybCA9IHVybDtcblx0XHRzLmRhdGEgPSBkYXRhO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdHdpbmRvd1sganNvbnBDYWxsYmFjayBdID0gZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBbIHJlc3BvbnNlIF07XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gU2V0IGNhbGxiYWNrIGJhY2sgdG8gcHJldmlvdXMgdmFsdWVcblx0XHRcdHdpbmRvd1sganNvbnBDYWxsYmFjayBdID0gcHJldmlvdXM7XG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHByZXZpb3VzICkgKSB7XG5cdFx0XHRcdHdpbmRvd1sganNvbnBDYWxsYmFjayBdKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGpzb25wQ2FsbGJhY2sgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gZm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59KTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9qYXZhc2NyaXB0fGVjbWFzY3JpcHQvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgZ2xvYmFsXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0XHRzLmdsb2JhbCA9IGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24ocykge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImhlYWRcIiApWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjYWxsYmFjayApIHtcblxuXHRcdFx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRcdFx0c2NyaXB0LmFzeW5jID0gXCJhc3luY1wiO1xuXG5cdFx0XHRcdGlmICggcy5zY3JpcHRDaGFyc2V0ICkge1xuXHRcdFx0XHRcdHNjcmlwdC5jaGFyc2V0ID0gcy5zY3JpcHRDaGFyc2V0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NyaXB0LnNyYyA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgYWxsIGJyb3dzZXJzXG5cdFx0XHRcdHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGlzQWJvcnQgfHwgIXNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoIHNjcmlwdC5yZWFkeVN0YXRlICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRVxuXHRcdFx0XHRcdFx0c2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIHNjcmlwdFxuXHRcdFx0XHRcdFx0aWYgKCBoZWFkICYmIHNjcmlwdC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0XHRoZWFkLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRGVyZWZlcmVuY2UgdGhlIHNjcmlwdFxuXHRcdFx0XHRcdFx0c2NyaXB0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHQvLyBDYWxsYmFjayBpZiBub3QgYWJvcnRcblx0XHRcdFx0XHRcdGlmICggIWlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCAyMDAsIFwic3VjY2Vzc1wiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBVc2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgYXBwZW5kQ2hpbGQgIHRvIGNpcmN1bXZlbnQgYW4gSUU2IGJ1Zy5cblx0XHRcdFx0Ly8gVGhpcyBhcmlzZXMgd2hlbiBhIGJhc2Ugbm9kZSBpcyB1c2VkICgjMjcwOSBhbmQgIzQzNzgpLlxuXHRcdFx0XHRoZWFkLmluc2VydEJlZm9yZSggc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQgKTtcblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBzY3JpcHQgKSB7XG5cdFx0XHRcdFx0c2NyaXB0Lm9ubG9hZCggMCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbnZhciAvLyAjNTI4MDogSW50ZXJuZXQgRXhwbG9yZXIgd2lsbCBrZWVwIGNvbm5lY3Rpb25zIGFsaXZlIGlmIHdlIGRvbid0IGFib3J0IG9uIHVubG9hZFxuXHR4aHJPblVubG9hZEFib3J0ID0gd2luZG93LkFjdGl2ZVhPYmplY3QgPyBmdW5jdGlvbigpIHtcblx0XHQvLyBBYm9ydCBhbGwgcGVuZGluZyByZXF1ZXN0c1xuXHRcdGZvciAoIHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0eGhyQ2FsbGJhY2tzWyBrZXkgXSggMCwgMSApO1xuXHRcdH1cblx0fSA6IGZhbHNlLFxuXHR4aHJJZCA9IDAsXG5cdHhockNhbGxiYWNrcztcblxuLy8gRnVuY3Rpb25zIHRvIGNyZWF0ZSB4aHJzXG5mdW5jdGlvbiBjcmVhdGVTdGFuZGFyZFhIUigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoKCBlICkge31cbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aXZlWEhSKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTEhUVFBcIiApO1xuXHR9IGNhdGNoKCBlICkge31cbn1cblxuLy8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdFxuLy8gKFRoaXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYWpheFNldHRpbmdzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSB3aW5kb3cuQWN0aXZlWE9iamVjdCA/XG5cdC8qIE1pY3Jvc29mdCBmYWlsZWQgdG8gcHJvcGVybHlcblx0ICogaW1wbGVtZW50IHRoZSBYTUxIdHRwUmVxdWVzdCBpbiBJRTcgKGNhbid0IHJlcXVlc3QgbG9jYWwgZmlsZXMpLFxuXHQgKiBzbyB3ZSB1c2UgdGhlIEFjdGl2ZVhPYmplY3Qgd2hlbiBpdCBpcyBhdmFpbGFibGVcblx0ICogQWRkaXRpb25hbGx5IFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBpbiBJRTcvSUU4IHNvXG5cdCAqIHdlIG5lZWQgYSBmYWxsYmFjay5cblx0ICovXG5cdGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5pc0xvY2FsICYmIGNyZWF0ZVN0YW5kYXJkWEhSKCkgfHwgY3JlYXRlQWN0aXZlWEhSKCk7XG5cdH0gOlxuXHQvLyBGb3IgYWxsIG90aGVyIGJyb3dzZXJzLCB1c2UgdGhlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuXHRjcmVhdGVTdGFuZGFyZFhIUjtcblxuLy8gRGV0ZXJtaW5lIHN1cHBvcnQgcHJvcGVydGllc1xuKGZ1bmN0aW9uKCB4aHIgKSB7XG5cdGpRdWVyeS5leHRlbmQoIGpRdWVyeS5zdXBwb3J0LCB7XG5cdFx0YWpheDogISF4aHIsXG5cdFx0Y29yczogISF4aHIgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhociApXG5cdH0pO1xufSkoIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCkgKTtcblxuLy8gQ3JlYXRlIHRyYW5zcG9ydCBpZiB0aGUgYnJvd3NlciBjYW4gcHJvdmlkZSBhbiB4aHJcbmlmICggalF1ZXJ5LnN1cHBvcnQuYWpheCApIHtcblxuXHRqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggcyApIHtcblx0XHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdFx0aWYgKCAhcy5jcm9zc0RvbWFpbiB8fCBqUXVlcnkuc3VwcG9ydC5jb3JzICkge1xuXG5cdFx0XHR2YXIgY2FsbGJhY2s7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblxuXHRcdFx0XHRcdC8vIEdldCBhIG5ldyB4aHJcblx0XHRcdFx0XHR2YXIgeGhyID0gcy54aHIoKSxcblx0XHRcdFx0XHRcdGhhbmRsZSxcblx0XHRcdFx0XHRcdGk7XG5cblx0XHRcdFx0XHQvLyBPcGVuIHRoZSBzb2NrZXRcblx0XHRcdFx0XHQvLyBQYXNzaW5nIG51bGwgdXNlcm5hbWUsIGdlbmVyYXRlcyBhIGxvZ2luIHBvcHVwIG9uIE9wZXJhICgjMjg2NSlcblx0XHRcdFx0XHRpZiAoIHMudXNlcm5hbWUgKSB7XG5cdFx0XHRcdFx0XHR4aHIub3Blbiggcy50eXBlLCBzLnVybCwgcy5hc3luYywgcy51c2VybmFtZSwgcy5wYXNzd29yZCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR4aHIub3Blbiggcy50eXBlLCBzLnVybCwgcy5hc3luYyApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0XHRpZiAoIHMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggaSBpbiBzLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBzLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0XHRpZiAoIHMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggcy5taW1lVHlwZSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdFx0aWYgKCAhcy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5lZWQgYW4gZXh0cmEgdHJ5L2NhdGNoIGZvciBjcm9zcyBkb21haW4gcmVxdWVzdHMgaW4gRmlyZWZveCAzXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2goIF8gKSB7fVxuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRcdC8vIFRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbiB3aGljaCBpcyBhY3R1YWxseVxuXHRcdFx0XHRcdC8vIGhhbmRsZWQgaW4galF1ZXJ5LmFqYXggKHNvIG5vIHRyeS9jYXRjaCBoZXJlKVxuXHRcdFx0XHRcdHhoci5zZW5kKCAoIHMuaGFzQ29udGVudCAmJiBzLmRhdGEgKSB8fCBudWxsICk7XG5cblx0XHRcdFx0XHQvLyBMaXN0ZW5lclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzdGF0dXMsXG5cdFx0XHRcdFx0XHRcdHN0YXR1c1RleHQsXG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VzLFxuXHRcdFx0XHRcdFx0XHR4bWw7XG5cblx0XHRcdFx0XHRcdC8vIEZpcmVmb3ggdGhyb3dzIGV4Y2VwdGlvbnMgd2hlbiBhY2Nlc3NpbmcgcHJvcGVydGllc1xuXHRcdFx0XHRcdFx0Ly8gb2YgYW4geGhyIHdoZW4gYSBuZXR3b3JrIGVycm9yIG9jY3VyZWRcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9oZWxwZnVsLmtub2JzLWRpYWxzLmNvbS9pbmRleC5waHAvQ29tcG9uZW50X3JldHVybmVkX2ZhaWx1cmVfY29kZTpfMHg4MDA0MDExMV8oTlNfRVJST1JfTk9UX0FWQUlMQUJMRSlcblx0XHRcdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gV2FzIG5ldmVyIGNhbGxlZCBhbmQgaXMgYWJvcnRlZCBvciBjb21wbGV0ZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICYmICggaXNBYm9ydCB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjYWxsZWQgb25jZVxuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRG8gbm90IGtlZXAgYXMgYWN0aXZlIGFueW1vcmVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBqUXVlcnkubm9vcDtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggeGhyT25VbmxvYWRBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIHhockNhbGxiYWNrc1sgaGFuZGxlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgaXQncyBhbiBhYm9ydFxuXHRcdFx0XHRcdFx0XHRcdGlmICggaXNBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFib3J0IGl0IG1hbnVhbGx5IGlmIG5lZWRlZFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSAhPT0gNCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMgPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRcdHhtbCA9IHhoci5yZXNwb25zZVhNTDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ29uc3RydWN0IHJlc3BvbnNlIGxpc3Rcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggeG1sICYmIHhtbC5kb2N1bWVudEVsZW1lbnQgLyogIzQ5NTggKi8gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcy54bWwgPSB4bWw7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMudGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3RhdHVzVGV4dCBmb3IgZmF1bHR5IGNyb3NzLWRvbWFpbiByZXF1ZXN0c1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0O1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCggZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gV2Ugbm9ybWFsaXplIHdpdGggV2Via2l0IGdpdmluZyBhbiBlbXB0eSBzdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWx0ZXIgc3RhdHVzIGZvciBub24gc3RhbmRhcmQgYmVoYXZpb3JzXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIElmIHRoZSByZXF1ZXN0IGlzIGxvY2FsIGFuZCB3ZSBoYXZlIGRhdGE6IGFzc3VtZSBhIHN1Y2Nlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdC8vIChzdWNjZXNzIHdpdGggbm8gZGF0YSB3b24ndCBnZXQgbm90aWZpZWQsIHRoYXQncyB0aGUgYmVzdCB3ZVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gY2FuIGRvIGdpdmVuIGN1cnJlbnQgaW1wbGVtZW50YXRpb25zKVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAhc3RhdHVzICYmIHMuaXNMb2NhbCAmJiAhcy5jcm9zc0RvbWFpbiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzID0gcmVzcG9uc2VzLnRleHQgPyAyMDAgOiA0MDQ7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRSAtICMxNDUwOiBzb21ldGltZXMgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAxMjIzICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSAyMDQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoKCBmaXJlZm94QWNjZXNzRXhjZXB0aW9uICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICFpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAtMSwgZmlyZWZveEFjY2Vzc0V4Y2VwdGlvbiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIENhbGwgY29tcGxldGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzLCByZXNwb25zZUhlYWRlcnMgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gaWYgd2UncmUgaW4gc3luYyBtb2RlIG9yIGl0J3MgaW4gY2FjaGVcblx0XHRcdFx0XHQvLyBhbmQgaGFzIGJlZW4gcmV0cmlldmVkIGRpcmVjdGx5IChJRTYgJiBJRTcpXG5cdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBtYW51YWxseSBmaXJlIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRcdGlmICggIXMuYXN5bmMgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRoYW5kbGUgPSArK3hocklkO1xuXHRcdFx0XHRcdFx0aWYgKCB4aHJPblVubG9hZEFib3J0ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFjdGl2ZSB4aHJzIGNhbGxiYWNrcyBsaXN0IGlmIG5lZWRlZFxuXHRcdFx0XHRcdFx0XHQvLyBhbmQgYXR0YWNoIHRoZSB1bmxvYWQgaGFuZGxlclxuXHRcdFx0XHRcdFx0XHRpZiAoICF4aHJDYWxsYmFja3MgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyQ2FsbGJhY2tzID0ge307XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS51bmxvYWQoIHhock9uVW5sb2FkQWJvcnQgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBBZGQgdG8gbGlzdCBvZiBhY3RpdmUgeGhycyBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0eGhyQ2FsbGJhY2tzWyBoYW5kbGUgXSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKDAsMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSk7XG59XG5cblxuXG5cbnZhciBlbGVtZGlzcGxheSA9IHt9LFxuXHRpZnJhbWUsIGlmcmFtZURvYyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJmeG51bSA9IC9eKFsrXFwtXT0pPyhbXFxkKy5cXC1dKykoW2EteiVdKikkL2ksXG5cdHRpbWVySWQsXG5cdGZ4QXR0cnMgPSBbXG5cdFx0Ly8gaGVpZ2h0IGFuaW1hdGlvbnNcblx0XHRbIFwiaGVpZ2h0XCIsIFwibWFyZ2luVG9wXCIsIFwibWFyZ2luQm90dG9tXCIsIFwicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdCb3R0b21cIiBdLFxuXHRcdC8vIHdpZHRoIGFuaW1hdGlvbnNcblx0XHRbIFwid2lkdGhcIiwgXCJtYXJnaW5MZWZ0XCIsIFwibWFyZ2luUmlnaHRcIiwgXCJwYWRkaW5nTGVmdFwiLCBcInBhZGRpbmdSaWdodFwiIF0sXG5cdFx0Ly8gb3BhY2l0eSBhbmltYXRpb25zXG5cdFx0WyBcIm9wYWNpdHlcIiBdXG5cdF0sXG5cdGZ4Tm93O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0c2hvdzogZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbGVtLCBkaXNwbGF5O1xuXG5cdFx0aWYgKCBzcGVlZCB8fCBzcGVlZCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIGdlbkZ4KFwic2hvd1wiLCAzKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSB0aGlzLmxlbmd0aDsgaSA8IGo7IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGVsZW0uc3R5bGUgKSB7XG5cdFx0XHRcdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblxuXHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdFx0XHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCAhalF1ZXJ5Ll9kYXRhKGVsZW0sIFwib2xkZGlzcGxheVwiKSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwiXCIgJiYgalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0XHRcdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgajsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggZWxlbS5zdHlsZSApIHtcblx0XHRcdFx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXG5cdFx0XHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIlwiIHx8IGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSxcblxuXHRoaWRlOiBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBzcGVlZCB8fCBzcGVlZCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIGdlbkZ4KFwiaGlkZVwiLCAzKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBlbGVtLCBkaXNwbGF5LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0aiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBqOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzW2ldO1xuXHRcdFx0XHRpZiAoIGVsZW0uc3R5bGUgKSB7XG5cdFx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHRcdFx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqOyBpKysgKSB7XG5cdFx0XHRcdGlmICggdGhpc1tpXS5zdHlsZSApIHtcblx0XHRcdFx0XHR0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sXG5cblx0Ly8gU2F2ZSB0aGUgb2xkIHRvZ2dsZSBmdW5jdGlvblxuXHRfdG9nZ2xlOiBqUXVlcnkuZm4udG9nZ2xlLFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24oIGZuLCBmbjIsIGNhbGxiYWNrICkge1xuXHRcdHZhciBib29sID0gdHlwZW9mIGZuID09PSBcImJvb2xlYW5cIjtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oZm4pICYmIGpRdWVyeS5pc0Z1bmN0aW9uKGZuMikgKSB7XG5cdFx0XHR0aGlzLl90b2dnbGUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCB8fCBib29sICkge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc3RhdGUgPSBib29sID8gZm4gOiBqUXVlcnkodGhpcykuaXMoXCI6aGlkZGVuXCIpO1xuXHRcdFx0XHRqUXVlcnkodGhpcylbIHN0YXRlID8gXCJzaG93XCIgOiBcImhpZGVcIiBdKCk7XG5cdFx0XHR9KTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFuaW1hdGUoZ2VuRngoXCJ0b2dnbGVcIiwgMyksIGZuLCBmbjIsIGNhbGxiYWNrKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKFwiOmhpZGRlblwiKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKS5lbmQoKVxuXHRcdFx0XHRcdC5hbmltYXRlKHtvcGFjaXR5OiB0b30sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcblx0fSxcblxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIG9wdGFsbC5jb21wbGV0ZSwgWyBmYWxzZSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gRG8gbm90IGNoYW5nZSByZWZlcmVuY2VkIHByb3BlcnRpZXMgYXMgcGVyLXByb3BlcnR5IGVhc2luZyB3aWxsIGJlIGxvc3Rcblx0XHRwcm9wID0galF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKTtcblxuXHRcdGZ1bmN0aW9uIGRvQW5pbWF0aW9uKCkge1xuXHRcdFx0Ly8gWFhYICd0aGlzJyBkb2VzIG5vdCBhbHdheXMgaGF2ZSBhIG5vZGVOYW1lIHdoZW4gcnVubmluZyB0aGVcblx0XHRcdC8vIHRlc3Qgc3VpdGVcblxuXHRcdFx0aWYgKCBvcHRhbGwucXVldWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRqUXVlcnkuX21hcmsoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG9wdCA9IGpRdWVyeS5leHRlbmQoIHt9LCBvcHRhbGwgKSxcblx0XHRcdFx0aXNFbGVtZW50ID0gdGhpcy5ub2RlVHlwZSA9PT0gMSxcblx0XHRcdFx0aGlkZGVuID0gaXNFbGVtZW50ICYmIGpRdWVyeSh0aGlzKS5pcyhcIjpoaWRkZW5cIiksXG5cdFx0XHRcdG5hbWUsIHZhbCwgcCwgZSxcblx0XHRcdFx0cGFydHMsIHN0YXJ0LCBlbmQsIHVuaXQsXG5cdFx0XHRcdG1ldGhvZDtcblxuXHRcdFx0Ly8gd2lsbCBzdG9yZSBwZXIgcHJvcGVydHkgZWFzaW5nIGFuZCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGVuIGFuIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuXHRcdFx0b3B0LmFuaW1hdGVkUHJvcGVydGllcyA9IHt9O1xuXG5cdFx0XHRmb3IgKCBwIGluIHByb3AgKSB7XG5cblx0XHRcdFx0Ly8gcHJvcGVydHkgbmFtZSBub3JtYWxpemF0aW9uXG5cdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBwICk7XG5cdFx0XHRcdGlmICggcCAhPT0gbmFtZSApIHtcblx0XHRcdFx0XHRwcm9wWyBuYW1lIF0gPSBwcm9wWyBwIF07XG5cdFx0XHRcdFx0ZGVsZXRlIHByb3BbIHAgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhbCA9IHByb3BbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBlYXNpbmcgcmVzb2x1dGlvbjogcGVyIHByb3BlcnR5ID4gb3B0LnNwZWNpYWxFYXNpbmcgPiBvcHQuZWFzaW5nID4gJ3N3aW5nJyAoZGVmYXVsdClcblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdFx0b3B0LmFuaW1hdGVkUHJvcGVydGllc1sgbmFtZSBdID0gdmFsWyAxIF07XG5cdFx0XHRcdFx0dmFsID0gcHJvcFsgbmFtZSBdID0gdmFsWyAwIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3B0LmFuaW1hdGVkUHJvcGVydGllc1sgbmFtZSBdID0gb3B0LnNwZWNpYWxFYXNpbmcgJiYgb3B0LnNwZWNpYWxFYXNpbmdbIG5hbWUgXSB8fCBvcHQuZWFzaW5nIHx8ICdzd2luZyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHZhbCA9PT0gXCJoaWRlXCIgJiYgaGlkZGVuIHx8IHZhbCA9PT0gXCJzaG93XCIgJiYgIWhpZGRlbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0LmNvbXBsZXRlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaXNFbGVtZW50ICYmICggbmFtZSA9PT0gXCJoZWlnaHRcIiB8fCBuYW1lID09PSBcIndpZHRoXCIgKSApIHtcblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHRcdFx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90XG5cdFx0XHRcdFx0Ly8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXG5cdFx0XHRcdFx0Ly8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcblx0XHRcdFx0XHRvcHQub3ZlcmZsb3cgPSBbIHRoaXMuc3R5bGUub3ZlcmZsb3csIHRoaXMuc3R5bGUub3ZlcmZsb3dYLCB0aGlzLnN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHRcdFx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY3NzKCB0aGlzLCBcImRpc3BsYXlcIiApID09PSBcImlubGluZVwiICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jc3MoIHRoaXMsIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaW5saW5lLWxldmVsIGVsZW1lbnRzIGFjY2VwdCBpbmxpbmUtYmxvY2s7XG5cdFx0XHRcdFx0XHQvLyBibG9jay1sZXZlbCBlbGVtZW50cyBuZWVkIHRvIGJlIGlubGluZSB3aXRoIGxheW91dFxuXHRcdFx0XHRcdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCB8fCBkZWZhdWx0RGlzcGxheSggdGhpcy5ub2RlTmFtZSApID09PSBcImlubGluZVwiICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN0eWxlLnpvb20gPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdC5vdmVyZmxvdyAhPSBudWxsICkge1xuXHRcdFx0XHR0aGlzLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggcCBpbiBwcm9wICkge1xuXHRcdFx0XHRlID0gbmV3IGpRdWVyeS5meCggdGhpcywgb3B0LCBwICk7XG5cdFx0XHRcdHZhbCA9IHByb3BbIHAgXTtcblxuXHRcdFx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbCApICkge1xuXG5cdFx0XHRcdFx0Ly8gVHJhY2tzIHdoZXRoZXIgdG8gc2hvdyBvciBoaWRlIGJhc2VkIG9uIHByaXZhdGVcblx0XHRcdFx0XHQvLyBkYXRhIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0bWV0aG9kID0galF1ZXJ5Ll9kYXRhKCB0aGlzLCBcInRvZ2dsZVwiICsgcCApIHx8ICggdmFsID09PSBcInRvZ2dsZVwiID8gaGlkZGVuID8gXCJzaG93XCIgOiBcImhpZGVcIiA6IDAgKTtcblx0XHRcdFx0XHRpZiAoIG1ldGhvZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggdGhpcywgXCJ0b2dnbGVcIiArIHAsIG1ldGhvZCA9PT0gXCJzaG93XCIgPyBcImhpZGVcIiA6IFwic2hvd1wiICk7XG5cdFx0XHRcdFx0XHRlWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlWyB2YWwgXSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcnRzID0gcmZ4bnVtLmV4ZWMoIHZhbCApO1xuXHRcdFx0XHRcdHN0YXJ0ID0gZS5jdXIoKTtcblxuXHRcdFx0XHRcdGlmICggcGFydHMgKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBwYXJzZUZsb2F0KCBwYXJ0c1syXSApO1xuXHRcdFx0XHRcdFx0dW5pdCA9IHBhcnRzWzNdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNvbXB1dGUgc3RhcnRpbmcgdmFsdWVcblx0XHRcdFx0XHRcdGlmICggdW5pdCAhPT0gXCJweFwiICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHRoaXMsIHAsIChlbmQgfHwgMSkgKyB1bml0KTtcblx0XHRcdFx0XHRcdFx0c3RhcnQgPSAoIChlbmQgfHwgMSkgLyBlLmN1cigpICkgKiBzdGFydDtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0aGlzLCBwLCBzdGFydCArIHVuaXQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cblx0XHRcdFx0XHRcdGlmICggcGFydHNbMV0gKSB7XG5cdFx0XHRcdFx0XHRcdGVuZCA9ICggKHBhcnRzWyAxIF0gPT09IFwiLT1cIiA/IC0xIDogMSkgKiBlbmQgKSArIHN0YXJ0O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlLmN1c3RvbSggc3RhcnQsIGVuZCwgdW5pdCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGUuY3VzdG9tKCBzdGFydCwgdmFsLCBcIlwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBKUyBzdHJpY3QgY29tcGxpYW5jZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGhhZFRpbWVycyA9IGZhbHNlLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0galF1ZXJ5Ll9kYXRhKCB0aGlzICk7XG5cblx0XHRcdC8vIGNsZWFyIG1hcmtlciBjb3VudGVycyBpZiB3ZSBrbm93IHRoZXkgd29uJ3QgYmVcblx0XHRcdGlmICggIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5fdW5tYXJrKCB0cnVlLCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHN0b3BRdWV1ZSggZWxlbSwgZGF0YSwgaW5kZXggKSB7XG5cdFx0XHRcdHZhciBob29rcyA9IGRhdGFbIGluZGV4IF07XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBpbmRleCwgdHJ1ZSApO1xuXHRcdFx0XHRob29rcy5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZSA9PSBudWxsICkge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgaW5kZXguaW5kZXhPZihcIi5ydW5cIikgPT09IGluZGV4Lmxlbmd0aCAtIDQgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIHRoaXMsIGRhdGEsIGluZGV4ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBkYXRhWyBpbmRleCA9IHR5cGUgKyBcIi5ydW5cIiBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApe1xuXHRcdFx0XHRzdG9wUXVldWUoIHRoaXMsIGRhdGEsIGluZGV4ICk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUpICkge1xuXHRcdFx0XHRcdGlmICggZ290b0VuZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gZm9yY2UgdGhlIG5leHQgc3RlcCB0byBiZSB0aGUgbGFzdFxuXHRcdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdKCB0cnVlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5zYXZlU3RhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aGFkVGltZXJzID0gdHJ1ZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWRcblx0XHRcdC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXG5cdFx0XHQvLyBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZFxuXHRcdFx0aWYgKCAhKCBnb3RvRW5kICYmIGhhZFRpbWVycyApICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cbn0pO1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0c2V0VGltZW91dCggY2xlYXJGeE5vdywgMCApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG5mdW5jdGlvbiBjbGVhckZ4Tm93KCkge1xuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBudW0gKSB7XG5cdHZhciBvYmogPSB7fTtcblxuXHRqUXVlcnkuZWFjaCggZnhBdHRycy5jb25jYXQuYXBwbHkoW10sIGZ4QXR0cnMuc2xpY2UoIDAsIG51bSApKSwgZnVuY3Rpb24oKSB7XG5cdFx0b2JqWyB0aGlzIF0gPSB0eXBlO1xuXHR9KTtcblxuXHRyZXR1cm4gb2JqO1xufVxuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCh7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiLCAxICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiwgMSApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIsIDEgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHNwZWVkOiBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdFx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0XHR9O1xuXG5cdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcblx0XHRcdG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdFx0Ly8gbm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdFx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdFx0fVxuXG5cdFx0Ly8gUXVldWVpbmdcblx0XHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdFx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oIG5vVW5tYXJrICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG5vVW5tYXJrICE9PSBmYWxzZSApIHtcblx0XHRcdFx0alF1ZXJ5Ll91bm1hcmsoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIG9wdDtcblx0fSxcblxuXHRlYXNpbmc6IHtcblx0XHRsaW5lYXI6IGZ1bmN0aW9uKCBwLCBuLCBmaXJzdE51bSwgZGlmZiApIHtcblx0XHRcdHJldHVybiBmaXJzdE51bSArIGRpZmYgKiBwO1xuXHRcdH0sXG5cdFx0c3dpbmc6IGZ1bmN0aW9uKCBwLCBuLCBmaXJzdE51bSwgZGlmZiApIHtcblx0XHRcdHJldHVybiAoICggLU1hdGguY29zKCBwKk1hdGguUEkgKSAvIDIgKSArIDAuNSApICogZGlmZiArIGZpcnN0TnVtO1xuXHRcdH1cblx0fSxcblxuXHR0aW1lcnM6IFtdLFxuXG5cdGZ4OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCApIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblxuXHRcdG9wdGlvbnMub3JpZyA9IG9wdGlvbnMub3JpZyB8fCB7fTtcblx0fVxuXG59KTtcblxualF1ZXJ5LmZ4LnByb3RvdHlwZSA9IHtcblx0Ly8gU2ltcGxlIGZ1bmN0aW9uIGZvciBzZXR0aW5nIGEgc3R5bGUgdmFsdWVcblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdCggalF1ZXJ5LmZ4LnN0ZXBbIHRoaXMucHJvcCBdIHx8IGpRdWVyeS5meC5zdGVwLl9kZWZhdWx0ICkoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGN1cnJlbnQgc2l6ZVxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5lbGVtWyB0aGlzLnByb3AgXSAhPSBudWxsICYmICghdGhpcy5lbGVtLnN0eWxlIHx8IHRoaXMuZWxlbS5zdHlsZVsgdGhpcy5wcm9wIF0gPT0gbnVsbCkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtWyB0aGlzLnByb3AgXTtcblx0XHR9XG5cblx0XHR2YXIgcGFyc2VkLFxuXHRcdFx0ciA9IGpRdWVyeS5jc3MoIHRoaXMuZWxlbSwgdGhpcy5wcm9wICk7XG5cdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAsXG5cdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcyBpcyxcblx0XHQvLyBzaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdC5cblx0XHRyZXR1cm4gaXNOYU4oIHBhcnNlZCA9IHBhcnNlRmxvYXQoIHIgKSApID8gIXIgfHwgciA9PT0gXCJhdXRvXCIgPyAwIDogciA6IHBhcnNlZDtcblx0fSxcblxuXHQvLyBTdGFydCBhbiBhbmltYXRpb24gZnJvbSBvbmUgbnVtYmVyIHRvIGFub3RoZXJcblx0Y3VzdG9tOiBmdW5jdGlvbiggZnJvbSwgdG8sIHVuaXQgKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0ZnggPSBqUXVlcnkuZng7XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCk7XG5cdFx0dGhpcy5lbmQgPSB0bztcblx0XHR0aGlzLm5vdyA9IHRoaXMuc3RhcnQgPSBmcm9tO1xuXHRcdHRoaXMucG9zID0gdGhpcy5zdGF0ZSA9IDA7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCB0aGlzLnVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyB0aGlzLnByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblxuXHRcdGZ1bmN0aW9uIHQoIGdvdG9FbmQgKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5zdGVwKCBnb3RvRW5kICk7XG5cdFx0fVxuXG5cdFx0dC5xdWV1ZSA9IHRoaXMub3B0aW9ucy5xdWV1ZTtcblx0XHR0LmVsZW0gPSB0aGlzLmVsZW07XG5cdFx0dC5zYXZlU3RhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc2VsZi5vcHRpb25zLmhpZGUgJiYgalF1ZXJ5Ll9kYXRhKCBzZWxmLmVsZW0sIFwiZnhzaG93XCIgKyBzZWxmLnByb3AgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIHNlbGYuZWxlbSwgXCJmeHNob3dcIiArIHNlbGYucHJvcCwgc2VsZi5zdGFydCApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRpZiAoIHQoKSAmJiBqUXVlcnkudGltZXJzLnB1c2godCkgJiYgIXRpbWVySWQgKSB7XG5cdFx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGZ4LnRpY2ssIGZ4LmludGVydmFsICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFNpbXBsZSAnc2hvdycgZnVuY3Rpb25cblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGFTaG93ID0galF1ZXJ5Ll9kYXRhKCB0aGlzLmVsZW0sIFwiZnhzaG93XCIgKyB0aGlzLnByb3AgKTtcblxuXHRcdC8vIFJlbWVtYmVyIHdoZXJlIHdlIHN0YXJ0ZWQsIHNvIHRoYXQgd2UgY2FuIGdvIGJhY2sgdG8gaXQgbGF0ZXJcblx0XHR0aGlzLm9wdGlvbnMub3JpZ1sgdGhpcy5wcm9wIF0gPSBkYXRhU2hvdyB8fCBqUXVlcnkuc3R5bGUoIHRoaXMuZWxlbSwgdGhpcy5wcm9wICk7XG5cdFx0dGhpcy5vcHRpb25zLnNob3cgPSB0cnVlO1xuXG5cdFx0Ly8gQmVnaW4gdGhlIGFuaW1hdGlvblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlIHN0YXJ0IGF0IGEgc21hbGwgd2lkdGgvaGVpZ2h0IHRvIGF2b2lkIGFueSBmbGFzaCBvZiBjb250ZW50XG5cdFx0aWYgKCBkYXRhU2hvdyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gVGhpcyBzaG93IGlzIHBpY2tpbmcgdXAgd2hlcmUgYSBwcmV2aW91cyBoaWRlIG9yIHNob3cgbGVmdCBvZmZcblx0XHRcdHRoaXMuY3VzdG9tKCB0aGlzLmN1cigpLCBkYXRhU2hvdyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmN1c3RvbSggdGhpcy5wcm9wID09PSBcIndpZHRoXCIgfHwgdGhpcy5wcm9wID09PSBcImhlaWdodFwiID8gMSA6IDAsIHRoaXMuY3VyKCkgKTtcblx0XHR9XG5cblx0XHQvLyBTdGFydCBieSBzaG93aW5nIHRoZSBlbGVtZW50XG5cdFx0alF1ZXJ5KCB0aGlzLmVsZW0gKS5zaG93KCk7XG5cdH0sXG5cblx0Ly8gU2ltcGxlICdoaWRlJyBmdW5jdGlvblxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHQvLyBSZW1lbWJlciB3aGVyZSB3ZSBzdGFydGVkLCBzbyB0aGF0IHdlIGNhbiBnbyBiYWNrIHRvIGl0IGxhdGVyXG5cdFx0dGhpcy5vcHRpb25zLm9yaWdbIHRoaXMucHJvcCBdID0galF1ZXJ5Ll9kYXRhKCB0aGlzLmVsZW0sIFwiZnhzaG93XCIgKyB0aGlzLnByb3AgKSB8fCBqUXVlcnkuc3R5bGUoIHRoaXMuZWxlbSwgdGhpcy5wcm9wICk7XG5cdFx0dGhpcy5vcHRpb25zLmhpZGUgPSB0cnVlO1xuXG5cdFx0Ly8gQmVnaW4gdGhlIGFuaW1hdGlvblxuXHRcdHRoaXMuY3VzdG9tKCB0aGlzLmN1cigpLCAwICk7XG5cdH0sXG5cblx0Ly8gRWFjaCBzdGVwIG9mIGFuIGFuaW1hdGlvblxuXHRzdGVwOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHR2YXIgcCwgbiwgY29tcGxldGUsXG5cdFx0XHR0ID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGRvbmUgPSB0cnVlLFxuXHRcdFx0ZWxlbSA9IHRoaXMuZWxlbSxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAoIGdvdG9FbmQgfHwgdCA+PSBvcHRpb25zLmR1cmF0aW9uICsgdGhpcy5zdGFydFRpbWUgKSB7XG5cdFx0XHR0aGlzLm5vdyA9IHRoaXMuZW5kO1xuXHRcdFx0dGhpcy5wb3MgPSB0aGlzLnN0YXRlID0gMTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdG9wdGlvbnMuYW5pbWF0ZWRQcm9wZXJ0aWVzWyB0aGlzLnByb3AgXSA9IHRydWU7XG5cblx0XHRcdGZvciAoIHAgaW4gb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXMgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXNbIHAgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRkb25lID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkb25lICkge1xuXHRcdFx0XHQvLyBSZXNldCB0aGUgb3ZlcmZsb3dcblx0XHRcdFx0aWYgKCBvcHRpb25zLm92ZXJmbG93ICE9IG51bGwgJiYgIWpRdWVyeS5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkuZWFjaCggWyBcIlwiLCBcIlhcIiwgXCJZXCIgXSwgZnVuY3Rpb24oIGluZGV4LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc3R5bGVbIFwib3ZlcmZsb3dcIiArIHZhbHVlIF0gPSBvcHRpb25zLm92ZXJmbG93WyBpbmRleCBdO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGlkZSB0aGUgZWxlbWVudCBpZiB0aGUgXCJoaWRlXCIgb3BlcmF0aW9uIHdhcyBkb25lXG5cdFx0XHRcdGlmICggb3B0aW9ucy5oaWRlICkge1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc2V0IHRoZSBwcm9wZXJ0aWVzLCBpZiB0aGUgaXRlbSBoYXMgYmVlbiBoaWRkZW4gb3Igc2hvd25cblx0XHRcdFx0aWYgKCBvcHRpb25zLmhpZGUgfHwgb3B0aW9ucy5zaG93ICkge1xuXHRcdFx0XHRcdGZvciAoIHAgaW4gb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXMgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHAsIG9wdGlvbnMub3JpZ1sgcCBdICk7XG5cdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgXCJmeHNob3dcIiArIHAsIHRydWUgKTtcblx0XHRcdFx0XHRcdC8vIFRvZ2dsZSBkYXRhIGlzIG5vIGxvbmdlciBuZWVkZWRcblx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBcInRvZ2dsZVwiICsgcCwgdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGNvbXBsZXRlIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBjb21wbGV0ZSBmdW5jdGlvbiB0aHJvd3MgYW4gZXhjZXB0aW9uXG5cdFx0XHRcdC8vIHdlIG11c3QgZW5zdXJlIGl0IHdvbid0IGJlIGNhbGxlZCB0d2ljZS4gIzU2ODRcblxuXHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHRcdGlmICggY29tcGxldGUgKSB7XG5cblx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0Y29tcGxldGUuY2FsbCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBjbGFzc2ljYWwgZWFzaW5nIGNhbm5vdCBiZSB1c2VkIHdpdGggYW4gSW5maW5pdHkgZHVyYXRpb25cblx0XHRcdGlmICggb3B0aW9ucy5kdXJhdGlvbiA9PSBJbmZpbml0eSApIHtcblx0XHRcdFx0dGhpcy5ub3cgPSB0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0biA9IHQgLSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IG4gLyBvcHRpb25zLmR1cmF0aW9uO1xuXG5cdFx0XHRcdC8vIFBlcmZvcm0gdGhlIGVhc2luZyBmdW5jdGlvbiwgZGVmYXVsdHMgdG8gc3dpbmdcblx0XHRcdFx0dGhpcy5wb3MgPSBqUXVlcnkuZWFzaW5nWyBvcHRpb25zLmFuaW1hdGVkUHJvcGVydGllc1t0aGlzLnByb3BdIF0oIHRoaXMuc3RhdGUsIG4sIDAsIDEsIG9wdGlvbnMuZHVyYXRpb24gKTtcblx0XHRcdFx0dGhpcy5ub3cgPSB0aGlzLnN0YXJ0ICsgKCAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHRoaXMucG9zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBQZXJmb3JtIHRoZSBuZXh0IHN0ZXAgb2YgdGhlIGFuaW1hdGlvblxuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmZ4LCB7XG5cdHRpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aW1lcixcblx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0XHR9XG5cdH0sXG5cblx0aW50ZXJ2YWw6IDEzLFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblx0XHR0aW1lcklkID0gbnVsbDtcblx0fSxcblxuXHRzcGVlZHM6IHtcblx0XHRzbG93OiA2MDAsXG5cdFx0ZmFzdDogMjAwLFxuXHRcdC8vIERlZmF1bHQgc3BlZWRcblx0XHRfZGVmYXVsdDogNDAwXG5cdH0sXG5cblx0c3RlcDoge1xuXHRcdG9wYWNpdHk6IGZ1bmN0aW9uKCBmeCApIHtcblx0XHRcdGpRdWVyeS5zdHlsZSggZnguZWxlbSwgXCJvcGFjaXR5XCIsIGZ4Lm5vdyApO1xuXHRcdH0sXG5cblx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGZ4ICkge1xuXHRcdFx0aWYgKCBmeC5lbGVtLnN0eWxlICYmIGZ4LmVsZW0uc3R5bGVbIGZ4LnByb3AgXSAhPSBudWxsICkge1xuXHRcdFx0XHRmeC5lbGVtLnN0eWxlWyBmeC5wcm9wIF0gPSBmeC5ub3cgKyBmeC51bml0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZnguZWxlbVsgZngucHJvcCBdID0gZngubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEFkZHMgd2lkdGgvaGVpZ2h0IHN0ZXAgZnVuY3Rpb25zXG4vLyBEbyBub3Qgc2V0IGFueXRoaW5nIGJlbG93IDBcbmpRdWVyeS5lYWNoKFsgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuZnguc3RlcFsgcHJvcCBdID0gZnVuY3Rpb24oIGZ4ICkge1xuXHRcdGpRdWVyeS5zdHlsZSggZnguZWxlbSwgcHJvcCwgTWF0aC5tYXgoMCwgZngubm93KSArIGZ4LnVuaXQgKTtcblx0fTtcbn0pO1xuXG5pZiAoIGpRdWVyeS5leHByICYmIGpRdWVyeS5leHByLmZpbHRlcnMgKSB7XG5cdGpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdFx0fSkubGVuZ3RoO1xuXHR9O1xufVxuXG4vLyBUcnkgdG8gcmVzdG9yZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblxuXHRpZiAoICFlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSApIHtcblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHRcdGVsZW0gPSBqUXVlcnkoIFwiPFwiICsgbm9kZU5hbWUgKyBcIj5cIiApLmFwcGVuZFRvKCBib2R5ICksXG5cdFx0XHRkaXNwbGF5ID0gZWxlbS5jc3MoIFwiZGlzcGxheVwiICk7XG5cdFx0ZWxlbS5yZW1vdmUoKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLFxuXHRcdC8vIGdldCBlbGVtZW50J3MgcmVhbCBkZWZhdWx0IGRpc3BsYXkgYnkgYXR0YWNoaW5nIGl0IHRvIGEgdGVtcCBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHQvLyBObyBpZnJhbWUgdG8gdXNlIHlldCwgc28gY3JlYXRlIGl0XG5cdFx0XHRpZiAoICFpZnJhbWUgKSB7XG5cdFx0XHRcdGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaWZyYW1lXCIgKTtcblx0XHRcdFx0aWZyYW1lLmZyYW1lQm9yZGVyID0gaWZyYW1lLndpZHRoID0gaWZyYW1lLmhlaWdodCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGJvZHkuYXBwZW5kQ2hpbGQoIGlmcmFtZSApO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBjYWNoZWFibGUgY29weSBvZiB0aGUgaWZyYW1lIGRvY3VtZW50IG9uIGZpcnN0IGNhbGwuXG5cdFx0XHQvLyBJRSBhbmQgT3BlcmEgd2lsbCBhbGxvdyB1cyB0byByZXVzZSB0aGUgaWZyYW1lRG9jIHdpdGhvdXQgcmUtd3JpdGluZyB0aGUgZmFrZSBIVE1MXG5cdFx0XHQvLyBkb2N1bWVudCB0byBpdDsgV2ViS2l0ICYgRmlyZWZveCB3b24ndCBhbGxvdyByZXVzaW5nIHRoZSBpZnJhbWUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoICFpZnJhbWVEb2MgfHwgIWlmcmFtZS5jcmVhdGVFbGVtZW50ICkge1xuXHRcdFx0XHRpZnJhbWVEb2MgPSAoIGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQgKS5kb2N1bWVudDtcblx0XHRcdFx0aWZyYW1lRG9jLndyaXRlKCAoIGRvY3VtZW50LmNvbXBhdE1vZGUgPT09IFwiQ1NTMUNvbXBhdFwiID8gXCI8IWRvY3R5cGUgaHRtbD5cIiA6IFwiXCIgKSArIFwiPGh0bWw+PGJvZHk+XCIgKTtcblx0XHRcdFx0aWZyYW1lRG9jLmNsb3NlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0gPSBpZnJhbWVEb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKTtcblxuXHRcdFx0aWZyYW1lRG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblxuXHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRib2R5LnJlbW92ZUNoaWxkKCBpZnJhbWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG59XG5cblxuXG5cbnZhciBydGFibGUgPSAvXnQoPzphYmxlfGR8aCkkL2ksXG5cdHJyb290ID0gL14oPzpib2R5fGh0bWwpJC9pO1xuXG5pZiAoIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRqUXVlcnkuZm4ub2Zmc2V0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdLCBib3g7XG5cblx0XHRpZiAoIG9wdGlvbnMgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhZWxlbSB8fCAhZWxlbS5vd25lckRvY3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCBlbGVtID09PSBlbGVtLm93bmVyRG9jdW1lbnQuYm9keSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkub2Zmc2V0LmJvZHlPZmZzZXQoIGVsZW0gKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9IGNhdGNoKGUpIHt9XG5cblx0XHR2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWJveCB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94ID8geyB0b3A6IGJveC50b3AsIGxlZnQ6IGJveC5sZWZ0IH0gOiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHZhciBib2R5ID0gZG9jLmJvZHksXG5cdFx0XHR3aW4gPSBnZXRXaW5kb3coZG9jKSxcblx0XHRcdGNsaWVudFRvcCAgPSBkb2NFbGVtLmNsaWVudFRvcCAgfHwgYm9keS5jbGllbnRUb3AgIHx8IDAsXG5cdFx0XHRjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwLFxuXHRcdFx0c2Nyb2xsVG9wICA9IHdpbi5wYWdlWU9mZnNldCB8fCBqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCAmJiBkb2NFbGVtLnNjcm9sbFRvcCAgfHwgYm9keS5zY3JvbGxUb3AsXG5cdFx0XHRzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0IHx8IGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsICYmIGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQsXG5cdFx0XHR0b3AgID0gYm94LnRvcCAgKyBzY3JvbGxUb3AgIC0gY2xpZW50VG9wLFxuXHRcdFx0bGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cblx0XHRyZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuXHR9O1xuXG59IGVsc2Uge1xuXHRqUXVlcnkuZm4ub2Zmc2V0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXG5cdFx0aWYgKCBvcHRpb25zICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggIWVsZW0gfHwgIWVsZW0ub3duZXJEb2N1bWVudCApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmICggZWxlbSA9PT0gZWxlbS5vd25lckRvY3VtZW50LmJvZHkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5Lm9mZnNldC5ib2R5T2Zmc2V0KCBlbGVtICk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbXB1dGVkU3R5bGUsXG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCxcblx0XHRcdHByZXZPZmZzZXRQYXJlbnQgPSBlbGVtLFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG5cdFx0XHRib2R5ID0gZG9jLmJvZHksXG5cdFx0XHRkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0Vmlldyxcblx0XHRcdHByZXZDb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcgPyBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICkgOiBlbGVtLmN1cnJlbnRTdHlsZSxcblx0XHRcdHRvcCA9IGVsZW0ub2Zmc2V0VG9wLFxuXHRcdFx0bGVmdCA9IGVsZW0ub2Zmc2V0TGVmdDtcblxuXHRcdHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0gIT09IGJvZHkgJiYgZWxlbSAhPT0gZG9jRWxlbSApIHtcblx0XHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuZml4ZWRQb3NpdGlvbiAmJiBwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29tcHV0ZWRTdHlsZSA9IGRlZmF1bHRWaWV3ID8gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKSA6IGVsZW0uY3VycmVudFN0eWxlO1xuXHRcdFx0dG9wICAtPSBlbGVtLnNjcm9sbFRvcDtcblx0XHRcdGxlZnQgLT0gZWxlbS5zY3JvbGxMZWZ0O1xuXG5cdFx0XHRpZiAoIGVsZW0gPT09IG9mZnNldFBhcmVudCApIHtcblx0XHRcdFx0dG9wICArPSBlbGVtLm9mZnNldFRvcDtcblx0XHRcdFx0bGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5kb2VzTm90QWRkQm9yZGVyICYmICEoalF1ZXJ5LnN1cHBvcnQuZG9lc0FkZEJvcmRlckZvclRhYmxlQW5kQ2VsbHMgJiYgcnRhYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkpICkge1xuXHRcdFx0XHRcdHRvcCAgKz0gcGFyc2VGbG9hdCggY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCAgKSB8fCAwO1xuXHRcdFx0XHRcdGxlZnQgKz0gcGFyc2VGbG9hdCggY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGggKSB8fCAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJldk9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuc3VidHJhY3RzQm9yZGVyRm9yT3ZlcmZsb3dOb3RWaXNpYmxlICYmIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiICkge1xuXHRcdFx0XHR0b3AgICs9IHBhcnNlRmxvYXQoIGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGggICkgfHwgMDtcblx0XHRcdFx0bGVmdCArPSBwYXJzZUZsb2F0KCBjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCApIHx8IDA7XG5cdFx0XHR9XG5cblx0XHRcdHByZXZDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcblx0XHR9XG5cblx0XHRpZiAoIHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcHJldkNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHR0b3AgICs9IGJvZHkub2Zmc2V0VG9wO1xuXHRcdFx0bGVmdCArPSBib2R5Lm9mZnNldExlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5maXhlZFBvc2l0aW9uICYmIHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHR0b3AgICs9IE1hdGgubWF4KCBkb2NFbGVtLnNjcm9sbFRvcCwgYm9keS5zY3JvbGxUb3AgKTtcblx0XHRcdGxlZnQgKz0gTWF0aC5tYXgoIGRvY0VsZW0uc2Nyb2xsTGVmdCwgYm9keS5zY3JvbGxMZWZ0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcblx0fTtcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblxuXHRib2R5T2Zmc2V0OiBmdW5jdGlvbiggYm9keSApIHtcblx0XHR2YXIgdG9wID0gYm9keS5vZmZzZXRUb3AsXG5cdFx0XHRsZWZ0ID0gYm9keS5vZmZzZXRMZWZ0O1xuXG5cdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCApIHtcblx0XHRcdHRvcCAgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyhib2R5LCBcIm1hcmdpblRvcFwiKSApIHx8IDA7XG5cdFx0XHRsZWZ0ICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoYm9keSwgXCJtYXJnaW5MZWZ0XCIpICkgfHwgMDtcblx0XHR9XG5cblx0XHRyZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuXHR9LFxuXG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICk7XG5cblx0XHQvLyBzZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCksXG5cdFx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICksXG5cdFx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKSxcblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJiBqUXVlcnkuaW5BcnJheShcImF1dG9cIiwgW2N1ckNTU1RvcCwgY3VyQ1NTTGVmdF0pID4gLTEsXG5cdFx0XHRwcm9wcyA9IHt9LCBjdXJQb3NpdGlvbiA9IHt9LCBjdXJUb3AsIGN1ckxlZnQ7XG5cblx0XHQvLyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBjdXJPZmZzZXQgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWzBdICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdLFxuXG5cdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpLFxuXG5cdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXG5cdFx0cGFyZW50T2Zmc2V0ID0gcnJvb3QudGVzdChvZmZzZXRQYXJlbnRbMF0ubm9kZU5hbWUpID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblxuXHRcdC8vIFN1YnRyYWN0IGVsZW1lbnQgbWFyZ2luc1xuXHRcdC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG5cdFx0Ly8gYXJlIHRoZSBzYW1lIGluIFNhZmFyaSBjYXVzaW5nIG9mZnNldC5sZWZ0IHRvIGluY29ycmVjdGx5IGJlIDBcblx0XHRvZmZzZXQudG9wICAtPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luVG9wXCIpICkgfHwgMDtcblx0XHRvZmZzZXQubGVmdCAtPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luTGVmdFwiKSApIHx8IDA7XG5cblx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRwYXJlbnRPZmZzZXQudG9wICArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJUb3BXaWR0aFwiKSApIHx8IDA7XG5cdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnRbMF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIpICkgfHwgMDtcblxuXHRcdC8vIFN1YnRyYWN0IHRoZSB0d28gb2Zmc2V0c1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6ICBvZmZzZXQudG9wICAtIHBhcmVudE9mZnNldC50b3AsXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgKCFycm9vdC50ZXN0KG9mZnNldFBhcmVudC5ub2RlTmFtZSkgJiYgalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCIpICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudDtcblx0XHR9KTtcblx0fVxufSk7XG5cblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggW1wiTGVmdFwiLCBcIlRvcFwiXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBtZXRob2QgPSBcInNjcm9sbFwiICsgbmFtZTtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHR2YXIgZWxlbSwgd2luO1xuXG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRoZSBzY3JvbGwgb2Zmc2V0XG5cdFx0XHRyZXR1cm4gd2luID8gKFwicGFnZVhPZmZzZXRcIiBpbiB3aW4pID8gd2luWyBpID8gXCJwYWdlWU9mZnNldFwiIDogXCJwYWdlWE9mZnNldFwiIF0gOlxuXHRcdFx0XHRqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCAmJiB3aW4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBtZXRob2QgXSB8fFxuXHRcdFx0XHRcdHdpbi5kb2N1bWVudC5ib2R5WyBtZXRob2QgXSA6XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgc2Nyb2xsIG9mZnNldFxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW4gPSBnZXRXaW5kb3coIHRoaXMgKTtcblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhaSA/IHZhbCA6IGpRdWVyeSggd2luICkuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0XHRcdCBpID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxUb3AoKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/XG5cdFx0ZWxlbSA6XG5cdFx0ZWxlbS5ub2RlVHlwZSA9PT0gOSA/XG5cdFx0XHRlbGVtLmRlZmF1bHRWaWV3IHx8IGVsZW0ucGFyZW50V2luZG93IDpcblx0XHRcdGZhbHNlO1xufVxuXG5cblxuXG4vLyBDcmVhdGUgd2lkdGgsIGhlaWdodCwgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKFsgXCJIZWlnaHRcIiwgXCJXaWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdHZhciB0eXBlID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIGlubmVySGVpZ2h0IGFuZCBpbm5lcldpZHRoXG5cdGpRdWVyeS5mblsgXCJpbm5lclwiICsgbmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdHJldHVybiBlbGVtID9cblx0XHRcdGVsZW0uc3R5bGUgP1xuXHRcdFx0cGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgXCJwYWRkaW5nXCIgKSApIDpcblx0XHRcdHRoaXNbIHR5cGUgXSgpIDpcblx0XHRcdG51bGw7XG5cdH07XG5cblx0Ly8gb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGhcblx0alF1ZXJ5LmZuWyBcIm91dGVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1swXTtcblx0XHRyZXR1cm4gZWxlbSA/XG5cdFx0XHRlbGVtLnN0eWxlID9cblx0XHRcdHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIG1hcmdpbiA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICkgKSA6XG5cdFx0XHR0aGlzWyB0eXBlIF0oKSA6XG5cdFx0XHRudWxsO1xuXHR9O1xuXG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIHNpemUgKSB7XG5cdFx0Ly8gR2V0IHdpbmRvdyB3aWR0aCBvciBoZWlnaHRcblx0XHR2YXIgZWxlbSA9IHRoaXNbMF07XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiBzaXplID09IG51bGwgPyBudWxsIDogdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzaXplICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRzZWxmWyB0eXBlIF0oIHNpemUuY2FsbCggdGhpcywgaSwgc2VsZlsgdHlwZSBdKCkgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdC8vIEV2ZXJ5b25lIGVsc2UgdXNlIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCBvciBkb2N1bWVudC5ib2R5IGRlcGVuZGluZyBvbiBRdWlya3MgdnMgU3RhbmRhcmRzIG1vZGVcblx0XHRcdC8vIDNyZCBjb25kaXRpb24gYWxsb3dzIE5va2lhIHN1cHBvcnQsIGFzIGl0IHN1cHBvcnRzIHRoZSBkb2NFbGVtIHByb3AgYnV0IG5vdCBDU1MxQ29tcGF0XG5cdFx0XHR2YXIgZG9jRWxlbVByb3AgPSBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXSxcblx0XHRcdFx0Ym9keSA9IGVsZW0uZG9jdW1lbnQuYm9keTtcblx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmNvbXBhdE1vZGUgPT09IFwiQ1NTMUNvbXBhdFwiICYmIGRvY0VsZW1Qcm9wIHx8XG5cdFx0XHRcdGJvZHkgJiYgYm9keVsgXCJjbGllbnRcIiArIG5hbWUgXSB8fCBkb2NFbGVtUHJvcDtcblxuXHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdLCB3aGljaGV2ZXIgaXMgZ3JlYXRlclxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRlbGVtLmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiICsgbmFtZV0sXG5cdFx0XHRcdGVsZW0uYm9keVtcInNjcm9sbFwiICsgbmFtZV0sIGVsZW0uZG9jdW1lbnRFbGVtZW50W1wic2Nyb2xsXCIgKyBuYW1lXSxcblx0XHRcdFx0ZWxlbS5ib2R5W1wib2Zmc2V0XCIgKyBuYW1lXSwgZWxlbS5kb2N1bWVudEVsZW1lbnRbXCJvZmZzZXRcIiArIG5hbWVdXG5cdFx0XHQpO1xuXG5cdFx0Ly8gR2V0IG9yIHNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHR9IGVsc2UgaWYgKCBzaXplID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YXIgb3JpZyA9IGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdFx0cmV0ID0gcGFyc2VGbG9hdCggb3JpZyApO1xuXG5cdFx0XHRyZXR1cm4galF1ZXJ5LmlzTnVtZXJpYyggcmV0ICkgPyByZXQgOiBvcmlnO1xuXG5cdFx0Ly8gU2V0IHRoZSB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQgKGRlZmF1bHQgdG8gcGl4ZWxzIGlmIHZhbHVlIGlzIHVuaXRsZXNzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jc3MoIHR5cGUsIHR5cGVvZiBzaXplID09PSBcInN0cmluZ1wiID8gc2l6ZSA6IHNpemUgKyBcInB4XCIgKTtcblx0XHR9XG5cdH07XG5cbn0pO1xuXG5cblxuXG4vLyBFeHBvc2UgalF1ZXJ5IHRvIHRoZSBnbG9iYWwgb2JqZWN0XG53aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG5cbi8vIEV4cG9zZSBqUXVlcnkgYXMgYW4gQU1EIG1vZHVsZSwgYnV0IG9ubHkgZm9yIEFNRCBsb2FkZXJzIHRoYXRcbi8vIHVuZGVyc3RhbmQgdGhlIGlzc3VlcyB3aXRoIGxvYWRpbmcgbXVsdGlwbGUgdmVyc2lvbnMgb2YgalF1ZXJ5XG4vLyBpbiBhIHBhZ2UgdGhhdCBhbGwgbWlnaHQgY2FsbCBkZWZpbmUoKS4gVGhlIGxvYWRlciB3aWxsIGluZGljYXRlXG4vLyB0aGV5IGhhdmUgc3BlY2lhbCBhbGxvd2FuY2VzIGZvciBtdWx0aXBsZSBqUXVlcnkgdmVyc2lvbnMgYnlcbi8vIHNwZWNpZnlpbmcgZGVmaW5lLmFtZC5qUXVlcnkgPSB0cnVlLiBSZWdpc3RlciBhcyBhIG5hbWVkIG1vZHVsZSxcbi8vIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXIgZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSxcbi8vIGJ1dCBub3QgdXNlIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXQgdW5kZXJzdGFuZHMgYW5vbnltb3VzXG4vLyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdCB3YXkgdG8gcmVnaXN0ZXIuXG4vLyBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZSBkZXJpdmVkIGZyb21cbi8vIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlIGZpbGUgbmFtZS5cbi8vIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHMgdG8gY2FsbFxuLy8gbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lLmFtZC5qUXVlcnkgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpRdWVyeTsgfSApO1xufVxuXG5cblxufSkoIHdpbmRvdyApO1xuXG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiAkICE9IFwidW5kZWZpbmVkXCIgPyAkIDogd2luZG93LiQpO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGRlZmluZUV4cG9ydChleCkgeyBtb2R1bGUuZXhwb3J0cyA9IGV4OyB9KTtcblxufSkod2luZG93KSIsIihmdW5jdGlvbihnbG9iYWwpeyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGRlZmluZSkge1xuXG47IGdsb2JhbC4kID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbi8qXG4gKiBqUXVlcnkgSG90a2V5cyBQbHVnaW5cbiAqIENvcHlyaWdodCAyMDEwLCBKb2huIFJlc2lnXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiAqXG4gKiBCYXNlZCB1cG9uIHRoZSBwbHVnaW4gYnkgVHp1cnkgQmFyIFlvY2hheTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90enVyeWJ5L2pxdWVyeS5ob3RrZXlzXG4gKlxuICogT3JpZ2luYWwgaWRlYSBieTpcbiAqIEJpbm55IFYgQSwgaHR0cDovL3d3dy5vcGVuanMuY29tL3NjcmlwdHMvZXZlbnRzL2tleWJvYXJkX3Nob3J0Y3V0cy9cbiovXG5cbihmdW5jdGlvbihqUXVlcnkpe1xuXG5cdGpRdWVyeS5ob3RrZXlzID0ge1xuXHRcdHZlcnNpb246IFwiMC44XCIsXG5cblx0XHRzcGVjaWFsS2V5czoge1xuXHRcdFx0ODogXCJiYWNrc3BhY2VcIiwgOTogXCJ0YWJcIiwgMTM6IFwicmV0dXJuXCIsIDE2OiBcInNoaWZ0XCIsIDE3OiBcImN0cmxcIiwgMTg6IFwiYWx0XCIsIDE5OiBcInBhdXNlXCIsXG5cdFx0XHQyMDogXCJjYXBzbG9ja1wiLCAyNzogXCJlc2NcIiwgMzI6IFwic3BhY2VcIiwgMzM6IFwicGFnZXVwXCIsIDM0OiBcInBhZ2Vkb3duXCIsIDM1OiBcImVuZFwiLCAzNjogXCJob21lXCIsXG5cdFx0XHQzNzogXCJsZWZ0XCIsIDM4OiBcInVwXCIsIDM5OiBcInJpZ2h0XCIsIDQwOiBcImRvd25cIiwgNDU6IFwiaW5zZXJ0XCIsIDQ2OiBcImRlbFwiLFxuXHRcdFx0OTY6IFwiMFwiLCA5NzogXCIxXCIsIDk4OiBcIjJcIiwgOTk6IFwiM1wiLCAxMDA6IFwiNFwiLCAxMDE6IFwiNVwiLCAxMDI6IFwiNlwiLCAxMDM6IFwiN1wiLFxuXHRcdFx0MTA0OiBcIjhcIiwgMTA1OiBcIjlcIiwgMTA2OiBcIipcIiwgMTA3OiBcIitcIiwgMTA5OiBcIi1cIiwgMTEwOiBcIi5cIiwgMTExIDogXCIvXCIsXG5cdFx0XHQxMTI6IFwiZjFcIiwgMTEzOiBcImYyXCIsIDExNDogXCJmM1wiLCAxMTU6IFwiZjRcIiwgMTE2OiBcImY1XCIsIDExNzogXCJmNlwiLCAxMTg6IFwiZjdcIiwgMTE5OiBcImY4XCIsXG5cdFx0XHQxMjA6IFwiZjlcIiwgMTIxOiBcImYxMFwiLCAxMjI6IFwiZjExXCIsIDEyMzogXCJmMTJcIiwgMTQ0OiBcIm51bWxvY2tcIiwgMTQ1OiBcInNjcm9sbFwiLCAxOTE6IFwiL1wiLCAyMjQ6IFwibWV0YVwiXG5cdFx0fSxcblxuXHRcdHNoaWZ0TnVtczoge1xuXHRcdFx0XCJgXCI6IFwiflwiLCBcIjFcIjogXCIhXCIsIFwiMlwiOiBcIkBcIiwgXCIzXCI6IFwiI1wiLCBcIjRcIjogXCIkXCIsIFwiNVwiOiBcIiVcIiwgXCI2XCI6IFwiXlwiLCBcIjdcIjogXCImXCIsXG5cdFx0XHRcIjhcIjogXCIqXCIsIFwiOVwiOiBcIihcIiwgXCIwXCI6IFwiKVwiLCBcIi1cIjogXCJfXCIsIFwiPVwiOiBcIitcIiwgXCI7XCI6IFwiOiBcIiwgXCInXCI6IFwiXFxcIlwiLCBcIixcIjogXCI8XCIsXG5cdFx0XHRcIi5cIjogXCI+XCIsICBcIi9cIjogXCI/XCIsICBcIlxcXFxcIjogXCJ8XCJcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24ga2V5SGFuZGxlciggaGFuZGxlT2JqICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0b3BFdmVudCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBldnQuY2FuY2VsQnViYmxlPXRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5yZXR1cm5WYWx1ZT1mYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LmtleUNvZGU9MDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuXHRcdC8vIE9ubHkgY2FyZSB3aGVuIGEgcG9zc2libGUgaW5wdXQgaGFzIGJlZW4gc3BlY2lmaWVkXG5cdFx0aWYgKCB0eXBlb2YgaGFuZGxlT2JqLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9yaWdIYW5kbGVyID0gaGFuZGxlT2JqLmhhbmRsZXIsXG5cdFx0XHRrZXlzID0gaGFuZGxlT2JqLmRhdGEudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIik7XG5cblx0XHRoYW5kbGVPYmouaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdC8vIERvbid0IGZpcmUgaW4gdGV4dC1hY2NlcHRpbmcgaW5wdXRzIHRoYXQgd2UgZGlkbid0IGRpcmVjdGx5IGJpbmQgdG9cblx0XHRcdGlmICggdGhpcyAhPT0gZXZlbnQudGFyZ2V0ICYmICgvdGV4dGFyZWF8c2VsZWN0L2kudGVzdCggZXZlbnQudGFyZ2V0Lm5vZGVOYW1lICkgfHxcblx0XHRcdFx0IGV2ZW50LnRhcmdldC50eXBlID09PSBcInRleHRcIikgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2V5cHJlc3MgcmVwcmVzZW50cyBjaGFyYWN0ZXJzLCBub3Qgc3BlY2lhbCBrZXlzXG5cdFx0XHR2YXIgc3BlY2lhbCA9IGV2ZW50LnR5cGUgIT09IFwia2V5cHJlc3NcIiAmJiBqUXVlcnkuaG90a2V5cy5zcGVjaWFsS2V5c1sgZXZlbnQud2hpY2ggXSxcblx0XHRcdFx0Y2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZSggZXZlbnQud2hpY2ggKS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRrZXksIG1vZGlmID0gXCJcIiwgcG9zc2libGUgPSB7fTtcblxuXHRcdFx0Ly8gY2hlY2sgY29tYmluYXRpb25zIChhbHR8Y3RybHxzaGlmdCthbnl0aGluZylcblx0XHRcdGlmICggZXZlbnQuYWx0S2V5ICYmIHNwZWNpYWwgIT09IFwiYWx0XCIgKSB7XG5cdFx0XHRcdG1vZGlmICs9IFwiYWx0K1wiO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgJiYgc3BlY2lhbCAhPT0gXCJjdHJsXCIgKSB7XG5cdFx0XHRcdG1vZGlmICs9IFwiY3RybCtcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogTmVlZCB0byBtYWtlIHN1cmUgdGhpcyB3b3JrcyBjb25zaXN0ZW50bHkgYWNyb3NzIHBsYXRmb3Jtc1xuXHRcdFx0aWYgKCBldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5ICYmIHNwZWNpYWwgIT09IFwibWV0YVwiICkge1xuXHRcdFx0XHRtb2RpZiArPSBcIm1ldGErXCI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZXZlbnQuc2hpZnRLZXkgJiYgc3BlY2lhbCAhPT0gXCJzaGlmdFwiICkge1xuXHRcdFx0XHRtb2RpZiArPSBcInNoaWZ0K1wiO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdHBvc3NpYmxlWyBtb2RpZiArIHNwZWNpYWwgXSA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc3NpYmxlWyBtb2RpZiArIGNoYXJhY3RlciBdID0gdHJ1ZTtcblx0XHRcdFx0cG9zc2libGVbIG1vZGlmICsgalF1ZXJ5LmhvdGtleXMuc2hpZnROdW1zWyBjaGFyYWN0ZXIgXSBdID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBcIiRcIiBjYW4gYmUgdHJpZ2dlcmVkIGFzIFwiU2hpZnQrNFwiIG9yIFwiU2hpZnQrJFwiIG9yIGp1c3QgXCIkXCJcblx0XHRcdFx0aWYgKCBtb2RpZiA9PT0gXCJzaGlmdCtcIiApIHtcblx0XHRcdFx0XHRwb3NzaWJsZVsgalF1ZXJ5LmhvdGtleXMuc2hpZnROdW1zWyBjaGFyYWN0ZXIgXSBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBwb3NzaWJsZVsga2V5c1tpXSBdICkge1xuXHRcdFx0XHRcdHZhciByZXQgPSBvcmlnSGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuXG5cdFx0fTtcblx0fVxuXG5cdGpRdWVyeS5lYWNoKFsgXCJrZXlkb3duXCIsIFwia2V5dXBcIiwgXCJrZXlwcmVzc1wiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0aGlzIF0gPSB7YWRkOiBrZXlIYW5kbGVyfTtcblx0fSk7XG5cbn0pKCBqUXVlcnkgKTtcblxufSkuY2FsbChnbG9iYWwsIG1vZHVsZSwgdW5kZWZpbmVkKTtcblxufSkod2luZG93KSIsIihmdW5jdGlvbihnbG9iYWwpeyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGRlZmluZSkge1xuXG47IGdsb2JhbC4kID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbi8qISBDb3B5cmlnaHQgKGMpIDIwMTEgQnJhbmRvbiBBYXJvbiAoaHR0cDovL2JyYW5kb25hYXJvbi5uZXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKExJQ0VOU0UudHh0KS5cbiAqXG4gKiBUaGFua3MgdG86IGh0dHA6Ly9hZG9tYXMub3JnL2phdmFzY3JpcHQtbW91c2Utd2hlZWwvIGZvciBzb21lIHBvaW50ZXJzLlxuICogVGhhbmtzIHRvOiBNYXRoaWFzIEJhbmsoaHR0cDovL3d3dy5tYXRoaWFzLWJhbmsuZGUpIGZvciBhIHNjb3BlIGJ1ZyBmaXguXG4gKiBUaGFua3MgdG86IFNlYW11cyBMZWFoeSBmb3IgYWRkaW5nIGRlbHRhWCBhbmQgZGVsdGFZXG4gKlxuICogVmVyc2lvbjogMy4wLjZcbiAqXG4gKiBSZXF1aXJlczogMS4yLjIrXG4gKi9cblxuKGZ1bmN0aW9uKCQpIHtcblxudmFyIHR5cGVzID0gWydET01Nb3VzZVNjcm9sbCcsICdtb3VzZXdoZWVsJ107XG5cbmlmICgkLmV2ZW50LmZpeEhvb2tzKSB7XG4gICAgZm9yICggdmFyIGk9dHlwZXMubGVuZ3RoOyBpOyApIHtcbiAgICAgICAgJC5ldmVudC5maXhIb29rc1sgdHlwZXNbLS1pXSBdID0gJC5ldmVudC5tb3VzZUhvb2tzO1xuICAgIH1cbn1cblxuJC5ldmVudC5zcGVjaWFsLm1vdXNld2hlZWwgPSB7XG4gICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgIGZvciAoIHZhciBpPXR5cGVzLmxlbmd0aDsgaTsgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCB0eXBlc1stLWldLCBoYW5kbGVyLCBmYWxzZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbm1vdXNld2hlZWwgPSBoYW5kbGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaT10eXBlcy5sZW5ndGg7IGk7ICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZXNbLS1pXSwgaGFuZGxlciwgZmFsc2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZXdoZWVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbiQuZm4uZXh0ZW5kKHtcbiAgICBtb3VzZXdoZWVsOiBmdW5jdGlvbihmbikge1xuICAgICAgICByZXR1cm4gZm4gPyB0aGlzLmJpbmQoXCJtb3VzZXdoZWVsXCIsIGZuKSA6IHRoaXMudHJpZ2dlcihcIm1vdXNld2hlZWxcIik7XG4gICAgfSxcblxuICAgIHVubW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5iaW5kKFwibW91c2V3aGVlbFwiLCBmbik7XG4gICAgfVxufSk7XG5cblxuZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgIHZhciBvcmdFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudCwgYXJncyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLCBkZWx0YSA9IDAsIHJldHVyblZhbHVlID0gdHJ1ZSwgZGVsdGFYID0gMCwgZGVsdGFZID0gMDtcbiAgICBldmVudCA9ICQuZXZlbnQuZml4KG9yZ0V2ZW50KTtcbiAgICBldmVudC50eXBlID0gXCJtb3VzZXdoZWVsXCI7XG5cbiAgICAvLyBPbGQgc2Nob29sIHNjcm9sbHdoZWVsIGRlbHRhXG4gICAgaWYgKCBvcmdFdmVudC53aGVlbERlbHRhICkgeyBkZWx0YSA9IG9yZ0V2ZW50LndoZWVsRGVsdGEvMTIwOyB9XG4gICAgaWYgKCBvcmdFdmVudC5kZXRhaWwgICAgICkgeyBkZWx0YSA9IC1vcmdFdmVudC5kZXRhaWwvMzsgfVxuXG4gICAgLy8gTmV3IHNjaG9vbCBtdWx0aWRpbWVuc2lvbmFsIHNjcm9sbCAodG91Y2hwYWRzKSBkZWx0YXNcbiAgICBkZWx0YVkgPSBkZWx0YTtcblxuICAgIC8vIEdlY2tvXG4gICAgaWYgKCBvcmdFdmVudC5heGlzICE9PSB1bmRlZmluZWQgJiYgb3JnRXZlbnQuYXhpcyA9PT0gb3JnRXZlbnQuSE9SSVpPTlRBTF9BWElTICkge1xuICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICBkZWx0YVggPSAtMSpkZWx0YTtcbiAgICB9XG5cbiAgICAvLyBXZWJraXRcbiAgICBpZiAoIG9yZ0V2ZW50LndoZWVsRGVsdGFZICE9PSB1bmRlZmluZWQgKSB7IGRlbHRhWSA9IG9yZ0V2ZW50LndoZWVsRGVsdGFZLzEyMDsgfVxuICAgIGlmICggb3JnRXZlbnQud2hlZWxEZWx0YVggIT09IHVuZGVmaW5lZCApIHsgZGVsdGFYID0gLTEqb3JnRXZlbnQud2hlZWxEZWx0YVgvMTIwOyB9XG5cbiAgICAvLyBBZGQgZXZlbnQgYW5kIGRlbHRhIHRvIHRoZSBmcm9udCBvZiB0aGUgYXJndW1lbnRzXG4gICAgYXJncy51bnNoaWZ0KGV2ZW50LCBkZWx0YSwgZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgcmV0dXJuICgkLmV2ZW50LmRpc3BhdGNoIHx8ICQuZXZlbnQuaGFuZGxlKS5hcHBseSh0aGlzLCBhcmdzKTtcbn1cblxufSkoalF1ZXJ5KTtcblxufSkuY2FsbChnbG9iYWwsIG1vZHVsZSwgdW5kZWZpbmVkKTtcblxufSkod2luZG93KSIsIihmdW5jdGlvbihnbG9iYWwpeyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGRlZmluZSwgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18pIHtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbkRldGVjdG9yID0ge1xuXG5cdGNhbnZhcyA6ICEhIHdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG5cdHdlYmdsIDogKCBmdW5jdGlvbiAoKSB7IHRyeSB7IHJldHVybiAhISB3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmICEhIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICkuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcgKTsgfSBjYXRjaCggZSApIHsgcmV0dXJuIGZhbHNlOyB9IH0gKSgpLFxuXHR3b3JrZXJzIDogISEgd2luZG93Lldvcmtlcixcblx0ZmlsZWFwaSA6IHdpbmRvdy5GaWxlICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlTGlzdCAmJiB3aW5kb3cuQmxvYixcblxuXHRnZXRXZWJHTEVycm9yTWVzc2FnZSA6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblxuXHRcdGRvbUVsZW1lbnQuc3R5bGUuZm9udEZhbWlseSA9ICdtb25vc3BhY2UnO1xuXHRcdGRvbUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnMTNweCc7XG5cdFx0ZG9tRWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRkb21FbGVtZW50LnN0eWxlLmJhY2tncm91bmQgPSAnI2VlZSc7XG5cdFx0ZG9tRWxlbWVudC5zdHlsZS5jb2xvciA9ICcjMDAwJztcblx0XHRkb21FbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMWVtJztcblx0XHRkb21FbGVtZW50LnN0eWxlLndpZHRoID0gJzQ3NXB4Jztcblx0XHRkb21FbGVtZW50LnN0eWxlLm1hcmdpbiA9ICc1ZW0gYXV0byAwJztcblxuXHRcdGlmICggISB0aGlzLndlYmdsICkge1xuXG5cdFx0XHRkb21FbGVtZW50LmlubmVySFRNTCA9IHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgPyBbXG5cdFx0XHRcdCdZb3VyIGdyYXBoaWNzIGNhcmQgZG9lcyBub3Qgc2VlbSB0byBzdXBwb3J0IDxhIGhyZWY9XCJodHRwOi8va2hyb25vcy5vcmcvd2ViZ2wvd2lraS9HZXR0aW5nX2FfV2ViR0xfSW1wbGVtZW50YXRpb25cIj5XZWJHTDwvYT4uPGJyIC8+Jyxcblx0XHRcdFx0J0ZpbmQgb3V0IGhvdyB0byBnZXQgaXQgPGEgaHJlZj1cImh0dHA6Ly9nZXQud2ViZ2wub3JnL1wiPmhlcmU8L2E+Lidcblx0XHRcdF0uam9pbiggJ1xcbicgKSA6IFtcblx0XHRcdFx0J1lvdXIgYnJvd3NlciBkb2VzIG5vdCBzZWVtIHRvIHN1cHBvcnQgPGEgaHJlZj1cImh0dHA6Ly9raHJvbm9zLm9yZy93ZWJnbC93aWtpL0dldHRpbmdfYV9XZWJHTF9JbXBsZW1lbnRhdGlvblwiPldlYkdMPC9hPi48YnIvPicsXG5cdFx0XHRcdCdGaW5kIG91dCBob3cgdG8gZ2V0IGl0IDxhIGhyZWY9XCJodHRwOi8vZ2V0LndlYmdsLm9yZy9cIj5oZXJlPC9hPi4nXG5cdFx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZG9tRWxlbWVudDtcblxuXHR9LFxuXG5cdGFkZEdldFdlYkdMTWVzc2FnZSA6IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRcdHZhciBwYXJlbnQsIGlkLCBkb21FbGVtZW50O1xuXG5cdFx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0XHRwYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wYXJlbnQgOiBkb2N1bWVudC5ib2R5O1xuXHRcdGlkID0gcGFyYW1ldGVycy5pZCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5pZCA6ICdvbGRpZSc7XG5cblx0XHRkb21FbGVtZW50ID0gRGV0ZWN0b3IuZ2V0V2ViR0xFcnJvck1lc3NhZ2UoKTtcblx0XHRkb21FbGVtZW50LmlkID0gaWQ7XG5cblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoIGRvbUVsZW1lbnQgKTtcblxuXHR9XG5cbn07XG5cbjsgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18odHlwZW9mIERldGVjdG9yICE9IFwidW5kZWZpbmVkXCIgPyBEZXRlY3RvciA6IHdpbmRvdy5EZXRlY3Rvcik7XG5cbn0pLmNhbGwoZ2xvYmFsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuXG59KSh3aW5kb3cpIiwiKGZ1bmN0aW9uKGdsb2JhbCl7KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLy8gaHR0cDovL21ybC5ueXUuZWR1L35wZXJsaW4vbm9pc2UvXG5cbnZhciBJbXByb3ZlZE5vaXNlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBwID0gWzE1MSwxNjAsMTM3LDkxLDkwLDE1LDEzMSwxMywyMDEsOTUsOTYsNTMsMTk0LDIzMyw3LDIyNSwxNDAsMzYsMTAzLDMwLDY5LDE0Miw4LDk5LDM3LDI0MCwyMSwxMCxcblx0XHQgMjMsMTkwLDYsMTQ4LDI0NywxMjAsMjM0LDc1LDAsMjYsMTk3LDYyLDk0LDI1MiwyMTksMjAzLDExNywzNSwxMSwzMiw1NywxNzcsMzMsODgsMjM3LDE0OSw1Niw4Nyxcblx0XHQgMTc0LDIwLDEyNSwxMzYsMTcxLDE2OCw2OCwxNzUsNzQsMTY1LDcxLDEzNCwxMzksNDgsMjcsMTY2LDc3LDE0NiwxNTgsMjMxLDgzLDExMSwyMjksMTIyLDYwLDIxMSxcblx0XHQgMTMzLDIzMCwyMjAsMTA1LDkyLDQxLDU1LDQ2LDI0NSw0MCwyNDQsMTAyLDE0Myw1NCw2NSwyNSw2MywxNjEsMSwyMTYsODAsNzMsMjA5LDc2LDEzMiwxODcsMjA4LFxuXHRcdCA4OSwxOCwxNjksMjAwLDE5NiwxMzUsMTMwLDExNiwxODgsMTU5LDg2LDE2NCwxMDAsMTA5LDE5OCwxNzMsMTg2LDMsNjQsNTIsMjE3LDIyNiwyNTAsMTI0LDEyMyw1LFxuXHRcdCAyMDIsMzgsMTQ3LDExOCwxMjYsMjU1LDgyLDg1LDIxMiwyMDcsMjA2LDU5LDIyNyw0NywxNiw1OCwxNywxODIsMTg5LDI4LDQyLDIyMywxODMsMTcwLDIxMywxMTksXG5cdFx0IDI0OCwxNTIsMiw0NCwxNTQsMTYzLDcwLDIyMSwxNTMsMTAxLDE1NSwxNjcsNDMsMTcyLDksMTI5LDIyLDM5LDI1MywxOSw5OCwxMDgsMTEwLDc5LDExMywyMjQsMjMyLFxuXHRcdCAxNzgsMTg1LDExMiwxMDQsMjE4LDI0Niw5NywyMjgsMjUxLDM0LDI0MiwxOTMsMjM4LDIxMCwxNDQsMTIsMTkxLDE3OSwxNjIsMjQxLDgxLDUxLDE0NSwyMzUsMjQ5LFxuXHRcdCAxNCwyMzksMTA3LDQ5LDE5MiwyMTQsMzEsMTgxLDE5OSwxMDYsMTU3LDE4NCw4NCwyMDQsMTc2LDExNSwxMjEsNTAsNDUsMTI3LDQsMTUwLDI1NCwxMzgsMjM2LDIwNSxcblx0XHQgOTMsMjIyLDExNCw2NywyOSwyNCw3MiwyNDMsMTQxLDEyOCwxOTUsNzgsNjYsMjE1LDYxLDE1NiwxODBdO1xuXG5cdGZvciAodmFyIGk9MDsgaSA8IDI1NiA7IGkrKykge1xuXG5cdFx0cFsyNTYraV0gPSBwW2ldO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmYWRlKHQpIHtcblxuXHRcdHJldHVybiB0ICogdCAqIHQgKiAodCAqICh0ICogNiAtIDE1KSArIDEwKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gbGVycCh0LCBhLCBiKSB7XG5cblx0XHRyZXR1cm4gYSArIHQgKiAoYiAtIGEpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBncmFkKGhhc2gsIHgsIHksIHopIHtcblxuXHRcdHZhciBoID0gaGFzaCAmIDE1O1xuXHRcdHZhciB1ID0gaCA8IDggPyB4IDogeSwgdiA9IGggPCA0ID8geSA6IGggPT0gMTIgfHwgaCA9PSAxNCA/IHggOiB6O1xuXHRcdHJldHVybiAoKGgmMSkgPT0gMCA/IHUgOiAtdSkgKyAoKGgmMikgPT0gMCA/IHYgOiAtdik7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRub2lzZTogZnVuY3Rpb24gKHgsIHksIHopIHtcblxuXHRcdFx0dmFyIGZsb29yWCA9IH5+eCwgZmxvb3JZID0gfn55LCBmbG9vclogPSB+fno7XG5cblx0XHRcdHZhciBYID0gZmxvb3JYICYgMjU1LCBZID0gZmxvb3JZICYgMjU1LCBaID0gZmxvb3JaICYgMjU1O1xuXG5cdFx0XHR4IC09IGZsb29yWDtcblx0XHRcdHkgLT0gZmxvb3JZO1xuXHRcdFx0eiAtPSBmbG9vclo7XG5cblx0XHRcdHZhciB4TWludXMxID0geCAtMSwgeU1pbnVzMSA9IHkgLSAxLCB6TWludXMxID0geiAtIDE7XG5cblx0XHRcdHZhciB1ID0gZmFkZSh4KSwgdiA9IGZhZGUoeSksIHcgPSBmYWRlKHopO1xuXG5cdFx0XHR2YXIgQSA9IHBbWF0rWSwgQUEgPSBwW0FdK1osIEFCID0gcFtBKzFdK1osIEIgPSBwW1grMV0rWSwgQkEgPSBwW0JdK1osIEJCID0gcFtCKzFdK1o7XG5cblx0XHRcdHJldHVybiBsZXJwKHcsIGxlcnAodiwgbGVycCh1LCBncmFkKHBbQUFdLCB4LCB5LCB6KSwgXG5cdFx0XHRcdFx0XHRcdGdyYWQocFtCQV0sIHhNaW51czEsIHksIHopKSxcblx0XHRcdFx0XHRcdGxlcnAodSwgZ3JhZChwW0FCXSwgeCwgeU1pbnVzMSwgeiksXG5cdFx0XHRcdFx0XHRcdGdyYWQocFtCQl0sIHhNaW51czEsIHlNaW51czEsIHopKSksXG5cdFx0XHRcdFx0bGVycCh2LCBsZXJwKHUsIGdyYWQocFtBQSsxXSwgeCwgeSwgek1pbnVzMSksXG5cdFx0XHRcdFx0XHRcdGdyYWQocFtCQSsxXSwgeE1pbnVzMSwgeSwgei0xKSksXG5cdFx0XHRcdFx0XHRsZXJwKHUsIGdyYWQocFtBQisxXSwgeCwgeU1pbnVzMSwgek1pbnVzMSksXG5cdFx0XHRcdFx0XHRcdGdyYWQocFtCQisxXSwgeE1pbnVzMSwgeU1pbnVzMSwgek1pbnVzMSkpKSk7XG5cblx0XHR9XG5cdH1cbn1cblxuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgSW1wcm92ZWROb2lzZSAhPSBcInVuZGVmaW5lZFwiID8gSW1wcm92ZWROb2lzZSA6IHdpbmRvdy5JbXByb3ZlZE5vaXNlKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiBkZWZpbmVFeHBvcnQoZXgpIHsgbW9kdWxlLmV4cG9ydHMgPSBleDsgfSk7XG5cbn0pKHdpbmRvdykiLCIoZnVuY3Rpb24oZ2xvYmFsKXsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vLyBUaHJlZS5qcyByNDYgLSBodHRwOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanNcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxudmFyIFRIUkVFID0gVEhSRUUgfHwge307XG5cbmlmICggISBzZWxmLkludDMyQXJyYXkgKSB7XG5cblx0c2VsZi5JbnQzMkFycmF5ID0gQXJyYXk7XG5cdHNlbGYuRmxvYXQzMkFycmF5ID0gQXJyYXk7XG5cbn1cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5DbG9jayA9IGZ1bmN0aW9uICggYXV0b1N0YXJ0ICkge1xuXG5cdHRoaXMuYXV0b1N0YXJ0ID0gKCBhdXRvU3RhcnQgIT09IHVuZGVmaW5lZCApID8gYXV0b1N0YXJ0IDogdHJ1ZTtcblxuXHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdHRoaXMub2xkVGltZSA9IDA7XG5cdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXG5cdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5DbG9jay5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHR0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcblxuXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5DbG9jay5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XG5cblx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkNsb2NrLnByb3RvdHlwZS5nZXRFbGFwc2VkVGltZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmVsYXBzZWRUaW1lICs9IHRoaXMuZ2V0RGVsdGEoKTtcblxuXHRyZXR1cm4gdGhpcy5lbGFwc2VkVGltZTtcblxufTtcblxuXG5USFJFRS5DbG9jay5wcm90b3R5cGUuZ2V0RGVsdGEgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGRpZmYgPSAwO1xuXG5cdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHR0aGlzLnN0YXJ0KCk7XG5cblx0fVxuXG5cdGlmICggdGhpcy5ydW5uaW5nICkge1xuXG5cdFx0dmFyIG5ld1RpbWUgPSBEYXRlLm5vdygpO1xuXHRcdGRpZmYgPSAwLjAwMSAqICggbmV3VGltZSAtIHRoaXMub2xkVGltZSApO1xuXHRcdHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XG5cblx0XHR0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XG5cblx0fVxuXG5cdHJldHVybiBkaWZmO1xuXG59Oy8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ29sb3IgPSBmdW5jdGlvbiAoIGhleCApIHtcblxuXHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkgdGhpcy5zZXRIZXgoIGhleCApO1xuXHRyZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuQ29sb3IucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Db2xvcixcblxuXHRyOiAxLCBnOiAxLCBiOiAxLFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvci5yO1xuXHRcdHRoaXMuZyA9IGNvbG9yLmc7XG5cdFx0dGhpcy5iID0gY29sb3IuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvci5yICogY29sb3Iucjtcblx0XHR0aGlzLmcgPSBjb2xvci5nICogY29sb3IuZztcblx0XHR0aGlzLmIgPSBjb2xvci5iICogY29sb3IuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIGNvbG9yLnIgKTtcblx0XHR0aGlzLmcgPSBNYXRoLnNxcnQoIGNvbG9yLmcgKTtcblx0XHR0aGlzLmIgPSBNYXRoLnNxcnQoIGNvbG9yLmIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XG5cblx0XHR0aGlzLnIgPSByO1xuXHRcdHRoaXMuZyA9IGc7XG5cdFx0dGhpcy5iID0gYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0SFNWOiBmdW5jdGlvbiAoIGgsIHMsIHYgKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBNb2NoaUtpdCBpbXBsZW1lbnRhdGlvbiBieSBCb2IgSXBwb2xpdG9cblx0XHQvLyBoLHMsdiByYW5nZXMgYXJlIDwgMC4wIC0gMS4wID5cblxuXHRcdHZhciBpLCBmLCBwLCBxLCB0O1xuXG5cdFx0aWYgKCB2ID09PSAwICkge1xuXG5cdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSAwO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aSA9IE1hdGguZmxvb3IoIGggKiA2ICk7XG5cdFx0XHRmID0gKCBoICogNiApIC0gaTtcblx0XHRcdHAgPSB2ICogKCAxIC0gcyApO1xuXHRcdFx0cSA9IHYgKiAoIDEgLSAoIHMgKiBmICkgKTtcblx0XHRcdHQgPSB2ICogKCAxIC0gKCBzICogKCAxIC0gZiApICkgKTtcblxuXHRcdFx0c3dpdGNoICggaSApIHtcblxuXHRcdFx0XHRjYXNlIDE6IHRoaXMuciA9IHE7IHRoaXMuZyA9IHY7IHRoaXMuYiA9IHA7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6IHRoaXMuciA9IHA7IHRoaXMuZyA9IHY7IHRoaXMuYiA9IHQ7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM6IHRoaXMuciA9IHA7IHRoaXMuZyA9IHE7IHRoaXMuYiA9IHY7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQ6IHRoaXMuciA9IHQ7IHRoaXMuZyA9IHA7IHRoaXMuYiA9IHY7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDU6IHRoaXMuciA9IHY7IHRoaXMuZyA9IHA7IHRoaXMuYiA9IHE7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDY6IC8vIGZhbGwgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIDA6IHRoaXMuciA9IHY7IHRoaXMuZyA9IHQ7IHRoaXMuYiA9IHA7IGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEhleDogZnVuY3Rpb24gKCBoZXggKSB7XG5cblx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcblxuXHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XG5cdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xuXHRcdHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldEhleDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIH5+ICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiB+fiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiB+fiAoIHRoaXMuYiAqIDI1NSApO1xuXG5cdH0sXG5cblx0Z2V0Q29udGV4dFN0eWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gJ3JnYignICsgTWF0aC5mbG9vciggdGhpcy5yICogMjU1ICkgKyAnLCcgKyBNYXRoLmZsb29yKCB0aGlzLmcgKiAyNTUgKSArICcsJyArIE1hdGguZmxvb3IoIHRoaXMuYiAqIDI1NSApICsgJyknO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQ29sb3IoKS5zZXRSR0IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcblxuXHR9XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKi9cblxuVEhSRUUuVmVjdG9yMiA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHR0aGlzLnggPSB4IHx8IDA7XG5cdHRoaXMueSA9IHkgfHwgMDtcblxufTtcblxuVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjIsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHRoaXMueCwgdGhpcy55ICk7XG5cblx0fSxcblxuXG5cdGFkZDogZnVuY3Rpb24gKCB2MSwgdjIgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54ICsgdjIueDtcblx0XHR0aGlzLnkgPSB2MS55ICsgdjIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2VsZjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCAtIHYyLng7XG5cdFx0dGhpcy55ID0gdjEueSAtIHYyLnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YlNlbGY6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCAqPSBzO1xuXHRcdHRoaXMueSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdGlmICggcyApIHtcblxuXHRcdFx0dGhpcy54IC89IHM7XG5cdFx0XHR0aGlzLnkgLz0gcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAtMSApO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdH0sXG5cblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsICk7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG5cdH1cblxufTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKi9cblxuVEhSRUUuVmVjdG9yMyA9IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHR0aGlzLnggPSB4IHx8IDA7XG5cdHRoaXMueSA9IHkgfHwgMDtcblx0dGhpcy56ID0geiB8fCAwO1xuXG59O1xuXG5cblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IzLFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0dGhpcy56ID0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cblx0fSxcblxuXG5cdGFkZDogZnVuY3Rpb24gKCB2MSwgdjIgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54ICsgdjIueDtcblx0XHR0aGlzLnkgPSB2MS55ICsgdjIueTtcblx0XHR0aGlzLnogPSB2MS56ICsgdjIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2VsZjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cdFx0dGhpcy56ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YjogZnVuY3Rpb24gKCB2MSwgdjIgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54IC0gdjIueDtcblx0XHR0aGlzLnkgPSB2MS55IC0gdjIueTtcblx0XHR0aGlzLnogPSB2MS56IC0gdjIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViU2VsZjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKiBiLng7XG5cdFx0dGhpcy55ID0gYS55ICogYi55O1xuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTZWxmOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggKj0gdi54O1xuXHRcdHRoaXMueSAqPSB2Lnk7XG5cdFx0dGhpcy56ICo9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCAqPSBzO1xuXHRcdHRoaXMueSAqPSBzO1xuXHRcdHRoaXMueiAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTZWxmOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggLz0gdi54O1xuXHRcdHRoaXMueSAvPSB2Lnk7XG5cdFx0dGhpcy56IC89IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHRpZiAoIHMgKSB7XG5cblx0XHRcdHRoaXMueCAvPSBzO1xuXHRcdFx0dGhpcy55IC89IHM7XG5cdFx0XHR0aGlzLnogLz0gcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy56ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIC0xICk7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG5cblx0fSxcblxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9LFxuXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICk7XG5cblx0fSxcblxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGNvcnJlY3QgdmVyc2lvblxuXHRcdC8vIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy55ICsgdGhpcy56O1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGwgKTtcblxuXHR9LFxuXG5cblx0Y3Jvc3M6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueSAqIGIueiAtIGEueiAqIGIueTtcblx0XHR0aGlzLnkgPSBhLnogKiBiLnggLSBhLnggKiBiLno7XG5cdFx0dGhpcy56ID0gYS54ICogYi55IC0gYS55ICogYi54O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjcm9zc1NlbGY6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG5cdFx0dGhpcy54ID0geSAqIHYueiAtIHogKiB2Lnk7XG5cdFx0dGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViKCB0aGlzLCB2ICkubGVuZ3RoU3EoKTtcblxuXHR9LFxuXG5cblx0c2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR0aGlzLnggPSBtLm4xNDtcblx0XHR0aGlzLnkgPSBtLm4yNDtcblx0XHR0aGlzLnogPSBtLm4zNDtcblxuXHR9LFxuXG5cdHNldFJvdGF0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIGNvc1kgPSBNYXRoLmNvcyggdGhpcy55ICk7XG5cblx0XHR0aGlzLnkgPSBNYXRoLmFzaW4oIG0ubjEzICk7XG5cblx0XHRpZiAoIE1hdGguYWJzKCBjb3NZICkgPiAwLjAwMDAxICkge1xuXG5cdFx0XHR0aGlzLnggPSBNYXRoLmF0YW4yKCAtIG0ubjIzIC8gY29zWSwgbS5uMzMgLyBjb3NZICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLmF0YW4yKCAtIG0ubjEyIC8gY29zWSwgbS5uMTEgLyBjb3NZICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnggPSAwO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggbS5uMjEsIG0ubjIyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMubGVuZ3RoU3EoKSA8IDAuMDAwMSAvKiBhbG1vc3RaZXJvICovICk7XG5cblx0fVxuXG59O1xuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICovXG5cblRIUkVFLlZlY3RvcjQgPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cdHRoaXMueiA9IHogfHwgMDtcblx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG59O1xuXG5USFJFRS5WZWN0b3I0LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yNCxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXHRcdHRoaXMudyA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0dGhpcy56ID0gdi56O1xuXHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3I0KCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcblxuXHR9LFxuXG5cblx0YWRkOiBmdW5jdGlvbiAoIHYxLCB2MiApIHtcblxuXHRcdHRoaXMueCA9IHYxLnggKyB2Mi54O1xuXHRcdHRoaXMueSA9IHYxLnkgKyB2Mi55O1xuXHRcdHRoaXMueiA9IHYxLnogKyB2Mi56O1xuXHRcdHRoaXMudyA9IHYxLncgKyB2Mi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTZWxmOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0dGhpcy56ICs9IHYuejtcblx0XHR0aGlzLncgKz0gdi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCAtIHYyLng7XG5cdFx0dGhpcy55ID0gdjEueSAtIHYyLnk7XG5cdFx0dGhpcy56ID0gdjEueiAtIHYyLno7XG5cdFx0dGhpcy53ID0gdjEudyAtIHYyLnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YlNlbGY6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXHRcdHRoaXMudyAtPSB2Lnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKj0gcztcblx0XHR0aGlzLnkgKj0gcztcblx0XHR0aGlzLnogKj0gcztcblx0XHR0aGlzLncgKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHRpZiAoIHMgKSB7XG5cblx0XHRcdHRoaXMueCAvPSBzO1xuXHRcdFx0dGhpcy55IC89IHM7XG5cdFx0XHR0aGlzLnogLz0gcztcblx0XHRcdHRoaXMudyAvPSBzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy54ID0gMDtcblx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHR0aGlzLnogPSAwO1xuXHRcdFx0dGhpcy53ID0gMTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIC0xICk7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cblx0fSxcblxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZG90KCB0aGlzICk7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGwgKTtcblxuXHR9LFxuXG5cblx0bGVycFNlbGY6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcblx0XHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5SYXkgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdHRoaXMub3JpZ2luID0gb3JpZ2luIHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dGhpcy5pbnRlcnNlY3RTY2VuZSA9IGZ1bmN0aW9uICggc2NlbmUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RPYmplY3RzKCBzY2VuZS5jaGlsZHJlbiApO1xuXG5cdH07XG5cblx0dGhpcy5pbnRlcnNlY3RPYmplY3RzID0gZnVuY3Rpb24gKCBvYmplY3RzICkge1xuXG5cdFx0dmFyIGksIGwsIG9iamVjdCxcblx0XHRpbnRlcnNlY3RzID0gW107XG5cblx0XHRmb3IgKCBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIGludGVyc2VjdHMsIHRoaXMuaW50ZXJzZWN0T2JqZWN0KCBvYmplY3RzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7IHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTsgfSApO1xuXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0fTtcblxuXHR2YXIgYSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIGMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIG9yaWdpbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBpbnRlcnNlY3RQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKClcblxuXHR0aGlzLmludGVyc2VjdE9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0dmFyIGludGVyc2VjdCwgaW50ZXJzZWN0cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBpbnRlcnNlY3RzLCB0aGlzLmludGVyc2VjdE9iamVjdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZSApIHtcblxuXHRcdFx0dmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKCB0aGlzLm9yaWdpbiwgdGhpcy5kaXJlY3Rpb24sIG9iamVjdC5tYXRyaXhXb3JsZC5nZXRQb3NpdGlvbigpICk7XG5cblx0XHRcdGlmICggZGlzdGFuY2UgPT09IG51bGwgfHwgZGlzdGFuY2UgPiBvYmplY3Quc2NhbGUueCApIHtcblxuXHRcdFx0XHRyZXR1cm4gW107XG5cblx0XHRcdH1cblxuXHRcdFx0aW50ZXJzZWN0ID0ge1xuXG5cdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0cG9pbnQ6IG9iamVjdC5wb3NpdGlvbixcblx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0b2JqZWN0OiBvYmplY3RcblxuXHRcdFx0fTtcblxuXHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3QgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlXG5cblx0XHRcdHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbiggdGhpcy5vcmlnaW4sIHRoaXMuZGlyZWN0aW9uLCBvYmplY3QubWF0cml4V29ybGQuZ2V0UG9zaXRpb24oKSApO1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlID09PSBudWxsIHx8IGRpc3RhbmNlID4gb2JqZWN0Lmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLnJhZGl1cyAqIE1hdGgubWF4KCBvYmplY3Quc2NhbGUueCwgTWF0aC5tYXgoIG9iamVjdC5zY2FsZS55LCBvYmplY3Quc2NhbGUueiApICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2tpbmcgZmFjZXNcblxuXHRcdFx0dmFyIGYsIGZsLCBmYWNlLCBkb3QsIHNjYWxhcixcblx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LFxuXHRcdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcblx0XHRcdG9iak1hdHJpeDtcblxuXHRcdFx0b2JqZWN0Lm1hdHJpeFJvdGF0aW9uV29ybGQuZXh0cmFjdFJvdGF0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IGdlb21ldHJ5LmZhY2VzWyBmIF07XG5cblx0XHRcdFx0b3JpZ2luLmNvcHkoIHRoaXMub3JpZ2luICk7XG5cdFx0XHRcdGRpcmVjdGlvbi5jb3B5KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0XHRcdG9iak1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiBmYWNlLmNlbnRyb2lkIGlzIGJlaGluZCB0aGUgb3JpZ2luXG5cblx0XHRcdFx0dmVjdG9yID0gb2JqTWF0cml4Lm11bHRpcGx5VmVjdG9yMyggdmVjdG9yLmNvcHkoIGZhY2UuY2VudHJvaWQgKSApLnN1YlNlbGYoIG9yaWdpbiApO1xuXHRcdFx0XHRkb3QgPSB2ZWN0b3IuZG90KCBkaXJlY3Rpb24gKTtcblxuXHRcdFx0XHRpZiAoIGRvdCA8PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHRhID0gb2JqTWF0cml4Lm11bHRpcGx5VmVjdG9yMyggYS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0ucG9zaXRpb24gKSApO1xuXHRcdFx0XHRiID0gb2JqTWF0cml4Lm11bHRpcGx5VmVjdG9yMyggYi5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0ucG9zaXRpb24gKSApO1xuXHRcdFx0XHRjID0gb2JqTWF0cml4Lm11bHRpcGx5VmVjdG9yMyggYy5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0ucG9zaXRpb24gKSApO1xuXHRcdFx0XHRkID0gZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ID8gb2JqTWF0cml4Lm11bHRpcGx5VmVjdG9yMyggZC5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5kIF0ucG9zaXRpb24gKSApIDogbnVsbDtcblxuXHRcdFx0XHRub3JtYWwgPSBvYmplY3QubWF0cml4Um90YXRpb25Xb3JsZC5tdWx0aXBseVZlY3RvcjMoIG5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApICk7XG5cdFx0XHRcdGRvdCA9IGRpcmVjdGlvbi5kb3QoIG5vcm1hbCApO1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LmRvdWJsZVNpZGVkIHx8ICggb2JqZWN0LmZsaXBTaWRlZCA/IGRvdCA+IDAgOiBkb3QgPCAwICkgKSB7IC8vIE1hdGguYWJzKCBkb3QgKSA+IDAuMDAwMVxuXG5cdFx0XHRcdFx0c2NhbGFyID0gbm9ybWFsLmRvdCggdmVjdG9yLnN1YiggYSwgb3JpZ2luICkgKSAvIGRvdDtcblx0XHRcdFx0XHRpbnRlcnNlY3RQb2ludC5hZGQoIG9yaWdpbiwgZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSApO1xuXG5cdFx0XHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggcG9pbnRJbkZhY2UzKCBpbnRlcnNlY3RQb2ludCwgYSwgYiwgYyApICkge1xuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdCA9IHtcblxuXHRcdFx0XHRcdFx0XHRcdGRpc3RhbmNlOiBvcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcblx0XHRcdFx0XHRcdFx0XHRmYWNlOiBmYWNlLFxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdDogb2JqZWN0XG5cblx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggcG9pbnRJbkZhY2UzKCBpbnRlcnNlY3RQb2ludCwgYSwgYiwgZCApIHx8IHBvaW50SW5GYWNlMyggaW50ZXJzZWN0UG9pbnQsIGIsIGMsIGQgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3QgPSB7XG5cblx0XHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogb3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICksXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXG5cdFx0XHRcdFx0XHRcdFx0ZmFjZTogZmFjZSxcblx0XHRcdFx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxuXG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3QgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0fVxuXG5cdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgZG90LCBpbnRlcnNlY3QsIGRpc3RhbmNlO1xuXG5cdGZ1bmN0aW9uIGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbiggb3JpZ2luLCBkaXJlY3Rpb24sIHBvc2l0aW9uICkge1xuXG5cdFx0djAuc3ViKCBwb3NpdGlvbiwgb3JpZ2luICk7XG5cdFx0ZG90ID0gdjAuZG90KCBkaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZG90IDw9IDAgKSByZXR1cm4gbnVsbDsgLy8gY2hlY2sgaWYgcG9zaXRpb24gYmVoaW5kIG9yaWdpbi5cblxuXHRcdGludGVyc2VjdCA9IHYxLmFkZCggb3JpZ2luLCB2Mi5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZG90ICkgKTtcblx0XHRkaXN0YW5jZSA9IHBvc2l0aW9uLmRpc3RhbmNlVG8oIGludGVyc2VjdCApO1xuXG5cdFx0cmV0dXJuIGRpc3RhbmNlO1xuXG5cdH1cblxuXHQvLyBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXG5cblx0dmFyIGRvdDAwLCBkb3QwMSwgZG90MDIsIGRvdDExLCBkb3QxMiwgaW52RGVub20sIHUsIHY7XG5cblx0ZnVuY3Rpb24gcG9pbnRJbkZhY2UzKCBwLCBhLCBiLCBjICkge1xuXG5cdFx0djAuc3ViKCBjLCBhICk7XG5cdFx0djEuc3ViKCBiLCBhICk7XG5cdFx0djIuc3ViKCBwLCBhICk7XG5cblx0XHRkb3QwMCA9IHYwLmRvdCggdjAgKTtcblx0XHRkb3QwMSA9IHYwLmRvdCggdjEgKTtcblx0XHRkb3QwMiA9IHYwLmRvdCggdjIgKTtcblx0XHRkb3QxMSA9IHYxLmRvdCggdjEgKTtcblx0XHRkb3QxMiA9IHYxLmRvdCggdjIgKTtcblxuXHRcdGludkRlbm9tID0gMSAvICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcblx0XHR1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XG5cdFx0diA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xuXG5cdFx0cmV0dXJuICggdSA+PSAwICkgJiYgKCB2ID49IDAgKSAmJiAoIHUgKyB2IDwgMSApO1xuXG5cdH1cblxufTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBfbGVmdCwgX3RvcCwgX3JpZ2h0LCBfYm90dG9tLFxuXHRfd2lkdGgsIF9oZWlnaHQsIF9pc0VtcHR5ID0gdHJ1ZTtcblxuXHRmdW5jdGlvbiByZXNpemUoKSB7XG5cblx0XHRfd2lkdGggPSBfcmlnaHQgLSBfbGVmdDtcblx0XHRfaGVpZ2h0ID0gX2JvdHRvbSAtIF90b3A7XG5cblx0fVxuXG5cdHRoaXMuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfbGVmdDtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfdG9wO1xuXG5cdH07XG5cblx0dGhpcy5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfd2lkdGg7XG5cblx0fTtcblxuXHR0aGlzLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfaGVpZ2h0O1xuXG5cdH07XG5cblx0dGhpcy5nZXRMZWZ0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gX2xlZnQ7XG5cblx0fTtcblxuXHR0aGlzLmdldFRvcCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIF90b3A7XG5cblx0fTtcblxuXHR0aGlzLmdldFJpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gX3JpZ2h0O1xuXG5cdH07XG5cblx0dGhpcy5nZXRCb3R0b20gPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBfYm90dG9tO1xuXG5cdH07XG5cblx0dGhpcy5zZXQgPSBmdW5jdGlvbiAoIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSApIHtcblxuXHRcdF9pc0VtcHR5ID0gZmFsc2U7XG5cblx0XHRfbGVmdCA9IGxlZnQ7IF90b3AgPSB0b3A7XG5cdFx0X3JpZ2h0ID0gcmlnaHQ7IF9ib3R0b20gPSBib3R0b207XG5cblx0XHRyZXNpemUoKTtcblxuXHR9O1xuXG5cdHRoaXMuYWRkUG9pbnQgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0XHRpZiAoIF9pc0VtcHR5ICkge1xuXG5cdFx0XHRfaXNFbXB0eSA9IGZhbHNlO1xuXHRcdFx0X2xlZnQgPSB4OyBfdG9wID0geTtcblx0XHRcdF9yaWdodCA9IHg7IF9ib3R0b20gPSB5O1xuXG5cdFx0XHRyZXNpemUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9sZWZ0ID0gX2xlZnQgPCB4ID8gX2xlZnQgOiB4OyAvLyBNYXRoLm1pbiggX2xlZnQsIHggKTtcblx0XHRcdF90b3AgPSBfdG9wIDwgeSA/IF90b3AgOiB5OyAvLyBNYXRoLm1pbiggX3RvcCwgeSApO1xuXHRcdFx0X3JpZ2h0ID0gX3JpZ2h0ID4geCA/IF9yaWdodCA6IHg7IC8vIE1hdGgubWF4KCBfcmlnaHQsIHggKTtcblx0XHRcdF9ib3R0b20gPSBfYm90dG9tID4geSA/IF9ib3R0b20gOiB5OyAvLyBNYXRoLm1heCggX2JvdHRvbSwgeSApO1xuXG5cdFx0XHRyZXNpemUoKTtcblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmFkZDNQb2ludHMgPSBmdW5jdGlvbiAoIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMgKSB7XG5cblx0XHRpZiAoX2lzRW1wdHkpIHtcblxuXHRcdFx0X2lzRW1wdHkgPSBmYWxzZTtcblx0XHRcdF9sZWZ0ID0geDEgPCB4MiA/ICggeDEgPCB4MyA/IHgxIDogeDMgKSA6ICggeDIgPCB4MyA/IHgyIDogeDMgKTtcblx0XHRcdF90b3AgPSB5MSA8IHkyID8gKCB5MSA8IHkzID8geTEgOiB5MyApIDogKCB5MiA8IHkzID8geTIgOiB5MyApO1xuXHRcdFx0X3JpZ2h0ID0geDEgPiB4MiA/ICggeDEgPiB4MyA/IHgxIDogeDMgKSA6ICggeDIgPiB4MyA/IHgyIDogeDMgKTtcblx0XHRcdF9ib3R0b20gPSB5MSA+IHkyID8gKCB5MSA+IHkzID8geTEgOiB5MyApIDogKCB5MiA+IHkzID8geTIgOiB5MyApO1xuXG5cdFx0XHRyZXNpemUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9sZWZ0ID0geDEgPCB4MiA/ICggeDEgPCB4MyA/ICggeDEgPCBfbGVmdCA/IHgxIDogX2xlZnQgKSA6ICggeDMgPCBfbGVmdCA/IHgzIDogX2xlZnQgKSApIDogKCB4MiA8IHgzID8gKCB4MiA8IF9sZWZ0ID8geDIgOiBfbGVmdCApIDogKCB4MyA8IF9sZWZ0ID8geDMgOiBfbGVmdCApICk7XG5cdFx0XHRfdG9wID0geTEgPCB5MiA/ICggeTEgPCB5MyA/ICggeTEgPCBfdG9wID8geTEgOiBfdG9wICkgOiAoIHkzIDwgX3RvcCA/IHkzIDogX3RvcCApICkgOiAoIHkyIDwgeTMgPyAoIHkyIDwgX3RvcCA/IHkyIDogX3RvcCApIDogKCB5MyA8IF90b3AgPyB5MyA6IF90b3AgKSApO1xuXHRcdFx0X3JpZ2h0ID0geDEgPiB4MiA/ICggeDEgPiB4MyA/ICggeDEgPiBfcmlnaHQgPyB4MSA6IF9yaWdodCApIDogKCB4MyA+IF9yaWdodCA/IHgzIDogX3JpZ2h0ICkgKSA6ICggeDIgPiB4MyA/ICggeDIgPiBfcmlnaHQgPyB4MiA6IF9yaWdodCApIDogKCB4MyA+IF9yaWdodCA/IHgzIDogX3JpZ2h0ICkgKTtcblx0XHRcdF9ib3R0b20gPSB5MSA+IHkyID8gKCB5MSA+IHkzID8gKCB5MSA+IF9ib3R0b20gPyB5MSA6IF9ib3R0b20gKSA6ICggeTMgPiBfYm90dG9tID8geTMgOiBfYm90dG9tICkgKSA6ICggeTIgPiB5MyA/ICggeTIgPiBfYm90dG9tID8geTIgOiBfYm90dG9tICkgOiAoIHkzID4gX2JvdHRvbSA/IHkzIDogX2JvdHRvbSApICk7XG5cblx0XHRcdHJlc2l6ZSgpO1xuXG5cdFx0fTtcblxuXHR9O1xuXG5cdHRoaXMuYWRkUmVjdGFuZ2xlID0gZnVuY3Rpb24gKCByICkge1xuXG5cdFx0aWYgKCBfaXNFbXB0eSApIHtcblxuXHRcdFx0X2lzRW1wdHkgPSBmYWxzZTtcblx0XHRcdF9sZWZ0ID0gci5nZXRMZWZ0KCk7IF90b3AgPSByLmdldFRvcCgpO1xuXHRcdFx0X3JpZ2h0ID0gci5nZXRSaWdodCgpOyBfYm90dG9tID0gci5nZXRCb3R0b20oKTtcblxuXHRcdFx0cmVzaXplKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfbGVmdCA9IF9sZWZ0IDwgci5nZXRMZWZ0KCkgPyBfbGVmdCA6IHIuZ2V0TGVmdCgpOyAvLyBNYXRoLm1pbihfbGVmdCwgci5nZXRMZWZ0KCkgKTtcblx0XHRcdF90b3AgPSBfdG9wIDwgci5nZXRUb3AoKSA/IF90b3AgOiByLmdldFRvcCgpOyAvLyBNYXRoLm1pbihfdG9wLCByLmdldFRvcCgpICk7XG5cdFx0XHRfcmlnaHQgPSBfcmlnaHQgPiByLmdldFJpZ2h0KCkgPyBfcmlnaHQgOiByLmdldFJpZ2h0KCk7IC8vIE1hdGgubWF4KF9yaWdodCwgci5nZXRSaWdodCgpICk7XG5cdFx0XHRfYm90dG9tID0gX2JvdHRvbSA+IHIuZ2V0Qm90dG9tKCkgPyBfYm90dG9tIDogci5nZXRCb3R0b20oKTsgLy8gTWF0aC5tYXgoX2JvdHRvbSwgci5nZXRCb3R0b20oKSApO1xuXG5cdFx0XHRyZXNpemUoKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuaW5mbGF0ZSA9IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdF9sZWZ0IC09IHY7IF90b3AgLT0gdjtcblx0XHRfcmlnaHQgKz0gdjsgX2JvdHRvbSArPSB2O1xuXG5cdFx0cmVzaXplKCk7XG5cblx0fTtcblxuXHR0aGlzLm1pblNlbGYgPSBmdW5jdGlvbiAoIHIgKSB7XG5cblx0XHRfbGVmdCA9IF9sZWZ0ID4gci5nZXRMZWZ0KCkgPyBfbGVmdCA6IHIuZ2V0TGVmdCgpOyAvLyBNYXRoLm1heCggX2xlZnQsIHIuZ2V0TGVmdCgpICk7XG5cdFx0X3RvcCA9IF90b3AgPiByLmdldFRvcCgpID8gX3RvcCA6IHIuZ2V0VG9wKCk7IC8vIE1hdGgubWF4KCBfdG9wLCByLmdldFRvcCgpICk7XG5cdFx0X3JpZ2h0ID0gX3JpZ2h0IDwgci5nZXRSaWdodCgpID8gX3JpZ2h0IDogci5nZXRSaWdodCgpOyAvLyBNYXRoLm1pbiggX3JpZ2h0LCByLmdldFJpZ2h0KCkgKTtcblx0XHRfYm90dG9tID0gX2JvdHRvbSA8IHIuZ2V0Qm90dG9tKCkgPyBfYm90dG9tIDogci5nZXRCb3R0b20oKTsgLy8gTWF0aC5taW4oIF9ib3R0b20sIHIuZ2V0Qm90dG9tKCkgKTtcblxuXHRcdHJlc2l6ZSgpO1xuXG5cdH07XG5cblx0dGhpcy5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKCByICkge1xuXG5cdFx0cmV0dXJuIE1hdGgubWluKCBfcmlnaHQsIHIuZ2V0UmlnaHQoKSApIC0gTWF0aC5tYXgoIF9sZWZ0LCByLmdldExlZnQoKSApID49IDAgJiZcblx0XHQgICAgICAgIE1hdGgubWluKCBfYm90dG9tLCByLmdldEJvdHRvbSgpICkgLSBNYXRoLm1heCggX3RvcCwgci5nZXRUb3AoKSApID49IDA7XG5cblx0fTtcblxuXHR0aGlzLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0X2lzRW1wdHkgPSB0cnVlO1xuXG5cdFx0X2xlZnQgPSAwOyBfdG9wID0gMDtcblx0XHRfcmlnaHQgPSAwOyBfYm90dG9tID0gMDtcblxuXHRcdHJlc2l6ZSgpO1xuXG5cdH07XG5cblx0dGhpcy5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9pc0VtcHR5O1xuXG5cdH07XG5cbn07XG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTWF0aCA9IHtcblxuXHRjbGFtcDogZnVuY3Rpb24gKCB4LCBhLCBiICkge1xuXG5cdFx0cmV0dXJuICggeCA8IGEgKSA/IGEgOiAoICggeCA+IGIgKSA/IGIgOiB4ICk7XG5cblx0fSxcblxuXHRjbGFtcEJvdHRvbTogZnVuY3Rpb24gKCB4LCBhICkge1xuXG5cdFx0cmV0dXJuIHggPCBhID8gYSA6IHg7XG5cblx0fSxcblxuXHRtYXBMaW5lYXI6IGZ1bmN0aW9uKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcblxuXHRcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xuXG5cdH0sXG5cblx0Ly8gR2V0IDE2IGJpdHMgb2YgcmFuZG9tbmVzc1xuXHQvLyAoc3RhbmRhcmQgTWF0aC5yYW5kb20oKSBjcmVhdGVzIHJlcGV0aXRpdmUgcGF0dGVybnMgd2hlbiBhcHBsaWVkIG92ZXIgbGFyZ2VyIHNwYWNlKVxuXG5cdHJhbmRvbTE2OiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiAoIDY1MjgwICogTWF0aC5yYW5kb20oKSArIDI1NSAqIE1hdGgucmFuZG9tKCkgKSAvIDY1NTM1O1xuXG5cdH1cblxufTtcblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5tID0gW107XG5cbn07XG5cblRIUkVFLk1hdHJpeDMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRyaXgzLFxuXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRtcCwgbSA9IHRoaXMubTtcblxuXHRcdHRtcCA9IG1bMV07IG1bMV0gPSBtWzNdOyBtWzNdID0gdG1wO1xuXHRcdHRtcCA9IG1bMl07IG1bMl0gPSBtWzZdOyBtWzZdID0gdG1wO1xuXHRcdHRtcCA9IG1bNV07IG1bNV0gPSBtWzddOyBtWzddID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0cmFuc3Bvc2VJbnRvQXJyYXk6IGZ1bmN0aW9uICggciApIHtcblxuXHRcdHZhciBtID0gdGhpcy5tO1xuXG5cdFx0clsgMCBdID0gbVsgMCBdO1xuXHRcdHJbIDEgXSA9IG1bIDMgXTtcblx0XHRyWyAyIF0gPSBtWyA2IF07XG5cdFx0clsgMyBdID0gbVsgMSBdO1xuXHRcdHJbIDQgXSA9IG1bIDQgXTtcblx0XHRyWyA1IF0gPSBtWyA3IF07XG5cdFx0clsgNiBdID0gbVsgMiBdO1xuXHRcdHJbIDcgXSA9IG1bIDUgXTtcblx0XHRyWyA4IF0gPSBtWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIGpvcmRpX3JvcyAvIGh0dHA6Ly9wbGF0dHNvZnQuY29tXG4gKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XG5cblx0dGhpcy5zZXQoXG5cblx0XHQoIG4xMSAhPT0gdW5kZWZpbmVkICkgPyBuMTEgOiAxLCBuMTIgfHwgMCwgbjEzIHx8IDAsIG4xNCB8fCAwLFxuXHRcdG4yMSB8fCAwLCAoIG4yMiAhPT0gdW5kZWZpbmVkICkgPyBuMjIgOiAxLCBuMjMgfHwgMCwgbjI0IHx8IDAsXG5cdFx0bjMxIHx8IDAsIG4zMiB8fCAwLCAoIG4zMyAhPT0gdW5kZWZpbmVkICkgPyBuMzMgOiAxLCBuMzQgfHwgMCxcblx0XHRuNDEgfHwgMCwgbjQyIHx8IDAsIG40MyB8fCAwLCAoIG40NCAhPT0gdW5kZWZpbmVkICkgPyBuNDQgOiAxXG5cblx0KTtcblxuXHR0aGlzLmZsYXQgPSBuZXcgQXJyYXkoIDE2ICk7XG5cdHRoaXMubTMzID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxufTtcblxuVEhSRUUuTWF0cml4NC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDQsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdHRoaXMubjExID0gbjExOyB0aGlzLm4xMiA9IG4xMjsgdGhpcy5uMTMgPSBuMTM7IHRoaXMubjE0ID0gbjE0O1xuXHRcdHRoaXMubjIxID0gbjIxOyB0aGlzLm4yMiA9IG4yMjsgdGhpcy5uMjMgPSBuMjM7IHRoaXMubjI0ID0gbjI0O1xuXHRcdHRoaXMubjMxID0gbjMxOyB0aGlzLm4zMiA9IG4zMjsgdGhpcy5uMzMgPSBuMzM7IHRoaXMubjM0ID0gbjM0O1xuXHRcdHRoaXMubjQxID0gbjQxOyB0aGlzLm40MiA9IG40MjsgdGhpcy5uNDMgPSBuNDM7IHRoaXMubjQ0ID0gbjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtLm4xMSwgbS5uMTIsIG0ubjEzLCBtLm4xNCxcblx0XHRcdG0ubjIxLCBtLm4yMiwgbS5uMjMsIG0ubjI0LFxuXHRcdFx0bS5uMzEsIG0ubjMyLCBtLm4zMywgbS5uMzQsXG5cdFx0XHRtLm40MSwgbS5uNDIsIG0ubjQzLCBtLm40NFxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoIGV5ZSwgY2VudGVyLCB1cCApIHtcblxuXHRcdHZhciB4ID0gVEhSRUUuTWF0cml4NC5fX3YxLCB5ID0gVEhSRUUuTWF0cml4NC5fX3YyLCB6ID0gVEhSRUUuTWF0cml4NC5fX3YzO1xuXG5cdFx0ei5zdWIoIGV5ZSwgY2VudGVyICkubm9ybWFsaXplKCk7XG5cblx0XHRpZiAoIHoubGVuZ3RoKCkgPT09IDAgKSB7XG5cblx0XHRcdHoueiA9IDE7XG5cblx0XHR9XG5cblx0XHR4LmNyb3NzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0aWYgKCB4Lmxlbmd0aCgpID09PSAwICkge1xuXG5cdFx0XHR6LnggKz0gMC4wMDAxO1xuXHRcdFx0eC5jcm9zcyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuXHRcdH1cblxuXHRcdHkuY3Jvc3MoIHosIHggKS5ub3JtYWxpemUoKTtcblxuXG5cdFx0dGhpcy5uMTEgPSB4Lng7IHRoaXMubjEyID0geS54OyB0aGlzLm4xMyA9IHoueDtcblx0XHR0aGlzLm4yMSA9IHgueTsgdGhpcy5uMjIgPSB5Lnk7IHRoaXMubjIzID0gei55O1xuXHRcdHRoaXMubjMxID0geC56OyB0aGlzLm4zMiA9IHkuejsgdGhpcy5uMzMgPSB6Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR2YXIgYTExID0gYS5uMTEsIGExMiA9IGEubjEyLCBhMTMgPSBhLm4xMywgYTE0ID0gYS5uMTQsXG5cdFx0YTIxID0gYS5uMjEsIGEyMiA9IGEubjIyLCBhMjMgPSBhLm4yMywgYTI0ID0gYS5uMjQsXG5cdFx0YTMxID0gYS5uMzEsIGEzMiA9IGEubjMyLCBhMzMgPSBhLm4zMywgYTM0ID0gYS5uMzQsXG5cdFx0YTQxID0gYS5uNDEsIGE0MiA9IGEubjQyLCBhNDMgPSBhLm40MywgYTQ0ID0gYS5uNDQsXG5cblx0XHRiMTEgPSBiLm4xMSwgYjEyID0gYi5uMTIsIGIxMyA9IGIubjEzLCBiMTQgPSBiLm4xNCxcblx0XHRiMjEgPSBiLm4yMSwgYjIyID0gYi5uMjIsIGIyMyA9IGIubjIzLCBiMjQgPSBiLm4yNCxcblx0XHRiMzEgPSBiLm4zMSwgYjMyID0gYi5uMzIsIGIzMyA9IGIubjMzLCBiMzQgPSBiLm4zNCxcblx0XHRiNDEgPSBiLm40MSwgYjQyID0gYi5uNDIsIGI0MyA9IGIubjQzLCBiNDQgPSBiLm40NDtcblxuXHRcdHRoaXMubjExID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuXHRcdHRoaXMubjEyID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRoaXMubjEzID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuXHRcdHRoaXMubjE0ID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXG5cdFx0dGhpcy5uMjEgPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG5cdFx0dGhpcy5uMjIgPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGhpcy5uMjMgPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG5cdFx0dGhpcy5uMjQgPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cblx0XHR0aGlzLm4zMSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcblx0XHR0aGlzLm4zMiA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0aGlzLm4zMyA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0aGlzLm4zNCA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRoaXMubjQxID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuXHRcdHRoaXMubjQyID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuXHRcdHRoaXMubjQzID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuXHRcdHRoaXMubjQ0ID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNlbGY6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5KCB0aGlzLCBtICk7XG5cblx0fSxcblxuXHRtdWx0aXBseVRvQXJyYXk6IGZ1bmN0aW9uICggYSwgYiwgciApIHtcblxuXHRcdHRoaXMubXVsdGlwbHkoIGEsIGIgKTtcblxuXHRcdHJbIDAgXSA9IHRoaXMubjExOyByWyAxIF0gPSB0aGlzLm4yMTsgclsgMiBdID0gdGhpcy5uMzE7IHJbIDMgXSA9IHRoaXMubjQxO1xuXHRcdHJbIDQgXSA9IHRoaXMubjEyOyByWyA1IF0gPSB0aGlzLm4yMjsgclsgNiBdID0gdGhpcy5uMzI7IHJbIDcgXSA9IHRoaXMubjQyO1xuXHRcdHJbIDggXSAgPSB0aGlzLm4xMzsgclsgOSBdICA9IHRoaXMubjIzOyByWyAxMCBdID0gdGhpcy5uMzM7IHJbIDExIF0gPSB0aGlzLm40Mztcblx0XHRyWyAxMiBdID0gdGhpcy5uMTQ7IHJbIDEzIF0gPSB0aGlzLm4yNDsgclsgMTQgXSA9IHRoaXMubjM0OyByWyAxNSBdID0gdGhpcy5uNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLm4xMSAqPSBzOyB0aGlzLm4xMiAqPSBzOyB0aGlzLm4xMyAqPSBzOyB0aGlzLm4xNCAqPSBzO1xuXHRcdHRoaXMubjIxICo9IHM7IHRoaXMubjIyICo9IHM7IHRoaXMubjIzICo9IHM7IHRoaXMubjI0ICo9IHM7XG5cdFx0dGhpcy5uMzEgKj0gczsgdGhpcy5uMzIgKj0gczsgdGhpcy5uMzMgKj0gczsgdGhpcy5uMzQgKj0gcztcblx0XHR0aGlzLm40MSAqPSBzOyB0aGlzLm40MiAqPSBzOyB0aGlzLm40MyAqPSBzOyB0aGlzLm40NCAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciB2eCA9IHYueCwgdnkgPSB2LnksIHZ6ID0gdi56LFxuXHRcdGQgPSAxIC8gKCB0aGlzLm40MSAqIHZ4ICsgdGhpcy5uNDIgKiB2eSArIHRoaXMubjQzICogdnogKyB0aGlzLm40NCApO1xuXG5cdFx0di54ID0gKCB0aGlzLm4xMSAqIHZ4ICsgdGhpcy5uMTIgKiB2eSArIHRoaXMubjEzICogdnogKyB0aGlzLm4xNCApICogZDtcblx0XHR2LnkgPSAoIHRoaXMubjIxICogdnggKyB0aGlzLm4yMiAqIHZ5ICsgdGhpcy5uMjMgKiB2eiArIHRoaXMubjI0ICkgKiBkO1xuXHRcdHYueiA9ICggdGhpcy5uMzEgKiB2eCArIHRoaXMubjMyICogdnkgKyB0aGlzLm4zMyAqIHZ6ICsgdGhpcy5uMzQgKSAqIGQ7XG5cblx0XHRyZXR1cm4gdjtcblxuXHR9LFxuXG5cdG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHZ4ID0gdi54LCB2eSA9IHYueSwgdnogPSB2LnosIHZ3ID0gdi53O1xuXG5cdFx0di54ID0gdGhpcy5uMTEgKiB2eCArIHRoaXMubjEyICogdnkgKyB0aGlzLm4xMyAqIHZ6ICsgdGhpcy5uMTQgKiB2dztcblx0XHR2LnkgPSB0aGlzLm4yMSAqIHZ4ICsgdGhpcy5uMjIgKiB2eSArIHRoaXMubjIzICogdnogKyB0aGlzLm4yNCAqIHZ3O1xuXHRcdHYueiA9IHRoaXMubjMxICogdnggKyB0aGlzLm4zMiAqIHZ5ICsgdGhpcy5uMzMgKiB2eiArIHRoaXMubjM0ICogdnc7XG5cdFx0di53ID0gdGhpcy5uNDEgKiB2eCArIHRoaXMubjQyICogdnkgKyB0aGlzLm40MyAqIHZ6ICsgdGhpcy5uNDQgKiB2dztcblxuXHRcdHJldHVybiB2O1xuXG5cdH0sXG5cblx0cm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHZ4ID0gdi54LCB2eSA9IHYueSwgdnogPSB2Lno7XG5cblx0XHR2LnggPSB2eCAqIHRoaXMubjExICsgdnkgKiB0aGlzLm4xMiArIHZ6ICogdGhpcy5uMTM7XG5cdFx0di55ID0gdnggKiB0aGlzLm4yMSArIHZ5ICogdGhpcy5uMjIgKyB2eiAqIHRoaXMubjIzO1xuXHRcdHYueiA9IHZ4ICogdGhpcy5uMzEgKyB2eSAqIHRoaXMubjMyICsgdnogKiB0aGlzLm4zMztcblxuXHRcdHYubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdjtcblxuXHR9LFxuXG5cdGNyb3NzVmVjdG9yOiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cblx0XHR2LnggPSB0aGlzLm4xMSAqIGEueCArIHRoaXMubjEyICogYS55ICsgdGhpcy5uMTMgKiBhLnogKyB0aGlzLm4xNCAqIGEudztcblx0XHR2LnkgPSB0aGlzLm4yMSAqIGEueCArIHRoaXMubjIyICogYS55ICsgdGhpcy5uMjMgKiBhLnogKyB0aGlzLm4yNCAqIGEudztcblx0XHR2LnogPSB0aGlzLm4zMSAqIGEueCArIHRoaXMubjMyICogYS55ICsgdGhpcy5uMzMgKiBhLnogKyB0aGlzLm4zNCAqIGEudztcblxuXHRcdHYudyA9ICggYS53ICkgPyB0aGlzLm40MSAqIGEueCArIHRoaXMubjQyICogYS55ICsgdGhpcy5uNDMgKiBhLnogKyB0aGlzLm40NCAqIGEudyA6IDE7XG5cblx0XHRyZXR1cm4gdjtcblxuXHR9LFxuXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbjExID0gdGhpcy5uMTEsIG4xMiA9IHRoaXMubjEyLCBuMTMgPSB0aGlzLm4xMywgbjE0ID0gdGhpcy5uMTQsXG5cdFx0bjIxID0gdGhpcy5uMjEsIG4yMiA9IHRoaXMubjIyLCBuMjMgPSB0aGlzLm4yMywgbjI0ID0gdGhpcy5uMjQsXG5cdFx0bjMxID0gdGhpcy5uMzEsIG4zMiA9IHRoaXMubjMyLCBuMzMgPSB0aGlzLm4zMywgbjM0ID0gdGhpcy5uMzQsXG5cdFx0bjQxID0gdGhpcy5uNDEsIG40MiA9IHRoaXMubjQyLCBuNDMgPSB0aGlzLm40MywgbjQ0ID0gdGhpcy5uNDQ7XG5cblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXHRcdHJldHVybiAoXG5cdFx0XHRuMTQgKiBuMjMgKiBuMzIgKiBuNDEtXG5cdFx0XHRuMTMgKiBuMjQgKiBuMzIgKiBuNDEtXG5cdFx0XHRuMTQgKiBuMjIgKiBuMzMgKiBuNDErXG5cdFx0XHRuMTIgKiBuMjQgKiBuMzMgKiBuNDErXG5cblx0XHRcdG4xMyAqIG4yMiAqIG4zNCAqIG40MS1cblx0XHRcdG4xMiAqIG4yMyAqIG4zNCAqIG40MS1cblx0XHRcdG4xNCAqIG4yMyAqIG4zMSAqIG40Mitcblx0XHRcdG4xMyAqIG4yNCAqIG4zMSAqIG40MitcblxuXHRcdFx0bjE0ICogbjIxICogbjMzICogbjQyLVxuXHRcdFx0bjExICogbjI0ICogbjMzICogbjQyLVxuXHRcdFx0bjEzICogbjIxICogbjM0ICogbjQyK1xuXHRcdFx0bjExICogbjIzICogbjM0ICogbjQyK1xuXG5cdFx0XHRuMTQgKiBuMjIgKiBuMzEgKiBuNDMtXG5cdFx0XHRuMTIgKiBuMjQgKiBuMzEgKiBuNDMtXG5cdFx0XHRuMTQgKiBuMjEgKiBuMzIgKiBuNDMrXG5cdFx0XHRuMTEgKiBuMjQgKiBuMzIgKiBuNDMrXG5cblx0XHRcdG4xMiAqIG4yMSAqIG4zNCAqIG40My1cblx0XHRcdG4xMSAqIG4yMiAqIG4zNCAqIG40My1cblx0XHRcdG4xMyAqIG4yMiAqIG4zMSAqIG40NCtcblx0XHRcdG4xMiAqIG4yMyAqIG4zMSAqIG40NCtcblxuXHRcdFx0bjEzICogbjIxICogbjMyICogbjQ0LVxuXHRcdFx0bjExICogbjIzICogbjMyICogbjQ0LVxuXHRcdFx0bjEyICogbjIxICogbjMzICogbjQ0K1xuXHRcdFx0bjExICogbjIyICogbjMzICogbjQ0XG5cdFx0KTtcblxuXHR9LFxuXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRtcDtcblxuXHRcdHRtcCA9IHRoaXMubjIxOyB0aGlzLm4yMSA9IHRoaXMubjEyOyB0aGlzLm4xMiA9IHRtcDtcblx0XHR0bXAgPSB0aGlzLm4zMTsgdGhpcy5uMzEgPSB0aGlzLm4xMzsgdGhpcy5uMTMgPSB0bXA7XG5cdFx0dG1wID0gdGhpcy5uMzI7IHRoaXMubjMyID0gdGhpcy5uMjM7IHRoaXMubjIzID0gdG1wO1xuXG5cdFx0dG1wID0gdGhpcy5uNDE7IHRoaXMubjQxID0gdGhpcy5uMTQ7IHRoaXMubjE0ID0gdG1wO1xuXHRcdHRtcCA9IHRoaXMubjQyOyB0aGlzLm40MiA9IHRoaXMubjI0OyB0aGlzLm4yNCA9IHRtcDtcblx0XHR0bXAgPSB0aGlzLm40MzsgdGhpcy5uNDMgPSB0aGlzLm4zNDsgdGhpcy5uNDMgPSB0bXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRtLm4xMSA9IHRoaXMubjExOyBtLm4xMiA9IHRoaXMubjEyOyBtLm4xMyA9IHRoaXMubjEzOyBtLm4xNCA9IHRoaXMubjE0O1xuXHRcdG0ubjIxID0gdGhpcy5uMjE7IG0ubjIyID0gdGhpcy5uMjI7IG0ubjIzID0gdGhpcy5uMjM7IG0ubjI0ID0gdGhpcy5uMjQ7XG5cdFx0bS5uMzEgPSB0aGlzLm4zMTsgbS5uMzIgPSB0aGlzLm4zMjsgbS5uMzMgPSB0aGlzLm4zMzsgbS5uMzQgPSB0aGlzLm4zNDtcblx0XHRtLm40MSA9IHRoaXMubjQxOyBtLm40MiA9IHRoaXMubjQyOyBtLm40MyA9IHRoaXMubjQzOyBtLm40NCA9IHRoaXMubjQ0O1xuXG5cdFx0cmV0dXJuIG07XG5cblx0fSxcblxuXHRmbGF0dGVuOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmZsYXRbIDAgXSA9IHRoaXMubjExOyB0aGlzLmZsYXRbIDEgXSA9IHRoaXMubjIxOyB0aGlzLmZsYXRbIDIgXSA9IHRoaXMubjMxOyB0aGlzLmZsYXRbIDMgXSA9IHRoaXMubjQxO1xuXHRcdHRoaXMuZmxhdFsgNCBdID0gdGhpcy5uMTI7IHRoaXMuZmxhdFsgNSBdID0gdGhpcy5uMjI7IHRoaXMuZmxhdFsgNiBdID0gdGhpcy5uMzI7IHRoaXMuZmxhdFsgNyBdID0gdGhpcy5uNDI7XG5cdFx0dGhpcy5mbGF0WyA4IF0gID0gdGhpcy5uMTM7IHRoaXMuZmxhdFsgOSBdICA9IHRoaXMubjIzOyB0aGlzLmZsYXRbIDEwIF0gPSB0aGlzLm4zMzsgdGhpcy5mbGF0WyAxMSBdID0gdGhpcy5uNDM7XG5cdFx0dGhpcy5mbGF0WyAxMiBdID0gdGhpcy5uMTQ7IHRoaXMuZmxhdFsgMTMgXSA9IHRoaXMubjI0OyB0aGlzLmZsYXRbIDE0IF0gPSB0aGlzLm4zNDsgdGhpcy5mbGF0WyAxNSBdID0gdGhpcy5uNDQ7XG5cblx0XHRyZXR1cm4gdGhpcy5mbGF0O1xuXG5cdH0sXG5cblx0ZmxhdHRlblRvQXJyYXk6IGZ1bmN0aW9uICggZmxhdCApIHtcblxuXHRcdGZsYXRbIDAgXSA9IHRoaXMubjExOyBmbGF0WyAxIF0gPSB0aGlzLm4yMTsgZmxhdFsgMiBdID0gdGhpcy5uMzE7IGZsYXRbIDMgXSA9IHRoaXMubjQxO1xuXHRcdGZsYXRbIDQgXSA9IHRoaXMubjEyOyBmbGF0WyA1IF0gPSB0aGlzLm4yMjsgZmxhdFsgNiBdID0gdGhpcy5uMzI7IGZsYXRbIDcgXSA9IHRoaXMubjQyO1xuXHRcdGZsYXRbIDggXSAgPSB0aGlzLm4xMzsgZmxhdFsgOSBdICA9IHRoaXMubjIzOyBmbGF0WyAxMCBdID0gdGhpcy5uMzM7IGZsYXRbIDExIF0gPSB0aGlzLm40Mztcblx0XHRmbGF0WyAxMiBdID0gdGhpcy5uMTQ7IGZsYXRbIDEzIF0gPSB0aGlzLm4yNDsgZmxhdFsgMTQgXSA9IHRoaXMubjM0OyBmbGF0WyAxNSBdID0gdGhpcy5uNDQ7XG5cblx0XHRyZXR1cm4gZmxhdDtcblxuXHR9LFxuXG5cdGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiggZmxhdCwgb2Zmc2V0ICkge1xuXG5cdFx0ZmxhdFsgb2Zmc2V0IF0gPSB0aGlzLm4xMTtcblx0XHRmbGF0WyBvZmZzZXQgKyAxIF0gPSB0aGlzLm4yMTtcblx0XHRmbGF0WyBvZmZzZXQgKyAyIF0gPSB0aGlzLm4zMTtcblx0XHRmbGF0WyBvZmZzZXQgKyAzIF0gPSB0aGlzLm40MTtcblxuXHRcdGZsYXRbIG9mZnNldCArIDQgXSA9IHRoaXMubjEyO1xuXHRcdGZsYXRbIG9mZnNldCArIDUgXSA9IHRoaXMubjIyO1xuXHRcdGZsYXRbIG9mZnNldCArIDYgXSA9IHRoaXMubjMyO1xuXHRcdGZsYXRbIG9mZnNldCArIDcgXSA9IHRoaXMubjQyO1xuXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgOCBdICA9IHRoaXMubjEzO1xuXHRcdGZsYXRbIG9mZnNldCArIDkgXSAgPSB0aGlzLm4yMztcblx0XHRmbGF0WyBvZmZzZXQgKyAxMCBdID0gdGhpcy5uMzM7XG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTEgXSA9IHRoaXMubjQzO1xuXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTIgXSA9IHRoaXMubjE0O1xuXHRcdGZsYXRbIG9mZnNldCArIDEzIF0gPSB0aGlzLm4yNDtcblx0XHRmbGF0WyBvZmZzZXQgKyAxNCBdID0gdGhpcy5uMzQ7XG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTUgXSA9IHRoaXMubjQ0O1xuXG5cdFx0cmV0dXJuIGZsYXQ7XG5cblx0fSxcblxuXHRzZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24oIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHQwLCAwLCAxLCB6LFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0U2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR4LCAwLCAwLCAwLFxuXHRcdFx0MCwgeSwgMCwgMCxcblx0XHRcdDAsIDAsIHosIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvblg6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgIDAsIDAsXG5cdFx0XHQwLCBjLCAtcywgMCxcblx0XHRcdDAsIHMsICBjLCAwLFxuXHRcdFx0MCwgMCwgIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFJvdGF0aW9uWTogZnVuY3Rpb24oIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdCBjLCAwLCBzLCAwLFxuXHRcdFx0IDAsIDEsIDAsIDAsXG5cdFx0XHQtcywgMCwgYywgMCxcblx0XHRcdCAwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvblo6IGZ1bmN0aW9uKCB0aGV0YSApIHtcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtcywgMCwgMCxcblx0XHRcdHMsICBjLCAwLCAwLFxuXHRcdFx0MCwgIDAsIDEsIDAsXG5cdFx0XHQwLCAgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25BeGlzOiBmdW5jdGlvbiggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksXG5cdFx0cyA9IE1hdGguc2luKCBhbmdsZSApLFxuXHRcdHQgPSAxIC0gYyxcblx0XHR4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56LFxuXHRcdHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdCBcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcblx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHQgcmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy5uMTQgPSB2Lng7XG5cdFx0dGhpcy5uMjQgPSB2Lnk7XG5cdFx0dGhpcy5uMzQgPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gVEhSRUUuTWF0cml4NC5fX3YxLnNldCggdGhpcy5uMTQsIHRoaXMubjI0LCB0aGlzLm4zNCApO1xuXG5cdH0sXG5cblx0Z2V0Q29sdW1uWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIFRIUkVFLk1hdHJpeDQuX192MS5zZXQoIHRoaXMubjExLCB0aGlzLm4yMSwgdGhpcy5uMzEgKTtcblxuXHR9LFxuXG5cdGdldENvbHVtblk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBUSFJFRS5NYXRyaXg0Ll9fdjEuc2V0KCB0aGlzLm4xMiwgdGhpcy5uMjIsIHRoaXMubjMyICk7XG5cblx0fSxcblxuXHRnZXRDb2x1bW5aOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBUSFJFRS5NYXRyaXg0Ll9fdjEuc2V0KCB0aGlzLm4xMywgdGhpcy5uMjMsIHRoaXMubjMzICk7XG5cblx0fSxcblxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblxuXHRcdHZhciBuMTEgPSBtLm4xMSwgbjEyID0gbS5uMTIsIG4xMyA9IG0ubjEzLCBuMTQgPSBtLm4xNCxcblx0XHRuMjEgPSBtLm4yMSwgbjIyID0gbS5uMjIsIG4yMyA9IG0ubjIzLCBuMjQgPSBtLm4yNCxcblx0XHRuMzEgPSBtLm4zMSwgbjMyID0gbS5uMzIsIG4zMyA9IG0ubjMzLCBuMzQgPSBtLm4zNCxcblx0XHRuNDEgPSBtLm40MSwgbjQyID0gbS5uNDIsIG40MyA9IG0ubjQzLCBuNDQgPSBtLm40NDtcblxuXHRcdHRoaXMubjExID0gbjIzKm4zNCpuNDIgLSBuMjQqbjMzKm40MiArIG4yNCpuMzIqbjQzIC0gbjIyKm4zNCpuNDMgLSBuMjMqbjMyKm40NCArIG4yMipuMzMqbjQ0O1xuXHRcdHRoaXMubjEyID0gbjE0Km4zMypuNDIgLSBuMTMqbjM0Km40MiAtIG4xNCpuMzIqbjQzICsgbjEyKm4zNCpuNDMgKyBuMTMqbjMyKm40NCAtIG4xMipuMzMqbjQ0O1xuXHRcdHRoaXMubjEzID0gbjEzKm4yNCpuNDIgLSBuMTQqbjIzKm40MiArIG4xNCpuMjIqbjQzIC0gbjEyKm4yNCpuNDMgLSBuMTMqbjIyKm40NCArIG4xMipuMjMqbjQ0O1xuXHRcdHRoaXMubjE0ID0gbjE0Km4yMypuMzIgLSBuMTMqbjI0Km4zMiAtIG4xNCpuMjIqbjMzICsgbjEyKm4yNCpuMzMgKyBuMTMqbjIyKm4zNCAtIG4xMipuMjMqbjM0O1xuXHRcdHRoaXMubjIxID0gbjI0Km4zMypuNDEgLSBuMjMqbjM0Km40MSAtIG4yNCpuMzEqbjQzICsgbjIxKm4zNCpuNDMgKyBuMjMqbjMxKm40NCAtIG4yMSpuMzMqbjQ0O1xuXHRcdHRoaXMubjIyID0gbjEzKm4zNCpuNDEgLSBuMTQqbjMzKm40MSArIG4xNCpuMzEqbjQzIC0gbjExKm4zNCpuNDMgLSBuMTMqbjMxKm40NCArIG4xMSpuMzMqbjQ0O1xuXHRcdHRoaXMubjIzID0gbjE0Km4yMypuNDEgLSBuMTMqbjI0Km40MSAtIG4xNCpuMjEqbjQzICsgbjExKm4yNCpuNDMgKyBuMTMqbjIxKm40NCAtIG4xMSpuMjMqbjQ0O1xuXHRcdHRoaXMubjI0ID0gbjEzKm4yNCpuMzEgLSBuMTQqbjIzKm4zMSArIG4xNCpuMjEqbjMzIC0gbjExKm4yNCpuMzMgLSBuMTMqbjIxKm4zNCArIG4xMSpuMjMqbjM0O1xuXHRcdHRoaXMubjMxID0gbjIyKm4zNCpuNDEgLSBuMjQqbjMyKm40MSArIG4yNCpuMzEqbjQyIC0gbjIxKm4zNCpuNDIgLSBuMjIqbjMxKm40NCArIG4yMSpuMzIqbjQ0O1xuXHRcdHRoaXMubjMyID0gbjE0Km4zMipuNDEgLSBuMTIqbjM0Km40MSAtIG4xNCpuMzEqbjQyICsgbjExKm4zNCpuNDIgKyBuMTIqbjMxKm40NCAtIG4xMSpuMzIqbjQ0O1xuXHRcdHRoaXMubjMzID0gbjEzKm4yNCpuNDEgLSBuMTQqbjIyKm40MSArIG4xNCpuMjEqbjQyIC0gbjExKm4yNCpuNDIgLSBuMTIqbjIxKm40NCArIG4xMSpuMjIqbjQ0O1xuXHRcdHRoaXMubjM0ID0gbjE0Km4yMipuMzEgLSBuMTIqbjI0Km4zMSAtIG4xNCpuMjEqbjMyICsgbjExKm4yNCpuMzIgKyBuMTIqbjIxKm4zNCAtIG4xMSpuMjIqbjM0O1xuXHRcdHRoaXMubjQxID0gbjIzKm4zMipuNDEgLSBuMjIqbjMzKm40MSAtIG4yMypuMzEqbjQyICsgbjIxKm4zMypuNDIgKyBuMjIqbjMxKm40MyAtIG4yMSpuMzIqbjQzO1xuXHRcdHRoaXMubjQyID0gbjEyKm4zMypuNDEgLSBuMTMqbjMyKm40MSArIG4xMypuMzEqbjQyIC0gbjExKm4zMypuNDIgLSBuMTIqbjMxKm40MyArIG4xMSpuMzIqbjQzO1xuXHRcdHRoaXMubjQzID0gbjEzKm4yMipuNDEgLSBuMTIqbjIzKm40MSAtIG4xMypuMjEqbjQyICsgbjExKm4yMypuNDIgKyBuMTIqbjIxKm40MyAtIG4xMSpuMjIqbjQzO1xuXHRcdHRoaXMubjQ0ID0gbjEyKm4yMypuMzEgLSBuMTMqbjIyKm4zMSArIG4xMypuMjEqbjMyIC0gbjExKm4yMypuMzIgLSBuMTIqbjIxKm4zMyArIG4xMSpuMjIqbjMzO1xuXHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBtLmRldGVybWluYW50KCkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uKCB2LCBvcmRlciApIHtcblxuXHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56LFxuXHRcdGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKSxcblx0XHRjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICksXG5cdFx0ZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xuXG5cdFx0c3dpdGNoICggb3JkZXIgKSB7XG5cblx0XHRcdGNhc2UgJ1lYWic6XG5cblx0XHRcdFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdFx0dGhpcy5uMTEgPSBjZSArIGRmICogYjtcblx0XHRcdFx0dGhpcy5uMTIgPSBkZSAqIGIgLSBjZjtcblx0XHRcdFx0dGhpcy5uMTMgPSBhICogZDtcblxuXHRcdFx0XHR0aGlzLm4yMSA9IGEgKiBmO1xuXHRcdFx0XHR0aGlzLm4yMiA9IGEgKiBlO1xuXHRcdFx0XHR0aGlzLm4yMyA9IC0gYjtcblxuXHRcdFx0XHR0aGlzLm4zMSA9IGNmICogYiAtIGRlO1xuXHRcdFx0XHR0aGlzLm4zMiA9IGRmICsgY2UgKiBiO1xuXHRcdFx0XHR0aGlzLm4zMyA9IGEgKiBjO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWlhZJzpcblxuXHRcdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0XHR0aGlzLm4xMSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0XHR0aGlzLm4xMiA9IC0gYSAqIGY7XG5cdFx0XHRcdHRoaXMubjEzID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdFx0dGhpcy5uMjEgPSBjZiArIGRlICogYjtcblx0XHRcdFx0dGhpcy5uMjIgPSBhICogZTtcblx0XHRcdFx0dGhpcy5uMjMgPSBkZiAtIGNlICogYjtcblxuXHRcdFx0XHR0aGlzLm4zMSA9IC0gYSAqIGQ7XG5cdFx0XHRcdHRoaXMubjMyID0gYjtcblx0XHRcdFx0dGhpcy5uMzMgPSBhICogYztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pZWCc6XG5cblx0XHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdFx0dGhpcy5uMTEgPSBjICogZTtcblx0XHRcdFx0dGhpcy5uMTIgPSBiZSAqIGQgLSBhZjtcblx0XHRcdFx0dGhpcy5uMTMgPSBhZSAqIGQgKyBiZjtcblxuXHRcdFx0XHR0aGlzLm4yMSA9IGMgKiBmO1xuXHRcdFx0XHR0aGlzLm4yMiA9IGJmICogZCArIGFlO1xuXHRcdFx0XHR0aGlzLm4yMyA9IGFmICogZCAtIGJlO1xuXG5cdFx0XHRcdHRoaXMubjMxID0gLSBkO1xuXHRcdFx0XHR0aGlzLm4zMiA9IGIgKiBjO1xuXHRcdFx0XHR0aGlzLm4zMyA9IGEgKiBjO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblxuXHRcdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0XHR0aGlzLm4xMSA9IGMgKiBlO1xuXHRcdFx0XHR0aGlzLm4xMiA9IGJkIC0gYWMgKiBmO1xuXHRcdFx0XHR0aGlzLm4xMyA9IGJjICogZiArIGFkO1xuXG5cdFx0XHRcdHRoaXMubjIxID0gZjtcblx0XHRcdFx0dGhpcy5uMjIgPSBhICogZTtcblx0XHRcdFx0dGhpcy5uMjMgPSAtIGIgKiBlO1xuXG5cdFx0XHRcdHRoaXMubjMxID0gLSBkICogZTtcblx0XHRcdFx0dGhpcy5uMzIgPSBhZCAqIGYgKyBiYztcblx0XHRcdFx0dGhpcy5uMzMgPSBhYyAtIGJkICogZjtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cblx0XHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdFx0dGhpcy5uMTEgPSBjICogZTtcblx0XHRcdFx0dGhpcy5uMTIgPSAtIGY7XG5cdFx0XHRcdHRoaXMubjEzID0gZCAqIGU7XG5cblx0XHRcdFx0dGhpcy5uMjEgPSBhYyAqIGYgKyBiZDtcblx0XHRcdFx0dGhpcy5uMjIgPSBhICogZTtcblx0XHRcdFx0dGhpcy5uMjMgPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0XHR0aGlzLm4zMSA9IGJjICogZiAtIGFkO1xuXHRcdFx0XHR0aGlzLm4zMiA9IGIgKiBlO1xuXHRcdFx0XHR0aGlzLm4zMyA9IGJkICogZiArIGFjO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDogLy8gJ1hZWidcblxuXHRcdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0XHR0aGlzLm4xMSA9IGMgKiBlO1xuXHRcdFx0XHR0aGlzLm4xMiA9IC0gYyAqIGY7XG5cdFx0XHRcdHRoaXMubjEzID0gZDtcblxuXHRcdFx0XHR0aGlzLm4yMSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0XHR0aGlzLm4yMiA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0XHR0aGlzLm4yMyA9IC0gYiAqIGM7XG5cblx0XHRcdFx0dGhpcy5uMzEgPSBiZiAtIGFlICogZDtcblx0XHRcdFx0dGhpcy5uMzIgPSBiZSArIGFmICogZDtcblx0XHRcdFx0dGhpcy5uMzMgPSBhICogYztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24oIHEgKSB7XG5cblx0XHR2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudyxcblx0XHR4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6LFxuXHRcdHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejIsXG5cdFx0eXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6Mixcblx0XHR3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xuXG5cdFx0dGhpcy5uMTEgPSAxIC0gKCB5eSArIHp6ICk7XG5cdFx0dGhpcy5uMTIgPSB4eSAtIHd6O1xuXHRcdHRoaXMubjEzID0geHogKyB3eTtcblxuXHRcdHRoaXMubjIxID0geHkgKyB3ejtcblx0XHR0aGlzLm4yMiA9IDEgLSAoIHh4ICsgenogKTtcblx0XHR0aGlzLm4yMyA9IHl6IC0gd3g7XG5cblx0XHR0aGlzLm4zMSA9IHh6IC0gd3k7XG5cdFx0dGhpcy5uMzIgPSB5eiArIHd4O1xuXHRcdHRoaXMubjMzID0gMSAtICggeHggKyB5eSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XG5cblx0XHR0aGlzLm4xMSAqPSB4OyB0aGlzLm4xMiAqPSB5OyB0aGlzLm4xMyAqPSB6O1xuXHRcdHRoaXMubjIxICo9IHg7IHRoaXMubjIyICo9IHk7IHRoaXMubjIzICo9IHo7XG5cdFx0dGhpcy5uMzEgKj0geDsgdGhpcy5uMzIgKj0geTsgdGhpcy5uMzMgKj0gejtcblx0XHR0aGlzLm40MSAqPSB4OyB0aGlzLm40MiAqPSB5OyB0aGlzLm40MyAqPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb21wb3NlOiBmdW5jdGlvbiAoIHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUgKSB7XG5cblx0XHR2YXIgbVJvdGF0aW9uID0gVEhSRUUuTWF0cml4NC5fX20xO1xuXHRcdHZhciBtU2NhbGUgPSBUSFJFRS5NYXRyaXg0Ll9fbTI7XG5cblx0XHRtUm90YXRpb24uaWRlbnRpdHkoKTtcblx0XHRtUm90YXRpb24uc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiggcm90YXRpb24gKTtcblxuXHRcdG1TY2FsZS5zZXRTY2FsZSggc2NhbGUueCwgc2NhbGUueSwgc2NhbGUueiApO1xuXG5cdFx0dGhpcy5tdWx0aXBseSggbVJvdGF0aW9uLCBtU2NhbGUgKTtcblxuXHRcdHRoaXMubjE0ID0gdHJhbnNsYXRpb24ueDtcblx0XHR0aGlzLm4yNCA9IHRyYW5zbGF0aW9uLnk7XG5cdFx0dGhpcy5uMzQgPSB0cmFuc2xhdGlvbi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICggdHJhbnNsYXRpb24sIHJvdGF0aW9uLCBzY2FsZSApIHtcblxuXHRcdC8vIGdyYWIgdGhlIGF4aXMgdmVjdG9yc1xuXG5cdFx0dmFyIHggPSBUSFJFRS5NYXRyaXg0Ll9fdjE7XG5cdFx0dmFyIHkgPSBUSFJFRS5NYXRyaXg0Ll9fdjI7XG5cdFx0dmFyIHogPSBUSFJFRS5NYXRyaXg0Ll9fdjM7XG5cblx0XHR4LnNldCggdGhpcy5uMTEsIHRoaXMubjIxLCB0aGlzLm4zMSApO1xuXHRcdHkuc2V0KCB0aGlzLm4xMiwgdGhpcy5uMjIsIHRoaXMubjMyICk7XG5cdFx0ei5zZXQoIHRoaXMubjEzLCB0aGlzLm4yMywgdGhpcy5uMzMgKTtcblxuXHRcdHRyYW5zbGF0aW9uID0gKCB0cmFuc2xhdGlvbiBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSA/IHRyYW5zbGF0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyb3RhdGlvbiA9ICggcm90YXRpb24gaW5zdGFuY2VvZiBUSFJFRS5RdWF0ZXJuaW9uICkgPyByb3RhdGlvbiA6IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cdFx0c2NhbGUgPSAoIHNjYWxlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApID8gc2NhbGUgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0c2NhbGUueCA9IHgubGVuZ3RoKCk7XG5cdFx0c2NhbGUueSA9IHkubGVuZ3RoKCk7XG5cdFx0c2NhbGUueiA9IHoubGVuZ3RoKCk7XG5cblx0XHR0cmFuc2xhdGlvbi54ID0gdGhpcy5uMTQ7XG5cdFx0dHJhbnNsYXRpb24ueSA9IHRoaXMubjI0O1xuXHRcdHRyYW5zbGF0aW9uLnogPSB0aGlzLm4zNDtcblxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cblx0XHR2YXIgbWF0cml4ID0gVEhSRUUuTWF0cml4NC5fX20xO1xuXG5cdFx0bWF0cml4LmNvcHkoIHRoaXMgKTtcblxuXHRcdG1hdHJpeC5uMTEgLz0gc2NhbGUueDtcblx0XHRtYXRyaXgubjIxIC89IHNjYWxlLng7XG5cdFx0bWF0cml4Lm4zMSAvPSBzY2FsZS54O1xuXG5cdFx0bWF0cml4Lm4xMiAvPSBzY2FsZS55O1xuXHRcdG1hdHJpeC5uMjIgLz0gc2NhbGUueTtcblx0XHRtYXRyaXgubjMyIC89IHNjYWxlLnk7XG5cblx0XHRtYXRyaXgubjEzIC89IHNjYWxlLno7XG5cdFx0bWF0cml4Lm4yMyAvPSBzY2FsZS56O1xuXHRcdG1hdHJpeC5uMzMgLz0gc2NhbGUuejtcblxuXHRcdHJvdGF0aW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRyZXR1cm4gWyB0cmFuc2xhdGlvbiwgcm90YXRpb24sIHNjYWxlIF07XG5cblx0fSxcblxuXHRleHRyYWN0UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHRoaXMubjE0ID0gbS5uMTQ7XG5cdFx0dGhpcy5uMjQgPSBtLm4yNDtcblx0XHR0aGlzLm4zNCA9IG0ubjM0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBUSFJFRS5NYXRyaXg0Ll9fdjE7XG5cblx0XHR2YXIgc2NhbGVYID0gMSAvIHZlY3Rvci5zZXQoIG0ubjExLCBtLm4yMSwgbS5uMzEgKS5sZW5ndGgoKTtcblx0XHR2YXIgc2NhbGVZID0gMSAvIHZlY3Rvci5zZXQoIG0ubjEyLCBtLm4yMiwgbS5uMzIgKS5sZW5ndGgoKTtcblx0XHR2YXIgc2NhbGVaID0gMSAvIHZlY3Rvci5zZXQoIG0ubjEzLCBtLm4yMywgbS5uMzMgKS5sZW5ndGgoKTtcblxuXHRcdHRoaXMubjExID0gbS5uMTEgKiBzY2FsZVg7XG5cdFx0dGhpcy5uMjEgPSBtLm4yMSAqIHNjYWxlWDtcblx0XHR0aGlzLm4zMSA9IG0ubjMxICogc2NhbGVYO1xuXG5cdFx0dGhpcy5uMTIgPSBtLm4xMiAqIHNjYWxlWTtcblx0XHR0aGlzLm4yMiA9IG0ubjIyICogc2NhbGVZO1xuXHRcdHRoaXMubjMyID0gbS5uMzIgKiBzY2FsZVk7XG5cblx0XHR0aGlzLm4xMyA9IG0ubjEzICogc2NhbGVaO1xuXHRcdHRoaXMubjIzID0gbS5uMjMgKiBzY2FsZVo7XG5cdFx0dGhpcy5uMzMgPSBtLm4zMyAqIHNjYWxlWjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTWF0cml4NC5tYWtlSW52ZXJ0M3gzID0gZnVuY3Rpb24gKCBtMSApIHtcblxuXHQvLyBpbnB1dDogIFRIUkVFLk1hdHJpeDQsIG91dHB1dDogVEhSRUUuTWF0cml4M1xuXHQvLyAoIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1tanMvIClcblxuXHR2YXIgbTMzID0gbTEubTMzLCBtMzNtID0gbTMzLm0sXG5cdGExMSA9ICAgbTEubjMzICogbTEubjIyIC0gbTEubjMyICogbTEubjIzLFxuXHRhMjEgPSAtIG0xLm4zMyAqIG0xLm4yMSArIG0xLm4zMSAqIG0xLm4yMyxcblx0YTMxID0gICBtMS5uMzIgKiBtMS5uMjEgLSBtMS5uMzEgKiBtMS5uMjIsXG5cdGExMiA9IC0gbTEubjMzICogbTEubjEyICsgbTEubjMyICogbTEubjEzLFxuXHRhMjIgPSAgIG0xLm4zMyAqIG0xLm4xMSAtIG0xLm4zMSAqIG0xLm4xMyxcblx0YTMyID0gLSBtMS5uMzIgKiBtMS5uMTEgKyBtMS5uMzEgKiBtMS5uMTIsXG5cdGExMyA9ICAgbTEubjIzICogbTEubjEyIC0gbTEubjIyICogbTEubjEzLFxuXHRhMjMgPSAtIG0xLm4yMyAqIG0xLm4xMSArIG0xLm4yMSAqIG0xLm4xMyxcblx0YTMzID0gICBtMS5uMjIgKiBtMS5uMTEgLSBtMS5uMjEgKiBtMS5uMTIsXG5cblx0ZGV0ID0gbTEubjExICogYTExICsgbTEubjIxICogYTEyICsgbTEubjMxICogYTEzLFxuXG5cdGlkZXQ7XG5cblx0Ly8gbm8gaW52ZXJzZVxuXG5cdGlmICggZGV0ID09PSAwICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQubWFrZUludmVydDN4MzogTWF0cml4IG5vdCBpbnZlcnRpYmxlLicgKTtcblxuXHR9XG5cblx0aWRldCA9IDEuMCAvIGRldDtcblxuXHRtMzNtWyAwIF0gPSBpZGV0ICogYTExOyBtMzNtWyAxIF0gPSBpZGV0ICogYTIxOyBtMzNtWyAyIF0gPSBpZGV0ICogYTMxO1xuXHRtMzNtWyAzIF0gPSBpZGV0ICogYTEyOyBtMzNtWyA0IF0gPSBpZGV0ICogYTIyOyBtMzNtWyA1IF0gPSBpZGV0ICogYTMyO1xuXHRtMzNtWyA2IF0gPSBpZGV0ICogYTEzOyBtMzNtWyA3IF0gPSBpZGV0ICogYTIzOyBtMzNtWyA4IF0gPSBpZGV0ICogYTMzO1xuXG5cdHJldHVybiBtMzM7XG5cbn1cblxuVEhSRUUuTWF0cml4NC5tYWtlRnJ1c3R1bSA9IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XG5cblx0dmFyIG0sIHgsIHksIGEsIGIsIGMsIGQ7XG5cblx0bSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0eCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcblx0eSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcblx0YyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcblx0ZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRtLm4xMSA9IHg7ICBtLm4xMiA9IDA7ICBtLm4xMyA9IGE7ICAgbS5uMTQgPSAwO1xuXHRtLm4yMSA9IDA7ICBtLm4yMiA9IHk7ICBtLm4yMyA9IGI7ICAgbS5uMjQgPSAwO1xuXHRtLm4zMSA9IDA7ICBtLm4zMiA9IDA7ICBtLm4zMyA9IGM7ICAgbS5uMzQgPSBkO1xuXHRtLm40MSA9IDA7ICBtLm40MiA9IDA7ICBtLm40MyA9IC0gMTsgbS5uNDQgPSAwO1xuXG5cdHJldHVybiBtO1xuXG59O1xuXG5USFJFRS5NYXRyaXg0Lm1ha2VQZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuXHR2YXIgeW1heCwgeW1pbiwgeG1pbiwgeG1heDtcblxuXHR5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBmb3YgKiBNYXRoLlBJIC8gMzYwICk7XG5cdHltaW4gPSAtIHltYXg7XG5cdHhtaW4gPSB5bWluICogYXNwZWN0O1xuXHR4bWF4ID0geW1heCAqIGFzcGVjdDtcblxuXHRyZXR1cm4gVEhSRUUuTWF0cml4NC5tYWtlRnJ1c3R1bSggeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyICk7XG5cbn07XG5cblRIUkVFLk1hdHJpeDQubWFrZU9ydGhvID0gZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHR2YXIgbSwgeCwgeSwgeiwgdywgaCwgcDtcblxuXHRtID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR3ID0gcmlnaHQgLSBsZWZ0O1xuXHRoID0gdG9wIC0gYm90dG9tO1xuXHRwID0gZmFyIC0gbmVhcjtcblxuXHR4ID0gKCByaWdodCArIGxlZnQgKSAvIHc7XG5cdHkgPSAoIHRvcCArIGJvdHRvbSApIC8gaDtcblx0eiA9ICggZmFyICsgbmVhciApIC8gcDtcblxuXHRtLm4xMSA9IDIgLyB3OyBtLm4xMiA9IDA7ICAgICBtLm4xMyA9IDA7ICAgICAgbS5uMTQgPSAteDtcblx0bS5uMjEgPSAwOyAgICAgbS5uMjIgPSAyIC8gaDsgbS5uMjMgPSAwOyAgICAgIG0ubjI0ID0gLXk7XG5cdG0ubjMxID0gMDsgICAgIG0ubjMyID0gMDsgICAgIG0ubjMzID0gLTIgLyBwOyBtLm4zNCA9IC16O1xuXHRtLm40MSA9IDA7ICAgICBtLm40MiA9IDA7ICAgICBtLm40MyA9IDA7ICAgICAgbS5uNDQgPSAxO1xuXG5cdHJldHVybiBtO1xuXG59O1xuXG5USFJFRS5NYXRyaXg0Ll9fdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuVEhSRUUuTWF0cml4NC5fX3YyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblRIUkVFLk1hdHJpeDQuX192MyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblRIUkVFLk1hdHJpeDQuX19tMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5USFJFRS5NYXRyaXg0Ll9fbTIgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk9iamVjdDNEID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXG5cdHRoaXMuaWQgPSBUSFJFRS5PYmplY3QzRENvdW50ICsrO1xuXG5cdHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuXHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0dGhpcy51cCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMucm90YXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR0aGlzLmV1bGVyT3JkZXIgPSAnWFlaJztcblx0dGhpcy5zY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0dGhpcy5keW5hbWljID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBpdCByZXRhaW5zIGFycmF5cyBzbyB0aGV5IGNhbiBiZSB1cGRhdGVkIHdpdGggX19kaXJ0eSpcblxuXHR0aGlzLmRvdWJsZVNpZGVkID0gZmFsc2U7XG5cdHRoaXMuZmxpcFNpZGVkID0gZmFsc2U7XG5cblx0dGhpcy5yZW5kZXJEZXB0aCA9IG51bGw7XG5cblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdHRoaXMubWF0cml4Um90YXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR0aGlzLnF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXHR0aGlzLnVzZVF1YXRlcm5pb24gPSBmYWxzZTtcblxuXHR0aGlzLmJvdW5kUmFkaXVzID0gMC4wO1xuXHR0aGlzLmJvdW5kUmFkaXVzU2NhbGUgPSAxLjA7XG5cblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcblx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG5cblx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblxuXHR0aGlzLl92ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5cblRIUkVFLk9iamVjdDNELnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0M0QsXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xuXG5cdFx0dGhpcy5tYXRyaXgucm90YXRlQXhpcyggYXhpcyApO1xuXHRcdHRoaXMucG9zaXRpb24uYWRkU2VsZiggYXhpcy5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlWDogZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRcdHRoaXMudHJhbnNsYXRlKCBkaXN0YW5jZSwgdGhpcy5fdmVjdG9yLnNldCggMSwgMCwgMCApICk7XG5cblx0fSxcblxuXHR0cmFuc2xhdGVZOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0dGhpcy50cmFuc2xhdGUoIGRpc3RhbmNlLCB0aGlzLl92ZWN0b3Iuc2V0KCAwLCAxLCAwICkgKTtcblxuXHR9LFxuXG5cdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cblx0XHR0aGlzLnRyYW5zbGF0ZSggZGlzdGFuY2UsIHRoaXMuX3ZlY3Rvci5zZXQoIDAsIDAsIDEgKSApO1xuXG5cdH0sXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdC8vIFRPRE86IEFkZCBoaWVyYXJjaHkgc3VwcG9ydC5cblxuXHRcdHRoaXMubWF0cml4Lmxvb2tBdCggdmVjdG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwICk7XG5cblx0XHRpZiAoIHRoaXMucm90YXRpb25BdXRvVXBkYXRlICkge1xuXG5cdFx0XHR0aGlzLnJvdGF0aW9uLnNldFJvdGF0aW9uRnJvbU1hdHJpeCggdGhpcy5tYXRyaXggKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICkgPT09IC0gMSApIHtcblxuXHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0Ly8gYWRkIHRvIHNjZW5lXG5cblx0XHRcdHZhciBzY2VuZSA9IHRoaXM7XG5cblx0XHRcdHdoaWxlICggc2NlbmUucGFyZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NlbmUgPSBzY2VuZS5wYXJlbnQ7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzY2VuZSAhPT0gdW5kZWZpbmVkICYmIHNjZW5lIGluc3RhbmNlb2YgVEhSRUUuU2NlbmUgKSAge1xuXG5cdFx0XHRcdHNjZW5lLmFkZE9iamVjdCggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdC8vIHJlbW92ZSBmcm9tIHNjZW5lXG5cblx0XHRcdHZhciBzY2VuZSA9IHRoaXM7XG5cblx0XHRcdHdoaWxlICggc2NlbmUucGFyZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NlbmUgPSBzY2VuZS5wYXJlbnQ7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzY2VuZSAhPT0gdW5kZWZpbmVkICYmIHNjZW5lIGluc3RhbmNlb2YgVEhSRUUuU2NlbmUgKSB7XG5cblx0XHRcdFx0c2NlbmUucmVtb3ZlT2JqZWN0KCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSwgZG9SZWN1cnNlICkge1xuXG5cdFx0dmFyIGMsIGNsLCBjaGlsZCwgcmVjdXJzZVJlc3VsdDtcblxuXHRcdGZvciAoIGMgPSAwLCBjbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBjIDwgY2w7IGMgKysgKSB7XG5cblx0XHRcdGNoaWxkID0gdGhpcy5jaGlsZHJlblsgYyBdO1xuXG5cdFx0XHRpZiAoIGNoaWxkLm5hbWUgPT09IG5hbWUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGNoaWxkO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZG9SZWN1cnNlICkge1xuXG5cdFx0XHRcdHJlY3Vyc2VSZXN1bHQgPSBjaGlsZC5nZXRDaGlsZEJ5TmFtZSggbmFtZSwgZG9SZWN1cnNlICk7XG5cblx0XHRcdFx0aWYgKCByZWN1cnNlUmVzdWx0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVjdXJzZVJlc3VsdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fSxcblxuXHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWF0cml4LnNldFBvc2l0aW9uKCB0aGlzLnBvc2l0aW9uICk7XG5cblx0XHRpZiAoIHRoaXMudXNlUXVhdGVybmlvbiApICB7XG5cblx0XHRcdHRoaXMubWF0cml4LnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXRyaXguc2V0Um90YXRpb25Gcm9tRXVsZXIoIHRoaXMucm90YXRpb24sIHRoaXMuZXVsZXJPcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnNjYWxlLnggIT09IDEgfHwgdGhpcy5zY2FsZS55ICE9PSAxIHx8IHRoaXMuc2NhbGUueiAhPT0gMSApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXguc2NhbGUoIHRoaXMuc2NhbGUgKTtcblx0XHRcdHRoaXMuYm91bmRSYWRpdXNTY2FsZSA9IE1hdGgubWF4KCB0aGlzLnNjYWxlLngsIE1hdGgubWF4KCB0aGlzLnNjYWxlLnksIHRoaXMuc2NhbGUueiApICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgJiYgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdC8vIHVwZGF0ZSBtYXRyaXhXb3JsZFxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wYXJlbnQgKSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseSggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRmb3JjZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVEhSRUUuT2JqZWN0M0RDb3VudCA9IDA7XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IganVsaWFud2EgLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWFud2FcbiAqL1xuXG5USFJFRS5Qcm9qZWN0b3IgPSBmdW5jdGlvbigpIHtcblxuXHR2YXIgX29iamVjdCwgX29iamVjdENvdW50LCBfb2JqZWN0UG9vbCA9IFtdLFxuXHRfdmVydGV4LCBfdmVydGV4Q291bnQsIF92ZXJ0ZXhQb29sID0gW10sXG5cdF9mYWNlLCBfZmFjZTNDb3VudCwgX2ZhY2UzUG9vbCA9IFtdLCBfZmFjZTRDb3VudCwgX2ZhY2U0UG9vbCA9IFtdLFxuXHRfbGluZSwgX2xpbmVDb3VudCwgX2xpbmVQb29sID0gW10sXG5cdF9wYXJ0aWNsZSwgX3BhcnRpY2xlQ291bnQsIF9wYXJ0aWNsZVBvb2wgPSBbXSxcblxuXHRfcmVuZGVyRGF0YSA9IHsgb2JqZWN0czogW10sIHNwcml0ZXM6IFtdLCBsaWdodHM6IFtdLCBlbGVtZW50czogW10gfSxcblxuXHRfdmVjdG9yMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdF92ZWN0b3I0ID0gbmV3IFRIUkVFLlZlY3RvcjQoKSxcblxuXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cdF9wcm9qU2NyZWVub2JqZWN0TWF0cml4V29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG5cdF9mcnVzdHVtID0gW1xuXHRcdG5ldyBUSFJFRS5WZWN0b3I0KCksXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjQoKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yNCgpLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3I0KCksXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjQoKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yNCgpXG5cdCBdLFxuXG5cdF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjQoKSxcblx0X2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpLFxuXG5cdF9mYWNlM1ZlcnRleE5vcm1hbHM7XG5cblx0dGhpcy5jb21wdXRlRnJ1c3R1bSA9IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdF9mcnVzdHVtWyAwIF0uc2V0KCBtLm40MSAtIG0ubjExLCBtLm40MiAtIG0ubjEyLCBtLm40MyAtIG0ubjEzLCBtLm40NCAtIG0ubjE0ICk7XG5cdFx0X2ZydXN0dW1bIDEgXS5zZXQoIG0ubjQxICsgbS5uMTEsIG0ubjQyICsgbS5uMTIsIG0ubjQzICsgbS5uMTMsIG0ubjQ0ICsgbS5uMTQgKTtcblx0XHRfZnJ1c3R1bVsgMiBdLnNldCggbS5uNDEgKyBtLm4yMSwgbS5uNDIgKyBtLm4yMiwgbS5uNDMgKyBtLm4yMywgbS5uNDQgKyBtLm4yNCApO1xuXHRcdF9mcnVzdHVtWyAzIF0uc2V0KCBtLm40MSAtIG0ubjIxLCBtLm40MiAtIG0ubjIyLCBtLm40MyAtIG0ubjIzLCBtLm40NCAtIG0ubjI0ICk7XG5cdFx0X2ZydXN0dW1bIDQgXS5zZXQoIG0ubjQxIC0gbS5uMzEsIG0ubjQyIC0gbS5uMzIsIG0ubjQzIC0gbS5uMzMsIG0ubjQ0IC0gbS5uMzQgKTtcblx0XHRfZnJ1c3R1bVsgNSBdLnNldCggbS5uNDEgKyBtLm4zMSwgbS5uNDIgKyBtLm4zMiwgbS5uNDMgKyBtLm4zMywgbS5uNDQgKyBtLm4zNCApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0dmFyIHBsYW5lID0gX2ZydXN0dW1bIGkgXTtcblx0XHRcdHBsYW5lLmRpdmlkZVNjYWxhciggTWF0aC5zcXJ0KCBwbGFuZS54ICogcGxhbmUueCArIHBsYW5lLnkgKiBwbGFuZS55ICsgcGxhbmUueiAqIHBsYW5lLnogKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5VmVjdG9yMyggdmVjdG9yICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yO1xuXG5cdH07XG5cblx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseSggY2FtZXJhLm1hdHJpeFdvcmxkLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseVZlY3RvcjMoIHZlY3RvciApO1xuXG5cdFx0cmV0dXJuIHZlY3RvcjtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGVzIGEgMkQgcG9pbnQgZnJvbSBOREMgdG8gYSBUSFJFRS5SYXlcblx0ICogdGhhdCBjYW4gYmUgdXNlZCBmb3IgcGlja2luZy5cblx0ICogQHZlY3RvciAtIFRIUkVFLlZlY3RvcjMgdGhhdCByZXByZXNlbnRzIDJEIHBvaW50XG5cdCAqIEBjYW1lcmEgLSBUSFJFRS5DYW1lcmFcblx0ICovXG5cdHRoaXMucGlja2luZ1JheSA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cblx0XHR2YXIgZW5kLCByYXksIHQ7XG5cblx0XHQvLyBzZXQgdHdvIHZlY3RvcnMgd2l0aCBvcHBvc2luZyB6IHZhbHVlc1xuXHRcdHZlY3Rvci56ID0gLTEuMDtcblx0XHRlbmQgPSBuZXcgVEhSRUUuVmVjdG9yMyggdmVjdG9yLngsIHZlY3Rvci55LCAxLjAgKTtcblxuXHRcdHRoaXMudW5wcm9qZWN0VmVjdG9yKCB2ZWN0b3IsIGNhbWVyYSApO1xuXHRcdHRoaXMudW5wcm9qZWN0VmVjdG9yKCBlbmQsIGNhbWVyYSApO1xuXG5cdFx0Ly8gZmluZCBkaXJlY3Rpb24gZnJvbSB2ZWN0b3IgdG8gZW5kXG5cdFx0ZW5kLnN1YlNlbGYoIHZlY3RvciApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5SYXkoIHZlY3RvciwgZW5kICk7XG5cblx0fTtcblxuXHR0aGlzLnByb2plY3RHcmFwaCA9IGZ1bmN0aW9uICggcm9vdCwgc29ydCApIHtcblxuXHRcdF9vYmplY3RDb3VudCA9IDA7XG5cblx0XHRfcmVuZGVyRGF0YS5vYmplY3RzLmxlbmd0aCA9IDA7XG5cdFx0X3JlbmRlckRhdGEuc3ByaXRlcy5sZW5ndGggPSAwO1xuXHRcdF9yZW5kZXJEYXRhLmxpZ2h0cy5sZW5ndGggPSAwO1xuXG5cdFx0dmFyIHByb2plY3RPYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGlmICggKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSAmJlxuXHRcdFx0KCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgaXNJbkZydXN0dW0oIG9iamVjdCApICkgKSB7XG5cblx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlWZWN0b3IzKCBfdmVjdG9yMy5jb3B5KCBvYmplY3QucG9zaXRpb24gKSApO1xuXG5cdFx0XHRcdF9vYmplY3QgPSBnZXROZXh0T2JqZWN0SW5Qb29sKCk7XG5cdFx0XHRcdF9vYmplY3Qub2JqZWN0ID0gb2JqZWN0O1xuXHRcdFx0XHRfb2JqZWN0LnogPSBfdmVjdG9yMy56O1xuXG5cdFx0XHRcdF9yZW5kZXJEYXRhLm9iamVjdHMucHVzaCggX29iamVjdCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGUgKSB7XG5cblx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlWZWN0b3IzKCBfdmVjdG9yMy5jb3B5KCBvYmplY3QucG9zaXRpb24gKSApO1xuXG5cdFx0XHRcdF9vYmplY3QgPSBnZXROZXh0T2JqZWN0SW5Qb29sKCk7XG5cdFx0XHRcdF9vYmplY3Qub2JqZWN0ID0gb2JqZWN0O1xuXHRcdFx0XHRfb2JqZWN0LnogPSBfdmVjdG9yMy56O1xuXG5cdFx0XHRcdF9yZW5kZXJEYXRhLnNwcml0ZXMucHVzaCggX29iamVjdCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcblxuXHRcdFx0XHRfcmVuZGVyRGF0YS5saWdodHMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGMgPSAwLCBjbCA9IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGMgPCBjbDsgYyArKyApIHtcblxuXHRcdFx0XHRwcm9qZWN0T2JqZWN0KCBvYmplY3QuY2hpbGRyZW5bIGMgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0cHJvamVjdE9iamVjdCggcm9vdCApO1xuXG5cdFx0c29ydCAmJiBfcmVuZGVyRGF0YS5vYmplY3RzLnNvcnQoIHBhaW50ZXJTb3J0ICk7XG5cblx0XHRyZXR1cm4gX3JlbmRlckRhdGE7XG5cblx0fTtcblxuXHR0aGlzLnByb2plY3RTY2VuZSA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgc29ydCApIHtcblxuXHRcdHZhciBuZWFyID0gY2FtZXJhLm5lYXIsIGZhciA9IGNhbWVyYS5mYXIsXG5cdFx0bywgb2wsIHYsIHZsLCBmLCBmbCwgbiwgbmwsIGMsIGNsLCB1LCB1bCwgb2JqZWN0LFxuXHRcdG9iamVjdE1hdHJpeFdvcmxkLCBvYmplY3RNYXRyaXhXb3JsZFJvdGF0aW9uLCBvYmplY3RNYXRlcmlhbCxcblx0XHRnZW9tZXRyeSwgZ2VvbWV0cnlNYXRlcmlhbHMsIHZlcnRpY2VzLCB2ZXJ0ZXgsIHZlcnRleFBvc2l0aW9uU2NyZWVuLFxuXHRcdGZhY2VzLCBmYWNlLCBmYWNlVmVydGV4Tm9ybWFscywgbm9ybWFsLCBmYWNlVmVydGV4VXZzLCB1dnMsXG5cdFx0djEsIHYyLCB2MywgdjQ7XG5cblx0XHRfZmFjZTNDb3VudCA9IDA7XG5cdFx0X2ZhY2U0Q291bnQgPSAwO1xuXHRcdF9saW5lQ291bnQgPSAwO1xuXHRcdF9wYXJ0aWNsZUNvdW50ID0gMDtcblxuXHRcdF9yZW5kZXJEYXRhLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG5cblx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogQ2FtZXJhIGhhc25cXCd0IGJlZW4gYWRkZWQgdG8gYSBTY2VuZS4gQWRkaW5nIGl0Li4uJyApO1xuXHRcdFx0c2NlbmUuYWRkKCBjYW1lcmEgKTtcblxuXHRcdH1cblxuXHRcdHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHkoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHR0aGlzLmNvbXB1dGVGcnVzdHVtKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0X3JlbmRlckRhdGEgPSB0aGlzLnByb2plY3RHcmFwaCggc2NlbmUsIGZhbHNlICk7XG5cblx0XHRmb3IgKCBvID0gMCwgb2wgPSBfcmVuZGVyRGF0YS5vYmplY3RzLmxlbmd0aDsgbyA8IG9sOyBvKysgKSB7XG5cblx0XHRcdG9iamVjdCA9IF9yZW5kZXJEYXRhLm9iamVjdHNbIG8gXS5vYmplY3Q7XG5cblx0XHRcdG9iamVjdE1hdHJpeFdvcmxkID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHRcdFx0b2JqZWN0TWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdF92ZXJ0ZXhDb3VudCA9IDA7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRcdFx0Z2VvbWV0cnlNYXRlcmlhbHMgPSBvYmplY3QuZ2VvbWV0cnkubWF0ZXJpYWxzO1xuXHRcdFx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXHRcdFx0XHRmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXHRcdFx0XHRmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2cztcblxuXHRcdFx0XHRvYmplY3RNYXRyaXhXb3JsZFJvdGF0aW9uID0gb2JqZWN0Lm1hdHJpeFJvdGF0aW9uV29ybGQuZXh0cmFjdFJvdGF0aW9uKCBvYmplY3RNYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdGZvciAoIHYgPSAwLCB2bCA9IHZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdFx0X3ZlcnRleCA9IGdldE5leHRWZXJ0ZXhJblBvb2woKTtcblx0XHRcdFx0XHRfdmVydGV4LnBvc2l0aW9uV29ybGQuY29weSggdmVydGljZXNbIHYgXS5wb3NpdGlvbiApO1xuXG5cdFx0XHRcdFx0b2JqZWN0TWF0cml4V29ybGQubXVsdGlwbHlWZWN0b3IzKCBfdmVydGV4LnBvc2l0aW9uV29ybGQgKTtcblxuXHRcdFx0XHRcdF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4uY29weSggX3ZlcnRleC5wb3NpdGlvbldvcmxkICk7XG5cdFx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlWZWN0b3I0KCBfdmVydGV4LnBvc2l0aW9uU2NyZWVuICk7XG5cblx0XHRcdFx0XHRfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnggLz0gX3ZlcnRleC5wb3NpdGlvblNjcmVlbi53O1xuXHRcdFx0XHRcdF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4ueSAvPSBfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnc7XG5cblx0XHRcdFx0XHRfdmVydGV4LnZpc2libGUgPSBfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnogPiBuZWFyICYmIF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4ueiA8IGZhcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRmYWNlID0gZmFjZXNbIGYgXTtcblxuXHRcdFx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xuXG5cdFx0XHRcdFx0XHR2MSA9IF92ZXJ0ZXhQb29sWyBmYWNlLmEgXTtcblx0XHRcdFx0XHRcdHYyID0gX3ZlcnRleFBvb2xbIGZhY2UuYiBdO1xuXHRcdFx0XHRcdFx0djMgPSBfdmVydGV4UG9vbFsgZmFjZS5jIF07XG5cblx0XHRcdFx0XHRcdGlmICggdjEudmlzaWJsZSAmJiB2Mi52aXNpYmxlICYmIHYzLnZpc2libGUgJiZcblx0XHRcdFx0XHRcdFx0KCBvYmplY3QuZG91YmxlU2lkZWQgfHwgKCBvYmplY3QuZmxpcFNpZGVkICE9XG5cdFx0XHRcdFx0XHRcdCggdjMucG9zaXRpb25TY3JlZW4ueCAtIHYxLnBvc2l0aW9uU2NyZWVuLnggKSAqICggdjIucG9zaXRpb25TY3JlZW4ueSAtIHYxLnBvc2l0aW9uU2NyZWVuLnkgKSAtXG5cdFx0XHRcdFx0XHRcdCggdjMucG9zaXRpb25TY3JlZW4ueSAtIHYxLnBvc2l0aW9uU2NyZWVuLnkgKSAqICggdjIucG9zaXRpb25TY3JlZW4ueCAtIHYxLnBvc2l0aW9uU2NyZWVuLnggKSA8IDAgKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdF9mYWNlID0gZ2V0TmV4dEZhY2UzSW5Qb29sKCk7XG5cblx0XHRcdFx0XHRcdFx0X2ZhY2UudjEuY29weSggdjEgKTtcblx0XHRcdFx0XHRcdFx0X2ZhY2UudjIuY29weSggdjIgKTtcblx0XHRcdFx0XHRcdFx0X2ZhY2UudjMuY29weSggdjMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xuXG5cdFx0XHRcdFx0XHR2MSA9IF92ZXJ0ZXhQb29sWyBmYWNlLmEgXTtcblx0XHRcdFx0XHRcdHYyID0gX3ZlcnRleFBvb2xbIGZhY2UuYiBdO1xuXHRcdFx0XHRcdFx0djMgPSBfdmVydGV4UG9vbFsgZmFjZS5jIF07XG5cdFx0XHRcdFx0XHR2NCA9IF92ZXJ0ZXhQb29sWyBmYWNlLmQgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB2MS52aXNpYmxlICYmIHYyLnZpc2libGUgJiYgdjMudmlzaWJsZSAmJiB2NC52aXNpYmxlICYmXG5cdFx0XHRcdFx0XHRcdCggb2JqZWN0LmRvdWJsZVNpZGVkIHx8ICggb2JqZWN0LmZsaXBTaWRlZCAhPVxuXHRcdFx0XHRcdFx0XHQoICggdjQucG9zaXRpb25TY3JlZW4ueCAtIHYxLnBvc2l0aW9uU2NyZWVuLnggKSAqICggdjIucG9zaXRpb25TY3JlZW4ueSAtIHYxLnBvc2l0aW9uU2NyZWVuLnkgKSAtXG5cdFx0XHRcdFx0XHRcdCggdjQucG9zaXRpb25TY3JlZW4ueSAtIHYxLnBvc2l0aW9uU2NyZWVuLnkgKSAqICggdjIucG9zaXRpb25TY3JlZW4ueCAtIHYxLnBvc2l0aW9uU2NyZWVuLnggKSA8IDAgfHxcblx0XHRcdFx0XHRcdFx0KCB2Mi5wb3NpdGlvblNjcmVlbi54IC0gdjMucG9zaXRpb25TY3JlZW4ueCApICogKCB2NC5wb3NpdGlvblNjcmVlbi55IC0gdjMucG9zaXRpb25TY3JlZW4ueSApIC1cblx0XHRcdFx0XHRcdFx0KCB2Mi5wb3NpdGlvblNjcmVlbi55IC0gdjMucG9zaXRpb25TY3JlZW4ueSApICogKCB2NC5wb3NpdGlvblNjcmVlbi54IC0gdjMucG9zaXRpb25TY3JlZW4ueCApIDwgMCApICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRfZmFjZSA9IGdldE5leHRGYWNlNEluUG9vbCgpO1xuXG5cdFx0XHRcdFx0XHRcdF9mYWNlLnYxLmNvcHkoIHYxICk7XG5cdFx0XHRcdFx0XHRcdF9mYWNlLnYyLmNvcHkoIHYyICk7XG5cdFx0XHRcdFx0XHRcdF9mYWNlLnYzLmNvcHkoIHYzICk7XG5cdFx0XHRcdFx0XHRcdF9mYWNlLnY0LmNvcHkoIHY0ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9mYWNlLm5vcm1hbFdvcmxkLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdFx0b2JqZWN0TWF0cml4V29ybGRSb3RhdGlvbi5tdWx0aXBseVZlY3RvcjMoIF9mYWNlLm5vcm1hbFdvcmxkICk7XG5cblx0XHRcdFx0XHRfZmFjZS5jZW50cm9pZFdvcmxkLmNvcHkoIGZhY2UuY2VudHJvaWQgKTtcblx0XHRcdFx0XHRvYmplY3RNYXRyaXhXb3JsZC5tdWx0aXBseVZlY3RvcjMoIF9mYWNlLmNlbnRyb2lkV29ybGQgKTtcblxuXHRcdFx0XHRcdF9mYWNlLmNlbnRyb2lkU2NyZWVuLmNvcHkoIF9mYWNlLmNlbnRyb2lkV29ybGQgKTtcblx0XHRcdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseVZlY3RvcjMoIF9mYWNlLmNlbnRyb2lkU2NyZWVuICk7XG5cblx0XHRcdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRcdGZvciAoIG4gPSAwLCBubCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgbiA8IG5sOyBuICsrICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWwgPSBfZmFjZS52ZXJ0ZXhOb3JtYWxzV29ybGRbIG4gXTtcblx0XHRcdFx0XHRcdG5vcm1hbC5jb3B5KCBmYWNlVmVydGV4Tm9ybWFsc1sgbiBdICk7XG5cdFx0XHRcdFx0XHRvYmplY3RNYXRyaXhXb3JsZFJvdGF0aW9uLm11bHRpcGx5VmVjdG9yMyggbm9ybWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCBjID0gMCwgY2wgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgYyA8IGNsOyBjICsrICkge1xuXG5cdFx0XHRcdFx0XHR1dnMgPSBmYWNlVmVydGV4VXZzWyBjIF1bIGYgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCAhdXZzICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdGZvciAoIHUgPSAwLCB1bCA9IHV2cy5sZW5ndGg7IHUgPCB1bDsgdSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRfZmFjZS51dnNbIGMgXVsgdSBdID0gdXZzWyB1IF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9mYWNlLm1hdGVyaWFsID0gb2JqZWN0TWF0ZXJpYWw7XG5cdFx0XHRcdFx0X2ZhY2UuZmFjZU1hdGVyaWFsID0gZmFjZS5tYXRlcmlhbEluZGV4ICE9PSBudWxsID8gZ2VvbWV0cnlNYXRlcmlhbHNbIGZhY2UubWF0ZXJpYWxJbmRleCBdIDogbnVsbDtcblxuXHRcdFx0XHRcdF9mYWNlLnogPSBfZmFjZS5jZW50cm9pZFNjcmVlbi56O1xuXG5cdFx0XHRcdFx0X3JlbmRlckRhdGEuZWxlbWVudHMucHVzaCggX2ZhY2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdFx0X3Byb2pTY3JlZW5vYmplY3RNYXRyaXhXb3JsZC5tdWx0aXBseSggX3Byb2pTY3JlZW5NYXRyaXgsIG9iamVjdE1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0dmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdFx0djEgPSBnZXROZXh0VmVydGV4SW5Qb29sKCk7XG5cdFx0XHRcdHYxLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHZlcnRpY2VzWyAwIF0ucG9zaXRpb24gKTtcblx0XHRcdFx0X3Byb2pTY3JlZW5vYmplY3RNYXRyaXhXb3JsZC5tdWx0aXBseVZlY3RvcjQoIHYxLnBvc2l0aW9uU2NyZWVuICk7XG5cblx0XHRcdFx0Zm9yICggdiA9IDEsIHZsID0gdmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYrKyApIHtcblxuXHRcdFx0XHRcdHYxID0gZ2V0TmV4dFZlcnRleEluUG9vbCgpO1xuXHRcdFx0XHRcdHYxLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHZlcnRpY2VzWyB2IF0ucG9zaXRpb24gKTtcblx0XHRcdFx0XHRfcHJvalNjcmVlbm9iamVjdE1hdHJpeFdvcmxkLm11bHRpcGx5VmVjdG9yNCggdjEucG9zaXRpb25TY3JlZW4gKTtcblxuXHRcdFx0XHRcdHYyID0gX3ZlcnRleFBvb2xbIF92ZXJ0ZXhDb3VudCAtIDIgXTtcblxuXHRcdFx0XHRcdF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLmNvcHkoIHYxLnBvc2l0aW9uU2NyZWVuICk7XG5cdFx0XHRcdFx0X2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4uY29weSggdjIucG9zaXRpb25TY3JlZW4gKTtcblxuXHRcdFx0XHRcdGlmICggY2xpcExpbmUoIF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLCBfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbiApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBQZXJmb3JtIHRoZSBwZXJzcGVjdGl2ZSBkaXZpZGVcblx0XHRcdFx0XHRcdF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLm11bHRpcGx5U2NhbGFyKCAxIC8gX2NsaXBwZWRWZXJ0ZXgxUG9zaXRpb25TY3JlZW4udyApO1xuXHRcdFx0XHRcdFx0X2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4ubXVsdGlwbHlTY2FsYXIoIDEgLyBfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbi53ICk7XG5cblx0XHRcdFx0XHRcdF9saW5lID0gZ2V0TmV4dExpbmVJblBvb2woKTtcblx0XHRcdFx0XHRcdF9saW5lLnYxLnBvc2l0aW9uU2NyZWVuLmNvcHkoIF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuICk7XG5cdFx0XHRcdFx0XHRfbGluZS52Mi5wb3NpdGlvblNjcmVlbi5jb3B5KCBfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbiApO1xuXG5cdFx0XHRcdFx0XHRfbGluZS56ID0gTWF0aC5tYXgoIF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLnosIF9jbGlwcGVkVmVydGV4MlBvc2l0aW9uU2NyZWVuLnogKTtcblxuXHRcdFx0XHRcdFx0X2xpbmUubWF0ZXJpYWwgPSBvYmplY3RNYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0X3JlbmRlckRhdGEuZWxlbWVudHMucHVzaCggX2xpbmUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIG8gPSAwLCBvbCA9IF9yZW5kZXJEYXRhLnNwcml0ZXMubGVuZ3RoOyBvIDwgb2w7IG8rKyApIHtcblxuXHRcdFx0b2JqZWN0ID0gX3JlbmRlckRhdGEuc3ByaXRlc1sgbyBdLm9iamVjdDtcblxuXHRcdFx0b2JqZWN0TWF0cml4V29ybGQgPSBvYmplY3QubWF0cml4V29ybGQ7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGUgKSB7XG5cblx0XHRcdFx0X3ZlY3RvcjQuc2V0KCBvYmplY3RNYXRyaXhXb3JsZC5uMTQsIG9iamVjdE1hdHJpeFdvcmxkLm4yNCwgb2JqZWN0TWF0cml4V29ybGQubjM0LCAxICk7XG5cdFx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5VmVjdG9yNCggX3ZlY3RvcjQgKTtcblxuXHRcdFx0XHRfdmVjdG9yNC56IC89IF92ZWN0b3I0Lnc7XG5cblx0XHRcdFx0aWYgKCBfdmVjdG9yNC56ID4gMCAmJiBfdmVjdG9yNC56IDwgMSApIHtcblxuXHRcdFx0XHRcdF9wYXJ0aWNsZSA9IGdldE5leHRQYXJ0aWNsZUluUG9vbCgpO1xuXHRcdFx0XHRcdF9wYXJ0aWNsZS54ID0gX3ZlY3RvcjQueCAvIF92ZWN0b3I0Lnc7XG5cdFx0XHRcdFx0X3BhcnRpY2xlLnkgPSBfdmVjdG9yNC55IC8gX3ZlY3RvcjQudztcblx0XHRcdFx0XHRfcGFydGljbGUueiA9IF92ZWN0b3I0Lno7XG5cblx0XHRcdFx0XHRfcGFydGljbGUucm90YXRpb24gPSBvYmplY3Qucm90YXRpb24uejtcblxuXHRcdFx0XHRcdF9wYXJ0aWNsZS5zY2FsZS54ID0gb2JqZWN0LnNjYWxlLnggKiBNYXRoLmFicyggX3BhcnRpY2xlLnggLSAoIF92ZWN0b3I0LnggKyBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5uMTEgKSAvICggX3ZlY3RvcjQudyArIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4Lm4xNCApICk7XG5cdFx0XHRcdFx0X3BhcnRpY2xlLnNjYWxlLnkgPSBvYmplY3Quc2NhbGUueSAqIE1hdGguYWJzKCBfcGFydGljbGUueSAtICggX3ZlY3RvcjQueSArIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4Lm4yMiApIC8gKCBfdmVjdG9yNC53ICsgY2FtZXJhLnByb2plY3Rpb25NYXRyaXgubjI0ICkgKTtcblxuXHRcdFx0XHRcdF9wYXJ0aWNsZS5tYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdF9yZW5kZXJEYXRhLmVsZW1lbnRzLnB1c2goIF9wYXJ0aWNsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c29ydCAmJiBfcmVuZGVyRGF0YS5lbGVtZW50cy5zb3J0KCBwYWludGVyU29ydCApO1xuXG5cdFx0cmV0dXJuIF9yZW5kZXJEYXRhO1xuXG5cdH07XG5cblx0Ly8gUG9vbHNcblxuXHRmdW5jdGlvbiBnZXROZXh0T2JqZWN0SW5Qb29sKCkge1xuXG5cdFx0dmFyIG9iamVjdCA9IF9vYmplY3RQb29sWyBfb2JqZWN0Q291bnQgXSA9IF9vYmplY3RQb29sWyBfb2JqZWN0Q291bnQgXSB8fCBuZXcgVEhSRUUuUmVuZGVyYWJsZU9iamVjdCgpO1xuXG5cdFx0X29iamVjdENvdW50ICsrO1xuXG5cdFx0cmV0dXJuIG9iamVjdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TmV4dFZlcnRleEluUG9vbCgpIHtcblxuXHRcdHZhciB2ZXJ0ZXggPSBfdmVydGV4UG9vbFsgX3ZlcnRleENvdW50IF0gPSBfdmVydGV4UG9vbFsgX3ZlcnRleENvdW50IF0gfHwgbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcblxuXHRcdF92ZXJ0ZXhDb3VudCArKztcblxuXHRcdHJldHVybiB2ZXJ0ZXg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldE5leHRGYWNlM0luUG9vbCgpIHtcblxuXHRcdHZhciBmYWNlID0gX2ZhY2UzUG9vbFsgX2ZhY2UzQ291bnQgXSA9IF9mYWNlM1Bvb2xbIF9mYWNlM0NvdW50IF0gfHwgbmV3IFRIUkVFLlJlbmRlcmFibGVGYWNlMygpO1xuXG5cdFx0X2ZhY2UzQ291bnQgKys7XG5cblx0XHRyZXR1cm4gZmFjZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TmV4dEZhY2U0SW5Qb29sKCkge1xuXG5cdFx0dmFyIGZhY2UgPSBfZmFjZTRQb29sWyBfZmFjZTRDb3VudCBdID0gX2ZhY2U0UG9vbFsgX2ZhY2U0Q291bnQgXSB8fCBuZXcgVEhSRUUuUmVuZGVyYWJsZUZhY2U0KCk7XG5cblx0XHRfZmFjZTRDb3VudCArKztcblxuXHRcdHJldHVybiBmYWNlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXROZXh0TGluZUluUG9vbCgpIHtcblxuXHRcdHZhciBsaW5lID0gX2xpbmVQb29sWyBfbGluZUNvdW50IF0gPSBfbGluZVBvb2xbIF9saW5lQ291bnQgXSB8fCBuZXcgVEhSRUUuUmVuZGVyYWJsZUxpbmUoKTtcblxuXHRcdF9saW5lQ291bnQgKys7XG5cblx0XHRyZXR1cm4gbGluZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TmV4dFBhcnRpY2xlSW5Qb29sKCkge1xuXG5cdFx0dmFyIHBhcnRpY2xlID0gX3BhcnRpY2xlUG9vbFsgX3BhcnRpY2xlQ291bnQgXSA9IF9wYXJ0aWNsZVBvb2xbIF9wYXJ0aWNsZUNvdW50IF0gfHwgbmV3IFRIUkVFLlJlbmRlcmFibGVQYXJ0aWNsZSgpO1xuXHRcdF9wYXJ0aWNsZUNvdW50ICsrO1xuXHRcdHJldHVybiBwYXJ0aWNsZTtcblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBwYWludGVyU29ydCggYSwgYiApIHtcblxuXHRcdHJldHVybiBiLnogLSBhLno7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGlzSW5GcnVzdHVtKCBvYmplY3QgKSB7XG5cblx0XHR2YXIgZGlzdGFuY2UsIG1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZCxcblx0XHRyYWRpdXMgPSAtIG9iamVjdC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKiBNYXRoLm1heCggb2JqZWN0LnNjYWxlLngsIE1hdGgubWF4KCBvYmplY3Quc2NhbGUueSwgb2JqZWN0LnNjYWxlLnogKSApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0ZGlzdGFuY2UgPSBfZnJ1c3R1bVsgaSBdLnggKiBtYXRyaXgubjE0ICsgX2ZydXN0dW1bIGkgXS55ICogbWF0cml4Lm4yNCArIF9mcnVzdHVtWyBpIF0ueiAqIG1hdHJpeC5uMzQgKyBfZnJ1c3R1bVsgaSBdLnc7XG5cdFx0XHRpZiAoIGRpc3RhbmNlIDw9IHJhZGl1cyApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gY2xpcExpbmUoIHMxLCBzMiApIHtcblxuXHRcdHZhciBhbHBoYTEgPSAwLCBhbHBoYTIgPSAxLFxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBib3VuZGFyeSBjb29yZGluYXRlIG9mIGVhY2ggdmVydGV4IGZvciB0aGUgbmVhciBhbmQgZmFyIGNsaXAgcGxhbmVzLFxuXHRcdC8vIFogPSAtMSBhbmQgWiA9ICsxLCByZXNwZWN0aXZlbHkuXG5cdFx0YmMxbmVhciA9ICBzMS56ICsgczEudyxcblx0XHRiYzJuZWFyID0gIHMyLnogKyBzMi53LFxuXHRcdGJjMWZhciA9ICAtIHMxLnogKyBzMS53LFxuXHRcdGJjMmZhciA9ICAtIHMyLnogKyBzMi53O1xuXG5cdFx0aWYgKCBiYzFuZWFyID49IDAgJiYgYmMybmVhciA+PSAwICYmIGJjMWZhciA+PSAwICYmIGJjMmZhciA+PSAwICkge1xuXG5cdFx0XHQvLyBCb3RoIHZlcnRpY2VzIGxpZSBlbnRpcmVseSB3aXRoaW4gYWxsIGNsaXAgcGxhbmVzLlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9IGVsc2UgaWYgKCAoIGJjMW5lYXIgPCAwICYmIGJjMm5lYXIgPCAwKSB8fCAoYmMxZmFyIDwgMCAmJiBiYzJmYXIgPCAwICkgKSB7XG5cblx0XHRcdC8vIEJvdGggdmVydGljZXMgbGllIGVudGlyZWx5IG91dHNpZGUgb25lIG9mIHRoZSBjbGlwIHBsYW5lcy5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFRoZSBsaW5lIHNlZ21lbnQgc3BhbnMgYXQgbGVhc3Qgb25lIGNsaXAgcGxhbmUuXG5cblx0XHRcdGlmICggYmMxbmVhciA8IDAgKSB7XG5cblx0XHRcdFx0Ly8gdjEgbGllcyBvdXRzaWRlIHRoZSBuZWFyIHBsYW5lLCB2MiBpbnNpZGVcblx0XHRcdFx0YWxwaGExID0gTWF0aC5tYXgoIGFscGhhMSwgYmMxbmVhciAvICggYmMxbmVhciAtIGJjMm5lYXIgKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBiYzJuZWFyIDwgMCApIHtcblxuXHRcdFx0XHQvLyB2MiBsaWVzIG91dHNpZGUgdGhlIG5lYXIgcGxhbmUsIHYxIGluc2lkZVxuXHRcdFx0XHRhbHBoYTIgPSBNYXRoLm1pbiggYWxwaGEyLCBiYzFuZWFyIC8gKCBiYzFuZWFyIC0gYmMybmVhciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBiYzFmYXIgPCAwICkge1xuXG5cdFx0XHRcdC8vIHYxIGxpZXMgb3V0c2lkZSB0aGUgZmFyIHBsYW5lLCB2MiBpbnNpZGVcblx0XHRcdFx0YWxwaGExID0gTWF0aC5tYXgoIGFscGhhMSwgYmMxZmFyIC8gKCBiYzFmYXIgLSBiYzJmYXIgKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBiYzJmYXIgPCAwICkge1xuXG5cdFx0XHRcdC8vIHYyIGxpZXMgb3V0c2lkZSB0aGUgZmFyIHBsYW5lLCB2MiBpbnNpZGVcblx0XHRcdFx0YWxwaGEyID0gTWF0aC5taW4oIGFscGhhMiwgYmMxZmFyIC8gKCBiYzFmYXIgLSBiYzJmYXIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYWxwaGEyIDwgYWxwaGExICkge1xuXG5cdFx0XHRcdC8vIFRoZSBsaW5lIHNlZ21lbnQgc3BhbnMgdHdvIGJvdW5kYXJpZXMsIGJ1dCBpcyBvdXRzaWRlIGJvdGggb2YgdGhlbS5cblx0XHRcdFx0Ly8gKFRoaXMgY2FuJ3QgaGFwcGVuIHdoZW4gd2UncmUgb25seSBjbGlwcGluZyBhZ2FpbnN0IGp1c3QgbmVhci9mYXIgYnV0IGdvb2Rcblx0XHRcdFx0Ly8gIHRvIGxlYXZlIHRoZSBjaGVjayBoZXJlIGZvciBmdXR1cmUgdXNhZ2UgaWYgb3RoZXIgY2xpcCBwbGFuZXMgYXJlIGFkZGVkLilcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgczEgYW5kIHMyIHZlcnRpY2VzIHRvIG1hdGNoIHRoZSBjbGlwcGVkIGxpbmUgc2VnbWVudC5cblx0XHRcdFx0czEubGVycFNlbGYoIHMyLCBhbHBoYTEgKTtcblx0XHRcdFx0czIubGVycFNlbGYoIHMxLCAxIC0gYWxwaGEyICk7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiggeCwgeSwgeiwgdyApIHtcblxuXHR0aGlzLnNldChcblxuXHRcdHggfHwgMCxcblx0XHR5IHx8IDAsXG5cdFx0eiB8fCAwLFxuXHRcdHcgIT09IHVuZGVmaW5lZCA/IHcgOiAxXG5cblx0KTtcblxufTtcblxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlF1YXRlcm5pb24sXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblx0XHR0aGlzLncgPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHR0aGlzLnggPSBxLng7XG5cdFx0dGhpcy55ID0gcS55O1xuXHRcdHRoaXMueiA9IHEuejtcblx0XHR0aGlzLncgPSBxLnc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21FdWxlcjogZnVuY3Rpb24gKCB2ZWMzICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLlBJIC8gMzYwLCAvLyAwLjUgKiBNYXRoLlBJIC8gMzYwLCAvLyAwLjUgaXMgYW4gb3B0aW1pemF0aW9uXG5cdFx0eCA9IHZlYzMueCAqIGMsXG5cdFx0eSA9IHZlYzMueSAqIGMsXG5cdFx0eiA9IHZlYzMueiAqIGMsXG5cblx0XHRjMSA9IE1hdGguY29zKCB5ICApLFxuXHRcdHMxID0gTWF0aC5zaW4oIHkgICksXG5cdFx0YzIgPSBNYXRoLmNvcyggLXogKSxcblx0XHRzMiA9IE1hdGguc2luKCAteiApLFxuXHRcdGMzID0gTWF0aC5jb3MoIHggICksXG5cdFx0czMgPSBNYXRoLnNpbiggeCAgKSxcblxuXHRcdGMxYzIgPSBjMSAqIGMyLFxuXHRcdHMxczIgPSBzMSAqIHMyO1xuXG5cdFx0dGhpcy53ID0gYzFjMiAqIGMzICAtIHMxczIgKiBzMztcblx0ICBcdHRoaXMueCA9IGMxYzIgKiBzMyAgKyBzMXMyICogYzM7XG5cdFx0dGhpcy55ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdHRoaXMueiA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXHRcdC8vIGF4aXMgaGF2ZSB0byBiZSBub3JtYWxpemVkXG5cblx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLFxuXHRcdFx0cyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMueCA9IGF4aXMueCAqIHM7XG5cdFx0dGhpcy55ID0gYXhpcy55ICogcztcblx0XHR0aGlzLnogPSBheGlzLnogKiBzO1xuXHRcdHRoaXMudyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cdFx0Ly8gQWRhcHRlZCBmcm9tOiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXHRcdGZ1bmN0aW9uIGNvcHlTaWduKGEsIGIpIHtcblx0XHRcdHJldHVybiBiIDwgMCA/IC1NYXRoLmFicyhhKSA6IE1hdGguYWJzKGEpO1xuXHRcdH1cblx0XHR2YXIgYWJzUSA9IE1hdGgucG93KG0uZGV0ZXJtaW5hbnQoKSwgMS4wIC8gMy4wKTtcblx0XHR0aGlzLncgPSBNYXRoLnNxcnQoIE1hdGgubWF4KCAwLCBhYnNRICsgbS5uMTEgKyBtLm4yMiArIG0ubjMzICkgKSAvIDI7XG5cdFx0dGhpcy54ID0gTWF0aC5zcXJ0KCBNYXRoLm1heCggMCwgYWJzUSArIG0ubjExIC0gbS5uMjIgLSBtLm4zMyApICkgLyAyO1xuXHRcdHRoaXMueSA9IE1hdGguc3FydCggTWF0aC5tYXgoIDAsIGFic1EgLSBtLm4xMSArIG0ubjIyIC0gbS5uMzMgKSApIC8gMjtcblx0XHR0aGlzLnogPSBNYXRoLnNxcnQoIE1hdGgubWF4KCAwLCBhYnNRIC0gbS5uMTEgLSBtLm4yMiArIG0ubjMzICkgKSAvIDI7XG5cdFx0dGhpcy54ID0gY29weVNpZ24oIHRoaXMueCwgKCBtLm4zMiAtIG0ubjIzICkgKTtcblx0XHR0aGlzLnkgPSBjb3B5U2lnbiggdGhpcy55LCAoIG0ubjEzIC0gbS5uMzEgKSApO1xuXHRcdHRoaXMueiA9IGNvcHlTaWduKCB0aGlzLnosICggbS5uMjEgLSBtLm4xMiApICk7XG5cdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjYWxjdWxhdGVXIDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy53ID0gLSBNYXRoLnNxcnQoIE1hdGguYWJzKCAxLjAgLSB0aGlzLnggKiB0aGlzLnggLSB0aGlzLnkgKiB0aGlzLnkgLSB0aGlzLnogKiB0aGlzLnogKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggKj0gLTE7XG5cdFx0dGhpcy55ICo9IC0xO1xuXHRcdHRoaXMueiAqPSAtMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGwgPSBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG5cdFx0aWYgKCBsID09PSAwICkge1xuXG5cdFx0XHR0aGlzLnggPSAwO1xuXHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdHRoaXMueiA9IDA7XG5cdFx0XHR0aGlzLncgPSAwO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLnggPSB0aGlzLnggKiBsO1xuXHRcdFx0dGhpcy55ID0gdGhpcy55ICogbDtcblx0XHRcdHRoaXMueiA9IHRoaXMueiAqIGw7XG5cdFx0XHR0aGlzLncgPSB0aGlzLncgKiBsO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNlbGY6IGZ1bmN0aW9uICggcXVhdDIgKSB7XG5cblx0XHR2YXIgcWF4ID0gdGhpcy54LCAgcWF5ID0gdGhpcy55LCAgcWF6ID0gdGhpcy56LCAgcWF3ID0gdGhpcy53LFxuXHRcdHFieCA9IHF1YXQyLngsIHFieSA9IHF1YXQyLnksIHFieiA9IHF1YXQyLnosIHFidyA9IHF1YXQyLnc7XG5cblx0XHR0aGlzLnggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0dGhpcy55ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuXHRcdHRoaXMueiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLncgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHExLCBxMiApIHtcblxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG5cdFx0dGhpcy54ID0gIHExLnggKiBxMi53ICsgcTEueSAqIHEyLnogLSBxMS56ICogcTIueSArIHExLncgKiBxMi54O1xuXHRcdHRoaXMueSA9IC1xMS54ICogcTIueiArIHExLnkgKiBxMi53ICsgcTEueiAqIHEyLnggKyBxMS53ICogcTIueTtcblx0XHR0aGlzLnogPSAgcTEueCAqIHEyLnkgLSBxMS55ICogcTIueCArIHExLnogKiBxMi53ICsgcTEudyAqIHEyLno7XG5cdFx0dGhpcy53ID0gLXExLnggKiBxMi54IC0gcTEueSAqIHEyLnkgLSBxMS56ICogcTIueiArIHExLncgKiBxMi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjLCBkZXN0ICkge1xuXG5cdFx0aWYoICFkZXN0ICkgeyBkZXN0ID0gdmVjOyB9XG5cblx0XHR2YXIgeCAgICA9IHZlYy54LCAgeSAgPSB2ZWMueSwgIHogID0gdmVjLnosXG5cdFx0XHRxeCAgID0gdGhpcy54LCBxeSA9IHRoaXMueSwgcXogPSB0aGlzLnosIHF3ID0gdGhpcy53O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcblxuXHRcdHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG5cdFx0XHRpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG5cdFx0XHRpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG5cdFx0XHRpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cblx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cblx0XHRkZXN0LnggPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuXHRcdGRlc3QueSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG5cdFx0ZGVzdC56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcblxuXHRcdHJldHVybiBkZXN0O1xuXG5cdH1cblxufVxuXG5USFJFRS5RdWF0ZXJuaW9uLnNsZXJwID0gZnVuY3Rpb24gKCBxYSwgcWIsIHFtLCB0ICkge1xuXG5cdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0dmFyIGNvc0hhbGZUaGV0YSA9IHFhLncgKiBxYi53ICsgcWEueCAqIHFiLnggKyBxYS55ICogcWIueSArIHFhLnogKiBxYi56O1xuXG5cdGlmIChjb3NIYWxmVGhldGEgPCAwKSB7XG5cdFx0cW0udyA9IC1xYi53OyBxbS54ID0gLXFiLng7IHFtLnkgPSAtcWIueTsgcW0ueiA9IC1xYi56O1xuXHRcdGNvc0hhbGZUaGV0YSA9IC1jb3NIYWxmVGhldGE7XG5cdH0gZWxzZSB7XG5cdFx0cW0uY29weShxYik7XG5cdH1cblxuXHRpZiAoIE1hdGguYWJzKCBjb3NIYWxmVGhldGEgKSA+PSAxLjAgKSB7XG5cblx0XHRxbS53ID0gcWEudzsgcW0ueCA9IHFhLng7IHFtLnkgPSBxYS55OyBxbS56ID0gcWEuejtcblx0XHRyZXR1cm4gcW07XG5cblx0fVxuXG5cdHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoIGNvc0hhbGZUaGV0YSApLFxuXHRzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xuXG5cdGlmICggTWF0aC5hYnMoIHNpbkhhbGZUaGV0YSApIDwgMC4wMDEgKSB7XG5cblx0XHRxbS53ID0gMC41ICogKCBxYS53ICsgcWIudyApO1xuXHRcdHFtLnggPSAwLjUgKiAoIHFhLnggKyBxYi54ICk7XG5cdFx0cW0ueSA9IDAuNSAqICggcWEueSArIHFiLnkgKTtcblx0XHRxbS56ID0gMC41ICogKCBxYS56ICsgcWIueiApO1xuXG5cdFx0cmV0dXJuIHFtO1xuXG5cdH1cblxuXHR2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG5cdHFtLncgPSAoIHFhLncgKiByYXRpb0EgKyBxbS53ICogcmF0aW9CICk7XG5cdHFtLnggPSAoIHFhLnggKiByYXRpb0EgKyBxbS54ICogcmF0aW9CICk7XG5cdHFtLnkgPSAoIHFhLnkgKiByYXRpb0EgKyBxbS55ICogcmF0aW9CICk7XG5cdHFtLnogPSAoIHFhLnogKiByYXRpb0EgKyBxbS56ICogcmF0aW9CICk7XG5cblx0cmV0dXJuIHFtO1xuXG59XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlZlcnRleCA9IGZ1bmN0aW9uICggcG9zaXRpb24gKSB7XG5cblx0dGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uIHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5GYWNlMyA9IGZ1bmN0aW9uICggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHR0aGlzLmEgPSBhO1xuXHR0aGlzLmIgPSBiO1xuXHR0aGlzLmMgPSBjO1xuXG5cdHRoaXMubm9ybWFsID0gbm9ybWFsIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMudmVydGV4Tm9ybWFscyA9IG5vcm1hbCBpbnN0YW5jZW9mIEFycmF5ID8gbm9ybWFsIDogWyBdO1xuXG5cdHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBjb2xvciBpbnN0YW5jZW9mIEFycmF5ID8gY29sb3IgOiBbXTtcblxuXHR0aGlzLnZlcnRleFRhbmdlbnRzID0gW107XG5cblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHR0aGlzLmNlbnRyb2lkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZhY2U0ID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdHRoaXMuYSA9IGE7XG5cdHRoaXMuYiA9IGI7XG5cdHRoaXMuYyA9IGM7XG5cdHRoaXMuZCA9IGQ7XG5cblx0dGhpcy5ub3JtYWwgPSBub3JtYWwgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzID0gbm9ybWFsIGluc3RhbmNlb2YgQXJyYXkgPyBub3JtYWwgOiBbIF07XG5cblx0dGhpcy5jb2xvciA9IGNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgPyBjb2xvciA6IG5ldyBUSFJFRS5Db2xvcigpO1xuXHR0aGlzLnZlcnRleENvbG9ycyA9IGNvbG9yIGluc3RhbmNlb2YgQXJyYXkgPyBjb2xvciA6IFtdO1xuXG5cdHRoaXMudmVydGV4VGFuZ2VudHMgPSBbXTtcblxuXHR0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdHRoaXMuY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5VViA9IGZ1bmN0aW9uICggdSwgdiApIHtcblxuXHR0aGlzLnUgPSB1IHx8IDA7XG5cdHRoaXMudiA9IHYgfHwgMDtcblxufTtcblxuVEhSRUUuVVYucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5VVixcblxuXHRzZXQ6IGZ1bmN0aW9uICggdSwgdiApIHtcblxuXHRcdHRoaXMudSA9IHU7XG5cdFx0dGhpcy52ID0gdjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCB1diApIHtcblxuXHRcdHRoaXMudSA9IHV2LnU7XG5cdFx0dGhpcy52ID0gdXYudjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVVYoIHRoaXMudSwgdGhpcy52ICk7XG5cblx0fVxuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuaWQgPSBUSFJFRS5HZW9tZXRyeUNvdW50ICsrO1xuXG5cdHRoaXMudmVydGljZXMgPSBbXTtcblx0dGhpcy5jb2xvcnMgPSBbXTsgLy8gb25lLXRvLW9uZSB2ZXJ0ZXggY29sb3JzLCB1c2VkIGluIFBhcnRpY2xlU3lzdGVtLCBMaW5lIGFuZCBSaWJib25cblxuXHR0aGlzLm1hdGVyaWFscyA9IFtdO1xuXG5cdHRoaXMuZmFjZXMgPSBbXTtcblxuXHR0aGlzLmZhY2VVdnMgPSBbW11dO1xuXHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbW11dO1xuXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gW107XG5cdHRoaXMubW9ycGhDb2xvcnMgPSBbXTtcblxuXHR0aGlzLnNraW5XZWlnaHRzID0gW107XG5cdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0dGhpcy5oYXNUYW5nZW50cyA9IGZhbHNlO1xuXG5cdHRoaXMuZHluYW1pYyA9IGZhbHNlOyAvLyB1bmxlc3Mgc2V0IHRvIHRydWUgdGhlICpBcnJheXMgd2lsbCBiZSBkZWxldGVkIG9uY2Ugc2VudCB0byBhIGJ1ZmZlci5cblxufTtcblxuVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yIDogVEhSRUUuR2VvbWV0cnksXG5cblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0dmFyIG1hdHJpeFJvdGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRtYXRyaXhSb3RhdGlvbi5leHRyYWN0Um90YXRpb24oIG1hdHJpeCwgbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKSApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG5cblx0XHRcdG1hdHJpeC5tdWx0aXBseVZlY3RvcjMoIHZlcnRleC5wb3NpdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG5cdFx0XHRtYXRyaXhSb3RhdGlvbi5tdWx0aXBseVZlY3RvcjMoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0bWF0cml4Um90YXRpb24ubXVsdGlwbHlWZWN0b3IzKCBmYWNlLnZlcnRleE5vcm1hbHNbIGogXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdHJpeC5tdWx0aXBseVZlY3RvcjMoIGZhY2UuY2VudHJvaWQgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGNvbXB1dGVDZW50cm9pZHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBmLCBmbCwgZmFjZTtcblxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cdFx0XHRmYWNlLmNlbnRyb2lkLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcblxuXHRcdFx0XHRmYWNlLmNlbnRyb2lkLmFkZFNlbGYoIHRoaXMudmVydGljZXNbIGZhY2UuYSBdLnBvc2l0aW9uICk7XG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkU2VsZiggdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF0ucG9zaXRpb24gKTtcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGRTZWxmKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXS5wb3NpdGlvbiApO1xuXHRcdFx0XHRmYWNlLmNlbnRyb2lkLmRpdmlkZVNjYWxhciggMyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XG5cblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGRTZWxmKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXS5wb3NpdGlvbiApO1xuXHRcdFx0XHRmYWNlLmNlbnRyb2lkLmFkZFNlbGYoIHRoaXMudmVydGljZXNbIGZhY2UuYiBdLnBvc2l0aW9uICk7XG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkU2VsZiggdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF0ucG9zaXRpb24gKTtcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGRTZWxmKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmQgXS5wb3NpdGlvbiApO1xuXHRcdFx0XHRmYWNlLmNlbnRyb2lkLmRpdmlkZVNjYWxhciggNCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICggdXNlVmVydGV4Tm9ybWFscyApIHtcblxuXHRcdHZhciBuLCBubCwgdiwgdmwsIHZlcnRleCwgZiwgZmwsIGZhY2UsIHZBLCB2QiwgdkMsXG5cdFx0Y2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHQvKlxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdHZlcnRleCA9IHRoaXMudmVydGljZXNbIHYgXTtcblx0XHRcdHZlcnRleC5ub3JtYWwuc2V0KCAwLCAwLCAwICk7XG5cblx0XHR9XG5cdFx0Ki9cblxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdGlmICggdXNlVmVydGV4Tm9ybWFscyAmJiBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoICApIHtcblxuXHRcdFx0XHRjYi5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0XHRmb3IgKCBuID0gMCwgbmwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBuIDwgbmw7IG4rKyApIHtcblxuXHRcdFx0XHRcdGNiLmFkZFNlbGYoIGZhY2UudmVydGV4Tm9ybWFsc1tuXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYi5kaXZpZGVTY2FsYXIoIDMgKTtcblxuXHRcdFx0XHRpZiAoICEgY2IuaXNaZXJvKCkgKSB7XG5cblx0XHRcdFx0XHRjYi5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHR2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdGNiLnN1YiggdkMucG9zaXRpb24sIHZCLnBvc2l0aW9uICk7XG5cdFx0XHRcdGFiLnN1YiggdkEucG9zaXRpb24sIHZCLnBvc2l0aW9uICk7XG5cdFx0XHRcdGNiLmNyb3NzU2VsZiggYWIgKTtcblxuXHRcdFx0XHRpZiAoICFjYi5pc1plcm8oKSApIHtcblxuXHRcdFx0XHRcdGNiLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XG5cblx0XHQvLyBjcmVhdGUgaW50ZXJuYWwgYnVmZmVycyBmb3IgcmV1c2Ugd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIHJlcGVhdGVkbHlcblx0XHQvLyAob3RoZXJ3aXNlIG1lbW9yeSBhbGxvY2F0aW9uIC8gZGVhbGxvY2F0aW9uIGV2ZXJ5IGZyYW1lIGlzIGJpZyByZXNvdXJjZSBob2cpXG5cblx0XHRpZiAoIHRoaXMuX190bXBWZXJ0aWNlcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLl9fdG1wVmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XG5cdFx0XHR2ZXJ0aWNlcyA9IHRoaXMuX190bXBWZXJ0aWNlcztcblxuXHRcdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XG5cblx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMgPSBbIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCkgXTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XG5cblx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMgPSBbIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCkgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZlcnRpY2VzID0gdGhpcy5fX3RtcFZlcnRpY2VzO1xuXG5cdFx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzWyB2IF0uc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGRTZWxmKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkU2VsZiggZmFjZS5ub3JtYWwgKTtcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZFNlbGYoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkU2VsZiggZmFjZS5ub3JtYWwgKTtcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZFNlbGYoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGRTZWxmKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5kIF0uYWRkU2VsZiggZmFjZS5ub3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0dmVydGljZXNbIHYgXS5ub3JtYWxpemUoKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xuXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcblxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggdmVydGljZXNbIGZhY2UuYiBdICk7XG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDMgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5kIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxuXHRcdC8vIHRhbmdlbnRzIGdvIHRvIHZlcnRpY2VzXG5cblx0XHR2YXIgZiwgZmwsIHYsIHZsLCBpLCBpbCwgdmVydGV4SW5kZXgsXG5cdFx0XHRmYWNlLCB1diwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2Qyxcblx0XHRcdHgxLCB4MiwgeTEsIHkyLCB6MSwgejIsXG5cdFx0XHRzMSwgczIsIHQxLCB0MiwgciwgdCwgdGVzdCxcblx0XHRcdHRhbjEgPSBbXSwgdGFuMiA9IFtdLFxuXHRcdFx0c2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0dG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdG1wMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdztcblxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdHRhbjFbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGNvbnRleHQsIGEsIGIsIGMsIHVhLCB1YiwgdWMgKSB7XG5cblx0XHRcdHZBID0gY29udGV4dC52ZXJ0aWNlc1sgYSBdLnBvc2l0aW9uO1xuXHRcdFx0dkIgPSBjb250ZXh0LnZlcnRpY2VzWyBiIF0ucG9zaXRpb247XG5cdFx0XHR2QyA9IGNvbnRleHQudmVydGljZXNbIGMgXS5wb3NpdGlvbjtcblxuXHRcdFx0dXZBID0gdXZbIHVhIF07XG5cdFx0XHR1dkIgPSB1dlsgdWIgXTtcblx0XHRcdHV2QyA9IHV2WyB1YyBdO1xuXG5cdFx0XHR4MSA9IHZCLnggLSB2QS54O1xuXHRcdFx0eDIgPSB2Qy54IC0gdkEueDtcblx0XHRcdHkxID0gdkIueSAtIHZBLnk7XG5cdFx0XHR5MiA9IHZDLnkgLSB2QS55O1xuXHRcdFx0ejEgPSB2Qi56IC0gdkEuejtcblx0XHRcdHoyID0gdkMueiAtIHZBLno7XG5cblx0XHRcdHMxID0gdXZCLnUgLSB1dkEudTtcblx0XHRcdHMyID0gdXZDLnUgLSB1dkEudTtcblx0XHRcdHQxID0gdXZCLnYgLSB1dkEudjtcblx0XHRcdHQyID0gdXZDLnYgLSB1dkEudjtcblxuXHRcdFx0ciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcblx0XHRcdHNkaXIuc2V0KCAoIHQyICogeDEgLSB0MSAqIHgyICkgKiByLFxuXHRcdFx0XHRcdCAgKCB0MiAqIHkxIC0gdDEgKiB5MiApICogcixcblx0XHRcdFx0XHQgICggdDIgKiB6MSAtIHQxICogejIgKSAqIHIgKTtcblx0XHRcdHRkaXIuc2V0KCAoIHMxICogeDIgLSBzMiAqIHgxICkgKiByLFxuXHRcdFx0XHRcdCAgKCBzMSAqIHkyIC0gczIgKiB5MSApICogcixcblx0XHRcdFx0XHQgICggczEgKiB6MiAtIHMyICogejEgKSAqIHIgKTtcblxuXHRcdFx0dGFuMVsgYSBdLmFkZFNlbGYoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGIgXS5hZGRTZWxmKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBjIF0uYWRkU2VsZiggc2RpciApO1xuXG5cdFx0XHR0YW4yWyBhIF0uYWRkU2VsZiggdGRpciApO1xuXHRcdFx0dGFuMlsgYiBdLmFkZFNlbGYoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGMgXS5hZGRTZWxmKCB0ZGlyICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXHRcdFx0dXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgZiBdOyAvLyB1c2UgVVYgbGF5ZXIgMCBmb3IgdGFuZ2VudHNcblxuXHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XG5cblx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoIHRoaXMsIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMsIDAsIDEsIDIgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xuXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKCB0aGlzLCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jLCAwLCAxLCAyICk7XG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKCB0aGlzLCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5kLCAwLCAxLCAzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBmYWNlSW5kZXggPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdFx0bi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xuXG5cdFx0XHRcdHZlcnRleEluZGV4ID0gZmFjZVsgZmFjZUluZGV4WyBpIF0gXTtcblxuXHRcdFx0XHR0ID0gdGFuMVsgdmVydGV4SW5kZXggXTtcblxuXHRcdFx0XHQvLyBHcmFtLVNjaG1pZHQgb3J0aG9nb25hbGl6ZVxuXG5cdFx0XHRcdHRtcC5jb3B5KCB0ICk7XG5cdFx0XHRcdHRtcC5zdWJTZWxmKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHQvLyBDYWxjdWxhdGUgaGFuZGVkbmVzc1xuXG5cdFx0XHRcdHRtcDIuY3Jvc3MoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLCB0ICk7XG5cdFx0XHRcdHRlc3QgPSB0bXAyLmRvdCggdGFuMlsgdmVydGV4SW5kZXggXSApO1xuXHRcdFx0XHR3ID0gKHRlc3QgPCAwLjApID8gLTEuMCA6IDEuMDtcblxuXHRcdFx0XHRmYWNlLnZlcnRleFRhbmdlbnRzWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yNCggdG1wLngsIHRtcC55LCB0bXAueiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmhhc1RhbmdlbnRzID0gdHJ1ZTtcblxuXHR9LFxuXG5cdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHZlcnRleDtcblxuXHRcdGlmICggdGhpcy52ZXJ0aWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0geyAneCc6IFsgdGhpcy52ZXJ0aWNlc1sgMCBdLnBvc2l0aW9uLngsIHRoaXMudmVydGljZXNbIDAgXS5wb3NpdGlvbi54IF0sXG5cdFx0XHQneSc6IFsgdGhpcy52ZXJ0aWNlc1sgMCBdLnBvc2l0aW9uLnksIHRoaXMudmVydGljZXNbIDAgXS5wb3NpdGlvbi55IF0sXG5cdFx0XHQneic6IFsgdGhpcy52ZXJ0aWNlc1sgMCBdLnBvc2l0aW9uLnosIHRoaXMudmVydGljZXNbIDAgXS5wb3NpdGlvbi56IF0gfTtcblxuXHRcdFx0Zm9yICggdmFyIHYgPSAxLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdFx0dmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgdiBdO1xuXG5cdFx0XHRcdGlmICggdmVydGV4LnBvc2l0aW9uLnggPCB0aGlzLmJvdW5kaW5nQm94LnhbIDAgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3gueFsgMCBdID0gdmVydGV4LnBvc2l0aW9uLng7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdmVydGV4LnBvc2l0aW9uLnggPiB0aGlzLmJvdW5kaW5nQm94LnhbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3gueFsgMSBdID0gdmVydGV4LnBvc2l0aW9uLng7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdmVydGV4LnBvc2l0aW9uLnkgPCB0aGlzLmJvdW5kaW5nQm94LnlbIDAgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3gueVsgMCBdID0gdmVydGV4LnBvc2l0aW9uLnk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdmVydGV4LnBvc2l0aW9uLnkgPiB0aGlzLmJvdW5kaW5nQm94LnlbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3gueVsgMSBdID0gdmVydGV4LnBvc2l0aW9uLnk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdmVydGV4LnBvc2l0aW9uLnogPCB0aGlzLmJvdW5kaW5nQm94LnpbIDAgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guelsgMCBdID0gdmVydGV4LnBvc2l0aW9uLno7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdmVydGV4LnBvc2l0aW9uLnogPiB0aGlzLmJvdW5kaW5nQm94LnpbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guelsgMSBdID0gdmVydGV4LnBvc2l0aW9uLno7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHZhciByYWRpdXMgPSB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsID8gMCA6IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuXG5cdFx0dmFyIHJhZGl1cyA9IDA7XG5cblx0XHRmb3IgKCB2YXIgdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0cmFkaXVzID0gTWF0aC5tYXgoIHJhZGl1cywgdGhpcy52ZXJ0aWNlc1sgdiBdLnBvc2l0aW9uLmxlbmd0aCgpICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0geyByYWRpdXM6IHJhZGl1cyB9O1xuXG5cdH0sXG5cblx0Lypcblx0ICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxuXHQgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXG5cdCAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXG5cdCAqL1xuXG5cdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZSBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcblx0XHR2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcblxuXHRcdHZhciB2LCBrZXk7XG5cdFx0dmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZWcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXG5cdFx0dmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XG5cdFx0dmFyIGksaWwsIGZhY2U7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdLnBvc2l0aW9uO1xuXHRcdFx0a2V5ID0gWyBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSwgTWF0aC5yb3VuZCggdi55ICogcHJlY2lzaW9uICksIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApIF0uam9pbiggJ18nICk7XG5cblx0XHRcdGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcblx0XHRcdFx0dW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xuXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xuXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXG5cdFx0Ly8gU3RhcnQgdG8gcGF0Y2ggZmFjZSBpbmRpY2VzXG5cblx0XHRmb3IoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xuXG5cdFx0XHRcdGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHRmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcblx0XHRcdFx0ZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcblxuXHRcdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcblx0XHRcdFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XG5cdFx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xuXHRcdFx0XHRmYWNlLmQgPSBjaGFuZ2VzWyBmYWNlLmQgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcblxuXHRcdHRoaXMudmVydGljZXMgPSB1bmlxdWU7XG5cblx0fVxuXG59O1xuXG5USFJFRS5HZW9tZXRyeUNvdW50ID0gMDtcbi8qKlxuICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXG4gKiBodHRwOi8vc29sZS5naXRodWIuY29tL3R3ZWVuLmpzL2V4YW1wbGVzLzA1X3NwbGluZS5odG1sXG4gKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3BsaW5lID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cblx0dmFyIGMgPSBbXSwgdjMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcblx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3Myxcblx0cGEsIHBiLCBwYywgcGQ7XG5cblx0dGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24oIGEgKSB7XG5cblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0dGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uICggayApIHtcblxuXHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xuXHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdFx0Y1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcblx0XHRjWyAxIF0gPSBpbnRQb2ludDtcblx0XHRjWyAyIF0gPSBpbnRQb2ludCA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDIgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMTtcblx0XHRjWyAzIF0gPSBpbnRQb2ludCA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMjtcblxuXHRcdHBhID0gdGhpcy5wb2ludHNbIGNbIDAgXSBdO1xuXHRcdHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xuXHRcdHBjID0gdGhpcy5wb2ludHNbIGNbIDIgXSBdO1xuXHRcdHBkID0gdGhpcy5wb2ludHNbIGNbIDMgXSBdO1xuXG5cdFx0dzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XG5cdFx0dzMgPSB3ZWlnaHQgKiB3MjtcblxuXHRcdHYzLnggPSBpbnRlcnBvbGF0ZSggcGEueCwgcGIueCwgcGMueCwgcGQueCwgd2VpZ2h0LCB3MiwgdzMgKTtcblx0XHR2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XG5cdFx0djMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xuXG5cdFx0cmV0dXJuIHYzO1xuXG5cdH07XG5cblx0dGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaSwgcCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aCxcblx0XHRcdGNvb3JkcyA9IFtdO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRwID0gdGhpcy5wb2ludHNbIGkgXTtcblx0XHRcdGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY29vcmRzO1xuXG5cdH07XG5cblx0Ly8gYXBwcm94aW1hdGUgbGVuZ3RoIGJ5IHN1bW1pbmcgbGluZWFyIHNlZ21lbnRzXG5cblx0dGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoIG5TdWJEaXZpc2lvbnMgKSB7XG5cblx0XHR2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcblx0XHRcdHBvaW50ID0gMCwgaW50UG9pbnQgPSAwLCBvbGRJbnRQb2ludCA9IDAsXG5cdFx0XHRvbGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0Y2h1bmtMZW5ndGhzID0gW10sXG5cdFx0XHR0b3RhbExlbmd0aCA9IDA7XG5cblx0XHQvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcblxuXHRcdGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcblxuXHRcdGlmICggIW5TdWJEaXZpc2lvbnMgKSBuU3ViRGl2aXNpb25zID0gMTAwO1xuXG5cdFx0blNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xuXG5cdFx0b2xkUG9zaXRpb24uY29weSggdGhpcy5wb2ludHNbIDAgXSApO1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBuU2FtcGxlczsgaSArKyApIHtcblxuXHRcdFx0aW5kZXggPSBpIC8gblNhbXBsZXM7XG5cblx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcblx0XHRcdHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xuXG5cdFx0XHR0b3RhbExlbmd0aCArPSB0bXBWZWMuZGlzdGFuY2VUbyggb2xkUG9zaXRpb24gKTtcblxuXHRcdFx0b2xkUG9zaXRpb24uY29weSggcG9zaXRpb24gKTtcblxuXHRcdFx0cG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xuXHRcdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXG5cdFx0XHRpZiAoIGludFBvaW50ICE9IG9sZEludFBvaW50ICkge1xuXG5cdFx0XHRcdGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xuXHRcdFx0XHRvbGRJbnRQb2ludCA9IGludFBvaW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBsYXN0IHBvaW50IGVuZHMgd2l0aCB0b3RhbCBsZW5ndGhcblxuXHRcdGNodW5rTGVuZ3Roc1sgY2h1bmtMZW5ndGhzLmxlbmd0aCBdID0gdG90YWxMZW5ndGg7XG5cblx0XHRyZXR1cm4geyBjaHVua3M6IGNodW5rTGVuZ3RocywgdG90YWw6IHRvdGFsTGVuZ3RoIH07XG5cblx0fTtcblxuXHR0aGlzLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCA9IGZ1bmN0aW9uICggc2FtcGxpbmdDb2VmICkge1xuXG5cdFx0dmFyIGksIGosXG5cdFx0XHRpbmRleCwgaW5kZXhDdXJyZW50LCBpbmRleE5leHQsXG5cdFx0XHRsaW5lYXJEaXN0YW5jZSwgcmVhbERpc3RhbmNlLFxuXHRcdFx0c2FtcGxpbmcsIHBvc2l0aW9uLFxuXHRcdFx0bmV3cG9pbnRzID0gW10sXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0c2wgPSB0aGlzLmdldExlbmd0aCgpO1xuXG5cdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0Ly90bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgLSAxIF0gKTtcblx0XHRcdC8vbGluZWFyRGlzdGFuY2UgPSB0bXBWZWMuZGlzdGFuY2VUbyggdGhpcy5wb2ludHNbIGkgXSApO1xuXG5cdFx0XHRyZWFsRGlzdGFuY2UgPSBzbC5jaHVua3NbIGkgXSAtIHNsLmNodW5rc1sgaSAtIDEgXTtcblxuXHRcdFx0c2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XG5cblx0XHRcdGluZGV4Q3VycmVudCA9ICggaSAtIDEgKSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuXHRcdFx0aW5kZXhOZXh0ID0gaSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaisrICkge1xuXG5cdFx0XHRcdGluZGV4ID0gaW5kZXhDdXJyZW50ICsgaiAqICggMSAvIHNhbXBsaW5nICkgKiAoIGluZGV4TmV4dCAtIGluZGV4Q3VycmVudCApO1xuXG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcblx0XHRcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIF0gKS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcblxuXHR9O1xuXG5cdC8vIENhdG11bGwtUm9tXG5cblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHR9O1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqL1xuXG5USFJFRS5FZGdlID0gZnVuY3Rpb24oIHYxLCB2MiwgdmkxLCB2aTIgKSB7XG5cblx0dGhpcy52ZXJ0aWNlcyA9IFsgdjEsIHYyIF07IC8vIHZlcnRleCByZWZlcmVuY2VzXG5cdHRoaXMudmVydGV4SW5kaWNlcyA9IFsgdmkxLCB2aTIgXTsgLy8gdmVydGV4IGluZGljZXNcblxuXHR0aGlzLmZhY2VzID0gW107IC8vIGZhY2UgcmVmZXJlbmNlc1xuXHR0aGlzLmZhY2VJbmRpY2VzID0gW107XHQvLyBmYWNlIGluZGljZXNcblxufTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICovXG5cblRIUkVFLkNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBDYW1lcmEoKSBpcyBub3cgUGVyc3BlY3RpdmVDYW1lcmEoKSBvciBPcnRob2dyYXBoaWNDYW1lcmEoKS4nICk7XG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggYXJndW1lbnRzWyAwIF0sIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSwgYXJndW1lbnRzWyAzIF0gKTtcblxuXHR9XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXG59O1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2FtZXJhO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmxvb2tBdCA9IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdC8vIFRPRE86IEFkZCBoaWVyYXJjaHkgc3VwcG9ydC5cblxuXHR0aGlzLm1hdHJpeC5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xuXG5cdGlmICggdGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgKSB7XG5cblx0XHR0aGlzLnJvdGF0aW9uLnNldFJvdGF0aW9uRnJvbU1hdHJpeCggdGhpcy5tYXRyaXggKTtcblxuXHR9XG5cbn07XG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMubGVmdCA9IGxlZnQ7XG5cdHRoaXMucmlnaHQgPSByaWdodDtcblx0dGhpcy50b3AgPSB0b3A7XG5cdHRoaXMuYm90dG9tID0gYm90dG9tO1xuXG5cdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMC4xO1xuXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDIwMDA7XG5cblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuQ2FtZXJhKCk7XG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhO1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gVEhSRUUuTWF0cml4NC5tYWtlT3J0aG8oIHRoaXMubGVmdCwgdGhpcy5yaWdodCwgdGhpcy50b3AsIHRoaXMuYm90dG9tLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBncmVnZ21hbiAvIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XG5cblx0VEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XG5cdHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xuXHR0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xuXHR0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcblxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gbmV3IFRIUkVFLkNhbWVyYSgpO1xuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmE7XG5cblxuLyoqXG4gKiBVc2VzIEZvY2FsIExlbmd0aCAoaW4gbW0pIHRvIGVzdGltYXRlIGFuZCBzZXQgRk9WXG4gKiAzNW1tIChmdWxsZnJhbWUpIGNhbWVyYSBpcyB1c2VkIGlmIGZyYW1lIHNpemUgaXMgbm90IHNwZWNpZmllZDtcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lU2l6ZSApIHtcblxuXHRmcmFtZVNpemUgPSBmcmFtZVNpemUgIT09IHVuZGVmaW5lZCA/IGZyYW1lU2l6ZSA6IDQzLjI1OyAvLyAzNngyNG1tXG5cblx0dGhpcy5mb3YgPSAyICogTWF0aC5hdGFuKCBmcmFtZVNpemUgLyAoIGZvY2FsTGVuZ3RoICogMiApICk7XG5cdHRoaXMuZm92ID0gMTgwIC8gTWF0aC5QSSAqIHRoaXMuZm92O1xuXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59XG5cblxuLyoqXG4gKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG4gKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG4gKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXG4gKlxuICogICArLS0tKy0tLSstLS0rXG4gKiAgIHwgQSB8IEIgfCBDIHxcbiAqICAgKy0tLSstLS0rLS0tK1xuICogICB8IEQgfCBFIHwgRiB8XG4gKiAgICstLS0rLS0tKy0tLStcbiAqXG4gKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG4gKlxuICogICB2YXIgdyA9IDE5MjA7XG4gKiAgIHZhciBoID0gMTA4MDtcbiAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xuICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xuICpcbiAqICAgLS1BLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1CLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1DLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1ELS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcbiAqICAgLS1FLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcbiAqICAgLS1GLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcbiAqXG4gKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldFZpZXdPZmZzZXQgPSBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHR0aGlzLmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0dGhpcy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0dGhpcy54ID0geDtcblx0dGhpcy55ID0geTtcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAoIHRoaXMuZnVsbFdpZHRoICkge1xuXG5cdFx0dmFyIGFzcGVjdCA9IHRoaXMuZnVsbFdpZHRoIC8gdGhpcy5mdWxsSGVpZ2h0O1xuXHRcdHZhciB0b3AgPSBNYXRoLnRhbiggdGhpcy5mb3YgKiBNYXRoLlBJIC8gMzYwICkgKiB0aGlzLm5lYXI7XG5cdFx0dmFyIGJvdHRvbSA9IC10b3A7XG5cdFx0dmFyIGxlZnQgPSBhc3BlY3QgKiBib3R0b207XG5cdFx0dmFyIHJpZ2h0ID0gYXNwZWN0ICogdG9wO1xuXHRcdHZhciB3aWR0aCA9IE1hdGguYWJzKCByaWdodCAtIGxlZnQgKTtcblx0XHR2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoIHRvcCAtIGJvdHRvbSApO1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gVEhSRUUuTWF0cml4NC5tYWtlRnJ1c3R1bShcblx0XHRcdGxlZnQgKyB0aGlzLnggKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxuXHRcdFx0bGVmdCArICggdGhpcy54ICsgdGhpcy53aWR0aCApICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcblx0XHRcdHRvcCAtICggdGhpcy55ICsgdGhpcy5oZWlnaHQgKSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcblx0XHRcdHRvcCAtIHRoaXMueSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcblx0XHRcdHRoaXMubmVhcixcblx0XHRcdHRoaXMuZmFyICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IFRIUkVFLk1hdHJpeDQubWFrZVBlcnNwZWN0aXZlKCB0aGlzLmZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxuXHR9XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuIFxuVEhSRUUuTGlnaHQgPSBmdW5jdGlvbiAoIGhleCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggaGV4ICk7XG5cbn07XG5cblRIUkVFLkxpZ2h0LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuVEhSRUUuTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGlnaHQ7XG5USFJFRS5MaWdodC5wcm90b3R5cGUuc3VwciA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQW1iaWVudExpZ2h0ID0gZnVuY3Rpb24gKCBoZXggKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgaGV4ICk7XG5cbn07XG5cblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBuZXcgVEhSRUUuTGlnaHQoKTtcblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BbWJpZW50TGlnaHQ7IFxuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0ID0gZnVuY3Rpb24gKCBoZXgsIGludGVuc2l0eSwgZGlzdGFuY2UgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgaGV4ICk7XG5cblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuXG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5MaWdodCgpO1xuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Qb2ludExpZ2h0ID0gZnVuY3Rpb24gKCBoZXgsIGludGVuc2l0eSwgZGlzdGFuY2UgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgaGV4ICk7XG5cblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICk7XG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5MaWdodCgpO1xuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0O1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwb3RMaWdodCA9IGZ1bmN0aW9uICggaGV4LCBpbnRlbnNpdHksIGRpc3RhbmNlLCBjYXN0U2hhZG93ICkge1xuXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGhleCApO1xuXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuXG5cdHRoaXMuY2FzdFNoYWRvdyA9ICggY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkICkgPyBjYXN0U2hhZG93IDogZmFsc2U7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUgPSBuZXcgVEhSRUUuTGlnaHQoKTtcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHQ7XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXG5cdHRoaXMuaWQgPSBUSFJFRS5NYXRlcmlhbENvdW50ICsrO1xuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHRoaXMub3BhY2l0eSA9IHBhcmFtZXRlcnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5vcGFjaXR5IDogMTtcblx0dGhpcy50cmFuc3BhcmVudCA9IHBhcmFtZXRlcnMudHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMudHJhbnNwYXJlbnQgOiBmYWxzZTtcblxuXHR0aGlzLmJsZW5kaW5nID0gcGFyYW1ldGVycy5ibGVuZGluZyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5ibGVuZGluZyA6IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG5cdHRoaXMuZGVwdGhUZXN0ID0gcGFyYW1ldGVycy5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZGVwdGhUZXN0IDogdHJ1ZTtcblx0dGhpcy5kZXB0aFdyaXRlID0gcGFyYW1ldGVycy5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoV3JpdGUgOiB0cnVlO1xuXG5cdHRoaXMucG9seWdvbk9mZnNldCA9IHBhcmFtZXRlcnMucG9seWdvbk9mZnNldCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wb2x5Z29uT2Zmc2V0IDogZmFsc2U7XG5cdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IHBhcmFtZXRlcnMucG9seWdvbk9mZnNldEZhY3RvciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wb2x5Z29uT2Zmc2V0RmFjdG9yIDogMDtcblx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBwYXJhbWV0ZXJzLnBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wb2x5Z29uT2Zmc2V0VW5pdHMgOiAwO1xuXG5cdHRoaXMuYWxwaGFUZXN0ID0gcGFyYW1ldGVycy5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYWxwaGFUZXN0IDogMDtcblxuXHR0aGlzLm92ZXJkcmF3ID0gcGFyYW1ldGVycy5vdmVyZHJhdyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5vdmVyZHJhdyA6IGZhbHNlOyAvLyBCb29sZWFuIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXIgXG5cbn1cblxuVEhSRUUuTWF0ZXJpYWxDb3VudCA9IDA7XG5cblRIUkVFLk5vU2hhZGluZyA9IDA7XG5USFJFRS5GbGF0U2hhZGluZyA9IDE7XG5USFJFRS5TbW9vdGhTaGFkaW5nID0gMjtcblxuVEhSRUUuTm9Db2xvcnMgPSAwO1xuVEhSRUUuRmFjZUNvbG9ycyA9IDE7XG5USFJFRS5WZXJ0ZXhDb2xvcnMgPSAyO1xuXG5USFJFRS5Ob3JtYWxCbGVuZGluZyA9IDA7XG5USFJFRS5BZGRpdGl2ZUJsZW5kaW5nID0gMTtcblRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAyO1xuVEhSRUUuTXVsdGlwbHlCbGVuZGluZyA9IDM7XG5USFJFRS5BZGRpdGl2ZUFscGhhQmxlbmRpbmcgPSA0O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuICogIGxpbmVqb2luOiBcInJvdW5kXCIsXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHRoaXMuY29sb3IgPSBwYXJhbWV0ZXJzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBuZXcgVEhSRUUuQ29sb3IoIHBhcmFtZXRlcnMuY29sb3IgKSA6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuXHR0aGlzLmxpbmV3aWR0aCA9IHBhcmFtZXRlcnMubGluZXdpZHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmxpbmV3aWR0aCA6IDE7XG5cdHRoaXMubGluZWNhcCA9IHBhcmFtZXRlcnMubGluZWNhcCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5saW5lY2FwIDogJ3JvdW5kJztcblx0dGhpcy5saW5lam9pbiA9IHBhcmFtZXRlcnMubGluZWpvaW4gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubGluZWpvaW4gOiAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA6IGZhbHNlO1xuXG5cdHRoaXMuZm9nID0gcGFyYW1ldGVycy5mb2cgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZm9nIDogdHJ1ZTtcblxufTtcblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gbmV3IFRIUkVFLk1hdGVyaWFsKCk7XG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogZmFsc2UgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHRoaXMuY29sb3IgPSBwYXJhbWV0ZXJzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBuZXcgVEhSRUUuQ29sb3IoIHBhcmFtZXRlcnMuY29sb3IgKSA6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuXHR0aGlzLm1hcCA9IHBhcmFtZXRlcnMubWFwICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLm1hcCA6IG51bGw7XG5cblx0dGhpcy5saWdodE1hcCA9IHBhcmFtZXRlcnMubGlnaHRNYXAgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubGlnaHRNYXAgOiBudWxsO1xuXG5cdHRoaXMuZW52TWFwID0gcGFyYW1ldGVycy5lbnZNYXAgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZW52TWFwIDogbnVsbDtcblx0dGhpcy5jb21iaW5lID0gcGFyYW1ldGVycy5jb21iaW5lICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNvbWJpbmUgOiBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSBwYXJhbWV0ZXJzLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5yZWZsZWN0aXZpdHkgOiAxO1xuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHBhcmFtZXRlcnMucmVmcmFjdGlvblJhdGlvICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnJlZnJhY3Rpb25SYXRpbyA6IDAuOTg7XG5cblx0dGhpcy5mb2cgPSBwYXJhbWV0ZXJzLmZvZyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5mb2cgOiB0cnVlO1xuXG5cdHRoaXMuc2hhZGluZyA9IHBhcmFtZXRlcnMuc2hhZGluZyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaGFkaW5nIDogVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IHBhcmFtZXRlcnMud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndpcmVmcmFtZSA6IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndpcmVmcmFtZUxpbmV3aWR0aCA6IDE7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZWNhcCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5lY2FwIDogJ3JvdW5kJztcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZWpvaW4gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZWpvaW4gOiAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMudmVydGV4Q29sb3JzIDogZmFsc2U7XG5cblx0dGhpcy5za2lubmluZyA9IHBhcmFtZXRlcnMuc2tpbm5pbmcgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc2tpbm5pbmcgOiBmYWxzZTtcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgOiBmYWxzZTtcblxufTtcblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gbmV3IFRIUkVFLk1hdGVyaWFsKCk7XG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbDtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIGFtYmllbnQ6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IGZhbHNlIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqICBza2lubmluZzogPGJvb2w+LFxuICpcbiAqXHRmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHRoaXMuY29sb3IgPSBwYXJhbWV0ZXJzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBuZXcgVEhSRUUuQ29sb3IoIHBhcmFtZXRlcnMuY29sb3IgKSA6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblx0dGhpcy5hbWJpZW50ID0gcGFyYW1ldGVycy5hbWJpZW50ICE9PSB1bmRlZmluZWQgPyBuZXcgVEhSRUUuQ29sb3IoIHBhcmFtZXRlcnMuYW1iaWVudCApIDogbmV3IFRIUkVFLkNvbG9yKCAweDA1MDUwNSApO1xuXG5cdHRoaXMubWFwID0gcGFyYW1ldGVycy5tYXAgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubWFwIDogbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gcGFyYW1ldGVycy5saWdodE1hcCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5saWdodE1hcCA6IG51bGw7XG5cblx0dGhpcy5lbnZNYXAgPSBwYXJhbWV0ZXJzLmVudk1hcCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5lbnZNYXAgOiBudWxsO1xuXHR0aGlzLmNvbWJpbmUgPSBwYXJhbWV0ZXJzLmNvbWJpbmUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29tYmluZSA6IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHBhcmFtZXRlcnMucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnJlZmxlY3Rpdml0eSA6IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gcGFyYW1ldGVycy5yZWZyYWN0aW9uUmF0aW8gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucmVmcmFjdGlvblJhdGlvIDogMC45ODtcblxuXHR0aGlzLmZvZyA9IHBhcmFtZXRlcnMuZm9nICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZvZyA6IHRydWU7XG5cblx0dGhpcy5zaGFkaW5nID0gcGFyYW1ldGVycy5zaGFkaW5nICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNoYWRpbmcgOiBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gcGFyYW1ldGVycy53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2lyZWZyYW1lIDogZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZXdpZHRoIDogMTtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndpcmVmcmFtZUxpbmVjYXAgOiAncm91bmQnO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5lam9pbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5lam9pbiA6ICdyb3VuZCc7XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgOiBmYWxzZTtcblxuXHR0aGlzLnNraW5uaW5nID0gcGFyYW1ldGVycy5za2lubmluZyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5za2lubmluZyA6IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA6IGZhbHNlO1xuXG59O1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5NYXRlcmlhbCgpO1xuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsO1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgYW1iaWVudDogPGhleD4sXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxuICogIHNoaW5pbmVzczogPGZsb2F0PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBmYWxzZSAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqXG4gKlx0Zm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0dGhpcy5jb2xvciA9IHBhcmFtZXRlcnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IG5ldyBUSFJFRS5Db2xvciggcGFyYW1ldGVycy5jb2xvciApIDogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXHR0aGlzLmFtYmllbnQgPSBwYXJhbWV0ZXJzLmFtYmllbnQgIT09IHVuZGVmaW5lZCA/IG5ldyBUSFJFRS5Db2xvciggcGFyYW1ldGVycy5hbWJpZW50ICkgOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDUwNTA1ICk7XG5cdHRoaXMuc3BlY3VsYXIgPSBwYXJhbWV0ZXJzLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgPyBuZXcgVEhSRUUuQ29sb3IoIHBhcmFtZXRlcnMuc3BlY3VsYXIgKSA6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKTtcblx0dGhpcy5zaGluaW5lc3MgPSBwYXJhbWV0ZXJzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaGluaW5lc3MgOiAzMDtcblxuXHR0aGlzLm1ldGFsID0gcGFyYW1ldGVycy5tZXRhbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5tZXRhbCA6IGZhbHNlO1xuXHR0aGlzLnBlclBpeGVsID0gcGFyYW1ldGVycy5wZXJQaXhlbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wZXJQaXhlbCA6IGZhbHNlO1xuXG5cdHRoaXMubWFwID0gcGFyYW1ldGVycy5tYXAgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubWFwIDogbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gcGFyYW1ldGVycy5saWdodE1hcCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5saWdodE1hcCA6IG51bGw7XG5cblx0dGhpcy5lbnZNYXAgPSBwYXJhbWV0ZXJzLmVudk1hcCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5lbnZNYXAgOiBudWxsO1xuXHR0aGlzLmNvbWJpbmUgPSBwYXJhbWV0ZXJzLmNvbWJpbmUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29tYmluZSA6IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHBhcmFtZXRlcnMucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnJlZmxlY3Rpdml0eSA6IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gcGFyYW1ldGVycy5yZWZyYWN0aW9uUmF0aW8gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucmVmcmFjdGlvblJhdGlvIDogMC45ODtcblxuXHR0aGlzLmZvZyA9IHBhcmFtZXRlcnMuZm9nICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZvZyA6IHRydWU7XG5cblx0dGhpcy5zaGFkaW5nID0gcGFyYW1ldGVycy5zaGFkaW5nICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNoYWRpbmcgOiBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gcGFyYW1ldGVycy53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2lyZWZyYW1lIDogZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZXdpZHRoIDogMTtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndpcmVmcmFtZUxpbmVjYXAgOiAncm91bmQnO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5lam9pbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5lam9pbiA6ICdyb3VuZCc7XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgOiBmYWxzZTtcblxuXHR0aGlzLnNraW5uaW5nID0gcGFyYW1ldGVycy5za2lubmluZyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5za2lubmluZyA6IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA6IGZhbHNlO1xuXG59O1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUgPSBuZXcgVEhSRUUuTWF0ZXJpYWwoKTtcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsO1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuIFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiBcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqIH0gXG4gKi9cblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHRoaXMuc2hhZGluZyA9IHBhcmFtZXRlcnMuc2hhZGluZyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaGFkaW5nIDogVEhSRUUuU21vb3RoU2hhZGluZzsgLy8gZG9lc24ndCByZWFsbHkgYXBwbHkgaGVyZSwgbm9ybWFscyBhcmUgbm90IHVzZWRcblxuXHR0aGlzLndpcmVmcmFtZSA9IHBhcmFtZXRlcnMud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndpcmVmcmFtZSA6IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndpcmVmcmFtZUxpbmV3aWR0aCA6IDE7XG5cbn07XG5cblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5NYXRlcmlhbCgpO1xuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiBcbiAqICBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuXHR0aGlzLnNoYWRpbmcgPSBwYXJhbWV0ZXJzLnNoYWRpbmcgPyBwYXJhbWV0ZXJzLnNoYWRpbmcgOiBUSFJFRS5GbGF0U2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IHBhcmFtZXRlcnMud2lyZWZyYW1lID8gcGFyYW1ldGVycy53aXJlZnJhbWUgOiBmYWxzZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBwYXJhbWV0ZXJzLndpcmVmcmFtZUxpbmV3aWR0aCA/IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZXdpZHRoIDogMTtcblxufTtcblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5NYXRlcmlhbCgpO1xuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbDtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblRIUkVFLk1lc2hTaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBNZXNoU2hhZGVyTWF0ZXJpYWwoKSBpcyBub3cgU2hhZGVyTWF0ZXJpYWwoKS4nICk7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIHNpemU6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuXHR0aGlzLmNvbG9yID0gcGFyYW1ldGVycy5jb2xvciAhPT0gdW5kZWZpbmVkID8gbmV3IFRIUkVFLkNvbG9yKCBwYXJhbWV0ZXJzLmNvbG9yICkgOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0dGhpcy5tYXAgPSBwYXJhbWV0ZXJzLm1hcCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5tYXAgOiBudWxsO1xuXG5cdHRoaXMuc2l6ZSA9IHBhcmFtZXRlcnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaXplIDogMTtcblx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gOiB0cnVlO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMudmVydGV4Q29sb3JzIDogZmFsc2U7XG5cblx0dGhpcy5mb2cgPSBwYXJhbWV0ZXJzLmZvZyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5mb2cgOiB0cnVlO1xuXG59O1xuXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gbmV3IFRIUkVFLk1hdGVyaWFsKCk7XG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsO1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBwcm9ncmFtOiA8ZnVuY3Rpb24+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nXG4gKiB9XG4gKi9cblxuVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0dGhpcy5jb2xvciA9IHBhcmFtZXRlcnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IG5ldyBUSFJFRS5Db2xvciggcGFyYW1ldGVycy5jb2xvciApIDogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXHR0aGlzLnByb2dyYW0gPSBwYXJhbWV0ZXJzLnByb2dyYW0gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJvZ3JhbSA6IGZ1bmN0aW9uICggY29udGV4dCwgY29sb3IgKSB7fTtcblxufTtcblxuVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbC5wcm90b3R5cGUgPSBuZXcgVEhSRUUuTWF0ZXJpYWwoKTtcblRIUkVFLlBhcnRpY2xlQ2FudmFzTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbDtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUGFydGljbGVET01NYXRlcmlhbCA9IGZ1bmN0aW9uICggZG9tRWxlbWVudCApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxufTtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGZyYWdtZW50U2hhZGVyOiA8c3RyaW5nPixcbiAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxuXG4gKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdHlwZTogXCJpXCIgdmFsdWUyOiAyIH0gfSxcblxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXG4gKiAgbGlnaHRzOiA8Ym9vbD4sXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqIH1cbiAqL1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0dGhpcy5mcmFnbWVudFNoYWRlciA9IHBhcmFtZXRlcnMuZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZnJhZ21lbnRTaGFkZXIgOiBcInZvaWQgbWFpbigpIHt9XCI7XG5cdHRoaXMudmVydGV4U2hhZGVyID0gcGFyYW1ldGVycy52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMudmVydGV4U2hhZGVyIDogXCJ2b2lkIG1haW4oKSB7fVwiO1xuXHR0aGlzLnVuaWZvcm1zID0gcGFyYW1ldGVycy51bmlmb3JtcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy51bmlmb3JtcyA6IHt9O1xuXHR0aGlzLmF0dHJpYnV0ZXMgPSBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXM7XG5cblx0dGhpcy5zaGFkaW5nID0gcGFyYW1ldGVycy5zaGFkaW5nICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNoYWRpbmcgOiBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gcGFyYW1ldGVycy53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2lyZWZyYW1lIDogZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gcGFyYW1ldGVycy53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2lyZWZyYW1lTGluZXdpZHRoIDogMTtcblxuXHR0aGlzLmZvZyA9IHBhcmFtZXRlcnMuZm9nICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZvZyA6IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGZvZ1xuXHR0aGlzLmxpZ2h0cyA9IHBhcmFtZXRlcnMubGlnaHRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmxpZ2h0cyA6IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xuXHR0aGlzLnZlcnRleENvbG9ycyA9IHBhcmFtZXRlcnMudmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA6IGZhbHNlOyAvLyBzZXQgdG8gdXNlIFwiY29sb3JcIiBhdHRyaWJ1dGUgc3RyZWFtXG5cdHRoaXMuc2tpbm5pbmcgPSBwYXJhbWV0ZXJzLnNraW5uaW5nICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNraW5uaW5nIDogZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgOiBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXG5cbn07XG5cblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5NYXRlcmlhbCgpO1xuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhZGVyTWF0ZXJpYWw7XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqL1xuXG5USFJFRS5UZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciApIHtcblxuXHR0aGlzLmlkID0gVEhSRUUuVGV4dHVyZUNvdW50ICsrO1xuXG5cdHRoaXMuaW1hZ2UgPSBpbWFnZTtcblxuXHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogbmV3IFRIUkVFLlVWTWFwcGluZygpO1xuXG5cdHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHR0aGlzLndyYXBUID0gd3JhcFQgIT09IHVuZGVmaW5lZCA/IHdyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xuXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG5cdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5vblVwZGF0ZSA9IG51bGw7XG5cbn07XG5cblRIUkVFLlRleHR1cmUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlLFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgY2xvbmVkVGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCB0aGlzLmltYWdlLCB0aGlzLm1hcHBpbmcsIHRoaXMud3JhcFMsIHRoaXMud3JhcFQsIHRoaXMubWFnRmlsdGVyLCB0aGlzLm1pbkZpbHRlciApO1xuXG5cdFx0Y2xvbmVkVGV4dHVyZS5vZmZzZXQuY29weSggdGhpcy5vZmZzZXQgKTtcblx0XHRjbG9uZWRUZXh0dXJlLnJlcGVhdC5jb3B5KCB0aGlzLnJlcGVhdCApO1xuXG5cdFx0cmV0dXJuIGNsb25lZFRleHR1cmU7XG5cblx0fVxuXG59O1xuXG5USFJFRS5UZXh0dXJlQ291bnQgPSAwO1xuXG5USFJFRS5NdWx0aXBseU9wZXJhdGlvbiA9IDA7XG5USFJFRS5NaXhPcGVyYXRpb24gPSAxO1xuXG4vLyBNYXBwaW5nIG1vZGVzXG5cblRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IGZ1bmN0aW9uICgpIHt9O1xuVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XG5cblRIUkVFLkxhdGl0dWRlUmVmbGVjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblRIUkVFLkxhdGl0dWRlUmVmcmFjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxuVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblRIUkVFLlNwaGVyaWNhbFJlZnJhY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XG5cblRIUkVFLlVWTWFwcGluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBXcmFwcGluZyBtb2Rlc1xuXG5USFJFRS5SZXBlYXRXcmFwcGluZyA9IDA7XG5USFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nID0gMTtcblRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAyO1xuXG4vLyBGaWx0ZXJzXG5cblRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAzO1xuVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSA0O1xuVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDU7XG5USFJFRS5MaW5lYXJGaWx0ZXIgPSA2O1xuVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDc7XG5USFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSA4O1xuXG4vLyBUeXBlc1xuXG5USFJFRS5CeXRlVHlwZSA9IDk7XG5USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTA7XG5USFJFRS5TaG9ydFR5cGUgPSAxMTtcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlID0gMTI7XG5USFJFRS5JbnRUeXBlID0gMTM7XG5USFJFRS5VbnNpZ25lZEludFR5cGUgPSAxNDtcblRIUkVFLkZsb2F0VHlwZSA9IDE1O1xuXG4vLyBGb3JtYXRzXG5cblRIUkVFLkFscGhhRm9ybWF0ID0gMTY7XG5USFJFRS5SR0JGb3JtYXQgPSAxNztcblRIUkVFLlJHQkFGb3JtYXQgPSAxODtcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDE5O1xuVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAyMDtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5EYXRhVGV4dHVyZSA9IGZ1bmN0aW9uICggZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyICkge1xuXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciApO1xuXG5cdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcblxufTtcblxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRhdGFUZXh0dXJlO1xuXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGNsb25lZFRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIHRoaXMuZGF0YS5zbGljZSggMCApLCB0aGlzLm1hcHBpbmcsIHRoaXMud3JhcFMsIHRoaXMud3JhcFQsIHRoaXMubWFnRmlsdGVyLCB0aGlzLm1pbkZpbHRlciApO1xuXG5cdGNsb25lZFRleHR1cmUub2Zmc2V0LmNvcHkoIHRoaXMub2Zmc2V0ICk7XG5cdGNsb25lZFRleHR1cmUucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XG5cblx0cmV0dXJuIGNsb25lZFRleHR1cmU7XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlBhcnRpY2xlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG59O1xuXG5USFJFRS5QYXJ0aWNsZS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblRIUkVFLlBhcnRpY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhcnRpY2xlO1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdHRoaXMuc29ydFBhcnRpY2xlcyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5QYXJ0aWNsZVN5c3RlbS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblRIUkVFLlBhcnRpY2xlU3lzdGVtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhcnRpY2xlU3lzdGVtO1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHR5cGUgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdHRoaXMudHlwZSA9ICggdHlwZSAhPT0gdW5kZWZpbmVkICkgPyB0eXBlIDogVEhSRUUuTGluZVN0cmlwO1xuXG5cdGlmICggdGhpcy5nZW9tZXRyeSApIHtcblxuXHRcdGlmICggISB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICkge1xuXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVEhSRUUuTGluZVN0cmlwID0gMDtcblRIUkVFLkxpbmVQaWVjZXMgPSAxO1xuXG5USFJFRS5MaW5lLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuVEhSRUUuTGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lO1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICovXG5cblRIUkVFLk1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogTWVzaCBtYXRlcmlhbCBjYW4gbm8gbG9uZ2VyIGJlIGFuIEFycmF5LiBVc2luZyBtYXRlcmlhbCBhdCBpbmRleCAwLi4uJyApO1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbFsgMCBdO1xuXG5cdH1cblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkgKSB7XG5cblx0XHQvLyBjYWxjIGJvdW5kIHJhZGl1c1xuXG5cdFx0aWYoICF0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICkge1xuXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZFJhZGl1cyA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLnJhZGl1cztcblxuXG5cdFx0Ly8gc2V0dXAgbW9ycGggdGFyZ2V0c1xuXG5cdFx0aWYoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCApIHtcblxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEJhc2UgPSAtMTtcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRGb3JjZWRPcmRlciA9IFtdO1xuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcblx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdGZvciggdmFyIG0gPSAwOyBtIDwgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5USFJFRS5NZXNoLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuVEhSRUUuTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoO1xuVEhSRUUuTWVzaC5wcm90b3R5cGUuc3VwciA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZTtcblxuXG4vKlxuICogR2V0IE1vcnBoIFRhcmdldCBJbmRleCBieSBOYW1lXG4gKi9cblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZSA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG5cdGlmICggdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF07XG5cdH1cblxuXHRjb25zb2xlLmxvZyggXCJUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdC4gUmV0dXJuaW5nIDAuXCIgKTtcblx0cmV0dXJuIDA7XG5cbn1cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uKCBiZWxvbmdzVG9Ta2luICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnNraW4gPSBiZWxvbmdzVG9Ta2luO1xuXHR0aGlzLnNraW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG59O1xuXG5USFJFRS5Cb25lLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb25lO1xuVEhSRUUuQm9uZS5wcm90b3R5cGUuc3VwciA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZTtcblxuXG5USFJFRS5Cb25lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiggcGFyZW50U2tpbk1hdHJpeCwgZm9yY2VVcGRhdGUgKSB7XG5cblx0Ly8gdXBkYXRlIGxvY2FsXG5cblx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB7XG5cblx0XHRmb3JjZVVwZGF0ZSB8PSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdH1cblxuXHQvLyB1cGRhdGUgc2tpbiBtYXRyaXhcblxuXHRpZiAoIGZvcmNlVXBkYXRlIHx8IHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSApIHtcblxuXHRcdGlmKCBwYXJlbnRTa2luTWF0cml4ICkge1xuXG5cdFx0XHR0aGlzLnNraW5NYXRyaXgubXVsdGlwbHkoIHBhcmVudFNraW5NYXRyaXgsIHRoaXMubWF0cml4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNraW5NYXRyaXguY29weSggdGhpcy5tYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdGZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0dmFyIGNoaWxkLCBpLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG5cblx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZSggdGhpcy5za2luTWF0cml4LCBmb3JjZVVwZGF0ZSApO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Ta2lubmVkTWVzaCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0VEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHQvLyBpbml0IGJvbmVzXG5cblx0dGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0dGhpcy5ib25lcyA9IFtdO1xuXHR0aGlzLmJvbmVNYXRyaWNlcyA9IFtdO1xuXG5cdHZhciBiLCBib25lLCBnYm9uZSwgcCwgcSwgcztcblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGZvciAoIGIgPSAwOyBiIDwgdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgKysgKSB7XG5cblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG5cdFx0XHRwID0gZ2JvbmUucG9zO1xuXHRcdFx0cSA9IGdib25lLnJvdHE7XG5cdFx0XHRzID0gZ2JvbmUuc2NsO1xuXG5cdFx0XHRib25lID0gdGhpcy5hZGRCb25lKCk7XG5cblx0XHRcdGJvbmUubmFtZSA9IGdib25lLm5hbWU7XG5cdFx0XHRib25lLnBvc2l0aW9uLnNldCggcFswXSwgcFsxXSwgcFsyXSApO1xuXHRcdFx0Ym9uZS5xdWF0ZXJuaW9uLnNldCggcVswXSwgcVsxXSwgcVsyXSwgcVszXSApO1xuXHRcdFx0Ym9uZS51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ym9uZS5zY2FsZS5zZXQoIHNbMF0sIHNbMV0sIHNbMl0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib25lLnNjYWxlLnNldCggMSwgMSwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCBiID0gMDsgYiA8IHRoaXMuYm9uZXMubGVuZ3RoOyBiICsrICkge1xuXG5cdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcblx0XHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cblx0XHRcdGlmICggZ2JvbmUucGFyZW50ID09PSAtMSApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYm9uZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuYm9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdGhpcy5ib25lcy5sZW5ndGggKTtcblxuXHRcdHRoaXMucG9zZSgpO1xuXG5cdH1cblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlID0gbmV3IFRIUkVFLk1lc2goKTtcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNraW5uZWRNZXNoO1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuYWRkQm9uZSA9IGZ1bmN0aW9uKCBib25lICkge1xuXG5cdGlmICggYm9uZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Ym9uZSA9IG5ldyBUSFJFRS5Cb25lKCB0aGlzICk7XG5cblx0fVxuXG5cdHRoaXMuYm9uZXMucHVzaCggYm9uZSApO1xuXG5cdHJldHVybiBib25lO1xuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiAoIGZvcmNlICkge1xuXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSAmJiB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdC8vIHVwZGF0ZSBtYXRyaXhXb3JsZFxuXG5cdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseSggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGZvcmNlID0gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXG5cdFx0aWYgKCBjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cblx0XHRcdGNoaWxkLnVwZGF0ZSggdGhpcy5pZGVudGl0eU1hdHJpeCwgZmFsc2UgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNoaWxkLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG5cdHZhciBiLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoLFxuXHRcdGJhID0gdGhpcy5ib25lcyxcblx0XHRibSA9IHRoaXMuYm9uZU1hdHJpY2VzO1xuXG5cdGZvciAoIGIgPSAwOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRiYVsgYiBdLnNraW5NYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIGJtLCBiICogMTYgKTtcblxuXHR9XG5cbn07XG5cbi8qXG4gKiBQb3NlXG4gKi9cblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0dmFyIGJpbSwgYm9uZSwgYm9uZUludmVyc2VzID0gW107XG5cblx0Zm9yICggdmFyIGIgPSAwOyBiIDwgdGhpcy5ib25lcy5sZW5ndGg7IGIgKysgKSB7XG5cblx0XHRib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG5cdFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggYm9uZS5za2luTWF0cml4ICk7XG5cblx0XHRib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0Ym9uZS5za2luTWF0cml4LmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB0aGlzLmJvbmVNYXRyaWNlcywgYiAqIDE2ICk7XG5cblx0fVxuXG5cdC8vIHByb2plY3QgdmVydGljZXMgdG8gbG9jYWxcblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkuc2tpblZlcnRpY2VzQSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5za2luVmVydGljZXNBID0gW107XG5cdFx0dGhpcy5nZW9tZXRyeS5za2luVmVydGljZXNCID0gW107XG5cblx0XHR2YXIgb3JnVmVydGV4LCB2ZXJ0ZXg7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0b3JnVmVydGV4ID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlc1sgaSBdLnBvc2l0aW9uO1xuXG5cdFx0XHR2YXIgaW5kZXhBID0gdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlc1sgaSBdLng7XG5cdFx0XHR2YXIgaW5kZXhCID0gdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlc1sgaSBdLnk7XG5cblx0XHRcdHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCBvcmdWZXJ0ZXgueCwgb3JnVmVydGV4LnksIG9yZ1ZlcnRleC56ICk7XG5cdFx0XHR0aGlzLmdlb21ldHJ5LnNraW5WZXJ0aWNlc0EucHVzaCggYm9uZUludmVyc2VzWyBpbmRleEEgXS5tdWx0aXBseVZlY3RvcjMoIHZlcnRleCApICk7XG5cblx0XHRcdHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCBvcmdWZXJ0ZXgueCwgb3JnVmVydGV4LnksIG9yZ1ZlcnRleC56ICk7XG5cdFx0XHR0aGlzLmdlb21ldHJ5LnNraW5WZXJ0aWNlc0IucHVzaCggYm9uZUludmVyc2VzWyBpbmRleEIgXS5tdWx0aXBseVZlY3RvcjMoIHZlcnRleCApICk7XG5cblx0XHRcdC8vIHRvZG86IGFkZCBtb3JlIGluZmx1ZW5jZXNcblxuXHRcdFx0Ly8gbm9ybWFsaXplIHdlaWdodHNcblxuXHRcdFx0aWYgKCB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF0ueCArIHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXS55ICE9PSAxICkge1xuXG5cdFx0XHRcdHZhciBsZW4gPSAoIDEuMCAtICggdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdLnggKyB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF0ueSApICkgKiAwLjU7XG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXS54ICs9IGxlbjtcblx0XHRcdFx0dGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdLnkgKz0gbGVuO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59O1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1vcnBoQW5pbU1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0Ly8gQVBJXG5cblx0dGhpcy5kdXJhdGlvbiA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuXHR0aGlzLm1pcnJvcmVkTG9vcCA9IGZhbHNlO1xuXHR0aGlzLnRpbWUgPSAwO1xuXG5cdC8vIGludGVybmFsc1xuXG5cdHRoaXMubGFzdEtleWZyYW1lID0gMDtcblx0dGhpcy5jdXJyZW50S2V5ZnJhbWUgPSAwO1xuXG5cdHRoaXMuZGlyZWN0aW9uID0gMTtcblx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUgPSBuZXcgVEhSRUUuTWVzaCgpO1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Nb3JwaEFuaW1NZXNoO1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG5cdHZhciBmcmFtZVRpbWUgPSB0aGlzLmR1cmF0aW9uIC8gKCB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggLSAxICk7XG5cblx0dGhpcy50aW1lICs9IHRoaXMuZGlyZWN0aW9uICogZGVsdGE7XG5cblx0aWYgKCB0aGlzLm1pcnJvcmVkTG9vcCApIHtcblxuXHRcdGlmICggdGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbiB8fCB0aGlzLnRpbWUgPCAwICkge1xuXG5cdFx0XHR0aGlzLmRpcmVjdGlvbiAqPSAtMTtcblxuXHRcdFx0aWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG5cdFx0XHRcdHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMudGltZSA8IDAgKSB7XG5cblx0XHRcdFx0dGhpcy50aW1lID0gMDtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLnRpbWUgPSB0aGlzLnRpbWUgJSB0aGlzLmR1cmF0aW9uO1xuXG5cdH1cblxuXHR2YXIga2V5ZnJhbWUgPSBUSFJFRS5NYXRoLmNsYW1wKCBNYXRoLmZsb29yKCB0aGlzLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoIC0gMSApO1xuXG5cdGlmICgga2V5ZnJhbWUgIT0gdGhpcy5jdXJyZW50S2V5ZnJhbWUgKSB7XG5cblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5sYXN0S2V5ZnJhbWUgXSA9IDA7XG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEtleWZyYW1lIF0gPSAxO1xuXG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xuXG5cdFx0dGhpcy5sYXN0S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcblx0XHR0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IGtleWZyYW1lO1xuXG5cdH1cblxuXHR2YXIgbWl4ID0gKCB0aGlzLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcblxuXHRpZiAoIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzICkge1xuXG5cdFx0bWl4ID0gMSAtIG1peDtcblxuXHR9XG5cblx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEtleWZyYW1lIF0gPSBtaXg7XG5cdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMSAtIG1peDtcblxufTtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5SaWJib24gPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cbn07XG5cblRIUkVFLlJpYmJvbi5wcm90b3R5cGUgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblRIUkVFLlJpYmJvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SaWJib247XG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTE9EID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLkxPRHMgPSBbXTtcblxufTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuVEhSRUUuTE9ELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxPRDtcblRIUkVFLkxPRC5wcm90b3R5cGUuc3VwciA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5hZGRMZXZlbCA9IGZ1bmN0aW9uICggb2JqZWN0M0QsIHZpc2libGVBdERpc3RhbmNlICkge1xuXG5cdGlmICggdmlzaWJsZUF0RGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHZpc2libGVBdERpc3RhbmNlID0gMDtcblxuXHR9XG5cblx0dmlzaWJsZUF0RGlzdGFuY2UgPSBNYXRoLmFicyggdmlzaWJsZUF0RGlzdGFuY2UgKTtcblxuXHRmb3IgKCB2YXIgbCA9IDA7IGwgPCB0aGlzLkxPRHMubGVuZ3RoOyBsKysgKSB7XG5cblx0XHRpZiAoIHZpc2libGVBdERpc3RhbmNlIDwgdGhpcy5MT0RzWyBsIF0udmlzaWJsZUF0RGlzdGFuY2UgKSB7XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLkxPRHMuc3BsaWNlKCBsLCAwLCB7IHZpc2libGVBdERpc3RhbmNlOiB2aXNpYmxlQXREaXN0YW5jZSwgb2JqZWN0M0Q6IG9iamVjdDNEIH0gKTtcblx0dGhpcy5hZGQoIG9iamVjdDNEICk7XG5cbn07XG5cblRIUkVFLkxPRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0aWYgKCB0aGlzLkxPRHMubGVuZ3RoID4gMSApIHtcblxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0XHR2YXIgaW52ZXJzZSAgPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuXHRcdHZhciByYWRpdXMgICA9IHRoaXMuYm91bmRSYWRpdXMgKiB0aGlzLmJvdW5kUmFkaXVzU2NhbGU7XG5cdFx0dmFyIGRpc3RhbmNlID0gLSggaW52ZXJzZS5uMzEgKiB0aGlzLnBvc2l0aW9uLnggKyBpbnZlcnNlLm4zMiAqIHRoaXMucG9zaXRpb24ueSArIGludmVyc2UubjMzICogdGhpcy5wb3NpdGlvbi56ICsgaW52ZXJzZS5uMzQgKTtcblxuXHRcdHRoaXMuTE9Ec1sgMCBdLm9iamVjdDNELnZpc2libGUgPSB0cnVlO1xuXG5cdFx0Zm9yICggdmFyIGwgPSAxOyBsIDwgdGhpcy5MT0RzLmxlbmd0aDsgbCArKyApIHtcblxuXHRcdFx0aWYoIGRpc3RhbmNlID49IHRoaXMuTE9Ec1sgbCBdLnZpc2libGVBdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdHRoaXMuTE9Ec1sgbCAtIDEgXS5vYmplY3QzRC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuTE9Ec1sgbCAgICAgXS5vYmplY3QzRC52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yKCA7IGwgPCB0aGlzLkxPRHMubGVuZ3RoOyBsICsrICkge1xuXG5cdFx0XHR0aGlzLkxPRHNbIGwgXS5vYmplY3QzRC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICovXG5cblRIUkVFLlNwcml0ZSA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5jb2xvciA9ICggcGFyYW1ldGVycy5jb2xvciAhPT0gdW5kZWZpbmVkICkgPyBuZXcgVEhSRUUuQ29sb3IoIHBhcmFtZXRlcnMuY29sb3IgKSA6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblx0dGhpcy5tYXAgPSAoIHBhcmFtZXRlcnMubWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApID8gcGFyYW1ldGVycy5tYXAgOiBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKCBwYXJhbWV0ZXJzLm1hcCApO1xuXHR0aGlzLmJsZW5kaW5nID0gKCBwYXJhbWV0ZXJzLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSA/IHBhcmFtZXRlcnMuYmxlbmRpbmcgOiBUSFJFRS5Ob3JtYWxCbGVuZGluZztcblxuXHR0aGlzLnVzZVNjcmVlbkNvb3JkaW5hdGVzID0gKCBwYXJhbWV0ZXJzLnVzZVNjcmVlbkNvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQgKSA/IHBhcmFtZXRlcnMudXNlU2NyZWVuQ29vcmRpbmF0ZXMgOiB0cnVlO1xuXHR0aGlzLm1lcmdlV2l0aDNEID0gKCBwYXJhbWV0ZXJzLm1lcmdlV2l0aDNEICE9PSB1bmRlZmluZWQgKSA/IHBhcmFtZXRlcnMubWVyZ2VXaXRoM0QgOiAhdGhpcy51c2VTY3JlZW5Db29yZGluYXRlcztcblx0dGhpcy5hZmZlY3RlZEJ5RGlzdGFuY2UgPSAoIHBhcmFtZXRlcnMuYWZmZWN0ZWRCeURpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IHBhcmFtZXRlcnMuYWZmZWN0ZWRCeURpc3RhbmNlIDogIXRoaXMudXNlU2NyZWVuQ29vcmRpbmF0ZXM7XG5cdHRoaXMuc2NhbGVCeVZpZXdwb3J0ID0gKCBwYXJhbWV0ZXJzLnNjYWxlQnlWaWV3cG9ydCAhPT0gdW5kZWZpbmVkICkgPyBwYXJhbWV0ZXJzLnNjYWxlQnlWaWV3cG9ydCA6ICF0aGlzLmFmZmVjdGVkQnlEaXN0YW5jZTtcblx0dGhpcy5hbGlnbm1lbnQgPSAoIHBhcmFtZXRlcnMuYWxpZ25tZW50IGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiApID8gcGFyYW1ldGVycy5hbGlnbm1lbnQgOiBUSFJFRS5TcHJpdGVBbGlnbm1lbnQuY2VudGVyO1xuXG5cdHRoaXMucm90YXRpb24zZCA9IHRoaXMucm90YXRpb247XG5cdHRoaXMucm90YXRpb24gPSAwO1xuXHR0aGlzLm9wYWNpdHkgPSAxO1xuXG5cdHRoaXMudXZPZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApO1xuXHR0aGlzLnV2U2NhbGUgID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxufTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZTtcblxuXG4vKlxuICogQ3VzdG9tIHVwZGF0ZSBtYXRyaXhcbiAqL1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLnVwZGF0ZU1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLm1hdHJpeC5zZXRQb3NpdGlvbiggdGhpcy5wb3NpdGlvbiApO1xuXG5cdHRoaXMucm90YXRpb24zZC5zZXQoIDAsIDAsIHRoaXMucm90YXRpb24gKTtcblx0dGhpcy5tYXRyaXguc2V0Um90YXRpb25Gcm9tRXVsZXIoIHRoaXMucm90YXRpb24zZCApO1xuXG5cdGlmICggdGhpcy5zY2FsZS54ICE9PSAxIHx8IHRoaXMuc2NhbGUueSAhPT0gMSApIHtcblxuXHRcdHRoaXMubWF0cml4LnNjYWxlKCB0aGlzLnNjYWxlICk7XG5cdFx0dGhpcy5ib3VuZFJhZGl1c1NjYWxlID0gTWF0aC5tYXgoIHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55ICk7XG5cblx0fVxuXG5cdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cbi8qXG4gKiBBbGlnbm1lbnRcbiAqL1xuXG5USFJFRS5TcHJpdGVBbGlnbm1lbnQgPSB7fTtcblRIUkVFLlNwcml0ZUFsaWdubWVudC50b3BMZWZ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIC0xICk7XG5USFJFRS5TcHJpdGVBbGlnbm1lbnQudG9wQ2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIC0xICk7XG5USFJFRS5TcHJpdGVBbGlnbm1lbnQudG9wUmlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yMiggLTEsIC0xICk7XG5USFJFRS5TcHJpdGVBbGlnbm1lbnQuY2VudGVyTGVmdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAwICk7XG5USFJFRS5TcHJpdGVBbGlnbm1lbnQuY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcblRIUkVFLlNwcml0ZUFsaWdubWVudC5jZW50ZXJSaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAtMSwgMCApO1xuVEhSRUUuU3ByaXRlQWxpZ25tZW50LmJvdHRvbUxlZnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuVEhSRUUuU3ByaXRlQWxpZ25tZW50LmJvdHRvbUNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAxICk7XG5USFJFRS5TcHJpdGVBbGlnbm1lbnQuYm90dG9tUmlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yMiggLTEsIDEgKTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuU2NlbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMuZm9nID0gbnVsbDtcblx0dGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLm9iamVjdHMgPSBbXTtcblx0dGhpcy5saWdodHMgPSBbXTtcblxuXHR0aGlzLl9fb2JqZWN0c0FkZGVkID0gW107XG5cdHRoaXMuX19vYmplY3RzUmVtb3ZlZCA9IFtdO1xuXG59O1xuXG5USFJFRS5TY2VuZS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNjZW5lO1xuXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuYWRkT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcblxuXHRcdGlmICggdGhpcy5saWdodHMuaW5kZXhPZiggb2JqZWN0ICkgPT09IC0gMSApIHtcblxuXHRcdFx0dGhpcy5saWdodHMucHVzaCggb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIGlmICggISggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSApIHtcblxuXHRcdGlmICggdGhpcy5vYmplY3RzLmluZGV4T2YoIG9iamVjdCApID09PSAtIDEgKSB7XG5cblx0XHRcdHRoaXMub2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcblx0XHRcdHRoaXMuX19vYmplY3RzQWRkZWQucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdC8vIGNoZWNrIGlmIHByZXZpb3VzbHkgcmVtb3ZlZFxuXG5cdFx0XHR2YXIgaSA9IHRoaXMuX19vYmplY3RzUmVtb3ZlZC5pbmRleE9mKCBvYmplY3QgKTtcblxuXHRcdFx0aWYgKCBpICE9PSAtMSApIHtcblxuXHRcdFx0XHR0aGlzLl9fb2JqZWN0c1JlbW92ZWQuc3BsaWNlKCBpLCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Zm9yICggdmFyIGMgPSAwOyBjIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgYyArKyApIHtcblxuXHRcdHRoaXMuYWRkT2JqZWN0KCBvYmplY3QuY2hpbGRyZW5bIGMgXSApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlLnJlbW92ZU9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGlnaHQgKSB7XG5cblx0XHR2YXIgaSA9IHRoaXMubGlnaHRzLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpICE9PSAtMSApIHtcblxuXHRcdFx0dGhpcy5saWdodHMuc3BsaWNlKCBpLCAxICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIGlmICggISggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhICkgKSB7XG5cblx0XHR2YXIgaSA9IHRoaXMub2JqZWN0cy5pbmRleE9mKCBvYmplY3QgKTtcblxuXHRcdGlmKCBpICE9PSAtMSApIHtcblxuXHRcdFx0dGhpcy5vYmplY3RzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0dGhpcy5fX29iamVjdHNSZW1vdmVkLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHQvLyBjaGVjayBpZiBwcmV2aW91c2x5IGFkZGVkXG5cblx0XHRcdHZhciBhaSA9IHRoaXMuX19vYmplY3RzQWRkZWQuaW5kZXhPZiggb2JqZWN0ICk7XG5cblx0XHRcdGlmICggYWkgIT09IC0xICkge1xuXG5cdFx0XHRcdHRoaXMuX19vYmplY3RzQWRkZWQuc3BsaWNlKCBhaSwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZvciAoIHZhciBjID0gMDsgYyA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGMgKysgKSB7XG5cblx0XHR0aGlzLnJlbW92ZU9iamVjdCggb2JqZWN0LmNoaWxkcmVuWyBjIF0gKTtcblxuXHR9XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Gb2cgPSBmdW5jdGlvbiAoIGhleCwgbmVhciwgZmFyICkge1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGhleCApO1xuXG5cdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcblx0dGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAxMDAwO1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRm9nRXhwMiA9IGZ1bmN0aW9uICggaGV4LCBkZW5zaXR5ICkge1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGhleCApO1xuXHR0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkRPTVJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLlJlbmRlcmVyLmNhbGwoIHRoaXMgKTtcblxuXHR2YXIgX3JlbmRlckxpc3QgPSBudWxsLFxuXHRfcHJvamVjdG9yID0gbmV3IFRIUkVFLlByb2plY3RvcigpLFxuXHRfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKSxcblx0X3dpZHRoLCBfaGVpZ2h0LCBfd2lkdGhIYWxmLCBfaGVpZ2h0SGFsZjtcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfZGl2O1xuXG5cdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdF93aWR0aCA9IHdpZHRoOyBfaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdF93aWR0aEhhbGYgPSBfd2lkdGggLyAyOyBfaGVpZ2h0SGFsZiA9IF9oZWlnaHQgLyAyO1xuXG5cdH07XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHR2YXIgZSwgZWwsIG0sIG1sLCBlbGVtZW50LCBtYXRlcmlhbCwgZG9tLCB2MXgsIHYxeTtcblxuXHRcdF9yZW5kZXJMaXN0ID0gX3Byb2plY3Rvci5wcm9qZWN0U2NlbmUoIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdGZvciAoIGUgPSAwLCBlbCA9IF9yZW5kZXJMaXN0Lmxlbmd0aDsgZSA8IGVsOyBlKysgKSB7XG5cblx0XHRcdGVsZW1lbnQgPSBfcmVuZGVyTGlzdFsgZSBdO1xuXG5cdFx0XHRpZiAoIGVsZW1lbnQgaW5zdGFuY2VvZiBUSFJFRS5SZW5kZXJhYmxlUGFydGljbGUgKSB7XG5cblx0XHRcdFx0djF4ID0gZWxlbWVudC54ICogX3dpZHRoSGFsZiArIF93aWR0aEhhbGY7IHYxeSA9IGVsZW1lbnQueSAqIF9oZWlnaHRIYWxmICsgX2hlaWdodEhhbGY7XG5cblx0XHRcdFx0Zm9yICggbSA9IDAsIG1sID0gZWxlbWVudC5tYXRlcmlhbC5sZW5ndGg7IG0gPCBtbDsgbSsrICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBlbGVtZW50Lm1hdGVyaWFsWyBtIF07XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVET01NYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0ZG9tID0gbWF0ZXJpYWwuZG9tRWxlbWVudDtcblx0XHRcdFx0XHRcdGRvbS5zdHlsZS5sZWZ0ID0gdjF4ICsgJ3B4Jztcblx0XHRcdFx0XHRcdGRvbS5zdHlsZS50b3AgPSB2MXkgKyAncHgnO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cbn1cbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0dmFyIF90aGlzID0gdGhpcyxcblx0X3JlbmRlckRhdGEsIF9lbGVtZW50cywgX2xpZ2h0cyxcblx0X3Byb2plY3RvciA9IG5ldyBUSFJFRS5Qcm9qZWN0b3IoKSxcblxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fSxcblxuXHRfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcblxuXHRfY2FudmFzV2lkdGgsIF9jYW52YXNIZWlnaHQsIF9jYW52YXNXaWR0aEhhbGYsIF9jYW52YXNIZWlnaHRIYWxmLFxuXHRfY29udGV4dCA9IF9jYW52YXMuZ2V0Q29udGV4dCggJzJkJyApLFxuXG5cdF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxuXHRfY2xlYXJPcGFjaXR5ID0gMCxcblxuXHRfY29udGV4dEdsb2JhbEFscGhhID0gMSxcblx0X2NvbnRleHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAwLFxuXHRfY29udGV4dFN0cm9rZVN0eWxlID0gbnVsbCxcblx0X2NvbnRleHRGaWxsU3R5bGUgPSBudWxsLFxuXHRfY29udGV4dExpbmVXaWR0aCA9IG51bGwsXG5cdF9jb250ZXh0TGluZUNhcCA9IG51bGwsXG5cdF9jb250ZXh0TGluZUpvaW4gPSBudWxsLFxuXG5cdF92MSwgX3YyLCBfdjMsIF92NCxcblx0X3Y1ID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKSxcblx0X3Y2ID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKSxcblxuXHRfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LFxuXHRfdjR4LCBfdjR5LCBfdjV4LCBfdjV5LCBfdjZ4LCBfdjZ5LFxuXG5cdF9jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLFxuXHRfY29sb3IxID0gbmV3IFRIUkVFLkNvbG9yKCksXG5cdF9jb2xvcjIgPSBuZXcgVEhSRUUuQ29sb3IoKSxcblx0X2NvbG9yMyA9IG5ldyBUSFJFRS5Db2xvcigpLFxuXHRfY29sb3I0ID0gbmV3IFRIUkVFLkNvbG9yKCksXG5cblx0X3BhdHRlcm5zID0gW10sIF9pbWFnZWRhdGFzID0gW10sXG5cblx0X25lYXIsIF9mYXIsXG5cblx0X2ltYWdlLCBfdXZzLFxuXHRfdXYxeCwgX3V2MXksIF91djJ4LCBfdXYyeSwgX3V2M3gsIF91djN5LFxuXG5cdF9jbGlwUmVjdCA9IG5ldyBUSFJFRS5SZWN0YW5nbGUoKSxcblx0X2NsZWFyUmVjdCA9IG5ldyBUSFJFRS5SZWN0YW5nbGUoKSxcblx0X2Jib3hSZWN0ID0gbmV3IFRIUkVFLlJlY3RhbmdsZSgpLFxuXG5cdF9lbmFibGVMaWdodGluZyA9IGZhbHNlLFxuXHRfYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkNvbG9yKCksXG5cdF9kaXJlY3Rpb25hbExpZ2h0cyA9IG5ldyBUSFJFRS5Db2xvcigpLFxuXHRfcG9pbnRMaWdodHMgPSBuZXcgVEhSRUUuQ29sb3IoKSxcblxuXHRfcGkyID0gTWF0aC5QSSAqIDIsXG5cdF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgLy8gTmVlZGVkIGZvciBQb2ludExpZ2h0XG5cblx0X3BpeGVsTWFwLCBfcGl4ZWxNYXBDb250ZXh0LCBfcGl4ZWxNYXBJbWFnZSwgX3BpeGVsTWFwRGF0YSxcblx0X2dyYWRpZW50TWFwLCBfZ3JhZGllbnRNYXBDb250ZXh0LCBfZ3JhZGllbnRNYXBRdWFsaXR5ID0gMTY7XG5cblx0X3BpeGVsTWFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0X3BpeGVsTWFwLndpZHRoID0gX3BpeGVsTWFwLmhlaWdodCA9IDI7XG5cblx0X3BpeGVsTWFwQ29udGV4dCA9IF9waXhlbE1hcC5nZXRDb250ZXh0KCAnMmQnICk7XG5cdF9waXhlbE1hcENvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMSknO1xuXHRfcGl4ZWxNYXBDb250ZXh0LmZpbGxSZWN0KCAwLCAwLCAyLCAyICk7XG5cblx0X3BpeGVsTWFwSW1hZ2UgPSBfcGl4ZWxNYXBDb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgMiwgMiApO1xuXHRfcGl4ZWxNYXBEYXRhID0gX3BpeGVsTWFwSW1hZ2UuZGF0YTtcblxuXHRfZ3JhZGllbnRNYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuXHRfZ3JhZGllbnRNYXAud2lkdGggPSBfZ3JhZGllbnRNYXAuaGVpZ2h0ID0gX2dyYWRpZW50TWFwUXVhbGl0eTtcblxuXHRfZ3JhZGllbnRNYXBDb250ZXh0ID0gX2dyYWRpZW50TWFwLmdldENvbnRleHQoICcyZCcgKTtcblx0X2dyYWRpZW50TWFwQ29udGV4dC50cmFuc2xhdGUoIC0gX2dyYWRpZW50TWFwUXVhbGl0eSAvIDIsIC0gX2dyYWRpZW50TWFwUXVhbGl0eSAvIDIgKTtcblx0X2dyYWRpZW50TWFwQ29udGV4dC5zY2FsZSggX2dyYWRpZW50TWFwUXVhbGl0eSwgX2dyYWRpZW50TWFwUXVhbGl0eSApO1xuXG5cdF9ncmFkaWVudE1hcFF1YWxpdHkgLS07IC8vIEZpeCBVVnNcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXG5cdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcblx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XG5cdHRoaXMuc29ydEVsZW1lbnRzID0gdHJ1ZTtcblxuXHR0aGlzLmluZm8gPSB7XG5cblx0XHRyZW5kZXI6IHtcblxuXHRcdFx0dmVydGljZXM6IDAsXG5cdFx0XHRmYWNlczogMFxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRfY2FudmFzV2lkdGggPSB3aWR0aDtcblx0XHRfY2FudmFzSGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdF9jYW52YXNXaWR0aEhhbGYgPSBNYXRoLmZsb29yKCBfY2FudmFzV2lkdGggLyAyICk7XG5cdFx0X2NhbnZhc0hlaWdodEhhbGYgPSBNYXRoLmZsb29yKCBfY2FudmFzSGVpZ2h0IC8gMiApO1xuXG5cdFx0X2NhbnZhcy53aWR0aCA9IF9jYW52YXNXaWR0aDtcblx0XHRfY2FudmFzLmhlaWdodCA9IF9jYW52YXNIZWlnaHQ7XG5cblx0XHRfY2xpcFJlY3Quc2V0KCAtIF9jYW52YXNXaWR0aEhhbGYsIC0gX2NhbnZhc0hlaWdodEhhbGYsIF9jYW52YXNXaWR0aEhhbGYsIF9jYW52YXNIZWlnaHRIYWxmICk7XG5cdFx0X2NsZWFyUmVjdC5zZXQoIC0gX2NhbnZhc1dpZHRoSGFsZiwgLSBfY2FudmFzSGVpZ2h0SGFsZiwgX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKTtcblxuXHRcdF9jb250ZXh0R2xvYmFsQWxwaGEgPSAxO1xuXHRcdF9jb250ZXh0R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gMDtcblx0XHRfY29udGV4dFN0cm9rZVN0eWxlID0gbnVsbDtcblx0XHRfY29udGV4dEZpbGxTdHlsZSA9IG51bGw7XG5cdFx0X2NvbnRleHRMaW5lV2lkdGggPSBudWxsO1xuXHRcdF9jb250ZXh0TGluZUNhcCA9IG51bGw7XG5cdFx0X2NvbnRleHRMaW5lSm9pbiA9IG51bGw7XG5cblx0fTtcblxuXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiggY29sb3IsIG9wYWNpdHkgKSB7XG5cblx0XHRfY2xlYXJDb2xvci5jb3B5KCBjb2xvciApO1xuXHRcdF9jbGVhck9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0X2NsZWFyUmVjdC5zZXQoIC0gX2NhbnZhc1dpZHRoSGFsZiwgLSBfY2FudmFzSGVpZ2h0SGFsZiwgX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKTtcblxuXHR9O1xuXG5cdHRoaXMuc2V0Q2xlYXJDb2xvckhleCA9IGZ1bmN0aW9uKCBoZXgsIG9wYWNpdHkgKSB7XG5cblx0XHRfY2xlYXJDb2xvci5zZXRIZXgoIGhleCApO1xuXHRcdF9jbGVhck9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0X2NsZWFyUmVjdC5zZXQoIC0gX2NhbnZhc1dpZHRoSGFsZiwgLSBfY2FudmFzSGVpZ2h0SGFsZiwgX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKTtcblxuXHR9O1xuXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIC0gMSwgX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKTtcblxuXHRcdGlmICggIV9jbGVhclJlY3QuaXNFbXB0eSgpICkge1xuXG5cdFx0XHRfY2xlYXJSZWN0Lm1pblNlbGYoIF9jbGlwUmVjdCApO1xuXHRcdFx0X2NsZWFyUmVjdC5pbmZsYXRlKCAyICk7XG5cblx0XHRcdGlmICggX2NsZWFyT3BhY2l0eSA8IDEgKSB7XG5cblx0XHRcdFx0X2NvbnRleHQuY2xlYXJSZWN0KCBNYXRoLmZsb29yKCBfY2xlYXJSZWN0LmdldFgoKSApLCBNYXRoLmZsb29yKCBfY2xlYXJSZWN0LmdldFkoKSApLCBNYXRoLmZsb29yKCBfY2xlYXJSZWN0LmdldFdpZHRoKCkgKSwgTWF0aC5mbG9vciggX2NsZWFyUmVjdC5nZXRIZWlnaHQoKSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBfY2xlYXJPcGFjaXR5ID4gMCApIHtcblxuXHRcdFx0XHRzZXRCbGVuZGluZyggVEhSRUUuTm9ybWFsQmxlbmRpbmcgKTtcblx0XHRcdFx0c2V0T3BhY2l0eSggMSApO1xuXG5cdFx0XHRcdHNldEZpbGxTdHlsZSggJ3JnYmEoJyArIE1hdGguZmxvb3IoIF9jbGVhckNvbG9yLnIgKiAyNTUgKSArICcsJyArIE1hdGguZmxvb3IoIF9jbGVhckNvbG9yLmcgKiAyNTUgKSArICcsJyArIE1hdGguZmxvb3IoIF9jbGVhckNvbG9yLmIgKiAyNTUgKSArICcsJyArIF9jbGVhck9wYWNpdHkgKyAnKScgKTtcblxuXHRcdFx0XHRfY29udGV4dC5maWxsUmVjdCggTWF0aC5mbG9vciggX2NsZWFyUmVjdC5nZXRYKCkgKSwgTWF0aC5mbG9vciggX2NsZWFyUmVjdC5nZXRZKCkgKSwgTWF0aC5mbG9vciggX2NsZWFyUmVjdC5nZXRXaWR0aCgpICksIE1hdGguZmxvb3IoIF9jbGVhclJlY3QuZ2V0SGVpZ2h0KCkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9jbGVhclJlY3QuZW1wdHkoKTtcblxuXHRcdH1cblxuXG5cdH07XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHR2YXIgZSwgZWwsIGVsZW1lbnQsIG1hdGVyaWFsO1xuXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPyB0aGlzLmNsZWFyKCkgOiBfY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIC0gMSwgX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKTtcblxuXHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzID0gMDtcblx0XHRfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyA9IDA7XG5cblx0XHRfcmVuZGVyRGF0YSA9IF9wcm9qZWN0b3IucHJvamVjdFNjZW5lKCBzY2VuZSwgY2FtZXJhLCB0aGlzLnNvcnRFbGVtZW50cyApO1xuXHRcdF9lbGVtZW50cyA9IF9yZW5kZXJEYXRhLmVsZW1lbnRzO1xuXHRcdF9saWdodHMgPSBfcmVuZGVyRGF0YS5saWdodHM7XG5cblx0XHQvKiBERUJVR1xuXHRcdF9jb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCAwLCAyNTUsIDI1NSwgMC41ICknO1xuXHRcdF9jb250ZXh0LmZpbGxSZWN0KCBfY2xpcFJlY3QuZ2V0WCgpLCBfY2xpcFJlY3QuZ2V0WSgpLCBfY2xpcFJlY3QuZ2V0V2lkdGgoKSwgX2NsaXBSZWN0LmdldEhlaWdodCgpICk7XG5cdFx0Ki9cblxuXHRcdF9lbmFibGVMaWdodGluZyA9IF9saWdodHMubGVuZ3RoID4gMDtcblxuXHRcdGlmICggX2VuYWJsZUxpZ2h0aW5nICkge1xuXG5cdFx0XHQgY2FsY3VsYXRlTGlnaHRzKCBfbGlnaHRzICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBlID0gMCwgZWwgPSBfZWxlbWVudHMubGVuZ3RoOyBlIDwgZWw7IGUrKyApIHtcblxuXHRcdFx0ZWxlbWVudCA9IF9lbGVtZW50c1sgZSBdO1xuXG5cdFx0XHRtYXRlcmlhbCA9IGVsZW1lbnQubWF0ZXJpYWw7XG5cdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCA/IGVsZW1lbnQuZmFjZU1hdGVyaWFsIDogbWF0ZXJpYWw7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgPT0gbnVsbCB8fCBtYXRlcmlhbC5vcGFjaXR5ID09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0X2Jib3hSZWN0LmVtcHR5KCk7XG5cblx0XHRcdGlmICggZWxlbWVudCBpbnN0YW5jZW9mIFRIUkVFLlJlbmRlcmFibGVQYXJ0aWNsZSApIHtcblxuXHRcdFx0XHRfdjEgPSBlbGVtZW50O1xuXHRcdFx0XHRfdjEueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjEueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcblxuXHRcdFx0XHRyZW5kZXJQYXJ0aWNsZSggX3YxLCBlbGVtZW50LCBtYXRlcmlhbCwgc2NlbmUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudCBpbnN0YW5jZW9mIFRIUkVFLlJlbmRlcmFibGVMaW5lICkge1xuXG5cdFx0XHRcdF92MSA9IGVsZW1lbnQudjE7IF92MiA9IGVsZW1lbnQudjI7XG5cblx0XHRcdFx0X3YxLnBvc2l0aW9uU2NyZWVuLnggKj0gX2NhbnZhc1dpZHRoSGFsZjsgX3YxLnBvc2l0aW9uU2NyZWVuLnkgKj0gX2NhbnZhc0hlaWdodEhhbGY7XG5cdFx0XHRcdF92Mi5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92Mi5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xuXG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YxLnBvc2l0aW9uU2NyZWVuLngsIF92MS5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YyLnBvc2l0aW9uU2NyZWVuLngsIF92Mi5wb3NpdGlvblNjcmVlbi55ICk7XG5cblx0XHRcdFx0aWYgKCBfY2xpcFJlY3QuaW50ZXJzZWN0cyggX2Jib3hSZWN0ICkgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJMaW5lKCBfdjEsIF92MiwgZWxlbWVudCwgbWF0ZXJpYWwsIHNjZW5lICk7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQgaW5zdGFuY2VvZiBUSFJFRS5SZW5kZXJhYmxlRmFjZTMgKSB7XG5cblx0XHRcdFx0X3YxID0gZWxlbWVudC52MTsgX3YyID0gZWxlbWVudC52MjsgX3YzID0gZWxlbWVudC52MztcblxuXHRcdFx0XHRfdjEucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjEucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcblx0XHRcdFx0X3YyLnBvc2l0aW9uU2NyZWVuLnggKj0gX2NhbnZhc1dpZHRoSGFsZjsgX3YyLnBvc2l0aW9uU2NyZWVuLnkgKj0gX2NhbnZhc0hlaWdodEhhbGY7XG5cdFx0XHRcdF92My5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92My5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwub3ZlcmRyYXcgKSB7XG5cblx0XHRcdFx0XHRleHBhbmQoIF92MS5wb3NpdGlvblNjcmVlbiwgX3YyLnBvc2l0aW9uU2NyZWVuICk7XG5cdFx0XHRcdFx0ZXhwYW5kKCBfdjIucG9zaXRpb25TY3JlZW4sIF92My5wb3NpdGlvblNjcmVlbiApO1xuXHRcdFx0XHRcdGV4cGFuZCggX3YzLnBvc2l0aW9uU2NyZWVuLCBfdjEucG9zaXRpb25TY3JlZW4gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2Jib3hSZWN0LmFkZDNQb2ludHMoIF92MS5wb3NpdGlvblNjcmVlbi54LCBfdjEucG9zaXRpb25TY3JlZW4ueSxcblx0XHRcdFx0XHRcdCAgICAgIF92Mi5wb3NpdGlvblNjcmVlbi54LCBfdjIucG9zaXRpb25TY3JlZW4ueSxcblx0XHRcdFx0XHRcdCAgICAgIF92My5wb3NpdGlvblNjcmVlbi54LCBfdjMucG9zaXRpb25TY3JlZW4ueSApO1xuXG5cdFx0XHRcdGlmICggX2NsaXBSZWN0LmludGVyc2VjdHMoIF9iYm94UmVjdCApICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyRmFjZTMoIF92MSwgX3YyLCBfdjMsIDAsIDEsIDIsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudCBpbnN0YW5jZW9mIFRIUkVFLlJlbmRlcmFibGVGYWNlNCApIHtcblxuXHRcdFx0XHRfdjEgPSBlbGVtZW50LnYxOyBfdjIgPSBlbGVtZW50LnYyOyBfdjMgPSBlbGVtZW50LnYzOyBfdjQgPSBlbGVtZW50LnY0O1xuXG5cdFx0XHRcdF92MS5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92MS5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xuXHRcdFx0XHRfdjIucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjIucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcblx0XHRcdFx0X3YzLnBvc2l0aW9uU2NyZWVuLnggKj0gX2NhbnZhc1dpZHRoSGFsZjsgX3YzLnBvc2l0aW9uU2NyZWVuLnkgKj0gX2NhbnZhc0hlaWdodEhhbGY7XG5cdFx0XHRcdF92NC5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92NC5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xuXG5cdFx0XHRcdF92NS5wb3NpdGlvblNjcmVlbi5jb3B5KCBfdjIucG9zaXRpb25TY3JlZW4gKTtcblx0XHRcdFx0X3Y2LnBvc2l0aW9uU2NyZWVuLmNvcHkoIF92NC5wb3NpdGlvblNjcmVlbiApO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwub3ZlcmRyYXcgKSB7XG5cblx0XHRcdFx0XHRleHBhbmQoIF92MS5wb3NpdGlvblNjcmVlbiwgX3YyLnBvc2l0aW9uU2NyZWVuICk7XG5cdFx0XHRcdFx0ZXhwYW5kKCBfdjIucG9zaXRpb25TY3JlZW4sIF92NC5wb3NpdGlvblNjcmVlbiApO1xuXHRcdFx0XHRcdGV4cGFuZCggX3Y0LnBvc2l0aW9uU2NyZWVuLCBfdjEucG9zaXRpb25TY3JlZW4gKTtcblxuXHRcdFx0XHRcdGV4cGFuZCggX3YzLnBvc2l0aW9uU2NyZWVuLCBfdjUucG9zaXRpb25TY3JlZW4gKTtcblx0XHRcdFx0XHRleHBhbmQoIF92My5wb3NpdGlvblNjcmVlbiwgX3Y2LnBvc2l0aW9uU2NyZWVuICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YxLnBvc2l0aW9uU2NyZWVuLngsIF92MS5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YyLnBvc2l0aW9uU2NyZWVuLngsIF92Mi5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YzLnBvc2l0aW9uU2NyZWVuLngsIF92My5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3Y0LnBvc2l0aW9uU2NyZWVuLngsIF92NC5wb3NpdGlvblNjcmVlbi55ICk7XG5cblx0XHRcdFx0aWYgKCBfY2xpcFJlY3QuaW50ZXJzZWN0cyggX2Jib3hSZWN0ICkgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJGYWNlNCggX3YxLCBfdjIsIF92MywgX3Y0LCBfdjUsIF92NiwgZWxlbWVudCwgbWF0ZXJpYWwsIHNjZW5lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8qXG5cdFx0XHRfY29udGV4dC5saW5lV2lkdGggPSAxO1xuXHRcdFx0X2NvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSggMCwgMjU1LCAwLCAwLjUgKSc7XG5cdFx0XHRfY29udGV4dC5zdHJva2VSZWN0KCBfYmJveFJlY3QuZ2V0WCgpLCBfYmJveFJlY3QuZ2V0WSgpLCBfYmJveFJlY3QuZ2V0V2lkdGgoKSwgX2Jib3hSZWN0LmdldEhlaWdodCgpICk7XG5cdFx0XHQqL1xuXG5cdFx0XHRfY2xlYXJSZWN0LmFkZFJlY3RhbmdsZSggX2Jib3hSZWN0ICk7XG5cblxuXHRcdH1cblxuXHRcdC8qIERFQlVHXG5cdFx0X2NvbnRleHQubGluZVdpZHRoID0gMTtcblx0XHRfY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCAyNTUsIDAsIDAsIDAuNSApJztcblx0XHRfY29udGV4dC5zdHJva2VSZWN0KCBfY2xlYXJSZWN0LmdldFgoKSwgX2NsZWFyUmVjdC5nZXRZKCksIF9jbGVhclJlY3QuZ2V0V2lkdGgoKSwgX2NsZWFyUmVjdC5nZXRIZWlnaHQoKSApO1xuXHRcdCovXG5cblx0XHRfY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBjYWxjdWxhdGVMaWdodHMoIGxpZ2h0cyApIHtcblxuXHRcdFx0dmFyIGwsIGxsLCBsaWdodCwgbGlnaHRDb2xvcjtcblxuXHRcdFx0X2FtYmllbnRMaWdodC5zZXRSR0IoIDAsIDAsIDAgKTtcblx0XHRcdF9kaXJlY3Rpb25hbExpZ2h0cy5zZXRSR0IoIDAsIDAsIDAgKTtcblx0XHRcdF9wb2ludExpZ2h0cy5zZXRSR0IoIDAsIDAsIDAgKTtcblxuXHRcdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xuXG5cdFx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cdFx0XHRcdGxpZ2h0Q29sb3IgPSBsaWdodC5jb2xvcjtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0X2FtYmllbnRMaWdodC5yICs9IGxpZ2h0Q29sb3Iucjtcblx0XHRcdFx0XHRfYW1iaWVudExpZ2h0LmcgKz0gbGlnaHRDb2xvci5nO1xuXHRcdFx0XHRcdF9hbWJpZW50TGlnaHQuYiArPSBsaWdodENvbG9yLmI7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0Ly8gZm9yIHBhcnRpY2xlc1xuXG5cdFx0XHRcdFx0X2RpcmVjdGlvbmFsTGlnaHRzLnIgKz0gbGlnaHRDb2xvci5yO1xuXHRcdFx0XHRcdF9kaXJlY3Rpb25hbExpZ2h0cy5nICs9IGxpZ2h0Q29sb3IuZztcblx0XHRcdFx0XHRfZGlyZWN0aW9uYWxMaWdodHMuYiArPSBsaWdodENvbG9yLmI7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0Ly8gZm9yIHBhcnRpY2xlc1xuXG5cdFx0XHRcdFx0X3BvaW50TGlnaHRzLnIgKz0gbGlnaHRDb2xvci5yO1xuXHRcdFx0XHRcdF9wb2ludExpZ2h0cy5nICs9IGxpZ2h0Q29sb3IuZztcblx0XHRcdFx0XHRfcG9pbnRMaWdodHMuYiArPSBsaWdodENvbG9yLmI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYWxjdWxhdGVMaWdodCggbGlnaHRzLCBwb3NpdGlvbiwgbm9ybWFsLCBjb2xvciApIHtcblxuXHRcdFx0dmFyIGwsIGxsLCBsaWdodCwgbGlnaHRDb2xvciwgbGlnaHRQb3NpdGlvbiwgYW1vdW50O1xuXG5cdFx0XHRmb3IgKCBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cblx0XHRcdFx0bGlnaHQgPSBsaWdodHNbIGwgXTtcblx0XHRcdFx0bGlnaHRDb2xvciA9IGxpZ2h0LmNvbG9yO1xuXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0bGlnaHRQb3NpdGlvbiA9IGxpZ2h0Lm1hdHJpeFdvcmxkLmdldFBvc2l0aW9uKCk7XG5cblx0XHRcdFx0XHRhbW91bnQgPSBub3JtYWwuZG90KCBsaWdodFBvc2l0aW9uICk7XG5cblx0XHRcdFx0XHRpZiAoIGFtb3VudCA8PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0XHRhbW91bnQgKj0gbGlnaHQuaW50ZW5zaXR5O1xuXG5cdFx0XHRcdFx0Y29sb3IuciArPSBsaWdodENvbG9yLnIgKiBhbW91bnQ7XG5cdFx0XHRcdFx0Y29sb3IuZyArPSBsaWdodENvbG9yLmcgKiBhbW91bnQ7XG5cdFx0XHRcdFx0Y29sb3IuYiArPSBsaWdodENvbG9yLmIgKiBhbW91bnQ7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0bGlnaHRQb3NpdGlvbiA9IGxpZ2h0Lm1hdHJpeFdvcmxkLmdldFBvc2l0aW9uKCk7XG5cblx0XHRcdFx0XHRhbW91bnQgPSBub3JtYWwuZG90KCBfdmVjdG9yMy5zdWIoIGxpZ2h0UG9zaXRpb24sIHBvc2l0aW9uICkubm9ybWFsaXplKCkgKTtcblxuXHRcdFx0XHRcdGlmICggYW1vdW50IDw9IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGFtb3VudCAqPSBsaWdodC5kaXN0YW5jZSA9PSAwID8gMSA6IDEgLSBNYXRoLm1pbiggcG9zaXRpb24uZGlzdGFuY2VUbyggbGlnaHRQb3NpdGlvbiApIC8gbGlnaHQuZGlzdGFuY2UsIDEgKTtcblxuXHRcdFx0XHRcdGlmICggYW1vdW50ID09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGFtb3VudCAqPSBsaWdodC5pbnRlbnNpdHk7XG5cblx0XHRcdFx0XHRjb2xvci5yICs9IGxpZ2h0Q29sb3IuciAqIGFtb3VudDtcblx0XHRcdFx0XHRjb2xvci5nICs9IGxpZ2h0Q29sb3IuZyAqIGFtb3VudDtcblx0XHRcdFx0XHRjb2xvci5iICs9IGxpZ2h0Q29sb3IuYiAqIGFtb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlclBhcnRpY2xlICggdjEsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApIHtcblxuXHRcdFx0c2V0T3BhY2l0eSggbWF0ZXJpYWwub3BhY2l0eSApO1xuXHRcdFx0c2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nICk7XG5cblx0XHRcdHZhciB3aWR0aCwgaGVpZ2h0LCBzY2FsZVgsIHNjYWxlWSxcblx0XHRcdGJpdG1hcCwgYml0bWFwV2lkdGgsIGJpdG1hcEhlaWdodDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0XHRcdGJpdG1hcCA9IG1hdGVyaWFsLm1hcC5pbWFnZTtcblx0XHRcdFx0XHRiaXRtYXBXaWR0aCA9IGJpdG1hcC53aWR0aCA+PiAxO1xuXHRcdFx0XHRcdGJpdG1hcEhlaWdodCA9IGJpdG1hcC5oZWlnaHQgPj4gMTtcblxuXHRcdFx0XHRcdHNjYWxlWCA9IGVsZW1lbnQuc2NhbGUueCAqIF9jYW52YXNXaWR0aEhhbGY7XG5cdFx0XHRcdFx0c2NhbGVZID0gZWxlbWVudC5zY2FsZS55ICogX2NhbnZhc0hlaWdodEhhbGY7XG5cblx0XHRcdFx0XHR3aWR0aCA9IHNjYWxlWCAqIGJpdG1hcFdpZHRoO1xuXHRcdFx0XHRcdGhlaWdodCA9IHNjYWxlWSAqIGJpdG1hcEhlaWdodDtcblxuXHRcdFx0XHRcdC8vIFRPRE86IFJvdGF0aW9ucyBicmVhayB0aGlzLi4uXG5cblx0XHRcdFx0XHRfYmJveFJlY3Quc2V0KCB2MS54IC0gd2lkdGgsIHYxLnkgLSBoZWlnaHQsIHYxLnggICsgd2lkdGgsIHYxLnkgKyBoZWlnaHQgKTtcblxuXHRcdFx0XHRcdGlmICggIV9jbGlwUmVjdC5pbnRlcnNlY3RzKCBfYmJveFJlY3QgKSApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2NvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRcdF9jb250ZXh0LnRyYW5zbGF0ZSggdjEueCwgdjEueSApO1xuXHRcdFx0XHRcdF9jb250ZXh0LnJvdGF0ZSggLSBlbGVtZW50LnJvdGF0aW9uICk7XG5cdFx0XHRcdFx0X2NvbnRleHQuc2NhbGUoIHNjYWxlWCwgLSBzY2FsZVkgKTtcblxuXHRcdFx0XHRcdF9jb250ZXh0LnRyYW5zbGF0ZSggLSBiaXRtYXBXaWR0aCwgLSBiaXRtYXBIZWlnaHQgKTtcblx0XHRcdFx0XHRfY29udGV4dC5kcmF3SW1hZ2UoIGJpdG1hcCwgMCwgMCApO1xuXG5cdFx0XHRcdFx0X2NvbnRleHQucmVzdG9yZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBERUJVR1xuXHRcdFx0XHRfY29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdFx0X2NvbnRleHQubW92ZVRvKCB2MS54IC0gMTAsIHYxLnkgKTtcblx0XHRcdFx0X2NvbnRleHQubGluZVRvKCB2MS54ICsgMTAsIHYxLnkgKTtcblx0XHRcdFx0X2NvbnRleHQubW92ZVRvKCB2MS54LCB2MS55IC0gMTAgKTtcblx0XHRcdFx0X2NvbnRleHQubGluZVRvKCB2MS54LCB2MS55ICsgMTAgKTtcblx0XHRcdFx0X2NvbnRleHQuY2xvc2VQYXRoKCk7XG5cdFx0XHRcdF9jb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYigyNTUsMjU1LDApJztcblx0XHRcdFx0X2NvbnRleHQuc3Ryb2tlKCk7XG5cdFx0XHRcdCovXG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHR3aWR0aCA9IGVsZW1lbnQuc2NhbGUueCAqIF9jYW52YXNXaWR0aEhhbGY7XG5cdFx0XHRcdGhlaWdodCA9IGVsZW1lbnQuc2NhbGUueSAqIF9jYW52YXNIZWlnaHRIYWxmO1xuXG5cdFx0XHRcdF9iYm94UmVjdC5zZXQoIHYxLnggLSB3aWR0aCwgdjEueSAtIGhlaWdodCwgdjEueCArIHdpZHRoLCB2MS55ICsgaGVpZ2h0ICk7XG5cblx0XHRcdFx0aWYgKCAhX2NsaXBSZWN0LmludGVyc2VjdHMoIF9iYm94UmVjdCApICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXRTdHJva2VTdHlsZSggbWF0ZXJpYWwuY29sb3IuZ2V0Q29udGV4dFN0eWxlKCkgKTtcblx0XHRcdFx0c2V0RmlsbFN0eWxlKCBtYXRlcmlhbC5jb2xvci5nZXRDb250ZXh0U3R5bGUoKSApO1xuXG5cdFx0XHRcdF9jb250ZXh0LnNhdmUoKTtcblx0XHRcdFx0X2NvbnRleHQudHJhbnNsYXRlKCB2MS54LCB2MS55ICk7XG5cdFx0XHRcdF9jb250ZXh0LnJvdGF0ZSggLSBlbGVtZW50LnJvdGF0aW9uICk7XG5cdFx0XHRcdF9jb250ZXh0LnNjYWxlKCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdFx0bWF0ZXJpYWwucHJvZ3JhbSggX2NvbnRleHQgKTtcblxuXHRcdFx0XHRfY29udGV4dC5yZXN0b3JlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlckxpbmUoIHYxLCB2MiwgZWxlbWVudCwgbWF0ZXJpYWwsIHNjZW5lICkge1xuXG5cdFx0XHRzZXRPcGFjaXR5KCBtYXRlcmlhbC5vcGFjaXR5ICk7XG5cdFx0XHRzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcgKTtcblxuXHRcdFx0X2NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRfY29udGV4dC5tb3ZlVG8oIHYxLnBvc2l0aW9uU2NyZWVuLngsIHYxLnBvc2l0aW9uU2NyZWVuLnkgKTtcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggdjIucG9zaXRpb25TY3JlZW4ueCwgdjIucG9zaXRpb25TY3JlZW4ueSApO1xuXHRcdFx0X2NvbnRleHQuY2xvc2VQYXRoKCk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xuXHRcdFx0XHRzZXRMaW5lQ2FwKCBtYXRlcmlhbC5saW5lY2FwICk7XG5cdFx0XHRcdHNldExpbmVKb2luKCBtYXRlcmlhbC5saW5lam9pbiApO1xuXHRcdFx0XHRzZXRTdHJva2VTdHlsZSggbWF0ZXJpYWwuY29sb3IuZ2V0Q29udGV4dFN0eWxlKCkgKTtcblxuXHRcdFx0XHRfY29udGV4dC5zdHJva2UoKTtcblx0XHRcdFx0X2Jib3hSZWN0LmluZmxhdGUoIG1hdGVyaWFsLmxpbmV3aWR0aCAqIDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyRmFjZTMoIHYxLCB2MiwgdjMsIHV2MSwgdXYyLCB1djMsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApIHtcblxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gMztcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICsrO1xuXG5cdFx0XHRzZXRPcGFjaXR5KCBtYXRlcmlhbC5vcGFjaXR5ICk7XG5cdFx0XHRzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcgKTtcblxuXHRcdFx0X3YxeCA9IHYxLnBvc2l0aW9uU2NyZWVuLng7IF92MXkgPSB2MS5wb3NpdGlvblNjcmVlbi55O1xuXHRcdFx0X3YyeCA9IHYyLnBvc2l0aW9uU2NyZWVuLng7IF92MnkgPSB2Mi5wb3NpdGlvblNjcmVlbi55O1xuXHRcdFx0X3YzeCA9IHYzLnBvc2l0aW9uU2NyZWVuLng7IF92M3kgPSB2My5wb3NpdGlvblNjcmVlbi55O1xuXG5cdFx0XHRkcmF3VHJpYW5nbGUoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3kgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwLyogJiYgIW1hdGVyaWFsLndpcmVmcmFtZSovICkge1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAubWFwcGluZyBpbnN0YW5jZW9mIFRIUkVFLlVWTWFwcGluZyApIHtcblxuXHRcdFx0XHRcdFx0X3V2cyA9IGVsZW1lbnQudXZzWyAwIF07XG5cdFx0XHRcdFx0XHRwYXR0ZXJuUGF0aCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3V2c1sgdXYxIF0udSwgX3V2c1sgdXYxIF0udiwgX3V2c1sgdXYyIF0udSwgX3V2c1sgdXYyIF0udiwgX3V2c1sgdXYzIF0udSwgX3V2c1sgdXYzIF0udiwgbWF0ZXJpYWwubWFwICk7XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nIGluc3RhbmNlb2YgVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjYW1lcmFNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5jb3B5KCBlbGVtZW50LnZlcnRleE5vcm1hbHNXb3JsZFsgdXYxIF0gKTtcblx0XHRcdFx0XHRcdF91djF4ID0gKCBfdmVjdG9yMy54ICogY2FtZXJhTWF0cml4Lm4xMSArIF92ZWN0b3IzLnkgKiBjYW1lcmFNYXRyaXgubjEyICsgX3ZlY3RvcjMueiAqIGNhbWVyYU1hdHJpeC5uMTMgKSAqIDAuNSArIDAuNTtcblx0XHRcdFx0XHRcdF91djF5ID0gLSAoIF92ZWN0b3IzLnggKiBjYW1lcmFNYXRyaXgubjIxICsgX3ZlY3RvcjMueSAqIGNhbWVyYU1hdHJpeC5uMjIgKyBfdmVjdG9yMy56ICogY2FtZXJhTWF0cml4Lm4yMyApICogMC41ICsgMC41O1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5jb3B5KCBlbGVtZW50LnZlcnRleE5vcm1hbHNXb3JsZFsgdXYyIF0gKTtcblx0XHRcdFx0XHRcdF91djJ4ID0gKCBfdmVjdG9yMy54ICogY2FtZXJhTWF0cml4Lm4xMSArIF92ZWN0b3IzLnkgKiBjYW1lcmFNYXRyaXgubjEyICsgX3ZlY3RvcjMueiAqIGNhbWVyYU1hdHJpeC5uMTMgKSAqIDAuNSArIDAuNTtcblx0XHRcdFx0XHRcdF91djJ5ID0gLSAoIF92ZWN0b3IzLnggKiBjYW1lcmFNYXRyaXgubjIxICsgX3ZlY3RvcjMueSAqIGNhbWVyYU1hdHJpeC5uMjIgKyBfdmVjdG9yMy56ICogY2FtZXJhTWF0cml4Lm4yMyApICogMC41ICsgMC41O1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5jb3B5KCBlbGVtZW50LnZlcnRleE5vcm1hbHNXb3JsZFsgdXYzIF0gKTtcblx0XHRcdFx0XHRcdF91djN4ID0gKCBfdmVjdG9yMy54ICogY2FtZXJhTWF0cml4Lm4xMSArIF92ZWN0b3IzLnkgKiBjYW1lcmFNYXRyaXgubjEyICsgX3ZlY3RvcjMueiAqIGNhbWVyYU1hdHJpeC5uMTMgKSAqIDAuNSArIDAuNTtcblx0XHRcdFx0XHRcdF91djN5ID0gLSAoIF92ZWN0b3IzLnggKiBjYW1lcmFNYXRyaXgubjIxICsgX3ZlY3RvcjMueSAqIGNhbWVyYU1hdHJpeC5uMjIgKyBfdmVjdG9yMy56ICogY2FtZXJhTWF0cml4Lm4yMyApICogMC41ICsgMC41O1xuXG5cdFx0XHRcdFx0XHRwYXR0ZXJuUGF0aCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3V2MXgsIF91djF5LCBfdXYyeCwgX3V2MnksIF91djN4LCBfdXYzeSwgbWF0ZXJpYWwuZW52TWFwICk7XG5cblx0XHRcdFx0XHR9LyogZWxzZSBpZiAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nID09IFRIUkVFLlNwaGVyaWNhbFJlZnJhY3Rpb25NYXBwaW5nICkge1xuXG5cdFx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdH0qL1xuXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLndpcmVmcmFtZSA/IHN0cm9rZVBhdGgoIG1hdGVyaWFsLmNvbG9yLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGgsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luICkgOiBmaWxsUGF0aCggbWF0ZXJpYWwuY29sb3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCAmJiAhbWF0ZXJpYWwud2lyZWZyYW1lICkge1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAubWFwcGluZyBpbnN0YW5jZW9mIFRIUkVFLlVWTWFwcGluZyApIHtcblxuXHRcdFx0XHRcdFx0X3V2cyA9IGVsZW1lbnQudXZzWyAwIF07XG5cdFx0XHRcdFx0XHRwYXR0ZXJuUGF0aCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3V2c1sgdXYxIF0udSwgX3V2c1sgdXYxIF0udiwgX3V2c1sgdXYyIF0udSwgX3V2c1sgdXYyIF0udiwgX3V2c1sgdXYzIF0udSwgX3V2c1sgdXYzIF0udiwgbWF0ZXJpYWwubWFwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZXRCbGVuZGluZyggVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIF9lbmFibGVMaWdodGluZyApIHtcblxuXHRcdFx0XHRcdGlmICggIW1hdGVyaWFsLndpcmVmcmFtZSAmJiBtYXRlcmlhbC5zaGFkaW5nID09IFRIUkVFLlNtb290aFNoYWRpbmcgJiYgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzV29ybGQubGVuZ3RoID09IDMgKSB7XG5cblx0XHRcdFx0XHRcdF9jb2xvcjEuciA9IF9jb2xvcjIuciA9IF9jb2xvcjMuciA9IF9hbWJpZW50TGlnaHQucjtcblx0XHRcdFx0XHRcdF9jb2xvcjEuZyA9IF9jb2xvcjIuZyA9IF9jb2xvcjMuZyA9IF9hbWJpZW50TGlnaHQuZztcblx0XHRcdFx0XHRcdF9jb2xvcjEuYiA9IF9jb2xvcjIuYiA9IF9jb2xvcjMuYiA9IF9hbWJpZW50TGlnaHQuYjtcblxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIF9saWdodHMsIGVsZW1lbnQudjEucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzV29ybGRbIDAgXSwgX2NvbG9yMSApO1xuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIF9saWdodHMsIGVsZW1lbnQudjIucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzV29ybGRbIDEgXSwgX2NvbG9yMiApO1xuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIF9saWdodHMsIGVsZW1lbnQudjMucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzV29ybGRbIDIgXSwgX2NvbG9yMyApO1xuXG5cdFx0XHRcdFx0XHRfY29sb3IxLnIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLnIgKiBfY29sb3IxLnIsIDEgKSApO1xuXHRcdFx0XHRcdFx0X2NvbG9yMS5nID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5nICogX2NvbG9yMS5nLCAxICkgKTtcblx0XHRcdFx0XHRcdF9jb2xvcjEuYiA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuYiAqIF9jb2xvcjEuYiwgMSApICk7XG5cblx0XHRcdFx0XHRcdF9jb2xvcjIuciA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuciAqIF9jb2xvcjIuciwgMSApICk7XG5cdFx0XHRcdFx0XHRfY29sb3IyLmcgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLmcgKiBfY29sb3IyLmcsIDEgKSApO1xuXHRcdFx0XHRcdFx0X2NvbG9yMi5iID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5iICogX2NvbG9yMi5iLCAxICkgKTtcblxuXHRcdFx0XHRcdFx0X2NvbG9yMy5yID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5yICogX2NvbG9yMy5yLCAxICkgKTtcblx0XHRcdFx0XHRcdF9jb2xvcjMuZyA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuZyAqIF9jb2xvcjMuZywgMSApICk7XG5cdFx0XHRcdFx0XHRfY29sb3IzLmIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLmIgKiBfY29sb3IzLmIsIDEgKSApO1xuXG5cdFx0XHRcdFx0XHRfY29sb3I0LnIgPSAoIF9jb2xvcjIuciArIF9jb2xvcjMuciApICogMC41O1xuXHRcdFx0XHRcdFx0X2NvbG9yNC5nID0gKCBfY29sb3IyLmcgKyBfY29sb3IzLmcgKSAqIDAuNTtcblx0XHRcdFx0XHRcdF9jb2xvcjQuYiA9ICggX2NvbG9yMi5iICsgX2NvbG9yMy5iICkgKiAwLjU7XG5cblx0XHRcdFx0XHRcdF9pbWFnZSA9IGdldEdyYWRpZW50VGV4dHVyZSggX2NvbG9yMSwgX2NvbG9yMiwgX2NvbG9yMywgX2NvbG9yNCApO1xuXG5cdFx0XHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X2NvbG9yLnIgPSBfYW1iaWVudExpZ2h0LnI7XG5cdFx0XHRcdFx0XHRfY29sb3IuZyA9IF9hbWJpZW50TGlnaHQuZztcblx0XHRcdFx0XHRcdF9jb2xvci5iID0gX2FtYmllbnRMaWdodC5iO1xuXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVMaWdodCggX2xpZ2h0cywgZWxlbWVudC5jZW50cm9pZFdvcmxkLCBlbGVtZW50Lm5vcm1hbFdvcmxkLCBfY29sb3IgKTtcblxuXHRcdFx0XHRcdFx0X2NvbG9yLnIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLnIgKiBfY29sb3IuciwgMSApICk7XG5cdFx0XHRcdFx0XHRfY29sb3IuZyA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuZyAqIF9jb2xvci5nLCAxICkgKTtcblx0XHRcdFx0XHRcdF9jb2xvci5iID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5iICogX2NvbG9yLmIsIDEgKSApO1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPyBzdHJva2VQYXRoKCBfY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKSA6IGZpbGxQYXRoKCBfY29sb3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID8gc3Ryb2tlUGF0aCggbWF0ZXJpYWwuY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKSA6IGZpbGxQYXRoKCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRfbmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0XHRfZmFyID0gY2FtZXJhLmZhcjtcblxuXHRcdFx0XHRfY29sb3IxLnIgPSBfY29sb3IxLmcgPSBfY29sb3IxLmIgPSAxIC0gc21vb3Roc3RlcCggdjEucG9zaXRpb25TY3JlZW4ueiwgX25lYXIsIF9mYXIgKTtcblx0XHRcdFx0X2NvbG9yMi5yID0gX2NvbG9yMi5nID0gX2NvbG9yMi5iID0gMSAtIHNtb290aHN0ZXAoIHYyLnBvc2l0aW9uU2NyZWVuLnosIF9uZWFyLCBfZmFyICk7XG5cdFx0XHRcdF9jb2xvcjMuciA9IF9jb2xvcjMuZyA9IF9jb2xvcjMuYiA9IDEgLSBzbW9vdGhzdGVwKCB2My5wb3NpdGlvblNjcmVlbi56LCBfbmVhciwgX2ZhciApO1xuXG5cdFx0XHRcdF9jb2xvcjQuciA9ICggX2NvbG9yMi5yICsgX2NvbG9yMy5yICkgKiAwLjU7XG5cdFx0XHRcdF9jb2xvcjQuZyA9ICggX2NvbG9yMi5nICsgX2NvbG9yMy5nICkgKiAwLjU7XG5cdFx0XHRcdF9jb2xvcjQuYiA9ICggX2NvbG9yMi5iICsgX2NvbG9yMy5iICkgKiAwLjU7XG5cblx0XHRcdFx0X2ltYWdlID0gZ2V0R3JhZGllbnRUZXh0dXJlKCBfY29sb3IxLCBfY29sb3IyLCBfY29sb3IzLCBfY29sb3I0ICk7XG5cblx0XHRcdFx0Y2xpcEltYWdlKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCAwLCAwLCAxLCAwLCAwLCAxLCBfaW1hZ2UgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0X2NvbG9yLnIgPSBub3JtYWxUb0NvbXBvbmVudCggZWxlbWVudC5ub3JtYWxXb3JsZC54ICk7XG5cdFx0XHRcdF9jb2xvci5nID0gbm9ybWFsVG9Db21wb25lbnQoIGVsZW1lbnQubm9ybWFsV29ybGQueSApO1xuXHRcdFx0XHRfY29sb3IuYiA9IG5vcm1hbFRvQ29tcG9uZW50KCBlbGVtZW50Lm5vcm1hbFdvcmxkLnogKTtcblxuXHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPyBzdHJva2VQYXRoKCBfY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKSA6IGZpbGxQYXRoKCBfY29sb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyRmFjZTQoIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApIHtcblxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gNDtcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICsrO1xuXG5cdFx0XHRzZXRPcGFjaXR5KCBtYXRlcmlhbC5vcGFjaXR5ICk7XG5cdFx0XHRzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgfHwgbWF0ZXJpYWwuZW52TWFwICkge1xuXG5cdFx0XHRcdC8vIExldCByZW5kZXJGYWNlMygpIGhhbmRsZSB0aGlzXG5cblx0XHRcdFx0cmVuZGVyRmFjZTMoIHYxLCB2MiwgdjQsIDAsIDEsIDMsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApO1xuXHRcdFx0XHRyZW5kZXJGYWNlMyggdjUsIHYzLCB2NiwgMSwgMiwgMywgZWxlbWVudCwgbWF0ZXJpYWwsIHNjZW5lICk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdF92MXggPSB2MS5wb3NpdGlvblNjcmVlbi54OyBfdjF5ID0gdjEucG9zaXRpb25TY3JlZW4ueTtcblx0XHRcdF92MnggPSB2Mi5wb3NpdGlvblNjcmVlbi54OyBfdjJ5ID0gdjIucG9zaXRpb25TY3JlZW4ueTtcblx0XHRcdF92M3ggPSB2My5wb3NpdGlvblNjcmVlbi54OyBfdjN5ID0gdjMucG9zaXRpb25TY3JlZW4ueTtcblx0XHRcdF92NHggPSB2NC5wb3NpdGlvblNjcmVlbi54OyBfdjR5ID0gdjQucG9zaXRpb25TY3JlZW4ueTtcblx0XHRcdF92NXggPSB2NS5wb3NpdGlvblNjcmVlbi54OyBfdjV5ID0gdjUucG9zaXRpb25TY3JlZW4ueTtcblx0XHRcdF92NnggPSB2Ni5wb3NpdGlvblNjcmVlbi54OyBfdjZ5ID0gdjYucG9zaXRpb25TY3JlZW4ueTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRcdGRyYXdRdWFkKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCBfdjR4LCBfdjR5ICk7XG5cblx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID8gc3Ryb2tlUGF0aCggbWF0ZXJpYWwuY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKSA6IGZpbGxQYXRoKCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0aWYgKCBfZW5hYmxlTGlnaHRpbmcgKSB7XG5cblx0XHRcdFx0XHRpZiAoICFtYXRlcmlhbC53aXJlZnJhbWUgJiYgbWF0ZXJpYWwuc2hhZGluZyA9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICYmIGVsZW1lbnQudmVydGV4Tm9ybWFsc1dvcmxkLmxlbmd0aCA9PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRfY29sb3IxLnIgPSBfY29sb3IyLnIgPSBfY29sb3IzLnIgPSBfY29sb3I0LnIgPSBfYW1iaWVudExpZ2h0LnI7XG5cdFx0XHRcdFx0XHRfY29sb3IxLmcgPSBfY29sb3IyLmcgPSBfY29sb3IzLmcgPSBfY29sb3I0LmcgPSBfYW1iaWVudExpZ2h0Lmc7XG5cdFx0XHRcdFx0XHRfY29sb3IxLmIgPSBfY29sb3IyLmIgPSBfY29sb3IzLmIgPSBfY29sb3I0LmIgPSBfYW1iaWVudExpZ2h0LmI7XG5cblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBfbGlnaHRzLCBlbGVtZW50LnYxLnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc1dvcmxkWyAwIF0sIF9jb2xvcjEgKTtcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBfbGlnaHRzLCBlbGVtZW50LnYyLnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc1dvcmxkWyAxIF0sIF9jb2xvcjIgKTtcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBfbGlnaHRzLCBlbGVtZW50LnY0LnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc1dvcmxkWyAzIF0sIF9jb2xvcjMgKTtcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBfbGlnaHRzLCBlbGVtZW50LnYzLnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc1dvcmxkWyAyIF0sIF9jb2xvcjQgKTtcblxuXHRcdFx0XHRcdFx0X2NvbG9yMS5yID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5yICogX2NvbG9yMS5yLCAxICkgKTtcblx0XHRcdFx0XHRcdF9jb2xvcjEuZyA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuZyAqIF9jb2xvcjEuZywgMSApICk7XG5cdFx0XHRcdFx0XHRfY29sb3IxLmIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLmIgKiBfY29sb3IxLmIsIDEgKSApO1xuXG5cdFx0XHRcdFx0XHRfY29sb3IyLnIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLnIgKiBfY29sb3IyLnIsIDEgKSApO1xuXHRcdFx0XHRcdFx0X2NvbG9yMi5nID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5nICogX2NvbG9yMi5nLCAxICkgKTtcblx0XHRcdFx0XHRcdF9jb2xvcjIuYiA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuYiAqIF9jb2xvcjIuYiwgMSApICk7XG5cblx0XHRcdFx0XHRcdF9jb2xvcjMuciA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuciAqIF9jb2xvcjMuciwgMSApICk7XG5cdFx0XHRcdFx0XHRfY29sb3IzLmcgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLmcgKiBfY29sb3IzLmcsIDEgKSApO1xuXHRcdFx0XHRcdFx0X2NvbG9yMy5iID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5iICogX2NvbG9yMy5iLCAxICkgKTtcblxuXHRcdFx0XHRcdFx0X2NvbG9yNC5yID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5yICogX2NvbG9yNC5yLCAxICkgKTtcblx0XHRcdFx0XHRcdF9jb2xvcjQuZyA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuZyAqIF9jb2xvcjQuZywgMSApICk7XG5cdFx0XHRcdFx0XHRfY29sb3I0LmIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLmIgKiBfY29sb3I0LmIsIDEgKSApO1xuXG5cdFx0XHRcdFx0XHRfaW1hZ2UgPSBnZXRHcmFkaWVudFRleHR1cmUoIF9jb2xvcjEsIF9jb2xvcjIsIF9jb2xvcjMsIF9jb2xvcjQgKTtcblxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogVVZzIGFyZSBpbmNvcnJlY3QsIHY0LT52Mz9cblxuXHRcdFx0XHRcdFx0ZHJhd1RyaWFuZ2xlKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjR4LCBfdjR5ICk7XG5cdFx0XHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92NHgsIF92NHksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xuXG5cdFx0XHRcdFx0XHRkcmF3VHJpYW5nbGUoIF92NXgsIF92NXksIF92M3gsIF92M3ksIF92NngsIF92NnkgKTtcblx0XHRcdFx0XHRcdGNsaXBJbWFnZSggX3Y1eCwgX3Y1eSwgX3YzeCwgX3YzeSwgX3Y2eCwgX3Y2eSwgMSwgMCwgMSwgMSwgMCwgMSwgX2ltYWdlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRfY29sb3IuciA9IF9hbWJpZW50TGlnaHQucjtcblx0XHRcdFx0XHRcdF9jb2xvci5nID0gX2FtYmllbnRMaWdodC5nO1xuXHRcdFx0XHRcdFx0X2NvbG9yLmIgPSBfYW1iaWVudExpZ2h0LmI7XG5cblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBfbGlnaHRzLCBlbGVtZW50LmNlbnRyb2lkV29ybGQsIGVsZW1lbnQubm9ybWFsV29ybGQsIF9jb2xvciApO1xuXG5cdFx0XHRcdFx0XHRfY29sb3IuciA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuciAqIF9jb2xvci5yLCAxICkgKTtcblx0XHRcdFx0XHRcdF9jb2xvci5nID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5nICogX2NvbG9yLmcsIDEgKSApO1xuXHRcdFx0XHRcdFx0X2NvbG9yLmIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLmIgKiBfY29sb3IuYiwgMSApICk7XG5cblx0XHRcdFx0XHRcdGRyYXdRdWFkKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCBfdjR4LCBfdjR5ICk7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsLndpcmVmcmFtZSA/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApIDogZmlsbFBhdGgoIF9jb2xvciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRkcmF3UXVhZCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3Y0eCwgX3Y0eSApO1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID8gc3Ryb2tlUGF0aCggbWF0ZXJpYWwuY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKSA6IGZpbGxQYXRoKCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0X2NvbG9yLnIgPSBub3JtYWxUb0NvbXBvbmVudCggZWxlbWVudC5ub3JtYWxXb3JsZC54ICk7XG5cdFx0XHRcdF9jb2xvci5nID0gbm9ybWFsVG9Db21wb25lbnQoIGVsZW1lbnQubm9ybWFsV29ybGQueSApO1xuXHRcdFx0XHRfY29sb3IuYiA9IG5vcm1hbFRvQ29tcG9uZW50KCBlbGVtZW50Lm5vcm1hbFdvcmxkLnogKTtcblxuXHRcdFx0XHRkcmF3UXVhZCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3Y0eCwgX3Y0eSApO1xuXG5cdFx0XHRcdG1hdGVyaWFsLndpcmVmcmFtZSA/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApIDogZmlsbFBhdGgoIF9jb2xvciApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdF9uZWFyID0gY2FtZXJhLm5lYXI7XG5cdFx0XHRcdF9mYXIgPSBjYW1lcmEuZmFyO1xuXG5cdFx0XHRcdF9jb2xvcjEuciA9IF9jb2xvcjEuZyA9IF9jb2xvcjEuYiA9IDEgLSBzbW9vdGhzdGVwKCB2MS5wb3NpdGlvblNjcmVlbi56LCBfbmVhciwgX2ZhciApO1xuXHRcdFx0XHRfY29sb3IyLnIgPSBfY29sb3IyLmcgPSBfY29sb3IyLmIgPSAxIC0gc21vb3Roc3RlcCggdjIucG9zaXRpb25TY3JlZW4ueiwgX25lYXIsIF9mYXIgKTtcblx0XHRcdFx0X2NvbG9yMy5yID0gX2NvbG9yMy5nID0gX2NvbG9yMy5iID0gMSAtIHNtb290aHN0ZXAoIHY0LnBvc2l0aW9uU2NyZWVuLnosIF9uZWFyLCBfZmFyICk7XG5cdFx0XHRcdF9jb2xvcjQuciA9IF9jb2xvcjQuZyA9IF9jb2xvcjQuYiA9IDEgLSBzbW9vdGhzdGVwKCB2My5wb3NpdGlvblNjcmVlbi56LCBfbmVhciwgX2ZhciApO1xuXG5cdFx0XHRcdF9pbWFnZSA9IGdldEdyYWRpZW50VGV4dHVyZSggX2NvbG9yMSwgX2NvbG9yMiwgX2NvbG9yMywgX2NvbG9yNCApO1xuXG5cdFx0XHRcdC8vIFRPRE86IFVWcyBhcmUgaW5jb3JyZWN0LCB2NC0+djM/XG5cblx0XHRcdFx0ZHJhd1RyaWFuZ2xlKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjR4LCBfdjR5ICk7XG5cdFx0XHRcdGNsaXBJbWFnZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3Y0eCwgX3Y0eSwgMCwgMCwgMSwgMCwgMCwgMSwgX2ltYWdlICk7XG5cblx0XHRcdFx0ZHJhd1RyaWFuZ2xlKCBfdjV4LCBfdjV5LCBfdjN4LCBfdjN5LCBfdjZ4LCBfdjZ5ICk7XG5cdFx0XHRcdGNsaXBJbWFnZSggX3Y1eCwgX3Y1eSwgX3YzeCwgX3YzeSwgX3Y2eCwgX3Y2eSwgMSwgMCwgMSwgMSwgMCwgMSwgX2ltYWdlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBkcmF3VHJpYW5nbGUoIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIgKSB7XG5cblx0XHRcdF9jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0X2NvbnRleHQubW92ZVRvKCB4MCwgeTAgKTtcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggeDEsIHkxICk7XG5cdFx0XHRfY29udGV4dC5saW5lVG8oIHgyLCB5MiApO1xuXHRcdFx0X2NvbnRleHQubGluZVRvKCB4MCwgeTAgKTtcblx0XHRcdF9jb250ZXh0LmNsb3NlUGF0aCgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZHJhd1F1YWQoIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyApIHtcblxuXHRcdFx0X2NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRfY29udGV4dC5tb3ZlVG8oIHgwLCB5MCApO1xuXHRcdFx0X2NvbnRleHQubGluZVRvKCB4MSwgeTEgKTtcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggeDIsIHkyICk7XG5cdFx0XHRfY29udGV4dC5saW5lVG8oIHgzLCB5MyApO1xuXHRcdFx0X2NvbnRleHQubGluZVRvKCB4MCwgeTAgKTtcblx0XHRcdF9jb250ZXh0LmNsb3NlUGF0aCgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3Ryb2tlUGF0aCggY29sb3IsIGxpbmV3aWR0aCwgbGluZWNhcCwgbGluZWpvaW4gKSB7XG5cblx0XHRcdHNldExpbmVXaWR0aCggbGluZXdpZHRoICk7XG5cdFx0XHRzZXRMaW5lQ2FwKCBsaW5lY2FwICk7XG5cdFx0XHRzZXRMaW5lSm9pbiggbGluZWpvaW4gKTtcblx0XHRcdHNldFN0cm9rZVN0eWxlKCBjb2xvci5nZXRDb250ZXh0U3R5bGUoKSApO1xuXG5cdFx0XHRfY29udGV4dC5zdHJva2UoKTtcblxuXHRcdFx0X2Jib3hSZWN0LmluZmxhdGUoIGxpbmV3aWR0aCAqIDIgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbGxQYXRoKCBjb2xvciApIHtcblxuXHRcdFx0c2V0RmlsbFN0eWxlKCBjb2xvci5nZXRDb250ZXh0U3R5bGUoKSApO1xuXHRcdFx0X2NvbnRleHQuZmlsbCgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGF0dGVyblBhdGgoIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHUwLCB2MCwgdTEsIHYxLCB1MiwgdjIsIHRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZS5pbWFnZS53aWR0aCA9PSAwICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUubmVlZHNVcGRhdGUgPT0gdHJ1ZSB8fCBfcGF0dGVybnNbIHRleHR1cmUuaWQgXSA9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIHJlcGVhdFggPSB0ZXh0dXJlLndyYXBTID09IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0XHR2YXIgcmVwZWF0WSA9IHRleHR1cmUud3JhcFQgPT0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0X3BhdHRlcm5zWyB0ZXh0dXJlLmlkIF0gPSBfY29udGV4dC5jcmVhdGVQYXR0ZXJuKCB0ZXh0dXJlLmltYWdlLCByZXBlYXRYICYmIHJlcGVhdFkgPyAncmVwZWF0JyA6IHJlcGVhdFggJiYgIXJlcGVhdFkgPyAncmVwZWF0LXgnIDogIXJlcGVhdFggJiYgcmVwZWF0WSA/ICdyZXBlYXQteScgOiAnbm8tcmVwZWF0JyApO1xuXG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzZXRGaWxsU3R5bGUoIF9wYXR0ZXJuc1sgdGV4dHVyZS5pZCBdICk7XG5cblx0XHRcdC8vIGh0dHA6Ly9leHRyZW1lbHlzYXRpc2ZhY3Rvcnl0b3RhbGl0YXJpYW5pc20uY29tL2Jsb2cvP3A9MjEyMFxuXG5cdFx0XHR2YXIgYSwgYiwgYywgZCwgZSwgZiwgZGV0LCBpZGV0LFxuXHRcdFx0b2Zmc2V0WCA9IHRleHR1cmUub2Zmc2V0LnggLyB0ZXh0dXJlLnJlcGVhdC54LFxuXHRcdFx0b2Zmc2V0WSA9IHRleHR1cmUub2Zmc2V0LnkgLyB0ZXh0dXJlLnJlcGVhdC55LFxuXHRcdFx0d2lkdGggPSB0ZXh0dXJlLmltYWdlLndpZHRoICogdGV4dHVyZS5yZXBlYXQueCxcblx0XHRcdGhlaWdodCA9IHRleHR1cmUuaW1hZ2UuaGVpZ2h0ICogdGV4dHVyZS5yZXBlYXQueTtcblxuXHRcdFx0dTAgPSAoIHUwICsgb2Zmc2V0WCApICogd2lkdGg7XG5cdFx0XHR2MCA9ICggdjAgKyBvZmZzZXRZICkgKiBoZWlnaHQ7XG5cblx0XHRcdHUxID0gKCB1MSArIG9mZnNldFggKSAqIHdpZHRoO1xuXHRcdFx0djEgPSAoIHYxICsgb2Zmc2V0WSApICogaGVpZ2h0O1xuXG5cdFx0XHR1MiA9ICggdTIgKyBvZmZzZXRYICkgKiB3aWR0aDtcblx0XHRcdHYyID0gKCB2MiArIG9mZnNldFkgKSAqIGhlaWdodDtcblxuXHRcdFx0eDEgLT0geDA7IHkxIC09IHkwO1xuXHRcdFx0eDIgLT0geDA7IHkyIC09IHkwO1xuXG5cdFx0XHR1MSAtPSB1MDsgdjEgLT0gdjA7XG5cdFx0XHR1MiAtPSB1MDsgdjIgLT0gdjA7XG5cblx0XHRcdGRldCA9IHUxICogdjIgLSB1MiAqIHYxO1xuXG5cdFx0XHRpZiAoIGRldCA9PSAwICkge1xuXG5cdFx0XHRcdGlmICggX2ltYWdlZGF0YXNbIHRleHR1cmUuaWQgXSA9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKVxuXHRcdFx0XHRcdGNhbnZhcy53aWR0aCA9IHRleHR1cmUuaW1hZ2Uud2lkdGg7XG5cdFx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IHRleHR1cmUuaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0XHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCB0ZXh0dXJlLmltYWdlLCAwLCAwICk7XG5cblx0XHRcdFx0XHRfaW1hZ2VkYXRhc1sgdGV4dHVyZS5pZCBdID0gY29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIHRleHR1cmUuaW1hZ2Uud2lkdGgsIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ICkuZGF0YTtcblxuXHRcdFx0XHRcdGRlbGV0ZSBjYW52YXM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRhID0gX2ltYWdlZGF0YXNbIHRleHR1cmUuaWQgXTtcblx0XHRcdFx0dmFyIGluZGV4ID0gKCBNYXRoLmZsb29yKCB1MCApICsgTWF0aC5mbG9vciggdjAgKSAqIHRleHR1cmUuaW1hZ2Uud2lkdGggKSAqIDQ7XG5cblx0XHRcdFx0X2NvbG9yLnNldFJHQiggZGF0YVsgaW5kZXggXSAvIDI1NSwgZGF0YVsgaW5kZXggKyAxIF0gLyAyNTUsIGRhdGFbIGluZGV4ICsgMiBdIC8gMjU1ICk7XG5cdFx0XHRcdGZpbGxQYXRoKCBfY29sb3IgKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWRldCA9IDEgLyBkZXQ7XG5cblx0XHRcdGEgPSAoIHYyICogeDEgLSB2MSAqIHgyICkgKiBpZGV0O1xuXHRcdFx0YiA9ICggdjIgKiB5MSAtIHYxICogeTIgKSAqIGlkZXQ7XG5cdFx0XHRjID0gKCB1MSAqIHgyIC0gdTIgKiB4MSApICogaWRldDtcblx0XHRcdGQgPSAoIHUxICogeTIgLSB1MiAqIHkxICkgKiBpZGV0O1xuXG5cdFx0XHRlID0geDAgLSBhICogdTAgLSBjICogdjA7XG5cdFx0XHRmID0geTAgLSBiICogdTAgLSBkICogdjA7XG5cblx0XHRcdF9jb250ZXh0LnNhdmUoKTtcblx0XHRcdF9jb250ZXh0LnRyYW5zZm9ybSggYSwgYiwgYywgZCwgZSwgZiApO1xuXHRcdFx0X2NvbnRleHQuZmlsbCgpO1xuXHRcdFx0X2NvbnRleHQucmVzdG9yZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2xpcEltYWdlKCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB1MCwgdjAsIHUxLCB2MSwgdTIsIHYyLCBpbWFnZSApIHtcblxuXHRcdFx0Ly8gaHR0cDovL2V4dHJlbWVseXNhdGlzZmFjdG9yeXRvdGFsaXRhcmlhbmlzbS5jb20vYmxvZy8/cD0yMTIwXG5cblx0XHRcdHZhciBhLCBiLCBjLCBkLCBlLCBmLCBkZXQsIGlkZXQsXG5cdFx0XHR3aWR0aCA9IGltYWdlLndpZHRoIC0gMSxcblx0XHRcdGhlaWdodCA9IGltYWdlLmhlaWdodCAtIDE7XG5cblx0XHRcdHUwICo9IHdpZHRoOyB2MCAqPSBoZWlnaHQ7XG5cdFx0XHR1MSAqPSB3aWR0aDsgdjEgKj0gaGVpZ2h0O1xuXHRcdFx0dTIgKj0gd2lkdGg7IHYyICo9IGhlaWdodDtcblxuXHRcdFx0eDEgLT0geDA7IHkxIC09IHkwO1xuXHRcdFx0eDIgLT0geDA7IHkyIC09IHkwO1xuXG5cdFx0XHR1MSAtPSB1MDsgdjEgLT0gdjA7XG5cdFx0XHR1MiAtPSB1MDsgdjIgLT0gdjA7XG5cblx0XHRcdGRldCA9IHUxICogdjIgLSB1MiAqIHYxO1xuXG5cdFx0XHRpZGV0ID0gMSAvIGRldDtcblxuXHRcdFx0YSA9ICggdjIgKiB4MSAtIHYxICogeDIgKSAqIGlkZXQ7XG5cdFx0XHRiID0gKCB2MiAqIHkxIC0gdjEgKiB5MiApICogaWRldDtcblx0XHRcdGMgPSAoIHUxICogeDIgLSB1MiAqIHgxICkgKiBpZGV0O1xuXHRcdFx0ZCA9ICggdTEgKiB5MiAtIHUyICogeTEgKSAqIGlkZXQ7XG5cblx0XHRcdGUgPSB4MCAtIGEgKiB1MCAtIGMgKiB2MDtcblx0XHRcdGYgPSB5MCAtIGIgKiB1MCAtIGQgKiB2MDtcblxuXHRcdFx0X2NvbnRleHQuc2F2ZSgpO1xuXHRcdFx0X2NvbnRleHQudHJhbnNmb3JtKCBhLCBiLCBjLCBkLCBlLCBmICk7XG5cdFx0XHRfY29udGV4dC5jbGlwKCk7XG5cdFx0XHRfY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwICk7XG5cdFx0XHRfY29udGV4dC5yZXN0b3JlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRHcmFkaWVudFRleHR1cmUoIGNvbG9yMSwgY29sb3IyLCBjb2xvcjMsIGNvbG9yNCApIHtcblxuXHRcdFx0Ly8gaHR0cDovL21yZG9vYi5jb20vYmxvZy9wb3N0LzcxMFxuXG5cdFx0XHR2YXIgYzFyID0gfn4gKCBjb2xvcjEuciAqIDI1NSApLCBjMWcgPSB+fiAoIGNvbG9yMS5nICogMjU1ICksIGMxYiA9IH5+ICggY29sb3IxLmIgKiAyNTUgKSxcblx0XHRcdGMyciA9IH5+ICggY29sb3IyLnIgKiAyNTUgKSwgYzJnID0gfn4gKCBjb2xvcjIuZyAqIDI1NSApLCBjMmIgPSB+fiAoIGNvbG9yMi5iICogMjU1ICksXG5cdFx0XHRjM3IgPSB+fiAoIGNvbG9yMy5yICogMjU1ICksIGMzZyA9IH5+ICggY29sb3IzLmcgKiAyNTUgKSwgYzNiID0gfn4gKCBjb2xvcjMuYiAqIDI1NSApLFxuXHRcdFx0YzRyID0gfn4gKCBjb2xvcjQuciAqIDI1NSApLCBjNGcgPSB+fiAoIGNvbG9yNC5nICogMjU1ICksIGM0YiA9IH5+ICggY29sb3I0LmIgKiAyNTUgKTtcblxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgMCBdID0gYzFyIDwgMCA/IDAgOiBjMXIgPiAyNTUgPyAyNTUgOiBjMXI7XG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyAxIF0gPSBjMWcgPCAwID8gMCA6IGMxZyA+IDI1NSA/IDI1NSA6IGMxZztcblx0XHRcdF9waXhlbE1hcERhdGFbIDIgXSA9IGMxYiA8IDAgPyAwIDogYzFiID4gMjU1ID8gMjU1IDogYzFiO1xuXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyA0IF0gPSBjMnIgPCAwID8gMCA6IGMyciA+IDI1NSA/IDI1NSA6IGMycjtcblx0XHRcdF9waXhlbE1hcERhdGFbIDUgXSA9IGMyZyA8IDAgPyAwIDogYzJnID4gMjU1ID8gMjU1IDogYzJnO1xuXHRcdFx0X3BpeGVsTWFwRGF0YVsgNiBdID0gYzJiIDwgMCA/IDAgOiBjMmIgPiAyNTUgPyAyNTUgOiBjMmI7XG5cblx0XHRcdF9waXhlbE1hcERhdGFbIDggXSA9IGMzciA8IDAgPyAwIDogYzNyID4gMjU1ID8gMjU1IDogYzNyO1xuXHRcdFx0X3BpeGVsTWFwRGF0YVsgOSBdID0gYzNnIDwgMCA/IDAgOiBjM2cgPiAyNTUgPyAyNTUgOiBjM2c7XG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyAxMCBdID0gYzNiIDwgMCA/IDAgOiBjM2IgPiAyNTUgPyAyNTUgOiBjM2I7XG5cblx0XHRcdF9waXhlbE1hcERhdGFbIDEyIF0gPSBjNHIgPCAwID8gMCA6IGM0ciA+IDI1NSA/IDI1NSA6IGM0cjtcblx0XHRcdF9waXhlbE1hcERhdGFbIDEzIF0gPSBjNGcgPCAwID8gMCA6IGM0ZyA+IDI1NSA/IDI1NSA6IGM0Zztcblx0XHRcdF9waXhlbE1hcERhdGFbIDE0IF0gPSBjNGIgPCAwID8gMCA6IGM0YiA+IDI1NSA/IDI1NSA6IGM0YjtcblxuXHRcdFx0X3BpeGVsTWFwQ29udGV4dC5wdXRJbWFnZURhdGEoIF9waXhlbE1hcEltYWdlLCAwLCAwICk7XG5cdFx0XHRfZ3JhZGllbnRNYXBDb250ZXh0LmRyYXdJbWFnZSggX3BpeGVsTWFwLCAwLCAwICk7XG5cblx0XHRcdHJldHVybiBfZ3JhZGllbnRNYXA7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzbW9vdGhzdGVwKCB2YWx1ZSwgbWluLCBtYXggKSB7XG5cblx0XHRcdHZhciB4ID0gKCB2YWx1ZSAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblx0XHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub3JtYWxUb0NvbXBvbmVudCggbm9ybWFsICkge1xuXG5cdFx0XHR2YXIgY29tcG9uZW50ID0gKCBub3JtYWwgKyAxICkgKiAwLjU7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50IDwgMCA/IDAgOiAoIGNvbXBvbmVudCA+IDEgPyAxIDogY29tcG9uZW50ICk7XG5cblx0XHR9XG5cblx0XHQvLyBIaWRlIGFudGktYWxpYXMgZ2Fwc1xuXG5cdFx0ZnVuY3Rpb24gZXhwYW5kKCB2MSwgdjIgKSB7XG5cblx0XHRcdHZhciB4ID0gdjIueCAtIHYxLngsIHkgPSAgdjIueSAtIHYxLnksXG5cdFx0XHRkZXQgPSB4ICogeCArIHkgKiB5LCBpZGV0O1xuXG5cdFx0XHRpZiAoIGRldCA9PSAwICkgcmV0dXJuO1xuXG5cdFx0XHRpZGV0ID0gMSAvIE1hdGguc3FydCggZGV0ICk7XG5cblx0XHRcdHggKj0gaWRldDsgeSAqPSBpZGV0O1xuXG5cdFx0XHR2Mi54ICs9IHg7IHYyLnkgKz0geTtcblx0XHRcdHYxLnggLT0geDsgdjEueSAtPSB5O1xuXG5cdFx0fVxuXHR9O1xuXG5cdC8vIENvbnRleHQgY2FjaGVkIG1ldGhvZHMuXG5cblx0ZnVuY3Rpb24gc2V0T3BhY2l0eSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIF9jb250ZXh0R2xvYmFsQWxwaGEgIT0gdmFsdWUgKSB7XG5cblx0XHRcdF9jb250ZXh0Lmdsb2JhbEFscGhhID0gX2NvbnRleHRHbG9iYWxBbHBoYSA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRCbGVuZGluZyggdmFsdWUgKSB7XG5cblx0XHRpZiAoIF9jb250ZXh0R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uICE9IHZhbHVlICkge1xuXG5cdFx0XHRzd2l0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjYXNlIFRIUkVFLk5vcm1hbEJsZW5kaW5nOlxuXG5cdFx0XHRcdFx0X2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuQWRkaXRpdmVCbGVuZGluZzpcblxuXHRcdFx0XHRcdF9jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdsaWdodGVyJztcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZzpcblxuXHRcdFx0XHRcdF9jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkYXJrZXInO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0X2NvbnRleHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB2YWx1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoKCB2YWx1ZSApIHtcblxuXHRcdGlmICggX2NvbnRleHRMaW5lV2lkdGggIT0gdmFsdWUgKSB7XG5cblx0XHRcdF9jb250ZXh0LmxpbmVXaWR0aCA9IF9jb250ZXh0TGluZVdpZHRoID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldExpbmVDYXAoIHZhbHVlICkge1xuXG5cdFx0Ly8gXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIlxuXG5cdFx0aWYgKCBfY29udGV4dExpbmVDYXAgIT0gdmFsdWUgKSB7XG5cblx0XHRcdF9jb250ZXh0LmxpbmVDYXAgPSBfY29udGV4dExpbmVDYXAgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0TGluZUpvaW4oIHZhbHVlICkge1xuXG5cdFx0Ly8gXCJyb3VuZFwiLCBcImJldmVsXCIsIFwibWl0ZXJcIlxuXG5cdFx0aWYgKCBfY29udGV4dExpbmVKb2luICE9IHZhbHVlICkge1xuXG5cdFx0XHRfY29udGV4dC5saW5lSm9pbiA9IF9jb250ZXh0TGluZUpvaW4gPSB2YWx1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U3Ryb2tlU3R5bGUoIHN0eWxlICkge1xuXG5cdFx0aWYgKCBfY29udGV4dFN0cm9rZVN0eWxlICE9IHN0eWxlICkge1xuXG5cdFx0XHRfY29udGV4dC5zdHJva2VTdHlsZSA9IF9jb250ZXh0U3Ryb2tlU3R5bGUgPSBzdHlsZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0RmlsbFN0eWxlKCBzdHlsZSApIHtcblxuXHRcdGlmICggX2NvbnRleHRGaWxsU3R5bGUgIT0gc3R5bGUgKSB7XG5cblx0XHRcdF9jb250ZXh0LmZpbGxTdHlsZSA9IF9jb250ZXh0RmlsbFN0eWxlID0gc3R5bGU7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TVkdSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgX3RoaXMgPSB0aGlzLFxuXHRfcmVuZGVyRGF0YSwgX2VsZW1lbnRzLCBfbGlnaHRzLFxuXHRfcHJvamVjdG9yID0gbmV3IFRIUkVFLlByb2plY3RvcigpLFxuXHRfc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKSxcblx0X3N2Z1dpZHRoLCBfc3ZnSGVpZ2h0LCBfc3ZnV2lkdGhIYWxmLCBfc3ZnSGVpZ2h0SGFsZixcblxuXHRfdjEsIF92MiwgX3YzLCBfdjQsXG5cblx0X2NsaXBSZWN0ID0gbmV3IFRIUkVFLlJlY3RhbmdsZSgpLFxuXHRfYmJveFJlY3QgPSBuZXcgVEhSRUUuUmVjdGFuZ2xlKCksXG5cblx0X2VuYWJsZUxpZ2h0aW5nID0gZmFsc2UsXG5cdF9jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLFxuXHRfYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkNvbG9yKCksXG5cdF9kaXJlY3Rpb25hbExpZ2h0cyA9IG5ldyBUSFJFRS5Db2xvcigpLFxuXHRfcG9pbnRMaWdodHMgPSBuZXcgVEhSRUUuQ29sb3IoKSxcblxuXHRfdywgLy8gei1idWZmZXIgdG8gdy1idWZmZXJcblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCAvLyBOZWVkZWQgZm9yIFBvaW50TGlnaHRcblxuXHRfc3ZnUGF0aFBvb2wgPSBbXSwgX3N2Z0NpcmNsZVBvb2wgPSBbXSwgX3N2Z0xpbmVQb29sID0gW10sXG5cdF9zdmdOb2RlLCBfcGF0aENvdW50LCBfY2lyY2xlQ291bnQsIF9saW5lQ291bnQsXG5cdF9xdWFsaXR5ID0gMTtcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfc3ZnO1xuXG5cdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcblx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XG5cdHRoaXMuc29ydEVsZW1lbnRzID0gdHJ1ZTtcblxuXHR0aGlzLmluZm8gPSB7XG5cblx0XHRyZW5kZXI6IHtcblxuXHRcdFx0dmVydGljZXM6IDAsXG5cdFx0XHRmYWNlczogMFxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLnNldFF1YWxpdHkgPSBmdW5jdGlvbiggcXVhbGl0eSApIHtcblxuXHRcdHN3aXRjaChxdWFsaXR5KSB7XG5cblx0XHRcdGNhc2UgXCJoaWdoXCI6IF9xdWFsaXR5ID0gMTsgYnJlYWs7XG5cdFx0XHRjYXNlIFwibG93XCI6IF9xdWFsaXR5ID0gMDsgYnJlYWs7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiggd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdF9zdmdXaWR0aCA9IHdpZHRoOyBfc3ZnSGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdF9zdmdXaWR0aEhhbGYgPSBfc3ZnV2lkdGggLyAyOyBfc3ZnSGVpZ2h0SGFsZiA9IF9zdmdIZWlnaHQgLyAyO1xuXG5cdFx0X3N2Zy5zZXRBdHRyaWJ1dGUoICd2aWV3Qm94JywgKCAtIF9zdmdXaWR0aEhhbGYgKSArICcgJyArICggLSBfc3ZnSGVpZ2h0SGFsZiApICsgJyAnICsgX3N2Z1dpZHRoICsgJyAnICsgX3N2Z0hlaWdodCApO1xuXHRcdF9zdmcuc2V0QXR0cmlidXRlKCAnd2lkdGgnLCBfc3ZnV2lkdGggKTtcblx0XHRfc3ZnLnNldEF0dHJpYnV0ZSggJ2hlaWdodCcsIF9zdmdIZWlnaHQgKTtcblxuXHRcdF9jbGlwUmVjdC5zZXQoIC0gX3N2Z1dpZHRoSGFsZiwgLSBfc3ZnSGVpZ2h0SGFsZiwgX3N2Z1dpZHRoSGFsZiwgX3N2Z0hlaWdodEhhbGYgKTtcblxuXHR9O1xuXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR3aGlsZSAoIF9zdmcuY2hpbGROb2Rlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRfc3ZnLnJlbW92ZUNoaWxkKCBfc3ZnLmNoaWxkTm9kZXNbIDAgXSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHR2YXIgZSwgZWwsIGVsZW1lbnQsIG1hdGVyaWFsO1xuXG5cdFx0dGhpcy5hdXRvQ2xlYXIgJiYgdGhpcy5jbGVhcigpO1xuXG5cdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgPSAwO1xuXHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzID0gMDtcblxuXHRcdF9yZW5kZXJEYXRhID0gX3Byb2plY3Rvci5wcm9qZWN0U2NlbmUoIHNjZW5lLCBjYW1lcmEsIHRoaXMuc29ydEVsZW1lbnRzICk7XG5cdFx0X2VsZW1lbnRzID0gX3JlbmRlckRhdGEuZWxlbWVudHM7XG5cdFx0X2xpZ2h0cyA9IF9yZW5kZXJEYXRhLmxpZ2h0cztcblxuXHRcdF9wYXRoQ291bnQgPSAwOyBfY2lyY2xlQ291bnQgPSAwOyBfbGluZUNvdW50ID0gMDtcblxuXHRcdF9lbmFibGVMaWdodGluZyA9IF9saWdodHMubGVuZ3RoID4gMDtcblxuXHRcdGlmICggX2VuYWJsZUxpZ2h0aW5nICkge1xuXG5cdFx0XHQgY2FsY3VsYXRlTGlnaHRzKCBfbGlnaHRzICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBlID0gMCwgZWwgPSBfZWxlbWVudHMubGVuZ3RoOyBlIDwgZWw7IGUgKysgKSB7XG5cblx0XHRcdGVsZW1lbnQgPSBfZWxlbWVudHNbIGUgXTtcblxuXHRcdFx0bWF0ZXJpYWwgPSBlbGVtZW50Lm1hdGVyaWFsO1xuXHRcdFx0bWF0ZXJpYWwgPSBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPyBlbGVtZW50LmZhY2VNYXRlcmlhbCA6IG1hdGVyaWFsO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsID09IG51bGwgfHwgbWF0ZXJpYWwub3BhY2l0eSA9PSAwICkgY29udGludWU7XG5cblx0XHRcdF9iYm94UmVjdC5lbXB0eSgpO1xuXG5cdFx0XHRpZiAoIGVsZW1lbnQgaW5zdGFuY2VvZiBUSFJFRS5SZW5kZXJhYmxlUGFydGljbGUgKSB7XG5cblx0XHRcdFx0X3YxID0gZWxlbWVudDtcblx0XHRcdFx0X3YxLnggKj0gX3N2Z1dpZHRoSGFsZjsgX3YxLnkgKj0gLV9zdmdIZWlnaHRIYWxmO1xuXG5cdFx0XHRcdHJlbmRlclBhcnRpY2xlKCBfdjEsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50IGluc3RhbmNlb2YgVEhSRUUuUmVuZGVyYWJsZUxpbmUgKSB7XG5cblx0XHRcdFx0X3YxID0gZWxlbWVudC52MTsgX3YyID0gZWxlbWVudC52MjtcblxuXHRcdFx0XHRfdjEucG9zaXRpb25TY3JlZW4ueCAqPSBfc3ZnV2lkdGhIYWxmOyBfdjEucG9zaXRpb25TY3JlZW4ueSAqPSAtIF9zdmdIZWlnaHRIYWxmO1xuXHRcdFx0XHRfdjIucG9zaXRpb25TY3JlZW4ueCAqPSBfc3ZnV2lkdGhIYWxmOyBfdjIucG9zaXRpb25TY3JlZW4ueSAqPSAtIF9zdmdIZWlnaHRIYWxmO1xuXG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YxLnBvc2l0aW9uU2NyZWVuLngsIF92MS5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YyLnBvc2l0aW9uU2NyZWVuLngsIF92Mi5wb3NpdGlvblNjcmVlbi55ICk7XG5cblx0XHRcdFx0aWYgKCAhX2NsaXBSZWN0LmludGVyc2VjdHMoIF9iYm94UmVjdCApICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlbmRlckxpbmUoIF92MSwgX3YyLCBlbGVtZW50LCBtYXRlcmlhbCwgc2NlbmUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudCBpbnN0YW5jZW9mIFRIUkVFLlJlbmRlcmFibGVGYWNlMyApIHtcblxuXHRcdFx0XHRfdjEgPSBlbGVtZW50LnYxOyBfdjIgPSBlbGVtZW50LnYyOyBfdjMgPSBlbGVtZW50LnYzO1xuXG5cdFx0XHRcdF92MS5wb3NpdGlvblNjcmVlbi54ICo9IF9zdmdXaWR0aEhhbGY7IF92MS5wb3NpdGlvblNjcmVlbi55ICo9IC0gX3N2Z0hlaWdodEhhbGY7XG5cdFx0XHRcdF92Mi5wb3NpdGlvblNjcmVlbi54ICo9IF9zdmdXaWR0aEhhbGY7IF92Mi5wb3NpdGlvblNjcmVlbi55ICo9IC0gX3N2Z0hlaWdodEhhbGY7XG5cdFx0XHRcdF92My5wb3NpdGlvblNjcmVlbi54ICo9IF9zdmdXaWR0aEhhbGY7IF92My5wb3NpdGlvblNjcmVlbi55ICo9IC0gX3N2Z0hlaWdodEhhbGY7XG5cblx0XHRcdFx0X2Jib3hSZWN0LmFkZFBvaW50KCBfdjEucG9zaXRpb25TY3JlZW4ueCwgX3YxLnBvc2l0aW9uU2NyZWVuLnkgKTtcblx0XHRcdFx0X2Jib3hSZWN0LmFkZFBvaW50KCBfdjIucG9zaXRpb25TY3JlZW4ueCwgX3YyLnBvc2l0aW9uU2NyZWVuLnkgKTtcblx0XHRcdFx0X2Jib3hSZWN0LmFkZFBvaW50KCBfdjMucG9zaXRpb25TY3JlZW4ueCwgX3YzLnBvc2l0aW9uU2NyZWVuLnkgKTtcblxuXHRcdFx0XHRpZiAoICFfY2xpcFJlY3QuaW50ZXJzZWN0cyggX2Jib3hSZWN0ICkgKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVuZGVyRmFjZTMoIF92MSwgX3YyLCBfdjMsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50IGluc3RhbmNlb2YgVEhSRUUuUmVuZGVyYWJsZUZhY2U0ICkge1xuXG5cdFx0XHRcdF92MSA9IGVsZW1lbnQudjE7IF92MiA9IGVsZW1lbnQudjI7IF92MyA9IGVsZW1lbnQudjM7IF92NCA9IGVsZW1lbnQudjQ7XG5cblx0XHRcdFx0X3YxLnBvc2l0aW9uU2NyZWVuLnggKj0gX3N2Z1dpZHRoSGFsZjsgX3YxLnBvc2l0aW9uU2NyZWVuLnkgKj0gLV9zdmdIZWlnaHRIYWxmO1xuXHRcdFx0XHRfdjIucG9zaXRpb25TY3JlZW4ueCAqPSBfc3ZnV2lkdGhIYWxmOyBfdjIucG9zaXRpb25TY3JlZW4ueSAqPSAtX3N2Z0hlaWdodEhhbGY7XG5cdFx0XHRcdF92My5wb3NpdGlvblNjcmVlbi54ICo9IF9zdmdXaWR0aEhhbGY7IF92My5wb3NpdGlvblNjcmVlbi55ICo9IC1fc3ZnSGVpZ2h0SGFsZjtcblx0XHRcdFx0X3Y0LnBvc2l0aW9uU2NyZWVuLnggKj0gX3N2Z1dpZHRoSGFsZjsgX3Y0LnBvc2l0aW9uU2NyZWVuLnkgKj0gLV9zdmdIZWlnaHRIYWxmO1xuXG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YxLnBvc2l0aW9uU2NyZWVuLngsIF92MS5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YyLnBvc2l0aW9uU2NyZWVuLngsIF92Mi5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3YzLnBvc2l0aW9uU2NyZWVuLngsIF92My5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0XHRcdF9iYm94UmVjdC5hZGRQb2ludCggX3Y0LnBvc2l0aW9uU2NyZWVuLngsIF92NC5wb3NpdGlvblNjcmVlbi55ICk7XG5cblx0XHRcdFx0aWYgKCAhX2NsaXBSZWN0LmludGVyc2VjdHMoIF9iYm94UmVjdCkgKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVuZGVyRmFjZTQoIF92MSwgX3YyLCBfdjMsIF92NCwgZWxlbWVudCwgbWF0ZXJpYWwsIHNjZW5lICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNhbGN1bGF0ZUxpZ2h0cyggbGlnaHRzICkge1xuXG5cdFx0dmFyIGwsIGxsLCBsaWdodCwgbGlnaHRDb2xvcjtcblxuXHRcdF9hbWJpZW50TGlnaHQuc2V0UkdCKCAwLCAwLCAwICk7XG5cdFx0X2RpcmVjdGlvbmFsTGlnaHRzLnNldFJHQiggMCwgMCwgMCApO1xuXHRcdF9wb2ludExpZ2h0cy5zZXRSR0IoIDAsIDAsIDAgKTtcblxuXHRcdGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCsrICkge1xuXG5cdFx0XHRsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXHRcdFx0bGlnaHRDb2xvciA9IGxpZ2h0LmNvbG9yO1xuXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xuXG5cdFx0XHRcdF9hbWJpZW50TGlnaHQuciArPSBsaWdodENvbG9yLnI7XG5cdFx0XHRcdF9hbWJpZW50TGlnaHQuZyArPSBsaWdodENvbG9yLmc7XG5cdFx0XHRcdF9hbWJpZW50TGlnaHQuYiArPSBsaWdodENvbG9yLmI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcblxuXHRcdFx0XHRfZGlyZWN0aW9uYWxMaWdodHMuciArPSBsaWdodENvbG9yLnI7XG5cdFx0XHRcdF9kaXJlY3Rpb25hbExpZ2h0cy5nICs9IGxpZ2h0Q29sb3IuZztcblx0XHRcdFx0X2RpcmVjdGlvbmFsTGlnaHRzLmIgKz0gbGlnaHRDb2xvci5iO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0X3BvaW50TGlnaHRzLnIgKz0gbGlnaHRDb2xvci5yO1xuXHRcdFx0XHRfcG9pbnRMaWdodHMuZyArPSBsaWdodENvbG9yLmc7XG5cdFx0XHRcdF9wb2ludExpZ2h0cy5iICs9IGxpZ2h0Q29sb3IuYjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjYWxjdWxhdGVMaWdodCggbGlnaHRzLCBwb3NpdGlvbiwgbm9ybWFsLCBjb2xvciApIHtcblxuXHRcdHZhciBsLCBsbCwgbGlnaHQsIGxpZ2h0Q29sb3IsIGxpZ2h0UG9zaXRpb24sIGFtb3VudDtcblxuXHRcdGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGwgXTtcblx0XHRcdGxpZ2h0Q29sb3IgPSBsaWdodC5jb2xvcjtcblxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XG5cblx0XHRcdFx0bGlnaHRQb3NpdGlvbiA9IGxpZ2h0Lm1hdHJpeFdvcmxkLmdldFBvc2l0aW9uKCk7XG5cblx0XHRcdFx0YW1vdW50ID0gbm9ybWFsLmRvdCggbGlnaHRQb3NpdGlvbiApO1xuXG5cdFx0XHRcdGlmICggYW1vdW50IDw9IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRhbW91bnQgKj0gbGlnaHQuaW50ZW5zaXR5O1xuXG5cdFx0XHRcdGNvbG9yLnIgKz0gbGlnaHRDb2xvci5yICogYW1vdW50O1xuXHRcdFx0XHRjb2xvci5nICs9IGxpZ2h0Q29sb3IuZyAqIGFtb3VudDtcblx0XHRcdFx0Y29sb3IuYiArPSBsaWdodENvbG9yLmIgKiBhbW91bnQ7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRsaWdodFBvc2l0aW9uID0gbGlnaHQubWF0cml4V29ybGQuZ2V0UG9zaXRpb24oKTtcblxuXHRcdFx0XHRhbW91bnQgPSBub3JtYWwuZG90KCBfdmVjdG9yMy5zdWIoIGxpZ2h0UG9zaXRpb24sIHBvc2l0aW9uICkubm9ybWFsaXplKCkgKTtcblxuXHRcdFx0XHRpZiAoIGFtb3VudCA8PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0YW1vdW50ICo9IGxpZ2h0LmRpc3RhbmNlID09IDAgPyAxIDogMSAtIE1hdGgubWluKCBwb3NpdGlvbi5kaXN0YW5jZVRvKCBsaWdodFBvc2l0aW9uICkgLyBsaWdodC5kaXN0YW5jZSwgMSApO1xuXG5cdFx0XHRcdGlmICggYW1vdW50ID09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRhbW91bnQgKj0gbGlnaHQuaW50ZW5zaXR5O1xuXG5cdFx0XHRcdGNvbG9yLnIgKz0gbGlnaHRDb2xvci5yICogYW1vdW50O1xuXHRcdFx0XHRjb2xvci5nICs9IGxpZ2h0Q29sb3IuZyAqIGFtb3VudDtcblx0XHRcdFx0Y29sb3IuYiArPSBsaWdodENvbG9yLmIgKiBhbW91bnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyUGFydGljbGUoIHYxLCBlbGVtZW50LCBtYXRlcmlhbCwgc2NlbmUgKSB7XG5cblx0XHQvKlxuXHRcdF9zdmdOb2RlID0gZ2V0Q2lyY2xlTm9kZSggX2NpcmNsZUNvdW50KysgKTtcblx0XHRfc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoICdjeCcsIHYxLnggKTtcblx0XHRfc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoICdjeScsIHYxLnkgKTtcblx0XHRfc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoICdyJywgZWxlbWVudC5zY2FsZS54ICogX3N2Z1dpZHRoSGFsZiApO1xuXG5cdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlQ2lyY2xlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdGlmICggX2VuYWJsZUxpZ2h0aW5nICkge1xuXG5cdFx0XHRcdF9jb2xvci5yID0gX2FtYmllbnRMaWdodC5yICsgX2RpcmVjdGlvbmFsTGlnaHRzLnIgKyBfcG9pbnRMaWdodHMucjtcblx0XHRcdFx0X2NvbG9yLmcgPSBfYW1iaWVudExpZ2h0LmcgKyBfZGlyZWN0aW9uYWxMaWdodHMuZyArIF9wb2ludExpZ2h0cy5nO1xuXHRcdFx0XHRfY29sb3IuYiA9IF9hbWJpZW50TGlnaHQuYiArIF9kaXJlY3Rpb25hbExpZ2h0cy5iICsgX3BvaW50TGlnaHRzLmI7XG5cblx0XHRcdFx0X2NvbG9yLnIgPSBtYXRlcmlhbC5jb2xvci5yICogX2NvbG9yLnI7XG5cdFx0XHRcdF9jb2xvci5nID0gbWF0ZXJpYWwuY29sb3IuZyAqIF9jb2xvci5nO1xuXHRcdFx0XHRfY29sb3IuYiA9IG1hdGVyaWFsLmNvbG9yLmIgKiBfY29sb3IuYjtcblxuXHRcdFx0XHRfY29sb3IudXBkYXRlU3R5bGVTdHJpbmcoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfY29sb3IgPSBtYXRlcmlhbC5jb2xvcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRfc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoICdzdHlsZScsICdmaWxsOiAnICsgX2NvbG9yLl9fc3R5bGVTdHJpbmcgKTtcblxuXHRcdH1cblxuXHRcdF9zdmcuYXBwZW5kQ2hpbGQoIF9zdmdOb2RlICk7XG5cdFx0Ki9cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyTGluZSAoIHYxLCB2MiwgZWxlbWVudCwgbWF0ZXJpYWwsIHNjZW5lICkge1xuXG5cdFx0X3N2Z05vZGUgPSBnZXRMaW5lTm9kZSggX2xpbmVDb3VudCArKyApO1xuXG5cdFx0X3N2Z05vZGUuc2V0QXR0cmlidXRlKCAneDEnLCB2MS5wb3NpdGlvblNjcmVlbi54ICk7XG5cdFx0X3N2Z05vZGUuc2V0QXR0cmlidXRlKCAneTEnLCB2MS5wb3NpdGlvblNjcmVlbi55ICk7XG5cdFx0X3N2Z05vZGUuc2V0QXR0cmlidXRlKCAneDInLCB2Mi5wb3NpdGlvblNjcmVlbi54ICk7XG5cdFx0X3N2Z05vZGUuc2V0QXR0cmlidXRlKCAneTInLCB2Mi5wb3NpdGlvblNjcmVlbi55ICk7XG5cblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdF9zdmdOb2RlLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgJ2ZpbGw6IG5vbmU7IHN0cm9rZTogJyArIG1hdGVyaWFsLmNvbG9yLmdldENvbnRleHRTdHlsZSgpICsgJzsgc3Ryb2tlLXdpZHRoOiAnICsgbWF0ZXJpYWwubGluZXdpZHRoICsgJzsgc3Ryb2tlLW9wYWNpdHk6ICcgKyBtYXRlcmlhbC5vcGFjaXR5ICsgJzsgc3Ryb2tlLWxpbmVjYXA6ICcgKyBtYXRlcmlhbC5saW5lY2FwICsgJzsgc3Ryb2tlLWxpbmVqb2luOiAnICsgbWF0ZXJpYWwubGluZWpvaW4gKTtcblxuXHRcdFx0X3N2Zy5hcHBlbmRDaGlsZCggX3N2Z05vZGUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyRmFjZTMoIHYxLCB2MiwgdjMsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApIHtcblxuXHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IDM7XG5cdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKys7XG5cblx0XHRfc3ZnTm9kZSA9IGdldFBhdGhOb2RlKCBfcGF0aENvdW50ICsrICk7XG5cdFx0X3N2Z05vZGUuc2V0QXR0cmlidXRlKCAnZCcsICdNICcgKyB2MS5wb3NpdGlvblNjcmVlbi54ICsgJyAnICsgdjEucG9zaXRpb25TY3JlZW4ueSArICcgTCAnICsgdjIucG9zaXRpb25TY3JlZW4ueCArICcgJyArIHYyLnBvc2l0aW9uU2NyZWVuLnkgKyAnIEwgJyArIHYzLnBvc2l0aW9uU2NyZWVuLnggKyAnLCcgKyB2My5wb3NpdGlvblNjcmVlbi55ICsgJ3onICk7XG5cblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdF9jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsICkge1xuXG5cdFx0XHRpZiAoIF9lbmFibGVMaWdodGluZyApIHtcblxuXHRcdFx0XHRfY29sb3IuciA9IF9hbWJpZW50TGlnaHQucjtcblx0XHRcdFx0X2NvbG9yLmcgPSBfYW1iaWVudExpZ2h0Lmc7XG5cdFx0XHRcdF9jb2xvci5iID0gX2FtYmllbnRMaWdodC5iO1xuXG5cdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBfbGlnaHRzLCBlbGVtZW50LmNlbnRyb2lkV29ybGQsIGVsZW1lbnQubm9ybWFsV29ybGQsIF9jb2xvciApO1xuXG5cdFx0XHRcdF9jb2xvci5yID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5yICogX2NvbG9yLnIsIDEgKSApO1xuXHRcdFx0XHRfY29sb3IuZyA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuZyAqIF9jb2xvci5nLCAxICkgKTtcblx0XHRcdFx0X2NvbG9yLmIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLmIgKiBfY29sb3IuYiwgMSApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2NvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XG5cblx0XHRcdF93ID0gMSAtICggbWF0ZXJpYWwuX18ybmVhciAvIChtYXRlcmlhbC5fX2ZhclBsdXNOZWFyIC0gZWxlbWVudC56ICogbWF0ZXJpYWwuX19mYXJNaW51c05lYXIpICk7XG5cdFx0XHRfY29sb3Iuc2V0UkdCKCBfdywgX3csIF93ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0X2NvbG9yLnNldFJHQiggbm9ybWFsVG9Db21wb25lbnQoIGVsZW1lbnQubm9ybWFsV29ybGQueCApLCBub3JtYWxUb0NvbXBvbmVudCggZWxlbWVudC5ub3JtYWxXb3JsZC55ICksIG5vcm1hbFRvQ29tcG9uZW50KCBlbGVtZW50Lm5vcm1hbFdvcmxkLnogKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgKSB7XG5cblx0XHRcdF9zdmdOb2RlLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgJ2ZpbGw6IG5vbmU7IHN0cm9rZTogJyArIF9jb2xvci5nZXRDb250ZXh0U3R5bGUoKSArICc7IHN0cm9rZS13aWR0aDogJyArIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCArICc7IHN0cm9rZS1vcGFjaXR5OiAnICsgbWF0ZXJpYWwub3BhY2l0eSArICc7IHN0cm9rZS1saW5lY2FwOiAnICsgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCArICc7IHN0cm9rZS1saW5lam9pbjogJyArIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoICdzdHlsZScsICdmaWxsOiAnICsgX2NvbG9yLmdldENvbnRleHRTdHlsZSgpICsgJzsgZmlsbC1vcGFjaXR5OiAnICsgbWF0ZXJpYWwub3BhY2l0eSApO1xuXG5cdFx0fVxuXG5cdFx0X3N2Zy5hcHBlbmRDaGlsZCggX3N2Z05vZGUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyRmFjZTQoIHYxLCB2MiwgdjMsIHY0LCBlbGVtZW50LCBtYXRlcmlhbCwgc2NlbmUgKSB7XG5cblx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSA0O1xuXHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICsrO1xuXG5cdFx0X3N2Z05vZGUgPSBnZXRQYXRoTm9kZSggX3BhdGhDb3VudCArKyApO1xuXHRcdF9zdmdOb2RlLnNldEF0dHJpYnV0ZSggJ2QnLCAnTSAnICsgdjEucG9zaXRpb25TY3JlZW4ueCArICcgJyArIHYxLnBvc2l0aW9uU2NyZWVuLnkgKyAnIEwgJyArIHYyLnBvc2l0aW9uU2NyZWVuLnggKyAnICcgKyB2Mi5wb3NpdGlvblNjcmVlbi55ICsgJyBMICcgKyB2My5wb3NpdGlvblNjcmVlbi54ICsgJywnICsgdjMucG9zaXRpb25TY3JlZW4ueSArICcgTCAnICsgdjQucG9zaXRpb25TY3JlZW4ueCArICcsJyArIHY0LnBvc2l0aW9uU2NyZWVuLnkgKyAneicgKTtcblxuXHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0X2NvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgKSB7XG5cblx0XHRcdGlmICggX2VuYWJsZUxpZ2h0aW5nICkge1xuXG5cdFx0XHRcdF9jb2xvci5yID0gX2FtYmllbnRMaWdodC5yO1xuXHRcdFx0XHRfY29sb3IuZyA9IF9hbWJpZW50TGlnaHQuZztcblx0XHRcdFx0X2NvbG9yLmIgPSBfYW1iaWVudExpZ2h0LmI7XG5cblx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIF9saWdodHMsIGVsZW1lbnQuY2VudHJvaWRXb3JsZCwgZWxlbWVudC5ub3JtYWxXb3JsZCwgX2NvbG9yICk7XG5cblx0XHRcdFx0X2NvbG9yLnIgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIG1hdGVyaWFsLmNvbG9yLnIgKiBfY29sb3IuciwgMSApICk7XG5cdFx0XHRcdF9jb2xvci5nID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBtYXRlcmlhbC5jb2xvci5nICogX2NvbG9yLmcsIDEgKSApO1xuXHRcdFx0XHRfY29sb3IuYiA9IE1hdGgubWF4KCAwLCBNYXRoLm1pbiggbWF0ZXJpYWwuY29sb3IuYiAqIF9jb2xvci5iLCAxICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0X3cgPSAxIC0gKCBtYXRlcmlhbC5fXzJuZWFyIC8gKG1hdGVyaWFsLl9fZmFyUGx1c05lYXIgLSBlbGVtZW50LnogKiBtYXRlcmlhbC5fX2Zhck1pbnVzTmVhcikgKTtcblx0XHRcdF9jb2xvci5zZXRSR0IoIF93LCBfdywgX3cgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsICkge1xuXG5cdFx0XHRfY29sb3Iuc2V0UkdCKCBub3JtYWxUb0NvbXBvbmVudCggZWxlbWVudC5ub3JtYWxXb3JsZC54ICksIG5vcm1hbFRvQ29tcG9uZW50KCBlbGVtZW50Lm5vcm1hbFdvcmxkLnkgKSwgbm9ybWFsVG9Db21wb25lbnQoIGVsZW1lbnQubm9ybWFsV29ybGQueiApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSApIHtcblxuXHRcdFx0X3N2Z05vZGUuc2V0QXR0cmlidXRlKCAnc3R5bGUnLCAnZmlsbDogbm9uZTsgc3Ryb2tlOiAnICsgX2NvbG9yLmdldENvbnRleHRTdHlsZSgpICsgJzsgc3Ryb2tlLXdpZHRoOiAnICsgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICsgJzsgc3Ryb2tlLW9wYWNpdHk6ICcgKyBtYXRlcmlhbC5vcGFjaXR5ICsgJzsgc3Ryb2tlLWxpbmVjYXA6ICcgKyBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwICsgJzsgc3Ryb2tlLWxpbmVqb2luOiAnICsgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9zdmdOb2RlLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgJ2ZpbGw6ICcgKyBfY29sb3IuZ2V0Q29udGV4dFN0eWxlKCkgKyAnOyBmaWxsLW9wYWNpdHk6ICcgKyBtYXRlcmlhbC5vcGFjaXR5ICk7XG5cblx0XHR9XG5cblx0XHRfc3ZnLmFwcGVuZENoaWxkKCBfc3ZnTm9kZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRMaW5lTm9kZSggaWQgKSB7XG5cblx0XHRpZiAoIF9zdmdMaW5lUG9vbFsgaWQgXSA9PSBudWxsICkge1xuXG5cdFx0XHRfc3ZnTGluZVBvb2xbIGlkIF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdsaW5lJyApO1xuXG5cdFx0XHRpZiAoIF9xdWFsaXR5ID09IDAgKSB7XG5cblx0XHRcdFx0X3N2Z0xpbmVQb29sWyBpZCBdLnNldEF0dHJpYnV0ZSggJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyApOyAvL29wdGltaXplU3BlZWRcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gX3N2Z0xpbmVQb29sWyBpZCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIF9zdmdMaW5lUG9vbFsgaWQgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UGF0aE5vZGUoIGlkICkge1xuXG5cdFx0aWYgKCBfc3ZnUGF0aFBvb2xbIGlkIF0gPT0gbnVsbCApIHtcblxuXHRcdFx0X3N2Z1BhdGhQb29sWyBpZCBdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcgKTtcblxuXHRcdFx0aWYgKCBfcXVhbGl0eSA9PSAwICkge1xuXG5cdFx0XHRcdF9zdmdQYXRoUG9vbFsgaWQgXS5zZXRBdHRyaWJ1dGUoICdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycgKTsgLy9vcHRpbWl6ZVNwZWVkXG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIF9zdmdQYXRoUG9vbFsgaWQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBfc3ZnUGF0aFBvb2xbIGlkIF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldENpcmNsZU5vZGUoIGlkICkge1xuXG5cdFx0aWYgKCBfc3ZnQ2lyY2xlUG9vbFtpZF0gPT0gbnVsbCApIHtcblxuXHRcdFx0X3N2Z0NpcmNsZVBvb2xbIGlkIF0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdjaXJjbGUnICk7XG5cblx0XHRcdGlmICggX3F1YWxpdHkgPT0gMCApIHtcblxuXHRcdFx0XHRfc3ZnQ2lyY2xlUG9vbFtpZF0uc2V0QXR0cmlidXRlKCAnc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnICk7IC8vb3B0aW1pemVTcGVlZFxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBfc3ZnQ2lyY2xlUG9vbFsgaWQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBfc3ZnQ2lyY2xlUG9vbFsgaWQgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gbm9ybWFsVG9Db21wb25lbnQoIG5vcm1hbCApIHtcblxuXHRcdHZhciBjb21wb25lbnQgPSAoIG5vcm1hbCArIDEgKSAqIDAuNTtcblx0XHRyZXR1cm4gY29tcG9uZW50IDwgMCA/IDAgOiAoIGNvbXBvbmVudCA+IDEgPyAxIDogY29tcG9uZW50ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBhZCggc3RyICkge1xuXG5cdFx0d2hpbGUgKCBzdHIubGVuZ3RoIDwgNiApIHN0ciA9ICcwJyArIHN0cjtcblx0XHRyZXR1cm4gc3RyO1xuXG5cdH1cblxufTtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICovXG5cblRIUkVFLlNoYWRlckNodW5rID0ge1xuXG5cdC8vIEZPR1xuXG5cdGZvZ19wYXJzX2ZyYWdtZW50OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfRk9HXCIsXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1wiLFxuXG5cdFx0XHRcIiNpZmRlZiBGT0dfRVhQMlwiLFxuXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1wiLFxuXG5cdFx0XHRcIiNlbHNlXCIsXG5cblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dGYXI7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZvZ19mcmFnbWVudDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX0ZPR1wiLFxuXG5cdFx0XHRcImZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcblxuXHRcdFx0XCIjaWZkZWYgRk9HX0VYUDJcIixcblxuXHRcdFx0XHRcImNvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTtcIixcblx0XHRcdFx0XCJmbG9hdCBmb2dGYWN0b3IgPSBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKTtcIixcblx0XHRcdFx0XCJmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApO1wiLFxuXG5cdFx0XHRcIiNlbHNlXCIsXG5cblx0XHRcdFx0XCJmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTtcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0Ly8gRU5WSVJPTk1FTlQgTUFQXG5cblx0ZW52bWFwX3BhcnNfZnJhZ21lbnQ6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9FTlZNQVBcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XCIsXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XCIsXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XCIsXG5cdFx0XHRcInVuaWZvcm0gaW50IGNvbWJpbmU7XCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGVudm1hcF9mcmFnbWVudDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX0VOVk1BUFwiLFxuXG5cdFx0XHRcInZlYzQgY3ViZUNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHZSZWZsZWN0LngsIHZSZWZsZWN0Lnl6ICkgKTtcIixcblxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcblxuXHRcdFx0XHRcImN1YmVDb2xvci54eXogKj0gY3ViZUNvbG9yLnh5ejtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XCJpZiAoIGNvbWJpbmUgPT0gMSApIHtcIixcblxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBtaXgoIGdsX0ZyYWdDb2xvci54eXosIGN1YmVDb2xvci54eXosIHJlZmxlY3Rpdml0eSApO1wiLFxuXG5cdFx0XHRcIn0gZWxzZSB7XCIsXG5cblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqIGN1YmVDb2xvci54eXo7XCIsXG5cblx0XHRcdFwifVwiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRlbnZtYXBfcGFyc192ZXJ0ZXg6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9FTlZNQVBcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XCIsXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XCIsXG5cdFx0XHRcInVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRlbnZtYXBfdmVydGV4IDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX0VOVk1BUFwiLFxuXG5cdFx0XHRcInZlYzQgbVBvc2l0aW9uID0gb2JqZWN0TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXHRcdFx0XCJ2ZWMzIG5Xb3JsZCA9IG1hdDMoIG9iamVjdE1hdHJpeFsgMCBdLnh5eiwgb2JqZWN0TWF0cml4WyAxIF0ueHl6LCBvYmplY3RNYXRyaXhbIDIgXS54eXogKSAqIG5vcm1hbDtcIixcblxuXHRcdFx0XCJpZiAoIHVzZVJlZnJhY3QgKSB7XCIsXG5cblx0XHRcdFx0XCJ2UmVmbGVjdCA9IHJlZnJhY3QoIG5vcm1hbGl6ZSggbVBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICksIG5vcm1hbGl6ZSggbldvcmxkLnh5eiApLCByZWZyYWN0aW9uUmF0aW8gKTtcIixcblxuXHRcdFx0XCJ9IGVsc2Uge1wiLFxuXG5cdFx0XHRcdFwidlJlZmxlY3QgPSByZWZsZWN0KCBub3JtYWxpemUoIG1Qb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApLCBub3JtYWxpemUoIG5Xb3JsZC54eXogKSApO1wiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0Ly8gQ09MT1IgTUFQIChwYXJ0aWNsZXMpXG5cblx0bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9NQVBcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cblx0bWFwX3BhcnRpY2xlX2ZyYWdtZW50OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfTUFQXCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4dHVyZTJEKCBtYXAsIGdsX1BvaW50Q29vcmQgKTtcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0Ly8gQ09MT1IgTUFQICh0cmlhbmdsZXMpXG5cblx0bWFwX3BhcnNfdmVydGV4OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfTUFQXCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0bWFwX3BhcnNfZnJhZ21lbnQ6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9NQVBcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdG1hcF92ZXJ0ZXg6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9NQVBcIixcblxuXHRcdFx0XCJ2VXYgPSB1diAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eTtcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0bWFwX2ZyYWdtZW50OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfTUFQXCIsXG5cblx0XHRcdFwiI2lmZGVmIEdBTU1BX0lOUFVUXCIsXG5cblx0XHRcdFx0XCJ2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XCIsXG5cdFx0XHRcdFwidGV4ZWxDb2xvci54eXogKj0gdGV4ZWxDb2xvci54eXo7XCIsXG5cblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXhlbENvbG9yO1wiLFxuXG5cdFx0XHRcIiNlbHNlXCIsXG5cblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdC8vIExJR0hUIE1BUFxuXG5cdGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9MSUdIVE1BUFwiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXYyO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0bGlnaHRtYXBfcGFyc192ZXJ0ZXg6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9MSUdIVE1BUFwiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXYyO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRsaWdodG1hcF9mcmFnbWVudDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX0xJR0hUTUFQXCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRsaWdodG1hcF92ZXJ0ZXg6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9MSUdIVE1BUFwiLFxuXG5cdFx0XHRcInZVdjIgPSB1djI7XCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdC8vIExJR0hUUyBMQU1CRVJUXG5cblx0bGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXg6IFtcblxuXHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XCIsXG5cdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblxuXHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxuXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XCIsXG5cblx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0bGlnaHRzX2xhbWJlcnRfdmVydGV4OiBbXG5cblx0XHRcInZMaWdodFdlaWdodGluZyA9IHZlYzMoIDAuMCApO1wiLFxuXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXG5cblx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XCIsXG5cblx0XHRcdFwidmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XCIsXG5cdFx0XHRcImZsb2F0IGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmcgPSBtYXgoIGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKSApLCAwLjAgKTtcIixcblx0XHRcdFwidkxpZ2h0V2VpZ2h0aW5nICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZztcIixcblxuXHRcdFwifVwiLFxuXG5cdFx0XCIjZW5kaWZcIixcblxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1wiLFxuXG5cdFx0XHRcdFwidmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcdFwiZmxvYXQgbERpc3RhbmNlID0gMS4wO1wiLFxuXG5cdFx0XHRcdFwiaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXG5cdFx0XHRcdFx0XCJsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcblxuXHRcdFx0XHRcImxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcIixcblxuXHRcdFx0XHRcImZsb2F0IHBvaW50TGlnaHRXZWlnaHRpbmcgPSBtYXgoIGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKSwgMC4wICk7XCIsXG5cdFx0XHRcdFwidkxpZ2h0V2VpZ2h0aW5nICs9IHBvaW50TGlnaHRDb2xvclsgaSBdICogcG9pbnRMaWdodFdlaWdodGluZyAqIGxEaXN0YW5jZTtcIixcblxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XCJ2TGlnaHRXZWlnaHRpbmcgPSB2TGlnaHRXZWlnaHRpbmcgKiBkaWZmdXNlICsgYW1iaWVudCAqIGFtYmllbnRMaWdodENvbG9yO1wiLFxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHQvLyBMSUdIVFMgUEhPTkdcblxuXHRsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXg6IFtcblxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cdFx0XCIjaWZuZGVmIFBIT05HX1BFUl9QSVhFTFwiLFxuXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlBvaW50TGlnaHRbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblxuXHRcdFwiI2VuZGlmXCIsXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXG5cdGxpZ2h0c19waG9uZ192ZXJ0ZXg6IFtcblxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cdFx0XCIjaWZuZGVmIFBIT05HX1BFUl9QSVhFTFwiLFxuXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcblxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcIixcblxuXHRcdFx0XHRcImZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcIixcblxuXHRcdFx0XHRcImlmICggcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxuXHRcdFx0XHRcdFwibERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XCIsXG5cblx0XHRcdFx0XCJsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XCIsXG5cblx0XHRcdFx0XCJ2UG9pbnRMaWdodFsgaSBdID0gdmVjNCggbFZlY3RvciwgbERpc3RhbmNlICk7XCIsXG5cblx0XHRcdFwifVwiLFxuXG5cdFx0XCIjZW5kaWZcIixcblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50OiBbXG5cblx0XHRcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcIixcblxuXHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1wiLFxuXG5cdFx0XCIjZW5kaWZcIixcblxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxuXG5cdFx0XHRcIiNpZmRlZiBQSE9OR19QRVJfUElYRUxcIixcblxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxuXG5cdFx0XHRcIiNlbHNlXCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlBvaW50TGlnaHRbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0bGlnaHRzX3Bob25nX2ZyYWdtZW50OiBbXG5cblx0XHRcInZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XCIsXG5cdFx0XCJ2ZWMzIHZpZXdQb3NpdGlvbiA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1wiLFxuXG5cdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcblxuXHRcdFx0XCJ2ZWMzIHBvaW50RGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFwidmVjMyBwb2ludFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXG5cblx0XHRcdFwiZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFx0XHRcIiNpZmRlZiBQSE9OR19QRVJfUElYRUxcIixcblxuXHRcdFx0XHRcdFwidmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XCIsXG5cblx0XHRcdFx0XHRcImZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcIixcblxuXHRcdFx0XHRcdFwiaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXG5cdFx0XHRcdFx0XHRcImxEaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIGxWZWN0b3IgKSAvIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0XCJsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XCIsXG5cblx0XHRcdFx0XCIjZWxzZVwiLFxuXG5cdFx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIHZQb2ludExpZ2h0WyBpIF0ueHl6ICk7XCIsXG5cdFx0XHRcdFx0XCJmbG9hdCBsRGlzdGFuY2UgPSB2UG9pbnRMaWdodFsgaSBdLnc7XCIsXG5cblx0XHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XHRcInZlYzMgcG9pbnRIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXG5cdFx0XHRcdFwiZmxvYXQgcG9pbnREaXN0YW5jZSA9IGxEaXN0YW5jZTtcIixcblxuXHRcdFx0XHRcImZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFx0XCJmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdCggbm9ybWFsLCBsVmVjdG9yICksIDAuMCApO1wiLFxuXG5cdFx0XHRcdFwiZmxvYXQgcG9pbnRTcGVjdWxhcldlaWdodCA9IHBvdyggcG9pbnREb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKTtcIixcblxuXHRcdFx0XHRcIiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIixcblxuXHRcdFx0XHRcdFwidmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBkb3QoIGxWZWN0b3IsIHBvaW50SGFsZlZlY3RvciApLCA1LjAgKTtcIixcblx0XHRcdFx0XHRcInBvaW50U3BlY3VsYXIgKz0gc2NobGljayAqIHBvaW50TGlnaHRDb2xvclsgaSBdICogcG9pbnRTcGVjdWxhcldlaWdodCAqIHBvaW50RGlmZnVzZVdlaWdodCAqIHBvaW50RGlzdGFuY2U7XCIsXG5cblx0XHRcdFx0XCIjZWxzZVwiLFxuXG5cdFx0XHRcdFx0XCJwb2ludFNwZWN1bGFyICs9IHNwZWN1bGFyICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogcG9pbnREaXN0YW5jZTtcIixcblxuXHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFwicG9pbnREaWZmdXNlICArPSBkaWZmdXNlICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBwb2ludERpc3RhbmNlO1wiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcblxuXHRcdFx0XCJ2ZWMzIGRpckRpZmZ1c2UgID0gdmVjMyggMC4wICk7XCIsXG5cdFx0XHRcInZlYzMgZGlyU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIiAsXG5cblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFx0XHRcInZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxuXG5cdFx0XHRcdFwidmVjMyBkaXJWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XCIsXG5cdFx0XHRcdFwidmVjMyBkaXJIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiArIHZpZXdQb3NpdGlvbiApO1wiLFxuXG5cdFx0XHRcdFwiZmxvYXQgZGlyRG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIGRpckhhbGZWZWN0b3IgKSwgMC4wICk7XCIsXG5cdFx0XHRcdFwiZmxvYXQgZGlyRGlmZnVzZVdlaWdodCA9IG1heCggZG90KCBub3JtYWwsIGRpclZlY3RvciApLCAwLjAgKTtcIixcblxuXHRcdFx0XHRcImZsb2F0IGRpclNwZWN1bGFyV2VpZ2h0ID0gcG93KCBkaXJEb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKTtcIixcblxuXHRcdFx0XHRcIiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIixcblxuXHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0Ly8gZnJlc25lbCB0ZXJtIGZyb20gc2tpbiBzaGFkZXJcblx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IEYwID0gMC4xMjg7XCIsXG5cblx0XHRcdFx0XHRcImZsb2F0IGJhc2UgPSAxLjAgLSBkb3QoIHZpZXdQb3NpdGlvbiwgZGlySGFsZlZlY3RvciApO1wiLFxuXHRcdFx0XHRcdFwiZmxvYXQgZXhwb25lbnRpYWwgPSBwb3coIGJhc2UsIDUuMCApO1wiLFxuXG5cdFx0XHRcdFx0XCJmbG9hdCBmcmVzbmVsID0gZXhwb25lbnRpYWwgKyBGMCAqICggMS4wIC0gZXhwb25lbnRpYWwgKTtcIixcblx0XHRcdFx0XHQqL1xuXG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQvLyBmcmVzbmVsIHRlcm0gZnJvbSBmcmVzbmVsIHNoYWRlclxuXHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgbUZyZXNuZWxCaWFzID0gMC4wODtcIixcblx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IG1GcmVzbmVsU2NhbGUgPSAwLjM7XCIsXG5cdFx0XHRcdFx0XCJjb25zdCBmbG9hdCBtRnJlc25lbFBvd2VyID0gNS4wO1wiLFxuXG5cdFx0XHRcdFx0XCJmbG9hdCBmcmVzbmVsID0gbUZyZXNuZWxCaWFzICsgbUZyZXNuZWxTY2FsZSAqIHBvdyggMS4wICsgZG90KCBub3JtYWxpemUoIC12aWV3UG9zaXRpb24gKSwgbm9ybWFsICksIG1GcmVzbmVsUG93ZXIgKTtcIixcblx0XHRcdFx0XHQqL1xuXG5cdFx0XHRcdFx0Ly8gbm9ybWFsaXphdGlvbiBmYWN0b3Jcblx0XHRcdFx0XHQvL2Zsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XG5cblx0XHRcdFx0XHQvL1wiZGlyU3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIGZyZXNuZWw7XCIsXG5cblx0XHRcdFx0XHRcInZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggZG90KCBkaXJWZWN0b3IsIGRpckhhbGZWZWN0b3IgKSwgNS4wICk7XCIsXG5cdFx0XHRcdFx0XCJkaXJTcGVjdWxhciArPSBzY2hsaWNrICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQ7XCIsXG5cblx0XHRcdFx0XCIjZWxzZVwiLFxuXG5cdFx0XHRcdFx0XCJkaXJTcGVjdWxhciArPSBzcGVjdWxhciAqIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0O1wiLFxuXG5cdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XCJkaXJEaWZmdXNlICArPSBkaWZmdXNlICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJEaWZmdXNlV2VpZ2h0O1wiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcInZlYzMgdG90YWxEaWZmdXNlID0gdmVjMyggMC4wICk7XCIsXG5cdFx0XCJ2ZWMzIHRvdGFsU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcblxuXHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcInRvdGFsRGlmZnVzZSArPSBkaXJEaWZmdXNlO1wiLFxuXHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IGRpclNwZWN1bGFyO1wiLFxuXG5cdFx0XCIjZW5kaWZcIixcblxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwidG90YWxEaWZmdXNlICs9IHBvaW50RGlmZnVzZTtcIixcblx0XHRcdFwidG90YWxTcGVjdWxhciArPSBwb2ludFNwZWN1bGFyO1wiLFxuXG5cdFx0XCIjZW5kaWZcIixcblxuXHRcdFwiI2lmZGVmIE1FVEFMXCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIHRvdGFsRGlmZnVzZSArIGFtYmllbnRMaWdodENvbG9yICogYW1iaWVudCArIHRvdGFsU3BlY3VsYXIgKTtcIixcblxuXHRcdFwiI2Vsc2VcIixcblxuXHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICkgKyB0b3RhbFNwZWN1bGFyO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHQvLyBWRVJURVggQ09MT1JTXG5cblx0Y29sb3JfcGFyc19mcmFnbWVudDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX0NPTE9SXCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZDb2xvcjtcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblxuXHRjb2xvcl9mcmFnbWVudDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX0NPTE9SXCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdmVjNCggdkNvbG9yLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGNvbG9yX3BhcnNfdmVydGV4OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfQ09MT1JcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkNvbG9yO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXG5cdGNvbG9yX3ZlcnRleDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX0NPTE9SXCIsXG5cblx0XHRcdFwiI2lmZGVmIEdBTU1BX0lOUFVUXCIsXG5cblx0XHRcdFx0XCJ2Q29sb3IgPSBjb2xvciAqIGNvbG9yO1wiLFxuXG5cdFx0XHRcIiNlbHNlXCIsXG5cblx0XHRcdFx0XCJ2Q29sb3IgPSBjb2xvcjtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0Ly8gU0tJTk5JTkdcblxuXHRza2lubmluZ19wYXJzX3ZlcnRleDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXG5cblx0XHRcdFwidW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdHNraW5uaW5nX3ZlcnRleDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXG5cblx0XHRcdFwiZ2xfUG9zaXRpb24gID0gKCBib25lR2xvYmFsTWF0cmljZXNbIGludCggc2tpbkluZGV4LnggKSBdICogc2tpblZlcnRleEEgKSAqIHNraW5XZWlnaHQueDtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gKz0gKCBib25lR2xvYmFsTWF0cmljZXNbIGludCggc2tpbkluZGV4LnkgKSBdICogc2tpblZlcnRleEIgKSAqIHNraW5XZWlnaHQueTtcIixcblxuXHRcdFx0Ly8gdGhpcyBkb2Vzbid0IHdvcmssIG5vIGlkZWEgd2h5XG5cdFx0XHQvL1wiZ2xfUG9zaXRpb24gID0gcHJvamVjdGlvbk1hdHJpeCAqIGNhbWVyYUludmVyc2VNYXRyaXggKiBvYmplY3RNYXRyaXggKiBnbF9Qb3NpdGlvbjtcIixcblxuXHRcdFx0XCJnbF9Qb3NpdGlvbiAgPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG9iamVjdE1hdHJpeCAqIGdsX1Bvc2l0aW9uO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHQvLyBNT1JQSElOR1xuXG5cdG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcIixcblxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0bW9ycGh0YXJnZXRfdmVydGV4OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXG5cblx0XHRcdFwidmVjMyBtb3JwaGVkID0gdmVjMyggMC4wLCAwLjAsIDAuMCApO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1wiLFxuXHRcdFx0XCJtb3JwaGVkICs9IHBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRkZWZhdWx0X3ZlcnRleCA6IFtcblxuXHRcdFwiI2lmbmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXG5cdFx0XCIjaWZuZGVmIFVTRV9TS0lOTklOR1wiLFxuXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cblx0XHRcIiNlbmRpZlwiLFxuXHRcdFwiI2VuZGlmXCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0Ly8gU0hBRE9XIE1BUFxuXG5cdC8vIGJhc2VkIG9uIFNwaWRlckdMIHNoYWRvdyBtYXAgYW5kIEZhYmllbiBTYW5nbGFyZCdzIEdMU0wgc2hhZG93IG1hcHBpbmcgZXhhbXBsZXNcblx0Ly8gIGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxuXHQvLyBcdGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1xuXG5cdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXCIsXG5cblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93TWFwWyBNQVhfU0hBRE9XUyBdO1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2hhZG93RGFya25lc3M7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2hhZG93QmlhcztcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1wiLFxuXG5cdFx0XHRcImZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XCIsXG5cblx0XHRcdFx0XCJjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XCIsXG5cdFx0XHRcdFwiZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1wiLFxuXHRcdFx0XHRcInJldHVybiBkZXB0aDtcIixcblxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdHNoYWRvd21hcF9mcmFnbWVudDogW1xuXG5cdFx0XCIjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxuXG5cdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfU09GVFwiLFxuXG5cdFx0XHRcdFwiY29uc3QgZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gU0hBRE9XTUFQX1dJRFRIO1wiLFxuXHRcdFx0XHRcImNvbnN0IGZsb2F0IHlQaXhlbE9mZnNldCA9IDEuMCAvIFNIQURPV01BUF9IRUlHSFQ7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwidmVjMyBzaGFkb3dDb2xvciA9IHZlYzMoIDEuMCApO1wiLFxuXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XCIsXG5cblx0XHRcdFx0XCJ2ZWMzIHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6IC8gdlNoYWRvd0Nvb3JkWyBpIF0udztcIixcblx0XHRcdFx0XCJzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXM7XCIsXG5cblx0XHRcdFx0XCJpZiAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wICYmIHNoYWRvd0Nvb3JkLnggPD0gMS4wICYmIHNoYWRvd0Nvb3JkLnkgPj0gMC4wICYmIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICkge1wiLFxuXG5cdFx0XHRcdFx0XCIjaWZkZWYgU0hBRE9XTUFQX1NPRlRcIixcblxuXHRcdFx0XHRcdFx0Ly8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcblx0XHRcdFx0XHRcdC8vICg5IHBpeGVsIGtlcm5lbClcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cblxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzaGFkb3cgPSAwLjA7XCIsXG5cblx0XHRcdFx0XHRcdFwiZm9yICggZmxvYXQgeSA9IC0xLjI1OyB5IDw9IDEuMjU7IHkgKz0gMS4yNSApXCIsXG5cdFx0XHRcdFx0XHRcdFwiZm9yICggZmxvYXQgeCA9IC0xLjI1OyB4IDw9IDEuMjU7IHggKz0gMS4yNSApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcdFwidmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG9lc24ndCBzZWVtIHRvIHByb2R1Y2UgYW55IG5vdGljZWFibGUgdmlzdWFsIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gc2ltcGxlIFwidGV4dHVyZTJEXCIgbG9va3VwXG5cdFx0XHRcdFx0XHRcdFx0Ly9cInZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEUHJvaiggc2hhZG93TWFwWyBpIF0sIHZlYzQoIHZTaGFkb3dDb29yZFsgaSBdLncgKiAoIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICksIDAuMDUsIHZTaGFkb3dDb29yZFsgaSBdLncgKSApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFx0XCJmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInNoYWRvdyArPSAxLjA7XCIsXG5cblx0XHRcdFx0XHRcdFwifVwiLFxuXG5cdFx0XHRcdFx0XHRcInNoYWRvdyAvPSA5LjA7XCIsXG5cdFx0XHRcdFx0XHRcInNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzICogc2hhZG93ICkgKTtcIixcblxuXHRcdFx0XHRcdFwiI2Vsc2VcIixcblxuXHRcdFx0XHRcdFx0XCJ2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XCIsXG5cdFx0XHRcdFx0XHRcImZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcIixcblxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVwiLFxuXG5cdFx0XHRcdFx0XHRcdC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGlzIGRhcmtlclxuXG5cdFx0XHRcdFx0XHRcdFwic2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoIHNoYWRvd0RhcmtuZXNzICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0Ly8gc3BvdCB3aXRoIG11bHRpcGxlIHNoYWRvd3MgaGFzIHRoZSBzYW1lIGNvbG9yIGFzIHNpbmdsZSBzaGFkb3cgc3BvdFxuXG5cdFx0XHRcdFx0XHRcdC8vXCJzaGFkb3dDb2xvciA9IG1pbiggc2hhZG93Q29sb3IsIHZlYzMoIHNoYWRvd0RhcmtuZXNzICkgKTtcIixcblxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XCJ9XCIsXG5cblxuXHRcdFx0XHQvLyB1bmNvbW1lbnQgdG8gc2VlIGxpZ2h0IGZydXN0dW0gYm91bmRhcmllc1xuXHRcdFx0XHQvL1wiaWYgKCAhKCBzaGFkb3dDb29yZC54ID49IDAuMCAmJiBzaGFkb3dDb29yZC54IDw9IDEuMCAmJiBzaGFkb3dDb29yZC55ID49IDAuMCAmJiBzaGFkb3dDb29yZC55IDw9IDEuMCApIClcIixcblx0XHRcdFx0Ly9cdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9ICBnbF9GcmFnQ29sb3IueHl6ICogdmVjMyggMS4wLCAwLjAsIDAuMCApO1wiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfT1VUUFVUXCIsXG5cblx0XHRcdFx0XCJzaGFkb3dDb2xvciAqPSBzaGFkb3dDb2xvcjtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqIHNoYWRvd0NvbG9yO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6IFtcblxuXHRcdFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgc2hhZG93TWF0cml4WyBNQVhfU0hBRE9XUyBdO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRzaGFkb3dtYXBfdmVydGV4OiBbXG5cblx0XHRcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXCIsXG5cblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcIixcblxuXHRcdFx0XHRcInZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiBvYmplY3RNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFwifVwiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHQvLyBBTFBIQVRFU1RcblxuXHRhbHBoYXRlc3RfZnJhZ21lbnQ6IFtcblxuXHRcdFwiI2lmZGVmIEFMUEhBVEVTVFwiLFxuXG5cdFx0XHRcImlmICggZ2xfRnJhZ0NvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1wiLFxuXG5cdFx0XCIjZW5kaWZcIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHQvLyBMSU5FQVIgU1BBQ0VcblxuXHRsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQ6IFtcblxuXHRcdFwiI2lmZGVmIEdBTU1BX09VVFBVVFwiLFxuXG5cdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBzcXJ0KCBnbF9GcmFnQ29sb3IueHl6ICk7XCIsXG5cblx0XHRcIiNlbmRpZlwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cbn07XG5cblRIUkVFLlVuaWZvcm1zVXRpbHMgPSB7XG5cblx0bWVyZ2U6IGZ1bmN0aW9uICggdW5pZm9ybXMgKSB7XG5cblx0XHR2YXIgdSwgcCwgdG1wLCBtZXJnZWQgPSB7fTtcblxuXHRcdGZvciAoIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1KysgKSB7XG5cblx0XHRcdHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcblxuXHRcdFx0Zm9yICggcCBpbiB0bXAgKSB7XG5cblx0XHRcdFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lcmdlZDtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcblxuXHRcdHZhciB1LCBwLCBwYXJhbWV0ZXIsIHBhcmFtZXRlcl9zcmMsIHVuaWZvcm1zX2RzdCA9IHt9O1xuXG5cdFx0Zm9yICggdSBpbiB1bmlmb3Jtc19zcmMgKSB7XG5cblx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdID0ge307XG5cblx0XHRcdGZvciAoIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVyX3NyYyA9IHVuaWZvcm1zX3NyY1sgdSBdWyBwIF07XG5cblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgfHxcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjIgfHxcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgfHxcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgfHxcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgfHxcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5jbG9uZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBBcnJheSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuaWZvcm1zX2RzdDtcblxuXHR9XG5cbn07XG5cblRIUkVFLlVuaWZvcm1zTGliID0ge1xuXG5cdGNvbW1vbjoge1xuXG5cdFx0XCJkaWZmdXNlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cblx0XHRcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IDAsIHRleHR1cmU6IG51bGwgfSxcblx0XHRcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXG5cblx0XHRcImxpZ2h0TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogMiwgdGV4dHVyZTogbnVsbCB9LFxuXG5cdFx0XCJlbnZNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiAxLCB0ZXh0dXJlOiBudWxsIH0sXG5cdFx0XCJmbGlwRW52TWFwXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLTEgfSxcblx0XHRcInVzZVJlZnJhY3RcIiA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cdFx0XCJyZWZsZWN0aXZpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcblx0XHRcInJlZnJhY3Rpb25SYXRpb1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuOTggfSxcblx0XHRcImNvbWJpbmVcIiA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cblx0XHRcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfVxuXG5cdH0sXG5cblx0Zm9nIDoge1xuXG5cdFx0XCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxuXHRcdFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblx0XHRcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcblx0XHRcImZvZ0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cblxuXHR9LFxuXG5cdGxpZ2h0czoge1xuXG5cdFx0XCJhbWJpZW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwiZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwiZGlyZWN0aW9uYWxMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XCJwb2ludExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcInBvaW50TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwicG9pbnRMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9XG5cblx0fSxcblxuXHRwYXJ0aWNsZToge1xuXG5cdFx0XCJwc0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJzaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJzY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogMCwgdGV4dHVyZTogbnVsbCB9LFxuXG5cdFx0XCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxuXHRcdFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblx0XHRcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcblx0XHRcImZvZ0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cblxuXHR9LFxuXG5cdHNoYWRvd21hcDoge1xuXG5cdFx0XCJzaGFkb3dNYXBcIjogeyB0eXBlOiBcInR2XCIsIHZhbHVlOiA2LCB0ZXh0dXJlOiBbXSB9LFxuXHRcdFwic2hhZG93TWF0cml4XCIgOiB7IHR5cGU6IFwibTR2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJzaGFkb3dCaWFzXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDM5IH0sXG5cdFx0XCJzaGFkb3dEYXJrbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4yIH1cblxuXHR9XG5cbn07XG5cblRIUkVFLlNoYWRlckxpYiA9IHtcblxuXHQnc3ByaXRlJzoge1xuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBpbnQgdXNlU2NyZWVuQ29vcmRpbmF0ZXM7XCIsXG5cdFx0XHRcInVuaWZvcm0gaW50IGFmZmVjdGVkQnlEaXN0YW5jZTtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1wiLFxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgYWxpZ25tZW50O1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdXZPZmZzZXQ7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMiB1dlNjYWxlO1wiLFxuXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcInZVViA9IHV2T2Zmc2V0ICsgdXYgKiB1dlNjYWxlO1wiLFxuXG5cdFx0XHRcdFwidmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiArIGFsaWdubWVudDtcIixcblxuXHRcdFx0XHRcInZlYzIgcm90YXRlZFBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcInJvdGF0ZWRQb3NpdGlvbi54ID0gKCBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55ICkgKiBzY2FsZS54O1wiLFxuXHRcdFx0XHRcInJvdGF0ZWRQb3NpdGlvbi55ID0gKCBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55ICkgKiBzY2FsZS55O1wiLFxuXG5cdFx0XHRcdFwidmVjNCBmaW5hbFBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFwiaWYoIHVzZVNjcmVlbkNvb3JkaW5hdGVzICE9IDAgKSB7XCIsXG5cblx0XHRcdFx0XHRcImZpbmFsUG9zaXRpb24gPSB2ZWM0KCBzY3JlZW5Qb3NpdGlvbi54eSArIHJvdGF0ZWRQb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cblx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxuXG5cdFx0XHRcdFx0XCJmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1wiLFxuXHRcdFx0XHRcdFwiZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb24gKiAoIGFmZmVjdGVkQnlEaXN0YW5jZSA9PSAxID8gMS4wIDogZmluYWxQb3NpdGlvbi56ICk7XCIsXG5cblx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IGZpbmFsUG9zaXRpb247XCIsXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwiI2lmZGVmIEdMX0VTXCIsXG5cdFx0XHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1wiLFxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0fSxcblxuXHQnZGVwdGgnOiB7XG5cblx0XHR1bmlmb3Jtczoge1xuXG5cdFx0XHRcIm1OZWFyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcblx0XHRcdFwibUZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAuMCB9LFxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cblxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIiksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbU5lYXI7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbUZhcjtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcImZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcblx0XHRcdFx0XCJmbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1wiLFxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGNvbG9yICksIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J25vcm1hbCc6IHtcblxuXHRcdHVuaWZvcm1zOiB7XG5cblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXHRcdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxuXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjUgKiBub3JtYWxpemUoIHZOb3JtYWwgKSArIDAuNSwgb3BhY2l0eSApO1wiLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0fSxcblxuXHQnYmFzaWMnOiB7XG5cblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0fSxcblxuXHQnbGFtYmVydCc6IHtcblxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXG5cblx0XHRcdHtcblx0XHRcdFx0XCJhbWJpZW50XCIgIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwNTA1MDUgKSB9XG5cdFx0XHR9XG5cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0V2VpZ2h0aW5nO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2TGlnaHRXZWlnaHRpbmc7XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyAoIDEuMCApLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogdkxpZ2h0V2VpZ2h0aW5nO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J3Bob25nJzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuXHRcdFx0e1xuXHRcdFx0XHRcImFtYmllbnRcIiAgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDA1MDUwNSApIH0sXG5cdFx0XHRcdFwic3BlY3VsYXJcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICkgfSxcblx0XHRcdFx0XCJzaGluaW5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDMwIH1cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XCJ2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwiI2lmbmRlZiBVU0VfRU5WTUFQXCIsXG5cblx0XHRcdFx0XHRcInZlYzQgbVBvc2l0aW9uID0gb2JqZWN0TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XCJ2Vmlld1Bvc2l0aW9uID0gLW12UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcdFwidmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG5vcm1hbDtcIixcblx0XHRcdFx0XCJ2Tm9ybWFsID0gdHJhbnNmb3JtZWROb3JtYWw7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIiksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyAoIDEuMCApLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J3BhcnRpY2xlX2Jhc2ljJzoge1xuXG5cdFx0dW5pZm9ybXM6ICBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInBhcnRpY2xlXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2l6ZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXCIsXG5cdFx0XHRcdFx0XCJnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIGxlbmd0aCggbXZQb3NpdGlvbi54eXogKSApO1wiLFxuXHRcdFx0XHRcIiNlbHNlXCIsXG5cdFx0XHRcdFx0XCJnbF9Qb2ludFNpemUgPSBzaXplO1wiLFxuXHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIHBzQ29sb3I7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggcHNDb2xvciwgb3BhY2l0eSApO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0Ly8gRGVwdGggZW5jb2RpbmcgaW50byBSR0JBIHRleHR1cmVcblx0Ly8gXHRiYXNlZCBvbiBTcGlkZXJHTCBzaGFkb3cgbWFwIGV4YW1wbGVcblx0Ly8gXHRcdGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxuXHQvLyBcdG9yaWdpbmFsbHkgZnJvbVxuXHQvL1x0XHRodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzQ0MjEzOC1wYWNraW5nLWEtZmxvYXQtaW50by1hLWE4cjhnOGI4LXRleHR1cmUtc2hhZGVyL3BhZ2VfX3doaWNocGFnZV9fMSUyNUVGJTI1QkYlMjVCRFxuXHQvLyBcdHNlZSBhbHNvIGhlcmU6XG5cdC8vXHRcdGh0dHA6Ly9hcmFzLXAuaW5mby9ibG9nLzIwMDkvMDcvMzAvZW5jb2RpbmctZmxvYXRzLXRvLXJnYmEtdGhlLWZpbmFsL1xuXG5cdCdkZXB0aFJHQkEnOiB7XG5cblx0XHR1bmlmb3Jtczoge30sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcInZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIiksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIsXG5cblx0XHRcdFx0XCJjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxuXHRcdFx0XHRcImNvbnN0IHZlYzQgYml0X21hc2sgID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXG5cdFx0XHRcdFwidmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcblx0XHRcdFx0XCJyZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcIixcblx0XHRcdFx0XCJyZXR1cm4gcmVzO1wiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogKTtcIixcblxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcblx0XHRcdFx0Ly9cImZsb2F0IHogPSAoICggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApIC0gMy4wICkgLyAoIDQwMDAuMCAtIDMuMCApO1wiLFxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIHogKTtcIixcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH1cblxufTsvKipcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdC8vIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnNcblxuXHR2YXIgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge30sXG5cblx0X2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICksXG5cblx0X3ByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXG5cdF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcblx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG5cdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcblxuXHRfY2xlYXJDb2xvciA9IHBhcmFtZXRlcnMuY2xlYXJDb2xvciAhPT0gdW5kZWZpbmVkID8gbmV3IFRIUkVFLkNvbG9yKCBwYXJhbWV0ZXJzLmNsZWFyQ29sb3IgKSA6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSxcblx0X2NsZWFyQWxwaGEgPSBwYXJhbWV0ZXJzLmNsZWFyQWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2xlYXJBbHBoYSA6IDAsXG5cblx0X21heExpZ2h0cyA9IHBhcmFtZXRlcnMubWF4TGlnaHRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLm1heExpZ2h0cyA6IDQ7XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXHR0aGlzLmNvbnRleHQgPSBudWxsO1xuXG5cdC8vIGNsZWFyaW5nXG5cblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHR0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcblx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cblx0Ly8gc2NlbmUgZ3JhcGhcblxuXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblxuXHR0aGlzLmF1dG9VcGRhdGVPYmplY3RzID0gdHJ1ZTtcblx0dGhpcy5hdXRvVXBkYXRlU2NlbmUgPSB0cnVlO1xuXG5cdC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xuXG5cdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xuXHR0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XG5cdHRoaXMucGh5c2ljYWxseUJhc2VkU2hhZGluZyA9IGZhbHNlO1xuXG5cdC8vIHNoYWRvdyBtYXBcblxuXHR0aGlzLnNoYWRvd01hcEJpYXMgPSAwLjAwMzk7XG5cdHRoaXMuc2hhZG93TWFwRGFya25lc3MgPSAwLjU7XG5cdHRoaXMuc2hhZG93TWFwV2lkdGggPSA1MTI7XG5cdHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gNTEyO1xuXG5cdHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IDE7XG5cdHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcblx0dGhpcy5zaGFkb3dDYW1lcmFGb3YgPSA1MDtcblxuXHR0aGlzLnNoYWRvd01hcCA9IFtdO1xuXG5cdHRoaXMuc2hhZG93TWFwRW5hYmxlZCA9IGZhbHNlO1xuXHR0aGlzLnNoYWRvd01hcEF1dG9VcGRhdGUgPSB0cnVlO1xuXHR0aGlzLnNoYWRvd01hcFNvZnQgPSB0cnVlO1xuXG5cdC8vIG1vcnBoc1xuXG5cdHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcblxuXHQvLyBpbmZvXG5cblx0dGhpcy5pbmZvID0ge1xuXG5cdFx0bWVtb3J5OiB7XG5cblx0XHRcdHByb2dyYW1zOiAwLFxuXHRcdFx0Z2VvbWV0cmllczogMCxcblx0XHRcdHRleHR1cmVzOiAwXG5cblx0XHR9LFxuXG5cdFx0cmVuZGVyOiB7XG5cblx0XHRcdGNhbGxzOiAwLFxuXHRcdFx0dmVydGljZXM6IDAsXG5cdFx0XHRmYWNlczogMFxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG5cdHZhciBfdGhpcyA9IHRoaXMsXG5cblx0X2dsLFxuXG5cdF9wcm9ncmFtcyA9IFtdLFxuXG5cdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cblx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbCxcblx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXG5cdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xLFxuXHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gbnVsbCxcblx0X2dlb21ldHJ5R3JvdXBDb3VudGVyID0gMCxcblxuXHQvLyBHTCBzdGF0ZSBjYWNoZVxuXG5cdF9vbGREb3VibGVTaWRlZCA9IG51bGwsXG5cdF9vbGRGbGlwU2lkZWQgPSBudWxsLFxuXHRfb2xkQmxlbmRpbmcgPSBudWxsLFxuXHRfb2xkRGVwdGhUZXN0ID0gbnVsbCxcblx0X29sZERlcHRoV3JpdGUgPSBudWxsLFxuXHRfb2xkUG9seWdvbk9mZnNldCA9IG51bGwsXG5cdF9vbGRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbCxcblx0X29sZFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGwsXG5cdF9vbGRMaW5lV2lkdGggPSBudWxsLFxuXG5cdF92aWV3cG9ydFggPSAwLFxuXHRfdmlld3BvcnRZID0gMCxcblx0X3ZpZXdwb3J0V2lkdGggPSAwLFxuXHRfdmlld3BvcnRIZWlnaHQgPSAwLFxuXG5cdC8vIGZydXN0dW0gY2FjaGVcblxuXHRfZnJ1c3R1bSA9IFtcblx0XHRuZXcgVEhSRUUuVmVjdG9yNCgpLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3I0KCksXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjQoKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yNCgpLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3I0KCksXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjQoKVxuXHQgXSxcblxuXHQgLy8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXHRfcHJvamVjdGlvbk1hdHJpeEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKSxcblx0X3ZpZXdNYXRyaXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICksXG5cblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yNCgpLFxuXG5cdC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxuXG5cdF9saWdodHMgPSB7XG5cblx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcblx0XHRkaXJlY3Rpb25hbDogeyBsZW5ndGg6IDAsIGNvbG9yczogbmV3IEFycmF5KCksIHBvc2l0aW9uczogbmV3IEFycmF5KCkgfSxcblx0XHRwb2ludDogeyBsZW5ndGg6IDAsIGNvbG9yczogbmV3IEFycmF5KCksIHBvc2l0aW9uczogbmV3IEFycmF5KCksIGRpc3RhbmNlczogbmV3IEFycmF5KCkgfVxuXG5cdH07XG5cblx0Ly8gc2hhZG93IG1hcHNcblxuXHR2YXIgX2NhbWVyYUxpZ2h0LCBfc2hhZG93TWF0cml4ID0gW107XG5cdHZhciBfZGVwdGhNYXRlcmlhbCwgX2RlcHRoTWF0ZXJpYWxNb3JwaDtcblxuXHQvLyBzcHJpdGVzXG5cblx0dmFyIF9zcHJpdGUgPSB7fTtcblx0dmFyIF9zcHJpdGVBdHRyaWJ1dGVzRW5hYmxlZCA9IGZhbHNlO1xuXG5cdC8vIGluaXRpYWxpemVcblxuXHRfZ2wgPSBpbml0R0woKTtcblxuXHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG5cdGluaXRTcHJpdGVzKCk7XG5cdGluaXRTaGFkb3dtYXBzKCk7XG5cblx0dGhpcy5jb250ZXh0ID0gX2dsO1xuXG5cdHZhciBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9ICggbWF4VmVydGV4VGV4dHVyZXMoKSA+IDAgKTtcblxuXHQvLyBBUElcblxuXHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gX2dsO1xuXG5cdH07XG5cblx0dGhpcy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzO1xuXG5cdH07XG5cblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgX2NhbnZhcy53aWR0aCwgX2NhbnZhcy5oZWlnaHQgKTtcblxuXHR9O1xuXG5cdHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRfdmlld3BvcnRYID0geDtcblx0XHRfdmlld3BvcnRZID0geTtcblxuXHRcdF92aWV3cG9ydFdpZHRoID0gd2lkdGg7XG5cdFx0X3ZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0X2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XG5cblx0fTtcblxuXHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRfZ2wuc2Npc3NvciggeCwgeSwgd2lkdGgsIGhlaWdodCApO1xuXG5cdH07XG5cblx0dGhpcy5lbmFibGVTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggZW5hYmxlICkge1xuXG5cdFx0ZW5hYmxlID8gX2dsLmVuYWJsZSggX2dsLlNDSVNTT1JfVEVTVCApIDogX2dsLmRpc2FibGUoIF9nbC5TQ0lTU09SX1RFU1QgKTtcblxuXHR9O1xuXG5cdC8vIENsZWFyaW5nXG5cblx0dGhpcy5zZXRDbGVhckNvbG9ySGV4ID0gZnVuY3Rpb24gKCBoZXgsIGFscGhhICkge1xuXG5cdFx0X2NsZWFyQ29sb3Iuc2V0SGV4KCBoZXggKTtcblx0XHRfY2xlYXJBbHBoYSA9IGFscGhhO1xuXG5cdFx0X2dsLmNsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cblx0fTtcblxuXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcblxuXHRcdF9jbGVhckNvbG9yLmNvcHkoIGNvbG9yICk7XG5cdFx0X2NsZWFyQWxwaGEgPSBhbHBoYTtcblxuXHRcdF9nbC5jbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG5cdH07XG5cblx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9jbGVhckNvbG9yO1xuXG5cdH07XG5cblx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9jbGVhckFscGhhO1xuXG5cdH07XG5cblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG5cdFx0dmFyIGJpdHMgPSAwO1xuXG5cdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkIHx8IGNvbG9yICkgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcblx0XHRpZiAoIGRlcHRoID09PSB1bmRlZmluZWQgfHwgZGVwdGggKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xuXHRcdGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cblx0XHRfZ2wuY2xlYXIoIGJpdHMgKTtcblxuXHR9O1xuXG5cdHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG5cdFx0c2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHR0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcblxuXHR9O1xuXG5cdC8vIERlYWxsb2NhdGlvblxuXG5cdHRoaXMuZGVhbGxvY2F0ZU9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCAhIG9iamVjdC5fX3dlYmdsSW5pdCApIHJldHVybjtcblxuXHRcdG9iamVjdC5fX3dlYmdsSW5pdCA9IGZhbHNlO1xuXG5cdFx0ZGVsZXRlIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4O1xuXG5cdFx0ZGVsZXRlIG9iamVjdC5fbm9ybWFsTWF0cml4QXJyYXk7XG5cdFx0ZGVsZXRlIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4QXJyYXk7XG5cdFx0ZGVsZXRlIG9iamVjdC5fb2JqZWN0TWF0cml4QXJyYXk7XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdGZvciAoIHZhciBnIGluIG9iamVjdC5nZW9tZXRyeS5nZW9tZXRyeUdyb3VwcyApIHtcblxuXHRcdFx0XHRkZWxldGVNZXNoQnVmZmVycyggb2JqZWN0Lmdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUmliYm9uICkge1xuXG5cdFx0XHRkZWxldGVSaWJib25CdWZmZXJzKCBvYmplY3QuZ2VvbWV0cnkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdGRlbGV0ZUxpbmVCdWZmZXJzKCBvYmplY3QuZ2VvbWV0cnkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkge1xuXG5cdFx0XHRkZWxldGVQYXJ0aWNsZUJ1ZmZlcnMoIG9iamVjdC5nZW9tZXRyeSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5kZWFsbG9jYXRlVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdGlmICggISB0ZXh0dXJlLl9fd2ViZ2xJbml0ICkgcmV0dXJuO1xuXG5cdFx0dGV4dHVyZS5fX3dlYmdsSW5pdCA9IGZhbHNlO1xuXHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XG5cblx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyAtLTtcblxuXHR9O1xuXG5cdC8vIFJlbmRlcmluZ1xuXG5cdHRoaXMudXBkYXRlU2hhZG93TWFwID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0cmVuZGVyU2hhZG93TWFwKCBzY2VuZSwgY2FtZXJhICk7XG5cblx0fTtcblxuXHQvLyBJbnRlcm5hbCBmdW5jdGlvbnNcblxuXHQvLyBCdWZmZXIgYWxsb2NhdGlvblxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhcnRpY2xlQnVmZmVycyAoIGdlb21ldHJ5ICkge1xuXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRfdGhpcy5pbmZvLmdlb21ldHJpZXMgKys7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVMaW5lQnVmZmVycyAoIGdlb21ldHJ5ICkge1xuXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlUmliYm9uQnVmZmVycyAoIGdlb21ldHJ5ICkge1xuXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlTWVzaEJ1ZmZlcnMgKCBnZW9tZXRyeUdyb3VwICkge1xuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbE5vcm1hbEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbENvbG9yQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5WZXJ0ZXhBQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5WZXJ0ZXhCQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0dmFyIG0sIG1sO1xuXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzID0gW107XG5cblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVycy5wdXNoKCBfZ2wuY3JlYXRlQnVmZmVyKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuXHRmdW5jdGlvbiBkZWxldGVQYXJ0aWNsZUJ1ZmZlcnMgKCBnZW9tZXRyeSApIHtcblxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XG5cblx0fTtcblxuXHRmdW5jdGlvbiBkZWxldGVMaW5lQnVmZmVycyAoIGdlb21ldHJ5ICkge1xuXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGRlbGV0ZVJpYmJvbkJ1ZmZlcnMgKCBnZW9tZXRyeSApIHtcblxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XG5cblx0fTtcblxuXHRmdW5jdGlvbiBkZWxldGVNZXNoQnVmZmVycyAoIGdlb21ldHJ5R3JvdXAgKSB7XG5cblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyICk7XG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVkJ1ZmZlciApO1xuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciApO1xuXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpblZlcnRleEFCdWZmZXIgKTtcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luVmVydGV4QkJ1ZmZlciApO1xuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyICk7XG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIgKTtcblxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgKTtcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQnVmZmVyICk7XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHM7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBtIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaWQgaW4gZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgKSB7XG5cblx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3RbIGlkIF0uYnVmZmVyICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XG5cblx0fTtcblxuXHQvLyBCdWZmZXIgaW5pdGlhbGl6YXRpb25cblxuXHRmdW5jdGlvbiBpbml0Q3VzdG9tQXR0cmlidXRlcyAoIGdlb21ldHJ5LCBvYmplY3QgKSB7XG5cblx0XHR2YXIgbnZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBhIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXNbIGEgXTtcblxuXHRcdFx0XHRpZiggIWF0dHJpYnV0ZS5fX3dlYmdsSW5pdGlhbGl6ZWQgfHwgYXR0cmlidXRlLmNyZWF0ZVVuaXF1ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHZhciBzaXplID0gMTtcdFx0Ly8gXCJmXCIgYW5kIFwiaVwiXG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS50eXBlID09PSBcInYyXCIgKSBzaXplID0gMjtcblx0XHRcdFx0XHRlbHNlIGlmICggYXR0cmlidXRlLnR5cGUgPT09IFwidjNcIiApIHNpemUgPSAzO1xuXHRcdFx0XHRcdGVsc2UgaWYgKCBhdHRyaWJ1dGUudHlwZSA9PT0gXCJ2NFwiICkgc2l6ZSA9IDQ7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSBcImNcIiAgKSBzaXplID0gMztcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5zaXplID0gc2l6ZTtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIHNpemUgKTtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgPSBhO1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LnB1c2goIGF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBpbml0UGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnksIG9iamVjdCApIHtcblxuXHRcdHZhciBudmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRnZW9tZXRyeS5fX3ZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXHRcdGdlb21ldHJ5Ll9fY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcblxuXHRcdGdlb21ldHJ5Ll9fc29ydEFycmF5ID0gW107XG5cblx0XHRnZW9tZXRyeS5fX3dlYmdsUGFydGljbGVDb3VudCA9IG52ZXJ0aWNlcztcblxuXHRcdGluaXRDdXN0b21BdHRyaWJ1dGVzICggZ2VvbWV0cnksIG9iamVjdCApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdExpbmVCdWZmZXJzICggZ2VvbWV0cnksIG9iamVjdCApIHtcblxuXHRcdHZhciBudmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRnZW9tZXRyeS5fX3ZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXHRcdGdlb21ldHJ5Ll9fY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcblxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xMaW5lQ291bnQgPSBudmVydGljZXM7XG5cblx0XHRpbml0Q3VzdG9tQXR0cmlidXRlcyAoIGdlb21ldHJ5LCBvYmplY3QgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXRSaWJib25CdWZmZXJzICggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgbnZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0Z2VvbWV0cnkuX192ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcblx0XHRnZW9tZXRyeS5fX2NvbG9yQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XG5cblx0XHRnZW9tZXRyeS5fX3dlYmdsVmVydGV4Q291bnQgPSBudmVydGljZXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBpbml0TWVzaEJ1ZmZlcnMgKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKSB7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnksXG5cdFx0XHRmYWNlczMgPSBnZW9tZXRyeUdyb3VwLmZhY2VzMyxcblx0XHRcdGZhY2VzNCA9IGdlb21ldHJ5R3JvdXAuZmFjZXM0LFxuXG5cdFx0XHRudmVydGljZXMgPSBmYWNlczMubGVuZ3RoICogMyArIGZhY2VzNC5sZW5ndGggKiA0LFxuXHRcdFx0bnRyaXMgICAgID0gZmFjZXMzLmxlbmd0aCAqIDEgKyBmYWNlczQubGVuZ3RoICogMixcblx0XHRcdG5saW5lcyAgICA9IGZhY2VzMy5sZW5ndGggKiAzICsgZmFjZXM0Lmxlbmd0aCAqIDQsXG5cblx0XHRcdG1hdGVyaWFsID0gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnlHcm91cCApLFxuXG5cdFx0XHR1dlR5cGUgPSBidWZmZXJHdWVzc1VWVHlwZSggbWF0ZXJpYWwgKSxcblx0XHRcdG5vcm1hbFR5cGUgPSBidWZmZXJHdWVzc05vcm1hbFR5cGUoIG1hdGVyaWFsICksXG5cdFx0XHR2ZXJ0ZXhDb2xvclR5cGUgPSBidWZmZXJHdWVzc1ZlcnRleENvbG9yVHlwZSggbWF0ZXJpYWwgKTtcblxuXHRcdC8vY29uc29sZS5sb2coIFwidXZUeXBlXCIsIHV2VHlwZSwgXCJub3JtYWxUeXBlXCIsIG5vcm1hbFR5cGUsIFwidmVydGV4Q29sb3JUeXBlXCIsIHZlcnRleENvbG9yVHlwZSwgb2JqZWN0LCBnZW9tZXRyeUdyb3VwLCBtYXRlcmlhbCApO1xuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3ZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXG5cdFx0aWYgKCBub3JtYWxUeXBlICkge1xuXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fbm9ybWFsQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5Lmhhc1RhbmdlbnRzICkge1xuXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fdGFuZ2VudEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogNCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB2ZXJ0ZXhDb2xvclR5cGUgKSB7XG5cblx0XHRcdGdlb21ldHJ5R3JvdXAuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1dlR5cGUgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuZmFjZVV2cy5sZW5ndGggPiAwIHx8IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fdXZBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmZhY2VVdnMubGVuZ3RoID4gMSB8fCBnZW9tZXRyeS5mYWNlVmVydGV4VXZzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3V2MkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggJiYgb2JqZWN0Lmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCApIHtcblxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3NraW5WZXJ0ZXhBQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiA0ICk7XG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fc2tpblZlcnRleEJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDQgKTtcblx0XHRcdGdlb21ldHJ5R3JvdXAuX19za2luSW5kZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDQgKTtcblx0XHRcdGdlb21ldHJ5R3JvdXAuX19za2luV2VpZ2h0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiA0ICk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeUdyb3VwLl9fZmFjZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBudHJpcyAqIDMgKTtcblx0XHRnZW9tZXRyeUdyb3VwLl9fbGluZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBubGluZXMgKiAyICk7XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhUYXJnZXRzQXJyYXlzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0czsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX19tb3JwaFRhcmdldHNBcnJheXMucHVzaCggbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VDb3VudCA9IG50cmlzICogMztcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQ291bnQgPSBubGluZXMgKiAyO1xuXG5cblx0XHQvLyBjdXN0b20gYXR0cmlidXRlc1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgYSBpbiBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIERvIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhdHRyaWJ1dGUgb2JqZWN0IHNvIGRpZmZlcmVudCBnZW9tZXRyeUdyb3VwIGNodW5rcyB1c2UgZGlmZmVyZW50XG5cdFx0XHRcdC8vIGF0dHJpYnV0ZSBidWZmZXJzIHdoaWNoIGFyZSBjb3JyZWN0bHkgaW5kZXhlZCBpbiB0aGUgc2V0TWVzaEJ1ZmZlcnMgZnVuY3Rpb25cblxuXHRcdFx0XHR2YXIgb3JpZ2luYWxBdHRyaWJ1dGUgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzWyBhIF07XG5cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHt9O1xuXG5cdFx0XHRcdGZvciAoIHZhciBwcm9wZXJ0eSBpbiBvcmlnaW5hbEF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZVsgcHJvcGVydHkgXSA9IG9yaWdpbmFsQXR0cmlidXRlWyBwcm9wZXJ0eSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggIWF0dHJpYnV0ZS5fX3dlYmdsSW5pdGlhbGl6ZWQgfHwgYXR0cmlidXRlLmNyZWF0ZVVuaXF1ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHZhciBzaXplID0gMTtcdFx0Ly8gXCJmXCIgYW5kIFwiaVwiXG5cblx0XHRcdFx0XHRpZiggYXR0cmlidXRlLnR5cGUgPT09IFwidjJcIiApIHNpemUgPSAyO1xuXHRcdFx0XHRcdGVsc2UgaWYoIGF0dHJpYnV0ZS50eXBlID09PSBcInYzXCIgKSBzaXplID0gMztcblx0XHRcdFx0XHRlbHNlIGlmKCBhdHRyaWJ1dGUudHlwZSA9PT0gXCJ2NFwiICkgc2l6ZSA9IDQ7XG5cdFx0XHRcdFx0ZWxzZSBpZiggYXR0cmlidXRlLnR5cGUgPT09IFwiY1wiICApIHNpemUgPSAzO1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLnNpemUgPSBzaXplO1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogc2l6ZSApO1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLmJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZSA9IGE7XG5cblx0XHRcdFx0XHRvcmlnaW5hbEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fb3JpZ2luYWwgPSBvcmlnaW5hbEF0dHJpYnV0ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QucHVzaCggYXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5R3JvdXAuX19pbml0dGVkQXJyYXlzID0gdHJ1ZTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKSB7XG5cblx0XHRpZiAoIG9iamVjdC5tYXRlcmlhbCAmJiAhICggb2JqZWN0Lm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApICkge1xuXG5cdFx0XHRyZXR1cm4gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0fSBlbHNlIGlmICggZ2VvbWV0cnlHcm91cC5tYXRlcmlhbEluZGV4ID49IDAgKSB7XG5cblx0XHRcdHJldHVybiBvYmplY3QuZ2VvbWV0cnkubWF0ZXJpYWxzWyBnZW9tZXRyeUdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIG1hdGVyaWFsTmVlZHNTbW9vdGhOb3JtYWxzICggbWF0ZXJpYWwgKSB7XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWwgJiYgbWF0ZXJpYWwuc2hhZGluZyAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBidWZmZXJHdWVzc05vcm1hbFR5cGUgKCBtYXRlcmlhbCApIHtcblxuXHRcdC8vIG9ubHkgTWVzaEJhc2ljTWF0ZXJpYWwgYW5kIE1lc2hEZXB0aE1hdGVyaWFsIGRvbid0IG5lZWQgbm9ybWFsc1xuXG5cdFx0aWYgKCAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgJiYgIW1hdGVyaWFsLmVudk1hcCApIHx8IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxOZWVkc1Ntb290aE5vcm1hbHMoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdHJldHVybiBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIFRIUkVFLkZsYXRTaGFkaW5nO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gYnVmZmVyR3Vlc3NWZXJ0ZXhDb2xvclR5cGUgKCBtYXRlcmlhbCApIHtcblxuXHRcdGlmICggbWF0ZXJpYWwudmVydGV4Q29sb3JzICkge1xuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWwudmVydGV4Q29sb3JzO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gYnVmZmVyR3Vlc3NVVlR5cGUgKCBtYXRlcmlhbCApIHtcblxuXHRcdC8vIG1hdGVyaWFsIG11c3QgdXNlIHNvbWUgdGV4dHVyZSB0byByZXF1aXJlIHV2c1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5tYXAgfHwgbWF0ZXJpYWwubGlnaHRNYXAgfHwgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fTtcblxuXHQvLyBCdWZmZXIgc2V0dGluZ1xuXG5cdGZ1bmN0aW9uIHNldFBhcnRpY2xlQnVmZmVycyAoIGdlb21ldHJ5LCBoaW50LCBvYmplY3QgKSB7XG5cblx0XHR2YXIgdiwgYywgdmVydGV4LCBvZmZzZXQsIGluZGV4LCBjb2xvcixcblxuXHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXG5cdFx0dmwgPSB2ZXJ0aWNlcy5sZW5ndGgsXG5cblx0XHRjb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnMsXG5cdFx0Y2wgPSBjb2xvcnMubGVuZ3RoLFxuXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeS5fX2NvbG9yQXJyYXksXG5cblx0XHRzb3J0QXJyYXkgPSBnZW9tZXRyeS5fX3NvcnRBcnJheSxcblxuXHRcdGRpcnR5VmVydGljZXMgPSBnZW9tZXRyeS5fX2RpcnR5VmVydGljZXMsXG5cdFx0ZGlydHlFbGVtZW50cyA9IGdlb21ldHJ5Ll9fZGlydHlFbGVtZW50cyxcblx0XHRkaXJ0eUNvbG9ycyA9IGdlb21ldHJ5Ll9fZGlydHlDb2xvcnMsXG5cblx0XHRjdXN0b21BdHRyaWJ1dGVzID0gZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxuXHRcdGksIGlsLFxuXHRcdGEsIGNhLCBjYWwsIHZhbHVlLFxuXHRcdGN1c3RvbUF0dHJpYnV0ZTtcblxuXHRcdGlmICggb2JqZWN0LnNvcnRQYXJ0aWNsZXMgKSB7XG5cblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5U2VsZiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdFx0dmVydGV4ID0gdmVydGljZXNbIHYgXS5wb3NpdGlvbjtcblxuXHRcdFx0XHRfdmVjdG9yMy5jb3B5KCB2ZXJ0ZXggKTtcblx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlWZWN0b3IzKCBfdmVjdG9yMyApO1xuXG5cdFx0XHRcdHNvcnRBcnJheVsgdiBdID0gWyBfdmVjdG9yMy56LCB2IF07XG5cblx0XHRcdH1cblxuXHRcdFx0c29ydEFycmF5LnNvcnQoIGZ1bmN0aW9uKCBhLCBiICkgeyByZXR1cm4gYlsgMCBdIC0gYVsgMCBdOyB9ICk7XG5cblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdFx0dmVydGV4ID0gdmVydGljZXNbIHNvcnRBcnJheVt2XVsxXSBdLnBvc2l0aW9uO1xuXG5cdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xuXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2ZXJ0ZXgueDtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHZlcnRleC55O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdmVydGV4Lno7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcblxuXHRcdFx0XHRvZmZzZXQgPSBjICogMztcblxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1sgc29ydEFycmF5W2NdWzFdIF07XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3Iucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggISAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApICkgY29udGludWU7XG5cblx0XHRcdFx0XHRvZmZzZXQgPSAwO1xuXG5cdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBjYSBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAzICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSBcImNcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XG5cblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICAgID0gdmFsdWUucjtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS5iO1xuXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUueDtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS56O1xuXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgICAgPSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgIF0gPSB2YWx1ZS55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDMgIF0gPSB2YWx1ZS53O1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSA0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGRpcnR5VmVydGljZXMgKSB7XG5cblx0XHRcdFx0Zm9yICggdiA9IDA7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF0ucG9zaXRpb247XG5cblx0XHRcdFx0XHRvZmZzZXQgPSB2ICogMztcblxuXHRcdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2ZXJ0ZXgueDtcblx0XHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHZlcnRleC56O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRpcnR5Q29sb3JzICkge1xuXG5cdFx0XHRcdGZvciAoIGMgPSAwOyBjIDwgY2w7IGMgKysgKSB7XG5cblx0XHRcdFx0XHRjb2xvciA9IGNvbG9yc1sgYyBdO1xuXG5cdFx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XG5cblx0XHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yO1xuXHRcdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmc7XG5cdFx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSAmJlxuXHRcdFx0XHRcdCAgICAgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0XHQgICBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJ2ZXJ0aWNlc1wiKSApIHtcblxuXHRcdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gMDtcblxuXHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcblxuXHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAyO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLnI7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICAgICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUubmVlZHNVcGRhdGUgfHwgb2JqZWN0LnNvcnRQYXJ0aWNsZXMgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmJ1ZmZlciApO1xuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYXJyYXksIGhpbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0TGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgaGludCApIHtcblxuXHRcdHZhciB2LCBjLCB2ZXJ0ZXgsIG9mZnNldCwgY29sb3IsXG5cblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxuXHRcdGNvbG9ycyA9IGdlb21ldHJ5LmNvbG9ycyxcblx0XHR2bCA9IHZlcnRpY2VzLmxlbmd0aCxcblx0XHRjbCA9IGNvbG9ycy5sZW5ndGgsXG5cblx0XHR2ZXJ0ZXhBcnJheSA9IGdlb21ldHJ5Ll9fdmVydGV4QXJyYXksXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5Ll9fY29sb3JBcnJheSxcblxuXHRcdGRpcnR5VmVydGljZXMgPSBnZW9tZXRyeS5fX2RpcnR5VmVydGljZXMsXG5cdFx0ZGlydHlDb2xvcnMgPSBnZW9tZXRyeS5fX2RpcnR5Q29sb3JzLFxuXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCxcblxuXHRcdGksIGlsLFxuXHRcdGEsIGNhLCBjYWwsIHZhbHVlLFxuXHRcdGN1c3RvbUF0dHJpYnV0ZTtcblxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcblxuXHRcdFx0Zm9yICggdiA9IDA7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgdiBdLnBvc2l0aW9uO1xuXG5cdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xuXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2ZXJ0ZXgueDtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHZlcnRleC55O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdmVydGV4Lno7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyApIHtcblxuXHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcblxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1sgYyBdO1xuXG5cdFx0XHRcdG9mZnNldCA9IGMgKiAzO1xuXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnI7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmc7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmI7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUubmVlZHNVcGRhdGUgJiZcblx0XHRcdFx0XHQgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0ICAgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApICkge1xuXG5cdFx0XHRcdFx0b2Zmc2V0ID0gMDtcblxuXHRcdFx0XHRcdGNhbCA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZS5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIGNhIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAyICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAzICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSBcImNcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUucjtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS5iO1xuXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0ID0gdmFsdWUueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyICBdID0gdmFsdWUuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAzICBdID0gdmFsdWUudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5idWZmZXIgKTtcblx0XHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmFycmF5LCBoaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXRSaWJib25CdWZmZXJzICggZ2VvbWV0cnksIGhpbnQgKSB7XG5cblx0XHR2YXIgdiwgYywgdmVydGV4LCBvZmZzZXQsIGNvbG9yLFxuXG5cdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcblx0XHRjb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnMsXG5cdFx0dmwgPSB2ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0Y2wgPSBjb2xvcnMubGVuZ3RoLFxuXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeS5fX2NvbG9yQXJyYXksXG5cblx0XHRkaXJ0eVZlcnRpY2VzID0gZ2VvbWV0cnkuX19kaXJ0eVZlcnRpY2VzLFxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuX19kaXJ0eUNvbG9ycztcblxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcblxuXHRcdFx0Zm9yICggdiA9IDA7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgdiBdLnBvc2l0aW9uO1xuXG5cdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xuXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2ZXJ0ZXgueDtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHZlcnRleC55O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdmVydGV4Lno7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyApIHtcblxuXHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcblxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1sgYyBdO1xuXG5cdFx0XHRcdG9mZnNldCA9IGMgKiAzO1xuXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnI7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmc7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmI7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QsIGhpbnQsIGRpc3Bvc2UsIG1hdGVyaWFsICkge1xuXG5cdFx0aWYgKCAhIGdlb21ldHJ5R3JvdXAuX19pbml0dGVkQXJyYXlzICkge1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyggb2JqZWN0ICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgbm9ybWFsVHlwZSA9IGJ1ZmZlckd1ZXNzTm9ybWFsVHlwZSggbWF0ZXJpYWwgKSxcblx0XHR2ZXJ0ZXhDb2xvclR5cGUgPSBidWZmZXJHdWVzc1ZlcnRleENvbG9yVHlwZSggbWF0ZXJpYWwgKSxcblx0XHR1dlR5cGUgPSBidWZmZXJHdWVzc1VWVHlwZSggbWF0ZXJpYWwgKSxcblxuXHRcdG5lZWRzU21vb3RoTm9ybWFscyA9ICggbm9ybWFsVHlwZSA9PT0gVEhSRUUuU21vb3RoU2hhZGluZyApO1xuXG5cdFx0dmFyIGYsIGZsLCBmaSwgZmFjZSxcblx0XHR2ZXJ0ZXhOb3JtYWxzLCBmYWNlTm9ybWFsLCBub3JtYWwsXG5cdFx0dmVydGV4Q29sb3JzLCBmYWNlQ29sb3IsXG5cdFx0dmVydGV4VGFuZ2VudHMsXG5cdFx0dXYsIHV2MiwgdjEsIHYyLCB2MywgdjQsIHQxLCB0MiwgdDMsIHQ0LFxuXHRcdGMxLCBjMiwgYzMsIGM0LFxuXHRcdHN3MSwgc3cyLCBzdzMsIHN3NCxcblx0XHRzaTEsIHNpMiwgc2kzLCBzaTQsXG5cdFx0c2ExLCBzYTIsIHNhMywgc2E0LFxuXHRcdHNiMSwgc2IyLCBzYjMsIHNiNCxcblx0XHRtLCBtbCwgaSwgaWwsXG5cdFx0dm4sIHV2aSwgdXYyaSxcblx0XHR2aywgdmtsLCB2a2EsXG5cdFx0YSxcblxuXHRcdHZlcnRleEluZGV4ID0gMCxcblxuXHRcdG9mZnNldCA9IDAsXG5cdFx0b2Zmc2V0X3V2ID0gMCxcblx0XHRvZmZzZXRfdXYyID0gMCxcblx0XHRvZmZzZXRfZmFjZSA9IDAsXG5cdFx0b2Zmc2V0X25vcm1hbCA9IDAsXG5cdFx0b2Zmc2V0X3RhbmdlbnQgPSAwLFxuXHRcdG9mZnNldF9saW5lID0gMCxcblx0XHRvZmZzZXRfY29sb3IgPSAwLFxuXHRcdG9mZnNldF9za2luID0gMCxcblx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgPSAwLFxuXHRcdG9mZnNldF9jdXN0b20gPSAwLFxuXHRcdG9mZnNldF9jdXN0b21TcmMgPSAwLFxuXG5cdFx0dmFsdWUsXG5cblx0XHR2ZXJ0ZXhBcnJheSA9IGdlb21ldHJ5R3JvdXAuX192ZXJ0ZXhBcnJheSxcblx0XHR1dkFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3V2QXJyYXksXG5cdFx0dXYyQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fdXYyQXJyYXksXG5cdFx0bm9ybWFsQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fbm9ybWFsQXJyYXksXG5cdFx0dGFuZ2VudEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3RhbmdlbnRBcnJheSxcblx0XHRjb2xvckFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX2NvbG9yQXJyYXksXG5cblx0XHRza2luVmVydGV4QUFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3NraW5WZXJ0ZXhBQXJyYXksXG5cdFx0c2tpblZlcnRleEJBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19za2luVmVydGV4QkFycmF5LFxuXHRcdHNraW5JbmRleEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5LFxuXHRcdHNraW5XZWlnaHRBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19za2luV2VpZ2h0QXJyYXksXG5cblx0XHRtb3JwaFRhcmdldHNBcnJheXMgPSBnZW9tZXRyeUdyb3VwLl9fbW9ycGhUYXJnZXRzQXJyYXlzLFxuXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxuXHRcdGN1c3RvbUF0dHJpYnV0ZSxcblxuXHRcdGZhY2VBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXksXG5cdFx0bGluZUFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX2xpbmVBcnJheSxcblxuXHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LCAvLyB0aGlzIGlzIHNoYXJlZCBmb3IgYWxsIGNodW5rc1xuXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5Ll9fZGlydHlWZXJ0aWNlcyxcblx0XHRkaXJ0eUVsZW1lbnRzID0gZ2VvbWV0cnkuX19kaXJ0eUVsZW1lbnRzLFxuXHRcdGRpcnR5VXZzID0gZ2VvbWV0cnkuX19kaXJ0eVV2cyxcblx0XHRkaXJ0eU5vcm1hbHMgPSBnZW9tZXRyeS5fX2RpcnR5Tm9ybWFscyxcblx0XHRkaXJ0eVRhbmdlbnRzID0gZ2VvbWV0cnkuX19kaXJ0eVRhbmdlbnRzLFxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuX19kaXJ0eUNvbG9ycyxcblx0XHRkaXJ0eU1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Ll9fZGlydHlNb3JwaFRhcmdldHMsXG5cblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxuXHRcdGNodW5rX2ZhY2VzMyA9IGdlb21ldHJ5R3JvdXAuZmFjZXMzLFxuXHRcdGNodW5rX2ZhY2VzNCA9IGdlb21ldHJ5R3JvdXAuZmFjZXM0LFxuXHRcdG9ial9mYWNlcyA9IGdlb21ldHJ5LmZhY2VzLFxuXG5cdFx0b2JqX3V2cyAgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0sXG5cdFx0b2JqX3V2czIgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAxIF0sXG5cblx0XHRvYmpfY29sb3JzID0gZ2VvbWV0cnkuY29sb3JzLFxuXG5cdFx0b2JqX3NraW5WZXJ0aWNlc0EgPSBnZW9tZXRyeS5za2luVmVydGljZXNBLFxuXHRcdG9ial9za2luVmVydGljZXNCID0gZ2VvbWV0cnkuc2tpblZlcnRpY2VzQixcblx0XHRvYmpfc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcyxcblx0XHRvYmpfc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cyxcblxuXHRcdG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0djEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF0ucG9zaXRpb247XG5cdFx0XHRcdHYyID0gdmVydGljZXNbIGZhY2UuYiBdLnBvc2l0aW9uO1xuXHRcdFx0XHR2MyA9IHZlcnRpY2VzWyBmYWNlLmMgXS5wb3NpdGlvbjtcblxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0IF0gICAgID0gdjEueDtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHYxLnk7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2MS56O1xuXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAzIF0gPSB2Mi54O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNCBdID0gdjIueTtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDUgXSA9IHYyLno7XG5cblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDYgXSA9IHYzLng7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA3IF0gPSB2My55O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgOCBdID0gdjMuejtcblxuXHRcdFx0XHRvZmZzZXQgKz0gOTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXM0WyBmIF0gXTtcblxuXHRcdFx0XHR2MSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5wb3NpdGlvbjtcblx0XHRcdFx0djIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF0ucG9zaXRpb247XG5cdFx0XHRcdHYzID0gdmVydGljZXNbIGZhY2UuYyBdLnBvc2l0aW9uO1xuXHRcdFx0XHR2NCA9IHZlcnRpY2VzWyBmYWNlLmQgXS5wb3NpdGlvbjtcblxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0IF0gICAgID0gdjEueDtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHYxLnk7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2MS56O1xuXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAzIF0gPSB2Mi54O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNCBdID0gdjIueTtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDUgXSA9IHYyLno7XG5cblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDYgXSA9IHYzLng7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA3IF0gPSB2My55O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgOCBdID0gdjMuejtcblxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgOSBdICA9IHY0Lng7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxMCBdID0gdjQueTtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDExIF0gPSB2NC56O1xuXG5cdFx0XHRcdG9mZnNldCArPSAxMjtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdmVydGV4QXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlNb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdGZvciAoIHZrID0gMCwgdmtsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdmsgPCB2a2w7IHZrICsrICkge1xuXG5cdFx0XHRcdG9mZnNldF9tb3JwaFRhcmdldCA9IDA7XG5cblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XG5cblx0XHRcdFx0XHR2MSA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5hIF0ucG9zaXRpb247XG5cdFx0XHRcdFx0djIgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYiBdLnBvc2l0aW9uO1xuXHRcdFx0XHRcdHYzID0gbW9ycGhUYXJnZXRzWyB2ayBdLnZlcnRpY2VzWyBmYWNlLmMgXS5wb3NpdGlvbjtcblxuXHRcdFx0XHRcdHZrYSA9IG1vcnBoVGFyZ2V0c0FycmF5c1sgdmsgXTtcblxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0IF0gXHQgID0gdjEueDtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEgXSA9IHYxLnk7XG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAyIF0gPSB2MS56O1xuXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAzIF0gPSB2Mi54O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNCBdID0gdjIueTtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDUgXSA9IHYyLno7XG5cblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDYgXSA9IHYzLng7XG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA3IF0gPSB2My55O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgOCBdID0gdjMuejtcblxuXHRcdFx0XHRcdG9mZnNldF9tb3JwaFRhcmdldCArPSA5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xuXG5cdFx0XHRcdFx0djEgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYSBdLnBvc2l0aW9uO1xuXHRcdFx0XHRcdHYyID0gbW9ycGhUYXJnZXRzWyB2ayBdLnZlcnRpY2VzWyBmYWNlLmIgXS5wb3NpdGlvbjtcblx0XHRcdFx0XHR2MyA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5jIF0ucG9zaXRpb247XG5cdFx0XHRcdFx0djQgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuZCBdLnBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0dmthID0gbW9ycGhUYXJnZXRzQXJyYXlzWyB2ayBdO1xuXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgXSBcdCAgPSB2MS54O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMSBdID0gdjEueTtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDIgXSA9IHYxLno7XG5cblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDMgXSA9IHYyLng7XG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA0IF0gPSB2Mi55O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNSBdID0gdjIuejtcblxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNiBdID0gdjMueDtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDcgXSA9IHYzLnk7XG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA4IF0gPSB2My56O1xuXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA5IF0gID0gdjQueDtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEwIF0gPSB2NC55O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMTEgXSA9IHY0Lno7XG5cblx0XHRcdFx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgKz0gMTI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyB2ayBdICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBtb3JwaFRhcmdldHNBcnJheXNbIHZrIF0sIGhpbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmpfc2tpbldlaWdodHMubGVuZ3RoICkge1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XG5cblx0XHRcdFx0Ly8gd2VpZ2h0c1xuXG5cdFx0XHRcdHN3MSA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5hIF07XG5cdFx0XHRcdHN3MiA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5iIF07XG5cdFx0XHRcdHN3MyA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5jIF07XG5cblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHN3MS54O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMSBdID0gc3cxLnk7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAyIF0gPSBzdzEuejtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHN3MS53O1xuXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA0IF0gPSBzdzIueDtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHN3Mi55O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc3cyLno7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA3IF0gPSBzdzIudztcblxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOCBdICA9IHN3My54O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHN3My55O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHN3My56O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTEgXSA9IHN3My53O1xuXG5cdFx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0XHRzaTEgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHRzaTIgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHRzaTMgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHNpMS54O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzaTEueTtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMiBdID0gc2kxLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHNpMS53O1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHNpMi54O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA1IF0gPSBzaTIueTtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc2kyLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IHNpMi53O1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDggXSAgPSBzaTMueDtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHNpMy55O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMCBdID0gc2kzLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDExIF0gPSBzaTMudztcblxuXHRcdFx0XHQvLyB2ZXJ0aWNlcyBBXG5cblx0XHRcdFx0c2ExID0gb2JqX3NraW5WZXJ0aWNlc0FbIGZhY2UuYSBdO1xuXHRcdFx0XHRzYTIgPSBvYmpfc2tpblZlcnRpY2VzQVsgZmFjZS5iIF07XG5cdFx0XHRcdHNhMyA9IG9ial9za2luVmVydGljZXNBWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHNhMS54O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDEgXSA9IHNhMS55O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDIgXSA9IHNhMS56O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IDE7IC8vIHBhZCBmb3IgZmFzdGVyIHZlcnRleCBzaGFkZXJcblxuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHNhMi54O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHNhMi55O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDYgXSA9IHNhMi56O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IDE7XG5cblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyA4IF0gID0gc2EzLng7XG5cdFx0XHRcdHNraW5WZXJ0ZXhBQXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHNhMy55O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDEwIF0gPSBzYTMuejtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyAxMSBdID0gMTtcblxuXHRcdFx0XHQvLyB2ZXJ0aWNlcyBCXG5cblx0XHRcdFx0c2IxID0gb2JqX3NraW5WZXJ0aWNlc0JbIGZhY2UuYSBdO1xuXHRcdFx0XHRzYjIgPSBvYmpfc2tpblZlcnRpY2VzQlsgZmFjZS5iIF07XG5cdFx0XHRcdHNiMyA9IG9ial9za2luVmVydGljZXNCWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHNiMS54O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDEgXSA9IHNiMS55O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDIgXSA9IHNiMS56O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IDE7IC8vIHBhZCBmb3IgZmFzdGVyIHZlcnRleCBzaGFkZXJcblxuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHNiMi54O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHNiMi55O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDYgXSA9IHNiMi56O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IDE7XG5cblx0XHRcdFx0c2tpblZlcnRleEJBcnJheVsgb2Zmc2V0X3NraW4gKyA4IF0gID0gc2IzLng7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHNiMy55O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDEwIF0gPSBzYjMuejtcblx0XHRcdFx0c2tpblZlcnRleEJBcnJheVsgb2Zmc2V0X3NraW4gKyAxMSBdID0gMTtcblxuXHRcdFx0XHRvZmZzZXRfc2tpbiArPSAxMjtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXM0WyBmIF0gXTtcblxuXHRcdFx0XHQvLyB3ZWlnaHRzXG5cblx0XHRcdFx0c3cxID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmEgXTtcblx0XHRcdFx0c3cyID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmIgXTtcblx0XHRcdFx0c3czID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmMgXTtcblx0XHRcdFx0c3c0ID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmQgXTtcblxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luIF0gICAgID0gc3cxLng7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzdzEueTtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDIgXSA9IHN3MS56O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMyBdID0gc3cxLnc7XG5cblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHN3Mi54O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNSBdID0gc3cyLnk7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA2IF0gPSBzdzIuejtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IHN3Mi53O1xuXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA4IF0gID0gc3czLng7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA5IF0gID0gc3czLnk7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxMCBdID0gc3czLno7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxMSBdID0gc3czLnc7XG5cblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDEyIF0gPSBzdzQueDtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDEzIF0gPSBzdzQueTtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDE0IF0gPSBzdzQuejtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDE1IF0gPSBzdzQudztcblxuXHRcdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdFx0c2kxID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmEgXTtcblx0XHRcdFx0c2kyID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdFx0c2kzID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmMgXTtcblx0XHRcdFx0c2k0ID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmQgXTtcblxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gXSAgICAgPSBzaTEueDtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMSBdID0gc2kxLnk7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDIgXSA9IHNpMS56O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAzIF0gPSBzaTEudztcblxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA0IF0gPSBzaTIueDtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNSBdID0gc2kyLnk7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDYgXSA9IHNpMi56O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA3IF0gPSBzaTIudztcblxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA4IF0gID0gc2kzLng7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDkgXSAgPSBzaTMueTtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHNpMy56O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMSBdID0gc2kzLnc7XG5cblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTIgXSA9IHNpNC54O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMyBdID0gc2k0Lnk7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDE0IF0gPSBzaTQuejtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTUgXSA9IHNpNC53O1xuXG5cdFx0XHRcdC8vIHZlcnRpY2VzIEFcblxuXHRcdFx0XHRzYTEgPSBvYmpfc2tpblZlcnRpY2VzQVsgZmFjZS5hIF07XG5cdFx0XHRcdHNhMiA9IG9ial9za2luVmVydGljZXNBWyBmYWNlLmIgXTtcblx0XHRcdFx0c2EzID0gb2JqX3NraW5WZXJ0aWNlc0FbIGZhY2UuYyBdO1xuXHRcdFx0XHRzYTQgPSBvYmpfc2tpblZlcnRpY2VzQVsgZmFjZS5kIF07XG5cblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gXSAgICAgPSBzYTEueDtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzYTEueTtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyAyIF0gPSBzYTEuejtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyAzIF0gPSAxOyAvLyBwYWQgZm9yIGZhc3RlciB2ZXJ0ZXggc2hhZGVyXG5cblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyA0IF0gPSBzYTIueDtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyA1IF0gPSBzYTIueTtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyA2IF0gPSBzYTIuejtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyA3IF0gPSAxO1xuXG5cdFx0XHRcdHNraW5WZXJ0ZXhBQXJyYXlbIG9mZnNldF9za2luICsgOCBdICA9IHNhMy54O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDkgXSAgPSBzYTMueTtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyAxMCBdID0gc2EzLno7XG5cdFx0XHRcdHNraW5WZXJ0ZXhBQXJyYXlbIG9mZnNldF9za2luICsgMTEgXSA9IDE7XG5cblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyAxMiBdID0gc2E0Lng7XG5cdFx0XHRcdHNraW5WZXJ0ZXhBQXJyYXlbIG9mZnNldF9za2luICsgMTMgXSA9IHNhNC55O1xuXHRcdFx0XHRza2luVmVydGV4QUFycmF5WyBvZmZzZXRfc2tpbiArIDE0IF0gPSBzYTQuejtcblx0XHRcdFx0c2tpblZlcnRleEFBcnJheVsgb2Zmc2V0X3NraW4gKyAxNSBdID0gMTtcblxuXHRcdFx0XHQvLyB2ZXJ0aWNlcyBCXG5cblx0XHRcdFx0c2IxID0gb2JqX3NraW5WZXJ0aWNlc0JbIGZhY2UuYSBdO1xuXHRcdFx0XHRzYjIgPSBvYmpfc2tpblZlcnRpY2VzQlsgZmFjZS5iIF07XG5cdFx0XHRcdHNiMyA9IG9ial9za2luVmVydGljZXNCWyBmYWNlLmMgXTtcblx0XHRcdFx0c2I0ID0gb2JqX3NraW5WZXJ0aWNlc0JbIGZhY2UuZCBdO1xuXG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luIF0gICAgID0gc2IxLng7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgMSBdID0gc2IxLnk7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgMiBdID0gc2IxLno7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgMyBdID0gMTsgLy8gcGFkIGZvciBmYXN0ZXIgdmVydGV4IHNoYWRlclxuXG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgNCBdID0gc2IyLng7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgNSBdID0gc2IyLnk7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc2IyLno7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgNyBdID0gMTtcblxuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDggXSAgPSBzYjMueDtcblx0XHRcdFx0c2tpblZlcnRleEJBcnJheVsgb2Zmc2V0X3NraW4gKyA5IF0gID0gc2IzLnk7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHNiMy56O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDExIF0gPSAxO1xuXG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgMTIgXSA9IHNiNC54O1xuXHRcdFx0XHRza2luVmVydGV4QkFycmF5WyBvZmZzZXRfc2tpbiArIDEzIF0gPSBzYjQueTtcblx0XHRcdFx0c2tpblZlcnRleEJBcnJheVsgb2Zmc2V0X3NraW4gKyAxNCBdID0gc2I0Lno7XG5cdFx0XHRcdHNraW5WZXJ0ZXhCQXJyYXlbIG9mZnNldF9za2luICsgMTUgXSA9IDE7XG5cblx0XHRcdFx0b2Zmc2V0X3NraW4gKz0gMTY7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvZmZzZXRfc2tpbiA+IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5WZXJ0ZXhBQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBza2luVmVydGV4QUFycmF5LCBoaW50ICk7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5WZXJ0ZXhCQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBza2luVmVydGV4QkFycmF5LCBoaW50ICk7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBza2luSW5kZXhBcnJheSwgaGludCApO1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciApO1xuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgc2tpbldlaWdodEFycmF5LCBoaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlDb2xvcnMgJiYgdmVydGV4Q29sb3JUeXBlICkge1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XG5cblx0XHRcdFx0dmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cdFx0XHRcdGZhY2VDb2xvciA9IGZhY2UuY29sb3I7XG5cblx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICYmIHZlcnRleENvbG9yVHlwZSA9PT0gVEhSRUUuVmVydGV4Q29sb3JzICkge1xuXG5cdFx0XHRcdFx0YzEgPSB2ZXJ0ZXhDb2xvcnNbIDAgXTtcblx0XHRcdFx0XHRjMiA9IHZlcnRleENvbG9yc1sgMSBdO1xuXHRcdFx0XHRcdGMzID0gdmVydGV4Q29sb3JzWyAyIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGMxID0gZmFjZUNvbG9yO1xuXHRcdFx0XHRcdGMyID0gZmFjZUNvbG9yO1xuXHRcdFx0XHRcdGMzID0gZmFjZUNvbG9yO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgXSAgICAgPSBjMS5yO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAxIF0gPSBjMS5nO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAyIF0gPSBjMS5iO1xuXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDMgXSA9IGMyLnI7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDQgXSA9IGMyLmc7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDUgXSA9IGMyLmI7XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNiBdID0gYzMucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNyBdID0gYzMuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgOCBdID0gYzMuYjtcblxuXHRcdFx0XHRvZmZzZXRfY29sb3IgKz0gOTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXM0WyBmIF0gXTtcblxuXHRcdFx0XHR2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblx0XHRcdFx0ZmFjZUNvbG9yID0gZmFjZS5jb2xvcjtcblxuXHRcdFx0XHRpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDQgJiYgdmVydGV4Q29sb3JUeXBlID09PSBUSFJFRS5WZXJ0ZXhDb2xvcnMgKSB7XG5cblx0XHRcdFx0XHRjMSA9IHZlcnRleENvbG9yc1sgMCBdO1xuXHRcdFx0XHRcdGMyID0gdmVydGV4Q29sb3JzWyAxIF07XG5cdFx0XHRcdFx0YzMgPSB2ZXJ0ZXhDb2xvcnNbIDIgXTtcblx0XHRcdFx0XHRjNCA9IHZlcnRleENvbG9yc1sgMyBdO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjMSA9IGZhY2VDb2xvcjtcblx0XHRcdFx0XHRjMiA9IGZhY2VDb2xvcjtcblx0XHRcdFx0XHRjMyA9IGZhY2VDb2xvcjtcblx0XHRcdFx0XHRjNCA9IGZhY2VDb2xvcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yIF0gICAgID0gYzEucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMSBdID0gYzEuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMiBdID0gYzEuYjtcblxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAzIF0gPSBjMi5yO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA0IF0gPSBjMi5nO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA1IF0gPSBjMi5iO1xuXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDYgXSA9IGMzLnI7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDcgXSA9IGMzLmc7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDggXSA9IGMzLmI7XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgOSBdICA9IGM0LnI7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDEwIF0gPSBjNC5nO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAxMSBdID0gYzQuYjtcblxuXHRcdFx0XHRvZmZzZXRfY29sb3IgKz0gMTI7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvZmZzZXRfY29sb3IgPiAwICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3JBcnJheSwgaGludCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGRpcnR5VGFuZ2VudHMgJiYgZ2VvbWV0cnkuaGFzVGFuZ2VudHMgKSB7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcblxuXHRcdFx0XHR2ZXJ0ZXhUYW5nZW50cyA9IGZhY2UudmVydGV4VGFuZ2VudHM7XG5cblx0XHRcdFx0dDEgPSB2ZXJ0ZXhUYW5nZW50c1sgMCBdO1xuXHRcdFx0XHR0MiA9IHZlcnRleFRhbmdlbnRzWyAxIF07XG5cdFx0XHRcdHQzID0gdmVydGV4VGFuZ2VudHNbIDIgXTtcblxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50IF0gICAgID0gdDEueDtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEgXSA9IHQxLnk7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAyIF0gPSB0MS56O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMyBdID0gdDEudztcblxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgNCBdID0gdDIueDtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDUgXSA9IHQyLnk7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA2IF0gPSB0Mi56O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgNyBdID0gdDIudztcblxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOCBdICA9IHQzLng7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA5IF0gID0gdDMueTtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEwIF0gPSB0My56O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMTEgXSA9IHQzLnc7XG5cblx0XHRcdFx0b2Zmc2V0X3RhbmdlbnQgKz0gMTI7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XG5cblx0XHRcdFx0dmVydGV4VGFuZ2VudHMgPSBmYWNlLnZlcnRleFRhbmdlbnRzO1xuXG5cdFx0XHRcdHQxID0gdmVydGV4VGFuZ2VudHNbIDAgXTtcblx0XHRcdFx0dDIgPSB2ZXJ0ZXhUYW5nZW50c1sgMSBdO1xuXHRcdFx0XHR0MyA9IHZlcnRleFRhbmdlbnRzWyAyIF07XG5cdFx0XHRcdHQ0ID0gdmVydGV4VGFuZ2VudHNbIDMgXTtcblxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50IF0gICAgID0gdDEueDtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEgXSA9IHQxLnk7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAyIF0gPSB0MS56O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMyBdID0gdDEudztcblxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgNCBdID0gdDIueDtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDUgXSA9IHQyLnk7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA2IF0gPSB0Mi56O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgNyBdID0gdDIudztcblxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOCBdICA9IHQzLng7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA5IF0gID0gdDMueTtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEwIF0gPSB0My56O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMTEgXSA9IHQzLnc7XG5cblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEyIF0gPSB0NC54O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMTMgXSA9IHQ0Lnk7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxNCBdID0gdDQuejtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDE1IF0gPSB0NC53O1xuXG5cdFx0XHRcdG9mZnNldF90YW5nZW50ICs9IDE2O1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdGFuZ2VudEFycmF5LCBoaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRpcnR5Tm9ybWFscyAmJiBub3JtYWxUeXBlICkge1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XG5cblx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsO1xuXG5cdFx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgJiYgbmVlZHNTbW9vdGhOb3JtYWxzICkge1xuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2biA9IHZlcnRleE5vcm1hbHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgXSAgICAgPSB2bi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAxIF0gPSB2bi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAyIF0gPSB2bi56O1xuXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgXSAgICAgPSBmYWNlTm9ybWFsLng7XG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDEgXSA9IGZhY2VOb3JtYWwueTtcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMiBdID0gZmFjZU5vcm1hbC56O1xuXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xuXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cdFx0XHRcdGZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbDtcblxuXHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSA0ICYmIG5lZWRzU21vb3RoTm9ybWFscyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dm4gPSB2ZXJ0ZXhOb3JtYWxzWyBpIF07XG5cblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsIF0gICAgID0gdm4ueDtcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMSBdID0gdm4ueTtcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMiBdID0gdm4uejtcblxuXHRcdFx0XHRcdFx0b2Zmc2V0X25vcm1hbCArPSAzO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsIF0gICAgID0gZmFjZU5vcm1hbC54O1xuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAxIF0gPSBmYWNlTm9ybWFsLnk7XG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDIgXSA9IGZhY2VOb3JtYWwuejtcblxuXHRcdFx0XHRcdFx0b2Zmc2V0X25vcm1hbCArPSAzO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbm9ybWFsQXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlVdnMgJiYgb2JqX3V2cyAmJiB1dlR5cGUgKSB7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmaSA9IGNodW5rX2ZhY2VzM1sgZiBdO1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGZpIF07XG5cdFx0XHRcdHV2ID0gb2JqX3V2c1sgZmkgXTtcblxuXHRcdFx0XHRpZiAoIHV2ID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1dmkgPSB1dlsgaSBdO1xuXG5cdFx0XHRcdFx0dXZBcnJheVsgb2Zmc2V0X3V2IF0gICAgID0gdXZpLnU7XG5cdFx0XHRcdFx0dXZBcnJheVsgb2Zmc2V0X3V2ICsgMSBdID0gdXZpLnY7XG5cblx0XHRcdFx0XHRvZmZzZXRfdXYgKz0gMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZpID0gY2h1bmtfZmFjZXM0WyBmIF07XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgZmkgXTtcblx0XHRcdFx0dXYgPSBvYmpfdXZzWyBmaSBdO1xuXG5cdFx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHV2aSA9IHV2WyBpIF07XG5cblx0XHRcdFx0XHR1dkFycmF5WyBvZmZzZXRfdXYgXSAgICAgPSB1dmkudTtcblx0XHRcdFx0XHR1dkFycmF5WyBvZmZzZXRfdXYgKyAxIF0gPSB1dmkudjtcblxuXHRcdFx0XHRcdG9mZnNldF91diArPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9mZnNldF91diA+IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB1dkFycmF5LCBoaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlVdnMgJiYgb2JqX3V2czIgJiYgdXZUeXBlICkge1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmkgPSBjaHVua19mYWNlczNbIGYgXTtcblxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBmaSBdO1xuXHRcdFx0XHR1djIgPSBvYmpfdXZzMlsgZmkgXTtcblxuXHRcdFx0XHRpZiAoIHV2MiA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dXYyaSA9IHV2MlsgaSBdO1xuXG5cdFx0XHRcdFx0dXYyQXJyYXlbIG9mZnNldF91djIgXSAgICAgPSB1djJpLnU7XG5cdFx0XHRcdFx0dXYyQXJyYXlbIG9mZnNldF91djIgKyAxIF0gPSB1djJpLnY7XG5cblx0XHRcdFx0XHRvZmZzZXRfdXYyICs9IDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmaSA9IGNodW5rX2ZhY2VzNFsgZiBdO1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGZpIF07XG5cdFx0XHRcdHV2MiA9IG9ial91dnMyWyBmaSBdO1xuXG5cdFx0XHRcdGlmICggdXYyID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1djJpID0gdXYyWyBpIF07XG5cblx0XHRcdFx0XHR1djJBcnJheVsgb2Zmc2V0X3V2MiBdICAgICA9IHV2MmkudTtcblx0XHRcdFx0XHR1djJBcnJheVsgb2Zmc2V0X3V2MiArIDEgXSA9IHV2MmkudjtcblxuXHRcdFx0XHRcdG9mZnNldF91djIgKz0gMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvZmZzZXRfdXYyID4gMCApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVYyQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB1djJBcnJheSwgaGludCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGRpcnR5RWxlbWVudHMgKSB7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcblxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlIF0gXHQgPSB2ZXJ0ZXhJbmRleDtcblx0XHRcdFx0ZmFjZUFycmF5WyBvZmZzZXRfZmFjZSArIDEgXSA9IHZlcnRleEluZGV4ICsgMTtcblx0XHRcdFx0ZmFjZUFycmF5WyBvZmZzZXRfZmFjZSArIDIgXSA9IHZlcnRleEluZGV4ICsgMjtcblxuXHRcdFx0XHRvZmZzZXRfZmFjZSArPSAzO1xuXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgXSAgICAgPSB2ZXJ0ZXhJbmRleDtcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDEgXSA9IHZlcnRleEluZGV4ICsgMTtcblxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMiBdID0gdmVydGV4SW5kZXg7XG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAzIF0gPSB2ZXJ0ZXhJbmRleCArIDI7XG5cblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDQgXSA9IHZlcnRleEluZGV4ICsgMTtcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDUgXSA9IHZlcnRleEluZGV4ICsgMjtcblxuXHRcdFx0XHRvZmZzZXRfbGluZSArPSA2O1xuXG5cdFx0XHRcdHZlcnRleEluZGV4ICs9IDM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XG5cblx0XHRcdFx0ZmFjZUFycmF5WyBvZmZzZXRfZmFjZSBdICAgICA9IHZlcnRleEluZGV4O1xuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlICsgMSBdID0gdmVydGV4SW5kZXggKyAxO1xuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlICsgMiBdID0gdmVydGV4SW5kZXggKyAzO1xuXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAzIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyA0IF0gPSB2ZXJ0ZXhJbmRleCArIDI7XG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyA1IF0gPSB2ZXJ0ZXhJbmRleCArIDM7XG5cblx0XHRcdFx0b2Zmc2V0X2ZhY2UgKz0gNjtcblxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lIF0gICAgID0gdmVydGV4SW5kZXg7XG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAxIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDIgXSA9IHZlcnRleEluZGV4O1xuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMyBdID0gdmVydGV4SW5kZXggKyAzO1xuXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA0IF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA1IF0gPSB2ZXJ0ZXhJbmRleCArIDI7XG5cblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDYgXSA9IHZlcnRleEluZGV4ICsgMjtcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDcgXSA9IHZlcnRleEluZGV4ICsgMztcblxuXHRcdFx0XHRvZmZzZXRfbGluZSArPSA4O1xuXG5cdFx0XHRcdHZlcnRleEluZGV4ICs9IDQ7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZUFycmF5LCBoaW50ICk7XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGxpbmVBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjdXN0b21BdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoICEgY3VzdG9tQXR0cmlidXRlLl9fb3JpZ2luYWwubmVlZHNVcGRhdGUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRvZmZzZXRfY3VzdG9tID0gMDtcblx0XHRcdFx0b2Zmc2V0X2N1c3RvbVNyYyA9IDA7XG5cblx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJ2ZXJ0aWNlc1wiICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAzO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuZCBdO1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gNDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZXNcIiApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzNFsgZiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gNDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAyICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XG5cdFx0XHRcdFx0XHRcdHYyID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcblx0XHRcdFx0XHRcdFx0djMgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2MS54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MS55O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYyLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyLnk7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjMueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjMueTtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDY7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcblx0XHRcdFx0XHRcdFx0djQgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuZCBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2MS54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MS55O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYyLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyLnk7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjMueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjMueTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2NC54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2NC55O1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gODtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZXNcIiApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHYxLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxLnk7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdjIueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjIueTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0IF0gPSB2My54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2My55O1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gNjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzNFsgZiBdIF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0djQgPSB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjEueTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2Mi55O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYzLnk7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiBdID0gdjQueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyBdID0gdjQueTtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDg7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcblxuXHRcdFx0XHRcdHZhciBwcDtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnR5cGUgPT09IFwiY1wiICkge1xuXG5cdFx0XHRcdFx0XHRwcCA9IFsgXCJyXCIsIFwiZ1wiLCBcImJcIiBdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0cHAgPSBbIFwieFwiLCBcInlcIiwgXCJ6XCIgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJ2ZXJ0aWNlc1wiICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjFbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjFbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdjFbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2MlsgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0IF0gPSB2MlsgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2MlsgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgXSA9IHYzWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgXSA9IHYzWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggXSA9IHYzWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA5O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdHYxID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmEgXTtcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xuXHRcdFx0XHRcdFx0XHR2MyA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XG5cdFx0XHRcdFx0XHRcdHY0ID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmQgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gXHQ9IHYxWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MVsgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjFbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjJbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2MlsgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2M1sgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjNbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHY0WyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2NFsgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjRbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJmYWNlc1wiICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjFbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjFbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdjFbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2MlsgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0IF0gPSB2MlsgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2MlsgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgXSA9IHYzWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgXSA9IHYzWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggXSA9IHYzWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA5O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXM0WyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2NCA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjFbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MVsgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MlsgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjJbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYzWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgIF0gPSB2M1sgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjNbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA5ICBdID0gdjRbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHY0WyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2NFsgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTI7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJ2ZXJ0aWNlc1wiICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gXHQ9IHYxLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjEuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYxLnc7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2Mi55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYyLnc7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2My55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjMuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxMjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXM0WyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XG5cdFx0XHRcdFx0XHRcdHYyID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcblx0XHRcdFx0XHRcdFx0djMgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xuXHRcdFx0XHRcdFx0XHR2NCA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5kIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MS54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxICBdID0gdjEueTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiAgXSA9IHYxLno7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MS53O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgIF0gPSB2Mi54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjIueTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYyLno7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgIF0gPSB2Mi53O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggIF0gPSB2My54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA5ICBdID0gdjMueTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHYzLno7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2My53O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEyIF0gPSB2NC54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMyBdID0gdjQueTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTQgXSA9IHY0Lno7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDE1IF0gPSB2NC53O1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTY7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcImZhY2VzXCIgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXM0WyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2NCA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMiBdID0gdjQueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTMgXSA9IHY0Lnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDE0IF0gPSB2NC56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxNSBdID0gdjQudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDE2O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYXJyYXksIGhpbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXNwb3NlICkge1xuXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXM7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2NvbG9yQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX190YW5nZW50QXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3V2QXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3V2MkFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3ZlcnRleEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19saW5lQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3NraW5WZXJ0ZXhBQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3NraW5WZXJ0ZXhCQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19za2luV2VpZ2h0QXJyYXk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBCdWZmZXIgcmVuZGVyaW5nXG5cblx0ZnVuY3Rpb24gcmVuZGVyQnVmZmVySW1tZWRpYXRlICggb2JqZWN0LCBwcm9ncmFtLCBzaGFkaW5nICkge1xuXG5cdFx0aWYgKCAhIG9iamVjdC5fX3dlYmdsVmVydGV4QnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCAhIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRpZiAoIG9iamVjdC5oYXNQb3MgKSB7XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIHByb2dyYW0uYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFsICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcblxuXHRcdFx0aWYgKCBzaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcblxuXHRcdFx0XHR2YXIgbngsIG55LCBueixcblx0XHRcdFx0XHRuYXgsIG5ieCwgbmN4LCBuYXksIG5ieSwgbmN5LCBuYXosIG5ieiwgbmN6LFxuXHRcdFx0XHRcdG5vcm1hbEFycmF5LFxuXHRcdFx0XHRcdGksIGlsID0gb2JqZWN0LmNvdW50ICogMztcblxuXHRcdFx0XHRmb3IoIGkgPSAwOyBpIDwgaWw7IGkgKz0gOSApIHtcblxuXHRcdFx0XHRcdG5vcm1hbEFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xuXG5cdFx0XHRcdFx0bmF4ICA9IG5vcm1hbEFycmF5WyBpIF07XG5cdFx0XHRcdFx0bmF5ICA9IG5vcm1hbEFycmF5WyBpICsgMSBdO1xuXHRcdFx0XHRcdG5heiAgPSBub3JtYWxBcnJheVsgaSArIDIgXTtcblxuXHRcdFx0XHRcdG5ieCAgPSBub3JtYWxBcnJheVsgaSArIDMgXTtcblx0XHRcdFx0XHRuYnkgID0gbm9ybWFsQXJyYXlbIGkgKyA0IF07XG5cdFx0XHRcdFx0bmJ6ICA9IG5vcm1hbEFycmF5WyBpICsgNSBdO1xuXG5cdFx0XHRcdFx0bmN4ICA9IG5vcm1hbEFycmF5WyBpICsgNiBdO1xuXHRcdFx0XHRcdG5jeSAgPSBub3JtYWxBcnJheVsgaSArIDcgXTtcblx0XHRcdFx0XHRuY3ogID0gbm9ybWFsQXJyYXlbIGkgKyA4IF07XG5cblx0XHRcdFx0XHRueCA9ICggbmF4ICsgbmJ4ICsgbmN4ICkgLyAzO1xuXHRcdFx0XHRcdG55ID0gKCBuYXkgKyBuYnkgKyBuY3kgKSAvIDM7XG5cdFx0XHRcdFx0bnogPSAoIG5heiArIG5ieiArIG5jeiApIC8gMztcblxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpIF0gXHQgPSBueDtcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDEgXSA9IG55O1xuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgMiBdID0gbno7XG5cblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDMgXSA9IG54O1xuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgNCBdID0gbnk7XG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA1IF0gPSBuejtcblxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgNiBdID0gbng7XG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA3IF0gPSBueTtcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDggXSA9IG56O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Lm5vcm1hbEFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIHByb2dyYW0uYXR0cmlidXRlcy5ub3JtYWwgKTtcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtLmF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFUywgMCwgb2JqZWN0LmNvdW50ICk7XG5cblx0XHRvYmplY3QuY291bnQgPSAwO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcmVuZGVyQnVmZmVyICggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApIHtcblxuXHRcdGlmICggbWF0ZXJpYWwub3BhY2l0eSA9PT0gMCApIHJldHVybjtcblxuXHRcdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCBsaW5ld2lkdGgsIHByaW1pdGl2ZXMsIGEsIGF0dHJpYnV0ZSwgaSwgaWw7XG5cblx0XHRwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0YXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlcztcblxuXHRcdHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2UsXG5cdFx0XHR3aXJlZnJhbWVCaXQgPSBtYXRlcmlhbC53aXJlZnJhbWUgPyAxIDogMCxcblx0XHRcdGdlb21ldHJ5R3JvdXBIYXNoID0gKCBnZW9tZXRyeUdyb3VwLmlkICogMHhmZmZmZmYgKSArICggcHJvZ3JhbS5pZCAqIDIgKSArIHdpcmVmcmFtZUJpdDtcblxuXHRcdGlmICggZ2VvbWV0cnlHcm91cEhhc2ggIT09IF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggKSB7XG5cblx0XHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSBnZW9tZXRyeUdyb3VwSGFzaDtcblx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdmVydGljZXNcblxuXHRcdGlmICggIW1hdGVyaWFsLm1vcnBoVGFyZ2V0cyAmJiBhdHRyaWJ1dGVzLnBvc2l0aW9uID49IDAgKSB7XG5cblx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSApIHtcblxuXHRcdFx0XHRzZXR1cE1vcnBoVGFyZ2V0cyggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0Ly8gY3VzdG9tIGF0dHJpYnV0ZXNcblxuXHRcdFx0Ly8gVXNlIHRoZSBwZXItZ2VvbWV0cnlHcm91cCBjdXN0b20gYXR0cmlidXRlIGFycmF5cyB3aGljaCBhcmUgc2V0dXAgaW4gaW5pdE1lc2hCdWZmZXJzXG5cblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgKSB7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUgPSBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdFsgaSBdO1xuXG5cdFx0XHRcdFx0aWYoIGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5idWZmZXIgKTtcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyBhdHRyaWJ1dGUuYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZSBdLCBhdHRyaWJ1dGUuc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIGNvbG9yc1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMuY29sb3IgPj0gMCApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBub3JtYWxzXG5cblx0XHRcdGlmICggYXR0cmlidXRlcy5ub3JtYWwgPj0gMCApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHRhbmdlbnRzXG5cblx0XHRcdGlmICggYXR0cmlidXRlcy50YW5nZW50ID49IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudGFuZ2VudCwgNCwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHV2c1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgPj0gMCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWQnVmZmVyICk7XG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy51diApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzLnV2ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXR0cmlidXRlcy51djIgPj0gMCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVjJCdWZmZXIgKTtcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51djIsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy51djIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X2dsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy51djIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyAmJlxuXHRcdFx0XHQgYXR0cmlidXRlcy5za2luVmVydGV4QSA+PSAwICYmIGF0dHJpYnV0ZXMuc2tpblZlcnRleEIgPj0gMCAmJlxuXHRcdFx0XHQgYXR0cmlidXRlcy5za2luSW5kZXggPj0gMCAmJiBhdHRyaWJ1dGVzLnNraW5XZWlnaHQgPj0gMCApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpblZlcnRleEFCdWZmZXIgKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuc2tpblZlcnRleEEsIDQsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpblZlcnRleEJCdWZmZXIgKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuc2tpblZlcnRleEIsIDQsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuc2tpbkluZGV4LCA0LCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnNraW5XZWlnaHQsIDQsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIG1lc2hcblxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0Ly8gd2lyZWZyYW1lXG5cblx0XHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lICkge1xuXG5cdFx0XHRcdHNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICk7XG5cblx0XHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUJ1ZmZlciApO1xuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuTElORVMsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVDb3VudCwgX2dsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblx0XHRcdC8vIHRyaWFuZ2xlc1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgKTtcblx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLlRSSUFOR0xFUywgZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50LCBfZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VDb3VudDtcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VDb3VudCAvIDM7XG5cblx0XHQvLyByZW5kZXIgbGluZXNcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdHByaW1pdGl2ZXMgPSAoIG9iamVjdC50eXBlID09PSBUSFJFRS5MaW5lU3RyaXAgKSA/IF9nbC5MSU5FX1NUUklQIDogX2dsLkxJTkVTO1xuXG5cdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xuXG5cdFx0XHRfZ2wuZHJhd0FycmF5cyggcHJpbWl0aXZlcywgMCwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUNvdW50ICk7XG5cblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXG5cdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB7XG5cblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuUE9JTlRTLCAwLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xQYXJ0aWNsZUNvdW50ICk7XG5cblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXG5cdFx0Ly8gcmVuZGVyIHJpYmJvblxuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUmliYm9uICkge1xuXG5cdFx0XHRfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFX1NUUklQLCAwLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhDb3VudCApO1xuXG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldHVwTW9ycGhUYXJnZXRzICggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApIHtcblxuXHRcdC8vIHNldCBiYXNlXG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IG1hdGVyaWFsLnByb2dyYW0uYXR0cmlidXRlcztcblxuXHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSAhPT0gLSAxICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSBdICk7XG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fSBlbHNlIGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiA+PSAwICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QubW9ycGhUYXJnZXRGb3JjZWRPcmRlci5sZW5ndGggKSB7XG5cblx0XHRcdC8vIHNldCBmb3JjZWQgb3JkZXJcblxuXHRcdFx0dmFyIG0gPSAwO1xuXHRcdFx0dmFyIG9yZGVyID0gb2JqZWN0Lm1vcnBoVGFyZ2V0Rm9yY2VkT3JkZXI7XG5cdFx0XHR2YXIgaW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRcdHdoaWxlICggbSA8IG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyAmJiBtIDwgb3JkZXIubGVuZ3RoICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBvcmRlclsgbSBdIF0gKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhUYXJnZXRcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBtIF0gPSBpbmZsdWVuY2VzWyBvcmRlclsgbSBdIF07XG5cblx0XHRcdFx0bSArKztcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGZpbmQgbW9zdCBpbmZsdWVuY2luZ1xuXG5cdFx0XHR2YXIgdXNlZCA9IFtdO1xuXHRcdFx0dmFyIGNhbmRpZGF0ZUluZmx1ZW5jZSA9IC0gMTtcblx0XHRcdHZhciBjYW5kaWRhdGUgPSAwO1xuXHRcdFx0dmFyIGluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXHRcdFx0dmFyIGksIGlsID0gaW5mbHVlbmNlcy5sZW5ndGg7XG5cdFx0XHR2YXIgbSA9IDA7XG5cblx0XHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdHVzZWRbIG9iamVjdC5tb3JwaFRhcmdldEJhc2UgXSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0d2hpbGUgKCBtIDwgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoICF1c2VkWyBpIF0gJiYgaW5mbHVlbmNlc1sgaSBdID4gY2FuZGlkYXRlSW5mbHVlbmNlICkge1xuXG5cdFx0XHRcdFx0XHRjYW5kaWRhdGUgPSBpO1xuXHRcdFx0XHRcdFx0Y2FuZGlkYXRlSW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgY2FuZGlkYXRlIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBjYW5kaWRhdGUgXSApO1xuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdFx0b2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXNbIG0gXSA9IGNhbmRpZGF0ZUluZmx1ZW5jZTtcblxuXHRcdFx0XHR1c2VkWyBjYW5kaWRhdGUgXSA9IDE7XG5cdFx0XHRcdGNhbmRpZGF0ZUluZmx1ZW5jZSA9IC0xO1xuXHRcdFx0XHRtICsrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBsb2FkIHVwZGF0ZWQgaW5mbHVlbmNlcyB1bmlmb3JtXG5cblx0XHRpZiggbWF0ZXJpYWwucHJvZ3JhbS51bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdF9nbC51bmlmb3JtMWZ2KCBtYXRlcmlhbC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcywgb2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gRnJ1c3R1bVxuXG5cdGZ1bmN0aW9uIGNvbXB1dGVGcnVzdHVtICggbSApIHtcblxuXHRcdF9mcnVzdHVtWyAwIF0uc2V0KCBtLm40MSAtIG0ubjExLCBtLm40MiAtIG0ubjEyLCBtLm40MyAtIG0ubjEzLCBtLm40NCAtIG0ubjE0ICk7XG5cdFx0X2ZydXN0dW1bIDEgXS5zZXQoIG0ubjQxICsgbS5uMTEsIG0ubjQyICsgbS5uMTIsIG0ubjQzICsgbS5uMTMsIG0ubjQ0ICsgbS5uMTQgKTtcblx0XHRfZnJ1c3R1bVsgMiBdLnNldCggbS5uNDEgKyBtLm4yMSwgbS5uNDIgKyBtLm4yMiwgbS5uNDMgKyBtLm4yMywgbS5uNDQgKyBtLm4yNCApO1xuXHRcdF9mcnVzdHVtWyAzIF0uc2V0KCBtLm40MSAtIG0ubjIxLCBtLm40MiAtIG0ubjIyLCBtLm40MyAtIG0ubjIzLCBtLm40NCAtIG0ubjI0ICk7XG5cdFx0X2ZydXN0dW1bIDQgXS5zZXQoIG0ubjQxIC0gbS5uMzEsIG0ubjQyIC0gbS5uMzIsIG0ubjQzIC0gbS5uMzMsIG0ubjQ0IC0gbS5uMzQgKTtcblx0XHRfZnJ1c3R1bVsgNSBdLnNldCggbS5uNDEgKyBtLm4zMSwgbS5uNDIgKyBtLm4zMiwgbS5uNDMgKyBtLm4zMywgbS5uNDQgKyBtLm4zNCApO1xuXG5cdFx0dmFyIGksIHBsYW5lO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRwbGFuZSA9IF9mcnVzdHVtWyBpIF07XG5cdFx0XHRwbGFuZS5kaXZpZGVTY2FsYXIoIE1hdGguc3FydCggcGxhbmUueCAqIHBsYW5lLnggKyBwbGFuZS55ICogcGxhbmUueSArIHBsYW5lLnogKiBwbGFuZS56ICkgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGlzSW5GcnVzdHVtICggb2JqZWN0ICkge1xuXG5cdFx0dmFyIGRpc3RhbmNlLCBtYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQsXG5cdFx0cmFkaXVzID0gLSBvYmplY3QuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUucmFkaXVzICogTWF0aC5tYXgoIG9iamVjdC5zY2FsZS54LCBNYXRoLm1heCggb2JqZWN0LnNjYWxlLnksIG9iamVjdC5zY2FsZS56ICkgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGRpc3RhbmNlID0gX2ZydXN0dW1bIGkgXS54ICogbWF0cml4Lm4xNCArIF9mcnVzdHVtWyBpIF0ueSAqIG1hdHJpeC5uMjQgKyBfZnJ1c3R1bVsgaSBdLnogKiBtYXRyaXgubjM0ICsgX2ZydXN0dW1bIGkgXS53O1xuXHRcdFx0aWYgKCBkaXN0YW5jZSA8PSByYWRpdXMgKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9O1xuXG5cblx0ZnVuY3Rpb24gcGFpbnRlclNvcnQgKCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIGIueiAtIGEuejtcblxuXHR9O1xuXG5cdC8vIFJlbmRlcmluZ1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XG5cblx0XHR2YXIgaSwgaWwsXG5cblx0XHRwcm9ncmFtLCBtYXRlcmlhbCxcblx0XHR3ZWJnbE9iamVjdCwgb2JqZWN0LFxuXHRcdHJlbmRlckxpc3QsXG5cblx0XHRsaWdodHMgPSBzY2VuZS5saWdodHMsXG5cdFx0Zm9nID0gc2NlbmUuZm9nO1xuXG5cdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XG5cblx0XHRpZiAoIHRoaXMuYXV0b1VwZGF0ZU9iamVjdHMgKSB0aGlzLmluaXRXZWJHTE9iamVjdHMoIHNjZW5lICk7XG5cblx0XHRpZiAoIHRoaXMuc2hhZG93TWFwRW5hYmxlZCAmJiB0aGlzLnNoYWRvd01hcEF1dG9VcGRhdGUgKSByZW5kZXJTaGFkb3dNYXAoIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzID0gMDtcblx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyA9IDA7XG5cdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgPSAwO1xuXG5cdFx0aWYgKCBjYW1lcmEucGFyZW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IENhbWVyYSBoYXNuXFwndCBiZWVuIGFkZGVkIHRvIGEgU2NlbmUuIEFkZGluZyBpdC4uLicgKTtcblx0XHRcdHNjZW5lLmFkZCggY2FtZXJhICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYXV0b1VwZGF0ZVNjZW5lICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5mbGF0dGVuVG9BcnJheSggX3ZpZXdNYXRyaXhBcnJheSApO1xuXHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmZsYXR0ZW5Ub0FycmF5KCBfcHJvamVjdGlvbk1hdHJpeEFycmF5ICk7XG5cblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHRjb21wdXRlRnJ1c3R1bSggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuXHRcdHNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRpZiAoIHRoaXMuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XG5cblx0XHRcdHRoaXMuY2xlYXIoIHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2V0IG1hdHJpY2VzIGZvciByZWd1bGFyIG9iamVjdHMgKGZydXN0dW0gY3VsbGVkKVxuXG5cdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBpIF07XG5cdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cblx0XHRcdHdlYmdsT2JqZWN0LnJlbmRlciA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICkge1xuXG5cdFx0XHRcdGlmICggISAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB8fCAhICggb2JqZWN0LmZydXN0dW1DdWxsZWQgKSB8fCBpc0luRnJ1c3R1bSggb2JqZWN0ICkgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QubWF0cml4V29ybGQuZmxhdHRlblRvQXJyYXkoIG9iamVjdC5fb2JqZWN0TWF0cml4QXJyYXkgKTtcblxuXHRcdFx0XHRcdHNldHVwTWF0cmljZXMoIG9iamVjdCwgY2FtZXJhLCB0cnVlICk7XG5cblx0XHRcdFx0XHR1bnJvbGxCdWZmZXJNYXRlcmlhbCggd2ViZ2xPYmplY3QgKTtcblxuXHRcdFx0XHRcdHdlYmdsT2JqZWN0LnJlbmRlciA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuc29ydE9iamVjdHMgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggb2JqZWN0LnJlbmRlckRlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdHdlYmdsT2JqZWN0LnogPSBvYmplY3QucmVuZGVyRGVwdGg7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuY29weSggb2JqZWN0LnBvc2l0aW9uICk7XG5cdFx0XHRcdFx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5VmVjdG9yMyggX3ZlY3RvcjMgKTtcblxuXHRcdFx0XHRcdFx0XHR3ZWJnbE9iamVjdC56ID0gX3ZlY3RvcjMuejtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnNvcnRPYmplY3RzICkge1xuXG5cdFx0XHRyZW5kZXJMaXN0LnNvcnQoIHBhaW50ZXJTb3J0ICk7XG5cblx0XHR9XG5cblx0XHQvLyBzZXQgbWF0cmljZXMgZm9yIGltbWVkaWF0ZSBvYmplY3RzXG5cblx0XHRyZW5kZXJMaXN0ID0gc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGU7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGkgXTtcblx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcblxuXHRcdFx0XHRpZiggb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QubWF0cml4V29ybGQuZmxhdHRlblRvQXJyYXkoIG9iamVjdC5fb2JqZWN0TWF0cml4QXJyYXkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0dXBNYXRyaWNlcyggb2JqZWN0LCBjYW1lcmEsIHRydWUgKTtcblxuXHRcdFx0XHR1bnJvbGxJbW1lZGlhdGVCdWZmZXJNYXRlcmlhbCggd2ViZ2xPYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0XHRzZXRCbGVuZGluZyggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbC5ibGVuZGluZyApO1xuXHRcdFx0c2V0RGVwdGhUZXN0KCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsLmRlcHRoVGVzdCApO1xuXHRcdFx0c2V0RGVwdGhXcml0ZSggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbC5kZXB0aFdyaXRlICk7XG5cdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3Rvciwgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggc2NlbmUuX193ZWJnbE9iamVjdHMsIGZhbHNlLCBcIlwiLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB0cnVlLCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICk7XG5cdFx0XHRyZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgXCJcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgZmFsc2UsIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxuXG5cdFx0XHRzZXRCbGVuZGluZyggVEhSRUUuTm9ybWFsQmxlbmRpbmcgKTtcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggc2NlbmUuX193ZWJnbE9iamVjdHMsIHRydWUsIFwib3BhcXVlXCIsIGNhbWVyYSwgbGlnaHRzLCBmb2csIGZhbHNlICk7XG5cdFx0XHRyZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgXCJvcGFxdWVcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgZmFsc2UgKTtcblxuXHRcdFx0Ly8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggc2NlbmUuX193ZWJnbE9iamVjdHMsIGZhbHNlLCBcInRyYW5zcGFyZW50XCIsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHRydWUgKTtcblx0XHRcdHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCBcInRyYW5zcGFyZW50XCIsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHRydWUgKTtcblxuXHRcdH1cblxuXHRcdC8vIHJlbmRlciAyZFxuXG5cdFx0aWYgKCBzY2VuZS5fX3dlYmdsU3ByaXRlcy5sZW5ndGggKSB7XG5cblx0XHRcdHJlbmRlclNwcml0ZXMoIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdH1cblxuXHRcdC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHJlbmRlclRhcmdldC5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcblxuXHRcdFx0dXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdH1cblxuXHRcdC8vX2dsLmZpbmlzaCgpO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcmVuZGVyU2hhZG93TWFwICggc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdHZhciBpLCBpbCwgaiwgamwsXG5cblx0XHRzaGFkb3dNYXAsIHNoYWRvd01hdHJpeCxcblx0XHRwcm9ncmFtLCBidWZmZXIsIG1hdGVyaWFsLFxuXHRcdHdlYmdsT2JqZWN0LCBvYmplY3QsIGxpZ2h0LFxuXG5cdFx0c2hhZG93SW5kZXggPSAwLFxuXG5cdFx0bGlnaHRzID0gc2NlbmUubGlnaHRzLFxuXHRcdGZvZyA9IG51bGw7XG5cblx0XHRpZiAoICEgX2NhbWVyYUxpZ2h0ICkge1xuXG5cdFx0XHRfY2FtZXJhTGlnaHQgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIF90aGlzLnNoYWRvd0NhbWVyYUZvdiwgX3RoaXMuc2hhZG93TWFwV2lkdGggLyBfdGhpcy5zaGFkb3dNYXBIZWlnaHQsIF90aGlzLnNoYWRvd0NhbWVyYU5lYXIsIF90aGlzLnNoYWRvd0NhbWVyYUZhciApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRsaWdodCA9IGxpZ2h0c1sgaSBdO1xuXG5cdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgJiYgbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XG5cblx0XHRcdFx0aWYgKCAhIF90aGlzLnNoYWRvd01hcFsgc2hhZG93SW5kZXggXSApIHtcblxuXHRcdFx0XHRcdHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCQUZvcm1hdCB9O1xuXG5cdFx0XHRcdFx0X3RoaXMuc2hhZG93TWFwWyBzaGFkb3dJbmRleCBdID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCBfdGhpcy5zaGFkb3dNYXBXaWR0aCwgX3RoaXMuc2hhZG93TWFwSGVpZ2h0LCBwYXJzICk7XG5cdFx0XHRcdFx0X3NoYWRvd01hdHJpeFsgc2hhZG93SW5kZXggXSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoYWRvd01hcCA9IF90aGlzLnNoYWRvd01hcFsgc2hhZG93SW5kZXggXTtcblx0XHRcdFx0c2hhZG93TWF0cml4ID0gX3NoYWRvd01hdHJpeFsgc2hhZG93SW5kZXggXTtcblxuXHRcdFx0XHRfY2FtZXJhTGlnaHQucG9zaXRpb24uY29weSggbGlnaHQucG9zaXRpb24gKTtcblx0XHRcdFx0X2NhbWVyYUxpZ2h0Lmxvb2tBdCggbGlnaHQudGFyZ2V0LnBvc2l0aW9uICk7XG5cblx0XHRcdFx0aWYgKCBfY2FtZXJhTGlnaHQucGFyZW50ID09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiQ2FtZXJhIGlzIG5vdCBvbiB0aGUgU2NlbmUuIEFkZGluZyBpdC4uLlwiICk7XG5cdFx0XHRcdFx0c2NlbmUuYWRkKCBfY2FtZXJhTGlnaHQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aGlzLmF1dG9VcGRhdGVTY2VuZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRcdFx0X2NhbWVyYUxpZ2h0Lm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBfY2FtZXJhTGlnaHQubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHQvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcblxuXHRcdFx0XHRzaGFkb3dNYXRyaXguc2V0KCAwLjUsIDAuMCwgMC4wLCAwLjUsXG5cdFx0XHRcdFx0XHRcdFx0ICAwLjAsIDAuNSwgMC4wLCAwLjUsXG5cdFx0XHRcdFx0XHRcdFx0ICAwLjAsIDAuMCwgMC41LCAwLjUsXG5cdFx0XHRcdFx0XHRcdFx0ICAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcblxuXHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHlTZWxmKCBfY2FtZXJhTGlnaHQucHJvamVjdGlvbk1hdHJpeCApO1xuXHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHlTZWxmKCBfY2FtZXJhTGlnaHQubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRcdFx0Ly8gcmVuZGVyIHNoYWRvdyBtYXBcblxuXHRcdFx0XHRfY2FtZXJhTGlnaHQubWF0cml4V29ybGRJbnZlcnNlLmZsYXR0ZW5Ub0FycmF5KCBfdmlld01hdHJpeEFycmF5ICk7XG5cdFx0XHRcdF9jYW1lcmFMaWdodC5wcm9qZWN0aW9uTWF0cml4LmZsYXR0ZW5Ub0FycmF5KCBfcHJvamVjdGlvbk1hdHJpeEFycmF5ICk7XG5cblx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHkoIF9jYW1lcmFMaWdodC5wcm9qZWN0aW9uTWF0cml4LCBfY2FtZXJhTGlnaHQubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0XHRcdGNvbXB1dGVGcnVzdHVtKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdHNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XG5cblx0XHRcdFx0Ly8gdXNpbmcgYXJiaXRyYXJ5IGNsZWFyIGNvbG9yIGluIGRlcHRoIHBhc3Ncblx0XHRcdFx0Ly8gY3JlYXRlcyB2YXJpYW5jZSBpbiBzaGFkb3dzXG5cblx0XHRcdFx0X2dsLmNsZWFyQ29sb3IoIDEsIDEsIDEsIDEgKTtcblx0XHRcdFx0Ly9fZ2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xuXG5cdFx0XHRcdF90aGlzLmNsZWFyKCk7XG5cblx0XHRcdFx0X2dsLmNsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cblx0XHRcdFx0Ly8gc2V0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXG5cblx0XHRcdFx0amwgPSBzY2VuZS5fX3dlYmdsT2JqZWN0cy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHdlYmdsT2JqZWN0ID0gc2NlbmUuX193ZWJnbE9iamVjdHNbIGogXTtcblx0XHRcdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cblx0XHRcdFx0XHR3ZWJnbE9iamVjdC5yZW5kZXIgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgJiYgb2JqZWN0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggISAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB8fCAhICggb2JqZWN0LmZydXN0dW1DdWxsZWQgKSB8fCBpc0luRnJ1c3R1bSggb2JqZWN0ICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm1hdHJpeFdvcmxkLmZsYXR0ZW5Ub0FycmF5KCBvYmplY3QuX29iamVjdE1hdHJpeEFycmF5ICk7XG5cblx0XHRcdFx0XHRcdFx0c2V0dXBNYXRyaWNlcyggb2JqZWN0LCBfY2FtZXJhTGlnaHQsIGZhbHNlICk7XG5cblx0XHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QucmVuZGVyID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZW5kZXIgcmVndWxhciBvYmplY3RzXG5cblx0XHRcdFx0c2V0RGVwdGhUZXN0KCB0cnVlICk7XG5cdFx0XHRcdHNldEJsZW5kaW5nKCBUSFJFRS5Ob3JtYWxCbGVuZGluZyApOyAvLyBtYXliZSBibGVuZGluZyBzaG91bGQgYmUganVzdCBkaXNhYmxlZD9cblxuXHRcdFx0XHQvL19nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHdlYmdsT2JqZWN0ID0gc2NlbmUuX193ZWJnbE9iamVjdHNbIGogXTtcblxuXHRcdFx0XHRcdGlmICggd2ViZ2xPYmplY3QucmVuZGVyICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cdFx0XHRcdFx0XHRidWZmZXIgPSB3ZWJnbE9iamVjdC5idWZmZXI7XG5cblx0XHRcdFx0XHRcdHNldE9iamVjdEZhY2VzKCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsTW9ycGg7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZW5kZXJCdWZmZXIoIF9jYW1lcmFMaWdodCwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZXQgbWF0cmljZXMgYW5kIHJlbmRlciBpbW1lZGlhdGUgb2JqZWN0c1xuXG5cdFx0XHRcdGpsID0gc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR3ZWJnbE9iamVjdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlWyBqIF07XG5cdFx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSAmJiBvYmplY3QuY2FzdFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdFx0aWYoIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZC5mbGF0dGVuVG9BcnJheSggb2JqZWN0Ll9vYmplY3RNYXRyaXhBcnJheSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcblxuXHRcdFx0XHRcdFx0c2V0dXBNYXRyaWNlcyggb2JqZWN0LCBfY2FtZXJhTGlnaHQsIGZhbHNlICk7XG5cblx0XHRcdFx0XHRcdHNldE9iamVjdEZhY2VzKCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdFx0cHJvZ3JhbSA9IHNldFByb2dyYW0oIF9jYW1lcmFMaWdodCwgbGlnaHRzLCBmb2csIF9kZXB0aE1hdGVyaWFsLCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrKCBwcm9ncmFtLCBfZ2wsIF9mcnVzdHVtICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0LnJlbmRlciggZnVuY3Rpb24oIG9iamVjdCApIHsgcmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIF9kZXB0aE1hdGVyaWFsLnNoYWRpbmcgKTsgfSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG5cdFx0XHRcdHNoYWRvd0luZGV4ICsrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiByZW5kZXJPYmplY3RzICggcmVuZGVyTGlzdCwgcmV2ZXJzZSwgbWF0ZXJpYWxUeXBlLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB1c2VCbGVuZGluZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuXHRcdHZhciB3ZWJnbE9iamVjdCwgb2JqZWN0LCBidWZmZXIsIG1hdGVyaWFsLCBzdGFydCwgZW5kLCBkZWx0YTtcblxuXHRcdGlmICggcmV2ZXJzZSApIHtcblxuXHRcdFx0c3RhcnQgPSByZW5kZXJMaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRlbmQgPSAtMTtcblx0XHRcdGRlbHRhID0gLTE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRlbmQgPSByZW5kZXJMaXN0Lmxlbmd0aDtcblx0XHRcdGRlbHRhID0gMTtcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0OyBpICE9PSBlbmQ7IGkgKz0gZGVsdGEgKSB7XG5cblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xuXG5cdFx0XHRpZiAoIHdlYmdsT2JqZWN0LnJlbmRlciApIHtcblxuXHRcdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cdFx0XHRcdGJ1ZmZlciA9IHdlYmdsT2JqZWN0LmJ1ZmZlcjtcblxuXHRcdFx0XHRpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gd2ViZ2xPYmplY3RbIG1hdGVyaWFsVHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCAhIG1hdGVyaWFsICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpZiAoIHVzZUJsZW5kaW5nICkgc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nICk7XG5cblx0XHRcdFx0XHRzZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuXHRcdFx0XHRcdHNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblx0XHRcdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0T2JqZWN0RmFjZXMoIG9iamVjdCApO1xuXG5cdFx0XHRcdHJlbmRlckJ1ZmZlciggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHNJbW1lZGlhdGUgKCByZW5kZXJMaXN0LCBtYXRlcmlhbFR5cGUsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHVzZUJsZW5kaW5nLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0dmFyIHdlYmdsT2JqZWN0LCBvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xuXHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICkge1xuXG5cdFx0XHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcblxuXHRcdFx0XHRpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gd2ViZ2xPYmplY3RbIG1hdGVyaWFsVHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCAhIG1hdGVyaWFsICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpZiAoIHVzZUJsZW5kaW5nICkgc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nICk7XG5cblx0XHRcdFx0XHRzZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuXHRcdFx0XHRcdHNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblx0XHRcdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0T2JqZWN0RmFjZXMoIG9iamVjdCApO1xuXG5cdFx0XHRcdHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2soIHByb2dyYW0sIF9nbCwgX2ZydXN0dW0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0b2JqZWN0LnJlbmRlciggZnVuY3Rpb24oIG9iamVjdCApIHsgcmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsLnNoYWRpbmcgKTsgfSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gdW5yb2xsSW1tZWRpYXRlQnVmZmVyTWF0ZXJpYWwgKCBnbG9iamVjdCApIHtcblxuXHRcdHZhciBvYmplY3QgPSBnbG9iamVjdC5vYmplY3QsXG5cdFx0XHRtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cblx0XHRcdGdsb2JqZWN0LnRyYW5zcGFyZW50ID0gbWF0ZXJpYWw7XG5cdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBudWxsO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbWF0ZXJpYWw7XG5cdFx0XHRnbG9iamVjdC50cmFuc3BhcmVudCA9IG51bGw7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiB1bnJvbGxCdWZmZXJNYXRlcmlhbCAoIGdsb2JqZWN0ICkge1xuXG5cdFx0dmFyIG9iamVjdCA9IGdsb2JqZWN0Lm9iamVjdCxcblx0XHRcdGJ1ZmZlciA9IGdsb2JqZWN0LmJ1ZmZlcixcblx0XHRcdG1hdGVyaWFsLCBtYXRlcmlhbEluZGV4LCBtZXNoTWF0ZXJpYWw7XG5cblx0XHRtZXNoTWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRpZiAoIG1lc2hNYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdG1hdGVyaWFsSW5kZXggPSBidWZmZXIubWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbEluZGV4ID49IDAgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwgPSBvYmplY3QuZ2VvbWV0cnkubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHRcdGdsb2JqZWN0LnRyYW5zcGFyZW50ID0gbWF0ZXJpYWw7XG5cdFx0XHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbnVsbDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbWF0ZXJpYWw7XG5cdFx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWF0ZXJpYWwgPSBtZXNoTWF0ZXJpYWw7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHRcdGdsb2JqZWN0LnRyYW5zcGFyZW50ID0gbWF0ZXJpYWw7XG5cdFx0XHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbnVsbDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbWF0ZXJpYWw7XG5cdFx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gcmVuZGVyU3ByaXRlcyAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHR2YXIgbywgb2wsIG9iamVjdDtcblx0XHR2YXIgYXR0cmlidXRlcyA9IF9zcHJpdGUuYXR0cmlidXRlcztcblx0XHR2YXIgdW5pZm9ybXMgPSBfc3ByaXRlLnVuaWZvcm1zO1xuXHRcdHZhciBpbnZBc3BlY3QgPSBfdmlld3BvcnRIZWlnaHQgLyBfdmlld3BvcnRXaWR0aDtcblx0XHR2YXIgc2l6ZSwgc2NhbGUgPSBbXTtcblx0XHR2YXIgc2NyZWVuUG9zaXRpb247XG5cdFx0dmFyIGhhbGZWaWV3cG9ydFdpZHRoID0gX3ZpZXdwb3J0V2lkdGggKiAwLjU7XG5cdFx0dmFyIGhhbGZWaWV3cG9ydEhlaWdodCA9IF92aWV3cG9ydEhlaWdodCAqIDAuNTtcblx0XHR2YXIgbWVyZ2VXaXRoM0QgPSB0cnVlO1xuXG5cdFx0Ly8gc2V0dXAgZ2xcblxuXHRcdF9nbC51c2VQcm9ncmFtKCBfc3ByaXRlLnByb2dyYW0gKTtcblx0XHRfY3VycmVudFByb2dyYW0gPSBfc3ByaXRlLnByb2dyYW07XG5cdFx0X29sZEJsZW5kaW5nID0gLTE7XG5cdFx0X29sZERlcHRoVGVzdCA9IC0xO1xuXHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcblxuXHRcdGlmICggIV9zcHJpdGVBdHRyaWJ1dGVzRW5hYmxlZCApIHtcblxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBfc3ByaXRlLmF0dHJpYnV0ZXMucG9zaXRpb24gKTtcblx0XHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggX3Nwcml0ZS5hdHRyaWJ1dGVzLnV2ICk7XG5cblx0XHRcdF9zcHJpdGVBdHRyaWJ1dGVzRW5hYmxlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRfZ2wuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXHRcdF9nbC5kZXB0aE1hc2soIHRydWUgKTtcblxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBfc3ByaXRlLnZlcnRleEJ1ZmZlciApO1xuXHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xuXHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX3Nwcml0ZS5lbGVtZW50QnVmZmVyICk7XG5cblx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIF9wcm9qZWN0aW9uTWF0cml4QXJyYXkgKTtcblxuXHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKTtcblx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcblxuXHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuXHRcdGZvciggbyA9IDAsIG9sID0gc2NlbmUuX193ZWJnbFNwcml0ZXMubGVuZ3RoOyBvIDwgb2w7IG8gKysgKSB7XG5cblx0XHRcdG9iamVjdCA9IHNjZW5lLl9fd2ViZ2xTcHJpdGVzWyBvIF07XG5cblx0XHRcdGlmICggIW9iamVjdC52aXNpYmxlIHx8IG9iamVjdC5vcGFjaXR5ID09PSAwICkgY29udGludWU7XG5cblx0XHRcdGlmKCAhb2JqZWN0LnVzZVNjcmVlbkNvb3JkaW5hdGVzICkge1xuXG5cdFx0XHRcdG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5VG9BcnJheSggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkLCBvYmplY3QuX21vZGVsVmlld01hdHJpeEFycmF5ICk7XG5cdFx0XHRcdG9iamVjdC56ID0gLW9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm4zNDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QueiA9IC1vYmplY3QucG9zaXRpb24uejtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c2NlbmUuX193ZWJnbFNwcml0ZXMuc29ydCggcGFpbnRlclNvcnQgKTtcblxuXHRcdC8vIHJlbmRlciBhbGwgc3ByaXRlc1xuXG5cdFx0Zm9yICggbyA9IDAsIG9sID0gc2NlbmUuX193ZWJnbFNwcml0ZXMubGVuZ3RoOyBvIDwgb2w7IG8gKysgKSB7XG5cblx0XHRcdG9iamVjdCA9IHNjZW5lLl9fd2ViZ2xTcHJpdGVzWyBvIF07XG5cblx0XHRcdGlmICggIW9iamVjdC52aXNpYmxlIHx8IG9iamVjdC5vcGFjaXR5ID09PSAwICkgY29udGludWU7XG5cblx0XHRcdGlmICggb2JqZWN0Lm1hcCAmJiBvYmplY3QubWFwLmltYWdlICYmIG9iamVjdC5tYXAuaW1hZ2Uud2lkdGggKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QudXNlU2NyZWVuQ29vcmRpbmF0ZXMgKSB7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy51c2VTY3JlZW5Db29yZGluYXRlcywgMSApO1xuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCAoIG9iamVjdC5wb3NpdGlvbi54IC0gaGFsZlZpZXdwb3J0V2lkdGggICkgLyBoYWxmVmlld3BvcnRXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggaGFsZlZpZXdwb3J0SGVpZ2h0IC0gb2JqZWN0LnBvc2l0aW9uLnkgKSAvIGhhbGZWaWV3cG9ydEhlaWdodCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgTWF0aC5tYXgoIDAsIE1hdGgubWluKCAxLCBvYmplY3QucG9zaXRpb24ueiApKSk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLnVzZVNjcmVlbkNvb3JkaW5hdGVzLCAwICk7XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMuYWZmZWN0ZWRCeURpc3RhbmNlLCBvYmplY3QuYWZmZWN0ZWRCeURpc3RhbmNlID8gMSA6IDAgKTtcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXhBcnJheSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaXplID0gb2JqZWN0Lm1hcC5pbWFnZS53aWR0aCAvICggb2JqZWN0LnNjYWxlQnlWaWV3cG9ydCA/IF92aWV3cG9ydEhlaWdodCA6IDEgKTtcblxuXHRcdFx0XHRzY2FsZVsgMCBdID0gc2l6ZSAqIGludkFzcGVjdCAqIG9iamVjdC5zY2FsZS54O1xuXHRcdFx0XHRzY2FsZVsgMSBdID0gc2l6ZSAqIG9iamVjdC5zY2FsZS55O1xuXG5cdFx0XHRcdF9nbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIG9iamVjdC51dlNjYWxlLngsIG9iamVjdC51dlNjYWxlLnkgKTtcblx0XHRcdFx0X2dsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIG9iamVjdC51dk9mZnNldC54LCBvYmplY3QudXZPZmZzZXQueSApO1xuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5hbGlnbm1lbnQsIG9iamVjdC5hbGlnbm1lbnQueCwgb2JqZWN0LmFsaWdubWVudC55ICk7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgb2JqZWN0Lm9wYWNpdHkgKTtcblx0XHRcdFx0X2dsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG9iamVjdC5jb2xvci5yLCBvYmplY3QuY29sb3IuZywgb2JqZWN0LmNvbG9yLmIgKTtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgb2JqZWN0LnJvdGF0aW9uICk7XG5cdFx0XHRcdF9nbC51bmlmb3JtMmZ2KCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUgKTtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5tZXJnZVdpdGgzRCAmJiAhbWVyZ2VXaXRoM0QgKSB7XG5cblx0XHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xuXHRcdFx0XHRcdG1lcmdlV2l0aDNEID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhb2JqZWN0Lm1lcmdlV2l0aDNEICYmIG1lcmdlV2l0aDNEICkge1xuXG5cdFx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5ERVBUSF9URVNUICk7XG5cdFx0XHRcdFx0bWVyZ2VXaXRoM0QgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0QmxlbmRpbmcoIG9iamVjdC5ibGVuZGluZyApO1xuXHRcdFx0XHRzZXRUZXh0dXJlKCBvYmplY3QubWFwLCAwICk7XG5cblx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLlRSSUFOR0xFUywgNiwgX2dsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0Ly8gcmVzdG9yZSBnbFxuXG5cdFx0X2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXHRcdF9nbC5lbmFibGUoIF9nbC5ERVBUSF9URVNUICk7XG5cdFx0X2dsLmRlcHRoTWFzayggX29sZERlcHRoV3JpdGUgKTtcblxuXHR9XG5cblx0Ly8gR2VvbWV0cnkgc3BsaXR0aW5nXG5cblx0ZnVuY3Rpb24gc29ydEZhY2VzQnlNYXRlcmlhbCAoIGdlb21ldHJ5ICkge1xuXG5cdFx0dmFyIGYsIGZsLCBmYWNlLCBtYXRlcmlhbEluZGV4LCB2ZXJ0aWNlcyxcblx0XHRcdG1hdGVyaWFsSGFzaCwgZ3JvdXBIYXNoLFxuXHRcdFx0aGFzaF9tYXAgPSB7fTtcblxuXHRcdHZhciBudW1Nb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO1xuXG5cdFx0Z2VvbWV0cnkuZ2VvbWV0cnlHcm91cHMgPSB7fTtcblxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGYgXTtcblx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdG1hdGVyaWFsSGFzaCA9ICggbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbEluZGV4IDogLTE7XG5cblx0XHRcdGlmICggaGFzaF9tYXBbIG1hdGVyaWFsSGFzaCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aGFzaF9tYXBbIG1hdGVyaWFsSGFzaCBdID0geyAnaGFzaCc6IG1hdGVyaWFsSGFzaCwgJ2NvdW50ZXInOiAwIH07XG5cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXBIYXNoID0gaGFzaF9tYXBbIG1hdGVyaWFsSGFzaCBdLmhhc2ggKyAnXycgKyBoYXNoX21hcFsgbWF0ZXJpYWxIYXNoIF0uY291bnRlcjtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0gPSB7ICdmYWNlczMnOiBbXSwgJ2ZhY2VzNCc6IFtdLCAnbWF0ZXJpYWxJbmRleCc6IG1hdGVyaWFsSW5kZXgsICd2ZXJ0aWNlcyc6IDAsICdudW1Nb3JwaFRhcmdldHMnOiBudW1Nb3JwaFRhcmdldHMgfTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2ZXJ0aWNlcyA9IGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyA/IDMgOiA0O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXS52ZXJ0aWNlcyArIHZlcnRpY2VzID4gNjU1MzUgKSB7XG5cblx0XHRcdFx0aGFzaF9tYXBbIG1hdGVyaWFsSGFzaCBdLmNvdW50ZXIgKz0gMTtcblx0XHRcdFx0Z3JvdXBIYXNoID0gaGFzaF9tYXBbIG1hdGVyaWFsSGFzaCBdLmhhc2ggKyAnXycgKyBoYXNoX21hcFsgbWF0ZXJpYWxIYXNoIF0uY291bnRlcjtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdID0geyAnZmFjZXMzJzogW10sICdmYWNlczQnOiBbXSwgJ21hdGVyaWFsSW5kZXgnOiBtYXRlcmlhbEluZGV4LCAndmVydGljZXMnOiAwLCAnbnVtTW9ycGhUYXJnZXRzJzogbnVtTW9ycGhUYXJnZXRzIH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXS5mYWNlczMucHVzaCggZiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXS5mYWNlczQucHVzaCggZiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXS52ZXJ0aWNlcyArPSB2ZXJ0aWNlcztcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzTGlzdCA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGcgaW4gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHMgKSB7XG5cblx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF0uaWQgPSBfZ2VvbWV0cnlHcm91cENvdW50ZXIgKys7XG5cblx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzTGlzdC5wdXNoKCBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZyBdICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBPYmplY3RzIHJlZnJlc2hcblxuXHR0aGlzLmluaXRXZWJHTE9iamVjdHMgPSBmdW5jdGlvbiAoIHNjZW5lICkge1xuXG5cdFx0aWYgKCAhc2NlbmUuX193ZWJnbE9iamVjdHMgKSB7XG5cblx0XHRcdHNjZW5lLl9fd2ViZ2xPYmplY3RzID0gW107XG5cdFx0XHRzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSA9IFtdO1xuXHRcdFx0c2NlbmUuX193ZWJnbFNwcml0ZXMgPSBbXTtcblxuXHRcdH1cblxuXHRcdHdoaWxlICggc2NlbmUuX19vYmplY3RzQWRkZWQubGVuZ3RoICkge1xuXG5cdFx0XHRhZGRPYmplY3QoIHNjZW5lLl9fb2JqZWN0c0FkZGVkWyAwIF0sIHNjZW5lICk7XG5cdFx0XHRzY2VuZS5fX29iamVjdHNBZGRlZC5zcGxpY2UoIDAsIDEgKTtcblxuXHRcdH1cblxuXHRcdHdoaWxlICggc2NlbmUuX19vYmplY3RzUmVtb3ZlZC5sZW5ndGggKSB7XG5cblx0XHRcdHJlbW92ZU9iamVjdCggc2NlbmUuX19vYmplY3RzUmVtb3ZlZFsgMCBdLCBzY2VuZSApO1xuXHRcdFx0c2NlbmUuX19vYmplY3RzUmVtb3ZlZC5zcGxpY2UoIDAsIDEgKTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBvYmplY3RzIGFkZGluZyAvIHJlbW92YWxcblxuXHRcdGZvciAoIHZhciBvID0gMCwgb2wgPSBzY2VuZS5fX3dlYmdsT2JqZWN0cy5sZW5ndGg7IG8gPCBvbDsgbyArKyApIHtcblxuXHRcdFx0dXBkYXRlT2JqZWN0KCBzY2VuZS5fX3dlYmdsT2JqZWN0c1sgbyBdLm9iamVjdCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gT2JqZWN0cyBhZGRpbmdcblxuXHRmdW5jdGlvbiBhZGRPYmplY3QgKCBvYmplY3QsIHNjZW5lICkge1xuXG5cdFx0dmFyIGcsIGdlb21ldHJ5LCBnZW9tZXRyeUdyb3VwO1xuXG5cdFx0aWYgKCAhIG9iamVjdC5fX3dlYmdsSW5pdCApIHtcblxuXHRcdFx0b2JqZWN0Ll9fd2ViZ2xJbml0ID0gdHJ1ZTtcblxuXHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRvYmplY3QuX25vcm1hbE1hdHJpeEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSApO1xuXHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICk7XG5cdFx0XHRvYmplY3QuX29iamVjdE1hdHJpeEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKTtcblxuXHRcdFx0b2JqZWN0Lm1hdHJpeFdvcmxkLmZsYXR0ZW5Ub0FycmF5KCBvYmplY3QuX29iamVjdE1hdHJpeEFycmF5ICk7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzb3J0RmFjZXNCeU1hdGVyaWFsKCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgc2VwYXJhdGUgVkJPcyBwZXIgZ2VvbWV0cnkgY2h1bmtcblxuXHRcdFx0XHRmb3IgKCBnIGluIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF07XG5cblx0XHRcdFx0XHQvLyBpbml0aWFsaXNlIFZCTyBvbiB0aGUgZmlyc3QgYWNjZXNzXG5cblx0XHRcdFx0XHRpZiAoICEgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRjcmVhdGVNZXNoQnVmZmVycyggZ2VvbWV0cnlHcm91cCApO1xuXHRcdFx0XHRcdFx0aW5pdE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuX19kaXJ0eVZlcnRpY2VzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGdlb21ldHJ5Ll9fZGlydHlNb3JwaFRhcmdldHMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuX19kaXJ0eUVsZW1lbnRzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGdlb21ldHJ5Ll9fZGlydHlVdnMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuX19kaXJ0eU5vcm1hbHMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuX19kaXJ0eVRhbmdlbnRzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGdlb21ldHJ5Ll9fZGlydHlDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUmliYm9uICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHRcdGlmKCAhIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRjcmVhdGVSaWJib25CdWZmZXJzKCBnZW9tZXRyeSApO1xuXHRcdFx0XHRcdGluaXRSaWJib25CdWZmZXJzKCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuX19kaXJ0eVZlcnRpY2VzID0gdHJ1ZTtcblx0XHRcdFx0XHRnZW9tZXRyeS5fX2RpcnR5Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdFx0aWYoICEgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdGNyZWF0ZUxpbmVCdWZmZXJzKCBnZW9tZXRyeSApO1xuXHRcdFx0XHRcdGluaXRMaW5lQnVmZmVycyggZ2VvbWV0cnksIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuX19kaXJ0eVZlcnRpY2VzID0gdHJ1ZTtcblx0XHRcdFx0XHRnZW9tZXRyeS5fX2RpcnR5Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHRcdGlmICggISBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyICkge1xuXG5cdFx0XHRcdFx0Y3JlYXRlUGFydGljbGVCdWZmZXJzKCBnZW9tZXRyeSApO1xuXHRcdFx0XHRcdGluaXRQYXJ0aWNsZUJ1ZmZlcnMoIGdlb21ldHJ5LCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdGdlb21ldHJ5Ll9fZGlydHlWZXJ0aWNlcyA9IHRydWU7XG5cdFx0XHRcdFx0Z2VvbWV0cnkuX19kaXJ0eUNvbG9ycyA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoICEgb2JqZWN0Ll9fd2ViZ2xBY3RpdmUgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0XHRmb3IgKCBnIGluIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF07XG5cblx0XHRcdFx0XHRhZGRCdWZmZXIoIHNjZW5lLl9fd2ViZ2xPYmplY3RzLCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlJpYmJvbiB8fFxuXHRcdFx0XHRcdFx0b2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fFxuXHRcdFx0XHRcdFx0b2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0XHRcdGFkZEJ1ZmZlciggc2NlbmUuX193ZWJnbE9iamVjdHMsIGdlb21ldHJ5LCBvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggVEhSRUUuTWFyY2hpbmdDdWJlcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1hcmNoaW5nQ3ViZXMgfHwgb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xuXG5cdFx0XHRcdGFkZEJ1ZmZlckltbWVkaWF0ZSggc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsIG9iamVjdCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XG5cblx0XHRcdFx0c2NlbmUuX193ZWJnbFNwcml0ZXMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0Ll9fd2ViZ2xBY3RpdmUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gYWRkQnVmZmVyICggb2JqbGlzdCwgYnVmZmVyLCBvYmplY3QgKSB7XG5cblx0XHRvYmpsaXN0LnB1c2goXG5cdFx0XHR7XG5cdFx0XHRcdGJ1ZmZlcjogYnVmZmVyLFxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcblx0XHRcdFx0b3BhcXVlOiBudWxsLFxuXHRcdFx0XHR0cmFuc3BhcmVudDogbnVsbFxuXHRcdFx0fVxuXHRcdCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBhZGRCdWZmZXJJbW1lZGlhdGUgKCBvYmpsaXN0LCBvYmplY3QgKSB7XG5cblx0XHRvYmpsaXN0LnB1c2goXG5cdFx0XHR7XG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRvcGFxdWU6IG51bGwsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiBudWxsXG5cdFx0XHR9XG5cdFx0KTtcblxuXHR9O1xuXG5cdC8vIE9iamVjdHMgdXBkYXRlc1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZU9iamVjdCAoIG9iamVjdCApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeSxcblx0XHRcdGdlb21ldHJ5R3JvdXAsIGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSwgbWF0ZXJpYWw7XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdC8vIGNoZWNrIGFsbCBnZW9tZXRyeSBncm91cHNcblxuXHRcdFx0Zm9yKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAgPSBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc0xpc3RbIGkgXTtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKTtcblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGVzRGlydHkgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGFyZUN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Ll9fZGlydHlWZXJ0aWNlcyB8fCBnZW9tZXRyeS5fX2RpcnR5TW9ycGhUYXJnZXRzIHx8IGdlb21ldHJ5Ll9fZGlydHlFbGVtZW50cyB8fFxuXHRcdFx0XHRcdCBnZW9tZXRyeS5fX2RpcnR5VXZzIHx8IGdlb21ldHJ5Ll9fZGlydHlOb3JtYWxzIHx8XG5cdFx0XHRcdFx0IGdlb21ldHJ5Ll9fZGlydHlDb2xvcnMgfHwgZ2VvbWV0cnkuX19kaXJ0eVRhbmdlbnRzIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcblxuXHRcdFx0XHRcdHNldE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QsIF9nbC5EWU5BTUlDX0RSQVcsICFnZW9tZXRyeS5keW5hbWljLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5fX2RpcnR5VmVydGljZXMgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5Ll9fZGlydHlNb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5Ll9fZGlydHlFbGVtZW50cyA9IGZhbHNlO1xuXHRcdFx0Z2VvbWV0cnkuX19kaXJ0eVV2cyA9IGZhbHNlO1xuXHRcdFx0Z2VvbWV0cnkuX19kaXJ0eU5vcm1hbHMgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5Ll9fZGlydHlDb2xvcnMgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5Ll9fZGlydHlUYW5nZW50cyA9IGZhbHNlO1xuXG5cdFx0XHRtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGNsZWFyQ3VzdG9tQXR0cmlidXRlcyggbWF0ZXJpYWwgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlJpYmJvbiApIHtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5fX2RpcnR5VmVydGljZXMgfHwgZ2VvbWV0cnkuX19kaXJ0eUNvbG9ycyApIHtcblxuXHRcdFx0XHRzZXRSaWJib25CdWZmZXJzKCBnZW9tZXRyeSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5Ll9fZGlydHlWZXJ0aWNlcyA9IGZhbHNlO1xuXHRcdFx0Z2VvbWV0cnkuX19kaXJ0eUNvbG9ycyA9IGZhbHNlO1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuXHRcdFx0bWF0ZXJpYWwgPSBnZXRCdWZmZXJNYXRlcmlhbCggb2JqZWN0LCBnZW9tZXRyeUdyb3VwICk7XG5cblx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5Ll9fZGlydHlWZXJ0aWNlcyB8fCAgZ2VvbWV0cnkuX19kaXJ0eUNvbG9ycyB8fCBjdXN0b21BdHRyaWJ1dGVzRGlydHkgKSB7XG5cblx0XHRcdFx0c2V0TGluZUJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuX19kaXJ0eVZlcnRpY2VzID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5fX2RpcnR5Q29sb3JzID0gZmFsc2U7XG5cblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB7XG5cblx0XHRcdG1hdGVyaWFsID0gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnlHcm91cCApO1xuXG5cdFx0XHRjdXN0b21BdHRyaWJ1dGVzRGlydHkgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGFyZUN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5fX2RpcnR5VmVydGljZXMgfHwgZ2VvbWV0cnkuX19kaXJ0eUNvbG9ycyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyB8fCBjdXN0b21BdHRyaWJ1dGVzRGlydHkgKSB7XG5cblx0XHRcdFx0c2V0UGFydGljbGVCdWZmZXJzKCBnZW9tZXRyeSwgX2dsLkRZTkFNSUNfRFJBVywgb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuX19kaXJ0eVZlcnRpY2VzID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5fX2RpcnR5Q29sb3JzID0gZmFsc2U7XG5cblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gT2JqZWN0cyB1cGRhdGVzIC0gY3VzdG9tIGF0dHJpYnV0ZXMgY2hlY2tcblxuXHRmdW5jdGlvbiBhcmVDdXN0b21BdHRyaWJ1dGVzRGlydHkgKCBtYXRlcmlhbCApIHtcblxuXHRcdGZvciAoIHZhciBhIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuYXR0cmlidXRlc1sgYSBdLm5lZWRzVXBkYXRlICkgcmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMgKCBtYXRlcmlhbCApIHtcblxuXHRcdGZvciAoIHZhciBhIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXNbIGEgXS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gT2JqZWN0cyByZW1vdmFsXG5cblx0ZnVuY3Rpb24gcmVtb3ZlT2JqZWN0ICggb2JqZWN0LCBzY2VuZSApIHtcblxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCAgfHxcblx0XHRcdCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSB8fFxuXHRcdFx0IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlJpYmJvbiB8fFxuXHRcdFx0IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdHJlbW92ZUluc3RhbmNlcyggc2NlbmUuX193ZWJnbE9iamVjdHMsIG9iamVjdCApO1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xuXG5cdFx0XHRyZW1vdmVJbnN0YW5jZXNEaXJlY3QoIHNjZW5lLl9fd2ViZ2xTcHJpdGVzLCBvYmplY3QgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1hcmNoaW5nQ3ViZXMgfHwgb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xuXG5cdFx0XHRyZW1vdmVJbnN0YW5jZXMoIHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCBvYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdG9iamVjdC5fX3dlYmdsQWN0aXZlID0gZmFsc2U7XG5cblx0fTtcblxuXHRmdW5jdGlvbiByZW1vdmVJbnN0YW5jZXMgKCBvYmpsaXN0LCBvYmplY3QgKSB7XG5cblx0XHRmb3IgKCB2YXIgbyA9IG9iamxpc3QubGVuZ3RoIC0gMTsgbyA+PSAwOyBvIC0tICkge1xuXG5cdFx0XHRpZiAoIG9iamxpc3RbIG8gXS5vYmplY3QgPT09IG9iamVjdCApIHtcblxuXHRcdFx0XHRvYmpsaXN0LnNwbGljZSggbywgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiByZW1vdmVJbnN0YW5jZXNEaXJlY3QgKCBvYmpsaXN0LCBvYmplY3QgKSB7XG5cblx0XHRmb3IgKCB2YXIgbyA9IG9iamxpc3QubGVuZ3RoIC0gMTsgbyA+PSAwOyBvIC0tICkge1xuXG5cdFx0XHRpZiAoIG9iamxpc3RbIG8gXSA9PT0gb2JqZWN0ICkge1xuXG5cdFx0XHRcdG9iamxpc3Quc3BsaWNlKCBvLCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIE1hdGVyaWFsc1xuXG5cdHRoaXMuaW5pdE1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcblxuXHRcdHZhciB1LCBhLCBpZGVudGlmaWVycywgaSwgcGFyYW1ldGVycywgbWF4TGlnaHRDb3VudCwgbWF4Qm9uZXMsIG1heFNoYWRvd3MsIHNoYWRlcklEO1xuXG5cdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdkZXB0aCc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAnbm9ybWFsJztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHNoYWRlcklEID0gJ2Jhc2ljJztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAnbGFtYmVydCc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdwaG9uZyc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdiYXNpYyc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAncGFydGljbGVfYmFzaWMnO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzaGFkZXJJRCApIHtcblxuXHRcdFx0c2V0TWF0ZXJpYWxTaGFkZXJzKCBtYXRlcmlhbCwgVEhSRUUuU2hhZGVyTGliWyBzaGFkZXJJRCBdICk7XG5cblx0XHR9XG5cblx0XHQvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxuXHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXG5cblx0XHRtYXhMaWdodENvdW50ID0gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApO1xuXG5cdFx0bWF4U2hhZG93cyA9IGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICk7XG5cblx0XHRtYXhCb25lcyA9IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApO1xuXG5cdFx0cGFyYW1ldGVycyA9IHtcblxuXHRcdFx0bWFwOiAhIW1hdGVyaWFsLm1hcCwgZW52TWFwOiAhIW1hdGVyaWFsLmVudk1hcCwgbGlnaHRNYXA6ICEhbWF0ZXJpYWwubGlnaHRNYXAsXG5cdFx0XHR2ZXJ0ZXhDb2xvcnM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyxcblx0XHRcdGZvZzogZm9nLCB1c2VGb2c6IG1hdGVyaWFsLmZvZyxcblx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxuXHRcdFx0c2tpbm5pbmc6IG1hdGVyaWFsLnNraW5uaW5nLFxuXHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXG5cdFx0XHRtYXhNb3JwaFRhcmdldHM6IHRoaXMubWF4TW9ycGhUYXJnZXRzLFxuXHRcdFx0bWF4RGlyTGlnaHRzOiBtYXhMaWdodENvdW50LmRpcmVjdGlvbmFsLCBtYXhQb2ludExpZ2h0czogbWF4TGlnaHRDb3VudC5wb2ludCxcblx0XHRcdG1heEJvbmVzOiBtYXhCb25lcyxcblx0XHRcdHNoYWRvd01hcEVuYWJsZWQ6IHRoaXMuc2hhZG93TWFwRW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyxcblx0XHRcdHNoYWRvd01hcFNvZnQ6IHRoaXMuc2hhZG93TWFwU29mdCxcblx0XHRcdHNoYWRvd01hcFdpZHRoOiB0aGlzLnNoYWRvd01hcFdpZHRoLFxuXHRcdFx0c2hhZG93TWFwSGVpZ2h0OiB0aGlzLnNoYWRvd01hcEhlaWdodCxcblx0XHRcdG1heFNoYWRvd3M6IG1heFNoYWRvd3MsXG5cdFx0XHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcblx0XHRcdG1ldGFsOiBtYXRlcmlhbC5tZXRhbCxcblx0XHRcdHBlclBpeGVsOiBtYXRlcmlhbC5wZXJQaXhlbFxuXG5cdFx0fTtcblxuXHRcdG1hdGVyaWFsLnByb2dyYW0gPSBidWlsZFByb2dyYW0oIHNoYWRlcklELCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciwgbWF0ZXJpYWwudmVydGV4U2hhZGVyLCBtYXRlcmlhbC51bmlmb3JtcywgbWF0ZXJpYWwuYXR0cmlidXRlcywgcGFyYW1ldGVycyApO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBtYXRlcmlhbC5wcm9ncmFtLmF0dHJpYnV0ZXM7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gPj0gMCApIF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdGlmICggYXR0cmlidXRlcy5jb2xvciA+PSAwICkgX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzLmNvbG9yICk7XG5cdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA+PSAwICkgX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xuXHRcdGlmICggYXR0cmlidXRlcy50YW5nZW50ID49IDAgKSBfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZXMudGFuZ2VudCApO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyAmJlxuXHRcdFx0IGF0dHJpYnV0ZXMuc2tpblZlcnRleEEgPj0wICYmIGF0dHJpYnV0ZXMuc2tpblZlcnRleEIgPj0gMCAmJlxuXHRcdFx0IGF0dHJpYnV0ZXMuc2tpbkluZGV4ID49IDAgJiYgYXR0cmlidXRlcy5za2luV2VpZ2h0ID49IDAgKSB7XG5cblx0XHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy5za2luVmVydGV4QSApO1xuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzLnNraW5WZXJ0ZXhCICk7XG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZXMuc2tpbkluZGV4ICk7XG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZXMuc2tpbldlaWdodCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRmb3IgKCBhIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0aWYoIGF0dHJpYnV0ZXNbIGEgXSAhPT0gdW5kZWZpbmVkICYmIGF0dHJpYnV0ZXNbIGEgXSA+PSAwICkgX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzWyBhIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XG5cblx0XHRcdHZhciBpZCwgYmFzZSA9IFwibW9ycGhUYXJnZXRcIjtcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuXHRcdFx0XHRpZCA9IGJhc2UgKyBpO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgaWQgXSA+PSAwICkge1xuXG5cdFx0XHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzWyBpZCBdICk7XG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bWF0ZXJpYWwudW5pZm9ybXNMaXN0ID0gW107XG5cblx0XHRmb3IgKCB1IGluIG1hdGVyaWFsLnVuaWZvcm1zICkge1xuXG5cdFx0XHRtYXRlcmlhbC51bmlmb3Jtc0xpc3QucHVzaCggWyBtYXRlcmlhbC51bmlmb3Jtc1sgdSBdLCB1IF0gKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldE1hdGVyaWFsU2hhZGVycyAoIG1hdGVyaWFsLCBzaGFkZXJzICkge1xuXG5cdFx0bWF0ZXJpYWwudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXJzLnVuaWZvcm1zICk7XG5cdFx0bWF0ZXJpYWwudmVydGV4U2hhZGVyID0gc2hhZGVycy52ZXJ0ZXhTaGFkZXI7XG5cdFx0bWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJzLmZyYWdtZW50U2hhZGVyO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0UHJvZ3JhbSAoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XG5cblx0XHRpZiAoICEgbWF0ZXJpYWwucHJvZ3JhbSApIHtcblxuXHRcdFx0X3RoaXMuaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdGlmICggISBvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcblxuXHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIF90aGlzLm1heE1vcnBoVGFyZ2V0cyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBfdGhpcy5tYXhNb3JwaFRhcmdldHM7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbC5wcm9ncmFtLFxuXHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0udW5pZm9ybXMsXG5cdFx0XHRtX3VuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG5cblx0XHRpZiAoIHByb2dyYW0gIT09IF9jdXJyZW50UHJvZ3JhbSApIHtcblxuXHRcdFx0X2dsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblx0XHRcdF9jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG5cblx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XG5cblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xuXHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgX3Byb2plY3Rpb25NYXRyaXhBcnJheSApO1xuXG5cdFx0XHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG5cdFx0XHRpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwubGlnaHRzICkge1xuXG5cdFx0XHRcdHNldHVwTGlnaHRzKCBwcm9ncmFtLCBsaWdodHMgKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGlnaHRzKCBtX3VuaWZvcm1zLCBfbGlnaHRzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZnJlc2ggc2luZ2xlIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bV91bmlmb3Jtcy5tTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0XHRtX3VuaWZvcm1zLm1GYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xuXHRcdFx0XHRtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgISBtYXRlcmlhbC5fc2hhZG93UGFzcyApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNTaGFkb3coIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9hZCBjb21tb24gdW5pZm9ybXNcblxuXHRcdFx0bG9hZFVuaWZvcm1zR2VuZXJpYyggcHJvZ3JhbSwgbWF0ZXJpYWwudW5pZm9ybXNMaXN0ICk7XG5cblx0XHRcdC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcblx0XHRcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwuZW52TWFwICkge1xuXG5cdFx0XHRcdGlmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiwgY2FtZXJhLnBvc2l0aW9uLngsIGNhbWVyYS5wb3NpdGlvbi55LCBjYW1lcmEucG9zaXRpb24ueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0aWYoIHBfdW5pZm9ybXMudmlld01hdHJpeCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBfdmlld01hdHJpeEFycmF5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0bG9hZFVuaWZvcm1zU2tpbm5pbmcoIHBfdW5pZm9ybXMsIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRsb2FkVW5pZm9ybXNNYXRyaWNlcyggcF91bmlmb3Jtcywgb2JqZWN0ICk7XG5cblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcblx0XHRcdCBtYXRlcmlhbC5lbnZNYXAgfHxcblx0XHRcdCBtYXRlcmlhbC5za2lubmluZyB8fFxuXHRcdFx0IG9iamVjdC5yZWNlaXZlU2hhZG93ICkge1xuXG5cdFx0XHRpZiAoIHBfdW5pZm9ybXMub2JqZWN0TWF0cml4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLm9iamVjdE1hdHJpeCwgZmFsc2UsIG9iamVjdC5fb2JqZWN0TWF0cml4QXJyYXkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb2dyYW07XG5cblx0fTtcblxuXHQvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMubWFwLnRleHR1cmUgPSBtYXRlcmlhbC5tYXA7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnksIG1hdGVyaWFsLm1hcC5yZXBlYXQueCwgbWF0ZXJpYWwubWFwLnJlcGVhdC55ICk7XG5cblx0XHR9XG5cblx0XHR1bmlmb3Jtcy5saWdodE1hcC50ZXh0dXJlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG5cblx0XHR1bmlmb3Jtcy5lbnZNYXAudGV4dHVyZSA9IG1hdGVyaWFsLmVudk1hcDtcblx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBtYXRlcmlhbC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSA/IDEgOiAtMTtcblxuXHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcblxuXHRcdFx0Ly91bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgKiBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XG5cdFx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XG5cblx0XHR9XG5cblx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XG5cdFx0dW5pZm9ybXMuY29tYmluZS52YWx1ZSA9IG1hdGVyaWFsLmNvbWJpbmU7XG5cdFx0dW5pZm9ybXMudXNlUmVmcmFjdC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyBpbnN0YW5jZW9mIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLnBzQ29sb3IudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuaGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxuXG5cdFx0dW5pZm9ybXMubWFwLnRleHR1cmUgPSBtYXRlcmlhbC5tYXA7XG5cblx0fTtcblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2cgKCB1bmlmb3JtcywgZm9nICkge1xuXG5cdFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XG5cblx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuXHRcdFx0dW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xuXHRcdFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcblxuXHRcdH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Bob25nICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gbWF0ZXJpYWwuc2hpbmluZXNzO1xuXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5hbWJpZW50ICk7XG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuc3BlY3VsYXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHVuaWZvcm1zLmFtYmllbnQudmFsdWUgPSBtYXRlcmlhbC5hbWJpZW50O1xuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhcjtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFtYmllbnQudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLmFtYmllbnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHVuaWZvcm1zLmFtYmllbnQudmFsdWUgPSBtYXRlcmlhbC5hbWJpZW50O1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGlnaHRzICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcblxuXHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmFtYmllbnQ7XG5cblx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuZGlyZWN0aW9uYWwuY29sb3JzO1xuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zO1xuXG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnBvaW50LmNvbG9ycztcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0UG9zaXRpb24udmFsdWUgPSBsaWdodHMucG9pbnQucG9zaXRpb25zO1xuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kaXN0YW5jZXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTaGFkb3cgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRpZiAoIHVuaWZvcm1zLnNoYWRvd01hdHJpeCApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgX3NoYWRvd01hdHJpeC5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWF0cml4LnZhbHVlWyBpIF0gPSBfc2hhZG93TWF0cml4WyBpIF07XG5cdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcC50ZXh0dXJlWyBpIF0gPSBfdGhpcy5zaGFkb3dNYXBbIGkgXTtcblxuXG5cdFx0XHR9XG5cblx0XHRcdHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlID0gX3RoaXMuc2hhZG93TWFwRGFya25lc3M7XG5cdFx0XHR1bmlmb3Jtcy5zaGFkb3dCaWFzLnZhbHVlID0gX3RoaXMuc2hhZG93TWFwQmlhcztcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcblxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNTa2lubmluZyAoIHVuaWZvcm1zLCBvYmplY3QgKSB7XG5cblx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMuY2FtZXJhSW52ZXJzZU1hdHJpeCwgZmFsc2UsIF92aWV3TWF0cml4QXJyYXkgKTtcblx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMuYm9uZUdsb2JhbE1hdHJpY2VzLCBmYWxzZSwgb2JqZWN0LmJvbmVNYXRyaWNlcyApO1xuXG5cdH07XG5cblxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNNYXRyaWNlcyAoIHVuaWZvcm1zLCBvYmplY3QgKSB7XG5cblx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXhBcnJheSApO1xuXG5cdFx0aWYgKCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXggKSB7XG5cblx0XHRcdF9nbC51bmlmb3JtTWF0cml4M2Z2KCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXgsIGZhbHNlLCBvYmplY3QuX25vcm1hbE1hdHJpeEFycmF5ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNHZW5lcmljICggcHJvZ3JhbSwgdW5pZm9ybXMgKSB7XG5cblx0XHR2YXIgdW5pZm9ybSwgdmFsdWUsIHR5cGUsIGxvY2F0aW9uLCB0ZXh0dXJlLCBpLCBpbCwgaiwgamwsIG9mZnNldDtcblxuXHRcdGZvciggaiA9IDAsIGpsID0gdW5pZm9ybXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdGxvY2F0aW9uID0gcHJvZ3JhbS51bmlmb3Jtc1sgdW5pZm9ybXNbIGogXVsgMSBdIF07XG5cdFx0XHRpZiAoICFsb2NhdGlvbiApIGNvbnRpbnVlO1xuXG5cdFx0XHR1bmlmb3JtID0gdW5pZm9ybXNbIGogXVsgMCBdO1xuXG5cdFx0XHR0eXBlID0gdW5pZm9ybS50eXBlO1xuXHRcdFx0dmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXG5cdFx0XHQvLyBzaW5nbGUgaW50ZWdlclxuXG5cdFx0XHRpZiggdHlwZSA9PT0gXCJpXCIgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdC8vIHNpbmdsZSBmbG9hdFxuXG5cdFx0XHR9IGVsc2UgaWYoIHR5cGUgPT09IFwiZlwiICkge1xuXG5cdFx0XHRcdF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yMlxuXG5cdFx0XHR9IGVsc2UgaWYoIHR5cGUgPT09IFwidjJcIiApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xuXG5cdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yM1xuXG5cdFx0XHR9IGVsc2UgaWYoIHR5cGUgPT09IFwidjNcIiApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiApO1xuXG5cdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yNFxuXG5cdFx0XHR9IGVsc2UgaWYoIHR5cGUgPT09IFwidjRcIiApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyApO1xuXG5cdFx0XHQvLyBzaW5nbGUgVEhSRUUuQ29sb3JcblxuXHRcdFx0fSBlbHNlIGlmKCB0eXBlID09PSBcImNcIiApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xuXG5cdFx0XHQvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXG5cblx0XHRcdH0gZWxzZSBpZiggdHlwZSA9PT0gXCJmdjFcIiApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG5cblx0XHRcdH0gZWxzZSBpZiggdHlwZSA9PT0gXCJmdlwiICkge1xuXG5cdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yM1xuXG5cdFx0XHR9IGVsc2UgaWYoIHR5cGUgPT09IFwidjN2XCIgKSB7XG5cblx0XHRcdFx0aWYgKCAhIHVuaWZvcm0uX2FycmF5ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAzICogdmFsdWUubGVuZ3RoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0b2Zmc2V0ID0gaSAqIDM7XG5cblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0IF0gXHQgPSB2YWx1ZVsgaSBdLng7XG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWVbIGkgXS56O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdC8vIHNpbmdsZSBUSFJFRS5NYXRyaXg0XG5cblx0XHRcdH0gZWxzZSBpZiggdHlwZSA9PT0gXCJtNFwiICkge1xuXG5cdFx0XHRcdGlmICggISB1bmlmb3JtLl9hcnJheSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFsdWUuZmxhdHRlblRvQXJyYXkoIHVuaWZvcm0uX2FycmF5ICk7XG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDRcblxuXHRcdFx0fSBlbHNlIGlmKCB0eXBlID09PSBcIm00dlwiICkge1xuXG5cdFx0XHRcdGlmICggISB1bmlmb3JtLl9hcnJheSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDE2ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cblxuXHRcdFx0Ly8gc2luZ2xlIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXG5cblx0XHRcdH0gZWxzZSBpZiggdHlwZSA9PT0gXCJ0XCIgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0dGV4dHVyZSA9IHVuaWZvcm0udGV4dHVyZTtcblxuXHRcdFx0XHRpZiAoICF0ZXh0dXJlICkgY29udGludWU7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmltYWdlIGluc3RhbmNlb2YgQXJyYXkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XG5cblx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdmFsdWUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmVEeW5hbWljKCB0ZXh0dXJlLCB2YWx1ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXRUZXh0dXJlKCB0ZXh0dXJlLCB2YWx1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuVGV4dHVyZSAoMmQpXG5cblx0XHRcdH0gZWxzZSBpZiggdHlwZSA9PT0gXCJ0dlwiICkge1xuXG5cdFx0XHRcdGlmICggISB1bmlmb3JtLl9hcnJheSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gW107XG5cblx0XHRcdFx0XHRmb3IoIGkgPSAwLCBpbCA9IHVuaWZvcm0udGV4dHVyZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkgXSA9IHZhbHVlICsgaTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdGZvciggaSA9IDAsIGlsID0gdW5pZm9ybS50ZXh0dXJlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZSA9IHVuaWZvcm0udGV4dHVyZVsgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCAhdGV4dHVyZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0c2V0VGV4dHVyZSggdGV4dHVyZSwgdW5pZm9ybS5fYXJyYXlbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0dXBNYXRyaWNlcyAoIG9iamVjdCwgY2FtZXJhLCBjb21wdXRlTm9ybWFsTWF0cml4ICkge1xuXG5cdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlUb0FycmF5KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQsIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4QXJyYXkgKTtcblxuXHRcdGlmICggY29tcHV0ZU5vcm1hbE1hdHJpeCApIHtcblxuXHRcdFx0VEhSRUUuTWF0cml4NC5tYWtlSW52ZXJ0M3gzKCBvYmplY3QuX21vZGVsVmlld01hdHJpeCApLnRyYW5zcG9zZUludG9BcnJheSggb2JqZWN0Ll9ub3JtYWxNYXRyaXhBcnJheSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0dXBMaWdodHMgKCBwcm9ncmFtLCBsaWdodHMgKSB7XG5cblx0XHR2YXIgbCwgbGwsIGxpZ2h0LCBuLFxuXHRcdHIgPSAwLCBnID0gMCwgYiA9IDAsXG5cdFx0Y29sb3IsIHBvc2l0aW9uLCBpbnRlbnNpdHksIGRpc3RhbmNlLFxuXG5cdFx0emxpZ2h0cyA9IF9saWdodHMsXG5cblx0XHRkY29sb3JzID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnMsXG5cdFx0ZHBvc2l0aW9ucyA9IHpsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zLFxuXG5cdFx0cGNvbG9ycyA9IHpsaWdodHMucG9pbnQuY29sb3JzLFxuXHRcdHBwb3NpdGlvbnMgPSB6bGlnaHRzLnBvaW50LnBvc2l0aW9ucyxcblx0XHRwZGlzdGFuY2VzID0gemxpZ2h0cy5wb2ludC5kaXN0YW5jZXMsXG5cblx0XHRkbGVuZ3RoID0gMCxcblx0XHRwbGVuZ3RoID0gMCxcblxuXHRcdGRvZmZzZXQgPSAwLFxuXHRcdHBvZmZzZXQgPSAwO1xuXG5cdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xuXG5cdFx0XHRsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXHRcdFx0Y29sb3IgPSBsaWdodC5jb2xvcjtcblxuXHRcdFx0cG9zaXRpb24gPSBsaWdodC5wb3NpdGlvbjtcblx0XHRcdGludGVuc2l0eSA9IGxpZ2h0LmludGVuc2l0eTtcblx0XHRcdGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQgKSB7XG5cblx0XHRcdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xuXG5cdFx0XHRcdFx0ciArPSBjb2xvci5yICogY29sb3Iucjtcblx0XHRcdFx0XHRnICs9IGNvbG9yLmcgKiBjb2xvci5nO1xuXHRcdFx0XHRcdGIgKz0gY29sb3IuYiAqIGNvbG9yLmI7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHIgKz0gY29sb3Iucjtcblx0XHRcdFx0XHRnICs9IGNvbG9yLmc7XG5cdFx0XHRcdFx0YiArPSBjb2xvci5iO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG5cdFx0XHRcdGRvZmZzZXQgPSBkbGVuZ3RoICogMztcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRkY29sb3JzWyBkb2Zmc2V0IF0gICAgID0gY29sb3IuciAqIGNvbG9yLnIgKiBpbnRlbnNpdHkgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0ZGNvbG9yc1sgZG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBjb2xvci5nICogaW50ZW5zaXR5ICogaW50ZW5zaXR5O1xuXHRcdFx0XHRcdGRjb2xvcnNbIGRvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogY29sb3IuYiAqIGludGVuc2l0eSAqIGludGVuc2l0eTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZGNvbG9yc1sgZG9mZnNldCBdICAgICA9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0ZGNvbG9yc1sgZG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0ZGNvbG9yc1sgZG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRwb3NpdGlvbnNbIGRvZmZzZXQgXSAgICAgPSBwb3NpdGlvbi54O1xuXHRcdFx0XHRkcG9zaXRpb25zWyBkb2Zmc2V0ICsgMSBdID0gcG9zaXRpb24ueTtcblx0XHRcdFx0ZHBvc2l0aW9uc1sgZG9mZnNldCArIDIgXSA9IHBvc2l0aW9uLno7XG5cblx0XHRcdFx0ZGxlbmd0aCArPSAxO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHsgLy8gaGFjaywgbm90IGEgcHJvcGVyIHNwb3RsaWdodFxuXG5cdFx0XHRcdGRvZmZzZXQgPSBkbGVuZ3RoICogMztcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRkY29sb3JzWyBkb2Zmc2V0IF0gICAgID0gY29sb3IuciAqIGNvbG9yLnIgKiBpbnRlbnNpdHkgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0ZGNvbG9yc1sgZG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBjb2xvci5nICogaW50ZW5zaXR5ICogaW50ZW5zaXR5O1xuXHRcdFx0XHRcdGRjb2xvcnNbIGRvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogY29sb3IuYiAqIGludGVuc2l0eSAqIGludGVuc2l0eTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZGNvbG9yc1sgZG9mZnNldCBdICAgICA9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0ZGNvbG9yc1sgZG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0ZGNvbG9yc1sgZG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG4gPSAxIC8gcG9zaXRpb24ubGVuZ3RoKCk7XG5cblx0XHRcdFx0ZHBvc2l0aW9uc1sgZG9mZnNldCBdICAgICA9IHBvc2l0aW9uLnggKiBuO1xuXHRcdFx0XHRkcG9zaXRpb25zWyBkb2Zmc2V0ICsgMSBdID0gcG9zaXRpb24ueSAqIG47XG5cdFx0XHRcdGRwb3NpdGlvbnNbIGRvZmZzZXQgKyAyIF0gPSBwb3NpdGlvbi56ICogbjtcblxuXHRcdFx0XHRkbGVuZ3RoICs9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdHBvZmZzZXQgPSBwbGVuZ3RoICogMztcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRwY29sb3JzWyBwb2Zmc2V0IF0gICAgID0gY29sb3IuciAqIGNvbG9yLnIgKiBpbnRlbnNpdHkgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0cGNvbG9yc1sgcG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBjb2xvci5nICogaW50ZW5zaXR5ICogaW50ZW5zaXR5O1xuXHRcdFx0XHRcdHBjb2xvcnNbIHBvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogY29sb3IuYiAqIGludGVuc2l0eSAqIGludGVuc2l0eTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cGNvbG9yc1sgcG9mZnNldCBdICAgICA9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0cGNvbG9yc1sgcG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0cGNvbG9yc1sgcG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBwb3NpdGlvbnNbIHBvZmZzZXQgXSAgICAgPSBwb3NpdGlvbi54O1xuXHRcdFx0XHRwcG9zaXRpb25zWyBwb2Zmc2V0ICsgMSBdID0gcG9zaXRpb24ueTtcblx0XHRcdFx0cHBvc2l0aW9uc1sgcG9mZnNldCArIDIgXSA9IHBvc2l0aW9uLno7XG5cblx0XHRcdFx0cGRpc3RhbmNlc1sgcGxlbmd0aCBdID0gZGlzdGFuY2U7XG5cblx0XHRcdFx0cGxlbmd0aCArPSAxO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBudWxsIGV2ZW50dWFsIHJlbWFpbnMgZnJvbSByZW1vdmVkIGxpZ2h0c1xuXHRcdC8vICh0aGlzIGlzIHRvIGF2b2lkIGlmIGluIHNoYWRlcilcblxuXHRcdGZvciAoIGwgPSBkbGVuZ3RoICogMywgbGwgPSBkY29sb3JzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkgZGNvbG9yc1sgbCBdID0gMC4wO1xuXHRcdGZvciAoIGwgPSBwbGVuZ3RoICogMywgbGwgPSBwY29sb3JzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkgcGNvbG9yc1sgbCBdID0gMC4wO1xuXG5cdFx0emxpZ2h0cy5wb2ludC5sZW5ndGggPSBwbGVuZ3RoO1xuXHRcdHpsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGxlbmd0aDtcblxuXHRcdHpsaWdodHMuYW1iaWVudFsgMCBdID0gcjtcblx0XHR6bGlnaHRzLmFtYmllbnRbIDEgXSA9IGc7XG5cdFx0emxpZ2h0cy5hbWJpZW50WyAyIF0gPSBiO1xuXG5cdH07XG5cblx0Ly8gR0wgc3RhdGUgc2V0dGluZ1xuXG5cdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2UgKSB7XG5cblx0XHRpZiAoIGN1bGxGYWNlICkge1xuXG5cdFx0XHRpZiAoICFmcm9udEZhY2UgfHwgZnJvbnRGYWNlID09PSBcImNjd1wiICkge1xuXG5cdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiggY3VsbEZhY2UgPT09IFwiYmFja1wiICkge1xuXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuXHRcdFx0fSBlbHNlIGlmKCBjdWxsRmFjZSA9PT0gXCJmcm9udFwiICkge1xuXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfZ2wuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoICggd2lkdGggKSB7XG5cblx0XHRpZiAoIHdpZHRoICE9PSBfb2xkTGluZVdpZHRoICkge1xuXG5cdFx0XHRfZ2wubGluZVdpZHRoKCB3aWR0aCApO1xuXG5cdFx0XHRfb2xkTGluZVdpZHRoID0gd2lkdGg7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXRPYmplY3RGYWNlcyAoIG9iamVjdCApIHtcblxuXHRcdGlmICggX29sZERvdWJsZVNpZGVkICE9PSBvYmplY3QuZG91YmxlU2lkZWQgKSB7XG5cblx0XHRcdGlmKCBvYmplY3QuZG91YmxlU2lkZWQgKSB7XG5cblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29sZERvdWJsZVNpZGVkID0gb2JqZWN0LmRvdWJsZVNpZGVkO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBfb2xkRmxpcFNpZGVkICE9PSBvYmplY3QuZmxpcFNpZGVkICkge1xuXG5cdFx0XHRpZiggb2JqZWN0LmZsaXBTaWRlZCApIHtcblxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29sZEZsaXBTaWRlZCA9IG9iamVjdC5mbGlwU2lkZWQ7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXREZXB0aFRlc3QgKCBkZXB0aFRlc3QgKSB7XG5cblx0XHRpZiAoIF9vbGREZXB0aFRlc3QgIT09IGRlcHRoVGVzdCApIHtcblxuXHRcdFx0aWYoIGRlcHRoVGVzdCApIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9vbGREZXB0aFRlc3QgPSBkZXB0aFRlc3Q7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXREZXB0aFdyaXRlICggZGVwdGhXcml0ZSApIHtcblxuXHRcdGlmICggX29sZERlcHRoV3JpdGUgIT09IGRlcHRoV3JpdGUgKSB7XG5cblx0XHRcdF9nbC5kZXB0aE1hc2soIGRlcHRoV3JpdGUgKTtcblx0XHRcdF9vbGREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldFBvbHlnb25PZmZzZXQgKCBwb2x5Z29ub2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xuXG5cdFx0aWYgKCBfb2xkUG9seWdvbk9mZnNldCAhPT0gcG9seWdvbm9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBwb2x5Z29ub2Zmc2V0ICkge1xuXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29sZFBvbHlnb25PZmZzZXQgPSBwb2x5Z29ub2Zmc2V0O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwb2x5Z29ub2Zmc2V0ICYmICggX29sZFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBfb2xkUG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApICkge1xuXG5cdFx0XHRfZ2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xuXG5cdFx0XHRfb2xkUG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3Rvcjtcblx0XHRcdF9vbGRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldEJsZW5kaW5nICggYmxlbmRpbmcgKSB7XG5cblx0XHRpZiAoIGJsZW5kaW5nICE9PSBfb2xkQmxlbmRpbmcgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGJsZW5kaW5nICkge1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuQWRkaXRpdmVCbGVuZGluZzpcblxuXHRcdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmc6XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cblxuXHRcdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuWkVSTywgX2dsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuTXVsdGlwbHlCbGVuZGluZzpcblxuXHRcdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxuXG5cdFx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xuXHRcdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIF9nbC5aRVJPLCBfZ2wuU1JDX0NPTE9SICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggX2dsLkZVTkNfQURELCBfZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRfZ2wuYmxlbmRGdW5jU2VwYXJhdGUoIF9nbC5TUkNfQUxQSEEsIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBfZ2wuT05FLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0X29sZEJsZW5kaW5nID0gYmxlbmRpbmc7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBTaGFkZXJzXG5cblx0ZnVuY3Rpb24gYnVpbGRQcm9ncmFtICggc2hhZGVySUQsIGZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzLCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0dmFyIHAsIHBsLCBwcm9ncmFtLCBjb2RlO1xuXHRcdHZhciBjaHVua3MgPSBbXTtcblxuXHRcdC8vIEdlbmVyYXRlIGNvZGVcblxuXHRcdGlmICggc2hhZGVySUQgKSB7XG5cblx0XHRcdGNodW5rcy5wdXNoKCBzaGFkZXJJRCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y2h1bmtzLnB1c2goIGZyYWdtZW50U2hhZGVyICk7XG5cdFx0XHRjaHVua3MucHVzaCggdmVydGV4U2hhZGVyICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBwIGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdGNodW5rcy5wdXNoKCBwICk7XG5cdFx0XHRjaHVua3MucHVzaCggcGFyYW1ldGVyc1sgcCBdICk7XG5cblx0XHR9XG5cblx0XHRjb2RlID0gY2h1bmtzLmpvaW4oKTtcblxuXHRcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxuXG5cdFx0Zm9yICggcCA9IDAsIHBsID0gX3Byb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xuXG5cdFx0XHRpZiAoIF9wcm9ncmFtc1sgcCBdLmNvZGUgPT09IGNvZGUgKSB7XG5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiQ29kZSBhbHJlYWR5IGNvbXBpbGVkLlwiIC8qOiBcXG5cXG5cIiArIGNvZGUqLyApO1xuXG5cdFx0XHRcdHJldHVybiBfcHJvZ3JhbXNbIHAgXS5wcm9ncmFtO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL2NvbnNvbGUubG9nKCBcImJ1aWxkaW5nIG5ldyBwcm9ncmFtIFwiICk7XG5cblx0XHQvL1xuXG5cdFx0cHJvZ3JhbSA9IF9nbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0XHR2YXIgcHJlZml4X3ZlcnRleCA9IFtcblxuXHRcdFx0X3N1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyBcIiNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTXCIgOiBcIlwiLFxuXG5cdFx0XHRfdGhpcy5nYW1tYUlucHV0ID8gXCIjZGVmaW5lIEdBTU1BX0lOUFVUXCIgOiBcIlwiLFxuXHRcdFx0X3RoaXMuZ2FtbWFPdXRwdXQgPyBcIiNkZWZpbmUgR0FNTUFfT1VUUFVUXCIgOiBcIlwiLFxuXHRcdFx0X3RoaXMucGh5c2ljYWxseUJhc2VkU2hhZGluZyA/IFwiI2RlZmluZSBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIiA6IFwiXCIsXG5cblx0XHRcdFwiI2RlZmluZSBNQVhfRElSX0xJR0hUUyBcIiArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxuXHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuXG5cdFx0XHRcIiNkZWZpbmUgTUFYX1NIQURPV1MgXCIgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXG5cblx0XHRcdFwiI2RlZmluZSBNQVhfQk9ORVMgXCIgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyBcIiNkZWZpbmUgVVNFX0VOVk1BUFwiIDogXCJcIixcblx0XHRcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyBcIiNkZWZpbmUgVVNFX0xJR0hUTUFQXCIgOiBcIlwiLFxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyBcIiNkZWZpbmUgVVNFX0NPTE9SXCIgOiBcIlwiLFxuXHRcdFx0cGFyYW1ldGVycy5za2lubmluZyA/IFwiI2RlZmluZSBVU0VfU0tJTk5JTkdcIiA6IFwiXCIsXG5cdFx0XHRwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/IFwiI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTXCIgOiBcIlwiLFxuXHRcdFx0cGFyYW1ldGVycy5wZXJQaXhlbCA/IFwiI2RlZmluZSBQSE9OR19QRVJfUElYRUxcIiA6IFwiXCIsXG5cblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCIgOiBcIlwiLFxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBTb2Z0ID8gXCIjZGVmaW5lIFNIQURPV01BUF9TT0ZUXCIgOiBcIlwiLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/IFwiI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OXCIgOiBcIlwiLFxuXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBvYmplY3RNYXRyaXg7XCIsXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1wiLFxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcblx0XHRcdFwidW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBjYW1lcmFJbnZlcnNlTWF0cml4O1wiLFxuXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBub3JtYWw7XCIsXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djI7XCIsXG5cblx0XHRcdFwiI2lmZGVmIFVTRV9DT0xPUlwiLFxuXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcIixcblxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDtcIixcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7XCIsXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyO1wiLFxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MztcIixcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDQ7XCIsXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1O1wiLFxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjtcIixcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDc7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxuXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzQgc2tpblZlcnRleEE7XCIsXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzQgc2tpblZlcnRleEI7XCIsXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzQgc2tpbkluZGV4O1wiLFxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwiXCJcblxuXHRcdF0uam9pbihcIlxcblwiKTtcblxuXHRcdHZhciBwcmVmaXhfZnJhZ21lbnQgPSBbXG5cblx0XHRcdFwiI2lmZGVmIEdMX0VTXCIsXG5cdFx0XHRcInByZWNpc2lvbiBcIiArIF9wcmVjaXNpb24gKyBcIiBmbG9hdDtcIixcblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwiI2RlZmluZSBNQVhfRElSX0xJR0hUUyBcIiArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxuXHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuXG5cdFx0XHRcIiNkZWZpbmUgTUFYX1NIQURPV1MgXCIgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXG5cblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gXCIjZGVmaW5lIEFMUEhBVEVTVCBcIiArIHBhcmFtZXRlcnMuYWxwaGFUZXN0OiBcIlwiLFxuXG5cdFx0XHRfdGhpcy5nYW1tYUlucHV0ID8gXCIjZGVmaW5lIEdBTU1BX0lOUFVUXCIgOiBcIlwiLFxuXHRcdFx0X3RoaXMuZ2FtbWFPdXRwdXQgPyBcIiNkZWZpbmUgR0FNTUFfT1VUUFVUXCIgOiBcIlwiLFxuXHRcdFx0X3RoaXMucGh5c2ljYWxseUJhc2VkU2hhZGluZyA/IFwiI2RlZmluZSBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIiA6IFwiXCIsXG5cblx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/IFwiI2RlZmluZSBVU0VfRk9HXCIgOiBcIlwiLFxuXHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSA/IFwiI2RlZmluZSBGT0dfRVhQMlwiIDogXCJcIixcblxuXHRcdFx0cGFyYW1ldGVycy5tYXAgPyBcIiNkZWZpbmUgVVNFX01BUFwiIDogXCJcIixcblx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gXCIjZGVmaW5lIFVTRV9FTlZNQVBcIiA6IFwiXCIsXG5cdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIixcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gXCIjZGVmaW5lIFVTRV9DT0xPUlwiIDogXCJcIixcblxuXHRcdFx0cGFyYW1ldGVycy5tZXRhbCA/IFwiI2RlZmluZSBNRVRBTFwiIDogXCJcIixcblx0XHRcdHBhcmFtZXRlcnMucGVyUGl4ZWwgPyBcIiNkZWZpbmUgUEhPTkdfUEVSX1BJWEVMXCIgOiBcIlwiLFxuXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgVVNFX1NIQURPV01BUFwiIDogXCJcIixcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwU29mdCA/IFwiI2RlZmluZSBTSEFET1dNQVBfU09GVFwiIDogXCJcIixcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwU29mdCA/IFwiI2RlZmluZSBTSEFET1dNQVBfV0lEVEggXCIgKyBwYXJhbWV0ZXJzLnNoYWRvd01hcFdpZHRoLnRvRml4ZWQoIDEgKSA6IFwiXCIsXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcFNvZnQgPyBcIiNkZWZpbmUgU0hBRE9XTUFQX0hFSUdIVCBcIiArIHBhcmFtZXRlcnMuc2hhZG93TWFwSGVpZ2h0LnRvRml4ZWQoIDEgKSA6IFwiXCIsXG5cblx0XHRcdFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjtcIixcblx0XHRcdFwiXCJcblxuXHRcdF0uam9pbihcIlxcblwiKTtcblxuXHRcdF9nbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdldFNoYWRlciggXCJmcmFnbWVudFwiLCBwcmVmaXhfZnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlciApICk7XG5cdFx0X2dsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2V0U2hhZGVyKCBcInZlcnRleFwiLCBwcmVmaXhfdmVydGV4ICsgdmVydGV4U2hhZGVyICkgKTtcblxuXHRcdF9nbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdFx0aWYgKCAhX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIF9nbC5MSU5LX1NUQVRVUyApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIkNvdWxkIG5vdCBpbml0aWFsaXNlIHNoYWRlclxcblwiICsgXCJWQUxJREFURV9TVEFUVVM6IFwiICsgX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIF9nbC5WQUxJREFURV9TVEFUVVMgKSArIFwiLCBnbCBlcnJvciBbXCIgKyBfZ2wuZ2V0RXJyb3IoKSArIFwiXVwiICk7XG5cblx0XHR9XG5cblx0XHQvL2NvbnNvbGUubG9nKCBwcmVmaXhfZnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlciApO1xuXHRcdC8vY29uc29sZS5sb2coIHByZWZpeF92ZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdHByb2dyYW0udW5pZm9ybXMgPSB7fTtcblx0XHRwcm9ncmFtLmF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdHZhciBpZGVudGlmaWVycywgdSwgYSwgaTtcblxuXHRcdC8vIGNhY2hlIHVuaWZvcm0gbG9jYXRpb25zXG5cblx0XHRpZGVudGlmaWVycyA9IFtcblxuXHRcdFx0J3ZpZXdNYXRyaXgnLCAnbW9kZWxWaWV3TWF0cml4JywgJ3Byb2plY3Rpb25NYXRyaXgnLCAnbm9ybWFsTWF0cml4JywgJ29iamVjdE1hdHJpeCcsICdjYW1lcmFQb3NpdGlvbicsXG5cdFx0XHQnY2FtZXJhSW52ZXJzZU1hdHJpeCcsICdib25lR2xvYmFsTWF0cmljZXMnLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJ1xuXG5cdFx0XTtcblxuXHRcdGZvciAoIHUgaW4gdW5pZm9ybXMgKSB7XG5cblx0XHRcdGlkZW50aWZpZXJzLnB1c2goIHUgKTtcblxuXHRcdH1cblxuXHRcdGNhY2hlVW5pZm9ybUxvY2F0aW9ucyggcHJvZ3JhbSwgaWRlbnRpZmllcnMgKTtcblxuXHRcdC8vIGNhY2hlIGF0dHJpYnV0ZXMgbG9jYXRpb25zXG5cblx0XHRpZGVudGlmaWVycyA9IFtcblxuXHRcdFx0XCJwb3NpdGlvblwiLCBcIm5vcm1hbFwiLCBcInV2XCIsIFwidXYyXCIsIFwidGFuZ2VudFwiLCBcImNvbG9yXCIsXG5cdFx0XHRcInNraW5WZXJ0ZXhBXCIsIFwic2tpblZlcnRleEJcIiwgXCJza2luSW5kZXhcIiwgXCJza2luV2VpZ2h0XCJcblxuXHRcdF07XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCBcIm1vcnBoVGFyZ2V0XCIgKyBpICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBhIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlkZW50aWZpZXJzLnB1c2goIGEgKTtcblxuXHRcdH1cblxuXHRcdGNhY2hlQXR0cmlidXRlTG9jYXRpb25zKCBwcm9ncmFtLCBpZGVudGlmaWVycyApO1xuXG5cdFx0cHJvZ3JhbS5pZCA9IF9wcm9ncmFtcy5sZW5ndGg7XG5cblx0XHRfcHJvZ3JhbXMucHVzaCggeyBwcm9ncmFtOiBwcm9ncmFtLCBjb2RlOiBjb2RlIH0gKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5LnByb2dyYW1zID0gX3Byb2dyYW1zLmxlbmd0aDtcblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH07XG5cblx0Ly8gU2hhZGVyIHBhcmFtZXRlcnMgY2FjaGVcblxuXHRmdW5jdGlvbiBjYWNoZVVuaWZvcm1Mb2NhdGlvbnMgKCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuXHRcdHZhciBpLCBsLCBpZDtcblxuXHRcdGZvciggaSA9IDAsIGwgPSBpZGVudGlmaWVycy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cblx0XHRcdGlkID0gaWRlbnRpZmllcnNbIGkgXTtcblx0XHRcdHByb2dyYW0udW5pZm9ybXNbIGlkIF0gPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBpZCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gY2FjaGVBdHRyaWJ1dGVMb2NhdGlvbnMgKCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuXHRcdHZhciBpLCBsLCBpZDtcblxuXHRcdGZvciggaSA9IDAsIGwgPSBpZGVudGlmaWVycy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cblx0XHRcdGlkID0gaWRlbnRpZmllcnNbIGkgXTtcblx0XHRcdHByb2dyYW0uYXR0cmlidXRlc1sgaWQgXSA9IF9nbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgaWQgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldFNoYWRlciAoIHR5cGUsIHN0cmluZyApIHtcblxuXHRcdHZhciBzaGFkZXI7XG5cblx0XHRpZiAoIHR5cGUgPT09IFwiZnJhZ21lbnRcIiApIHtcblxuXHRcdFx0c2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLkZSQUdNRU5UX1NIQURFUiApO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2ZXJ0ZXhcIiApIHtcblxuXHRcdFx0c2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLlZFUlRFWF9TSEFERVIgKTtcblxuXHRcdH1cblxuXHRcdF9nbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XG5cdFx0X2dsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xuXG5cdFx0aWYgKCAhX2dsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBfZ2wuQ09NUElMRV9TVEFUVVMgKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggX2dsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApICk7XG5cdFx0XHRjb25zb2xlLmVycm9yKCBzdHJpbmcgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNoYWRlcjtcblxuXHR9O1xuXG5cdC8vIFRleHR1cmVzXG5cblx0ZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMgKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaW1hZ2UgKSB7XG5cblx0XHRpZiAoIGlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBpc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApICkge1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFMgKSApO1xuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBUICkgKTtcblxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XG5cblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWluRmlsdGVyICkgKTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0VGV4dHVyZSAoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRpZiAoIHRleHR1cmUubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdGlmICggISB0ZXh0dXJlLl9fd2ViZ2xJbml0ICkge1xuXG5cdFx0XHRcdHRleHR1cmUuX193ZWJnbEluaXQgPSB0cnVlO1xuXHRcdFx0XHR0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0XHR2YXIgbmVlZHNNaXBNYXBzID0gc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCB0ZXh0dXJlLmltYWdlICk7XG5cblx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksIHRleHR1cmUuaW1hZ2Uud2lkdGgsIHRleHR1cmUuaW1hZ2UuaGVpZ2h0LCAwLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSwgX2dsLlVOU0lHTkVEX0JZVEUsIHRleHR1cmUuaW1hZ2UuZGF0YSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgX2dsLlJHQkEsIF9nbC5SR0JBLCBfZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5pbWFnZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbmVlZHNNaXBNYXBzICkge1xuXG5cdFx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZWQgKSB0ZXh0dXJlLm9uVXBkYXRlZCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlICggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdGlmICggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZS5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHRpZiAoICEgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICk7XG5cblx0XHRcdFx0dmFyIG5lZWRzTWlwTWFwcyA9IHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgdGV4dHVyZS5pbWFnZVsgMCBdICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgX2dsLlJHQkEsIF9nbC5SR0JBLCBfZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5pbWFnZVsgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmVlZHNNaXBNYXBzICkge1xuXG5cdFx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmVEeW5hbWljICggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdH07XG5cblx0Ly8gUmVuZGVyIHRhcmdldHNcblxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyICggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZVRhcmdldCApIHtcblxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlVGFyZ2V0LCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUsIDAgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgICkge1xuXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9DT01QT05FTlQxNiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0LyogRm9yIHNvbWUgcmVhc29uIHRoaXMgaXMgbm90IHdvcmtpbmcuIERlZmF1bHRpbmcgdG8gUkdCQTQuXG5cdFx0fSBlbHNlIGlmKCAhIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5TVEVOQ0lMX0lOREVYOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLlNURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cdFx0Ki9cblx0XHR9IGVsc2UgaWYoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuUkdCQTQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0UmVuZGVyVGFyZ2V0ICggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCAmJiAhIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdGlmKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XG5cdFx0XHRpZiggcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID0gdHJ1ZTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdFx0Ly8gU2V0dXAgdGV4dHVyZSwgY3JlYXRlIHJlbmRlciBhbmQgZnJhbWUgYnVmZmVyc1xuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XG5cdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyID0gW107XG5cblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XG5cdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuXHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC5mb3JtYXQgKSwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LmZvcm1hdCApLCBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnR5cGUgKSwgbnVsbCApO1xuXG5cdFx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LmZvcm1hdCApLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQuZm9ybWF0ICksIHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudHlwZSApLCBudWxsICk7XG5cblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV8yRCApO1xuXHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbGVhc2UgZXZlcnl0aGluZ1xuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG5cdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0d2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG5cdFx0XHRoZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXG5cdFx0XHR2eCA9IDA7XG5cdFx0XHR2eSA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmcmFtZWJ1ZmZlciA9IG51bGw7XG5cblx0XHRcdHdpZHRoID0gX3ZpZXdwb3J0V2lkdGg7XG5cdFx0XHRoZWlnaHQgPSBfdmlld3BvcnRIZWlnaHQ7XG5cblx0XHRcdHZ4ID0gX3ZpZXdwb3J0WDtcblx0XHRcdHZ5ID0gX3ZpZXdwb3J0WTtcblxuXHRcdH1cblxuXHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblx0XHRcdF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcblx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gZmFsbGJhY2sgZmlsdGVycyBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcblxuXHRmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayAoIGYgKSB7XG5cblx0XHRzd2l0Y2ggKCBmICkge1xuXG5cdFx0XHRjYXNlIFRIUkVFLk5lYXJlc3RGaWx0ZXI6XG5cdFx0XHRjYXNlIFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyOlxuXHRcdFx0Y2FzZSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyOiByZXR1cm4gX2dsLk5FQVJFU1Q7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRIUkVFLkxpbmVhckZpbHRlcjpcblx0XHRcdGNhc2UgVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcjpcblx0XHRcdGNhc2UgVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyOlxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRyZXR1cm4gX2dsLkxJTkVBUjsgYnJlYWs7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCAoIHAgKSB7XG5cblx0XHRzd2l0Y2ggKCBwICkge1xuXG5cdFx0XHRjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOiByZXR1cm4gX2dsLlJFUEVBVDsgYnJlYWs7XG5cdFx0XHRjYXNlIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc6IHJldHVybiBfZ2wuQ0xBTVBfVE9fRURHRTsgYnJlYWs7XG5cdFx0XHRjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6IHJldHVybiBfZ2wuTUlSUk9SRURfUkVQRUFUOyBicmVhaztcblxuXHRcdFx0Y2FzZSBUSFJFRS5OZWFyZXN0RmlsdGVyOiByZXR1cm4gX2dsLk5FQVJFU1Q7IGJyZWFrO1xuXHRcdFx0Y2FzZSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjogcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUOyBicmVhaztcblx0XHRcdGNhc2UgVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcjogcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRIUkVFLkxpbmVhckZpbHRlcjogcmV0dXJuIF9nbC5MSU5FQVI7IGJyZWFrO1xuXHRcdFx0Y2FzZSBUSFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyOiByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDsgYnJlYWs7XG5cdFx0XHRjYXNlIFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjogcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjsgYnJlYWs7XG5cblx0XHRcdGNhc2UgVEhSRUUuQnl0ZVR5cGU6IHJldHVybiBfZ2wuQllURTsgYnJlYWs7XG5cdFx0XHRjYXNlIFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU6IHJldHVybiBfZ2wuVU5TSUdORURfQllURTsgYnJlYWs7XG5cdFx0XHRjYXNlIFRIUkVFLlNob3J0VHlwZTogcmV0dXJuIF9nbC5TSE9SVDsgYnJlYWs7XG5cdFx0XHRjYXNlIFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlOiByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUOyBicmVhaztcblx0XHRcdGNhc2UgVEhSRUUuSW50VHlwZTogcmV0dXJuIF9nbC5JTlQ7IGJyZWFrO1xuXHRcdFx0Y2FzZSBUSFJFRS5VbnNpZ25lZFNob3J0VHlwZTogcmV0dXJuIF9nbC5VTlNJR05FRF9JTlQ7IGJyZWFrO1xuXHRcdFx0Y2FzZSBUSFJFRS5GbG9hdFR5cGU6IHJldHVybiBfZ2wuRkxPQVQ7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRIUkVFLkFscGhhRm9ybWF0OiByZXR1cm4gX2dsLkFMUEhBOyBicmVhaztcblx0XHRcdGNhc2UgVEhSRUUuUkdCRm9ybWF0OiByZXR1cm4gX2dsLlJHQjsgYnJlYWs7XG5cdFx0XHRjYXNlIFRIUkVFLlJHQkFGb3JtYXQ6IHJldHVybiBfZ2wuUkdCQTsgYnJlYWs7XG5cdFx0XHRjYXNlIFRIUkVFLkx1bWluYW5jZUZvcm1hdDogcmV0dXJuIF9nbC5MVU1JTkFOQ0U7IGJyZWFrO1xuXHRcdFx0Y2FzZSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdDogcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7IGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwO1xuXG5cdH07XG5cblx0Ly8gQWxsb2NhdGlvbnNcblxuXHRmdW5jdGlvbiBhbGxvY2F0ZUJvbmVzICggb2JqZWN0ICkge1xuXG5cdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxuXHRcdC8vICggZm9yIGV4YW1wbGUgd2hlbiBwcmVidWlsZGluZyBzaGFkZXJcblx0XHQvLyAgIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcblx0XHQvL1xuXHRcdC8vIFx0LSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xuXHRcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xuXHRcdC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcblxuXHRcdHZhciBtYXhCb25lcyA9IDUwO1xuXG5cdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuXHRcdFx0bWF4Qm9uZXMgPSBvYmplY3QuYm9uZXMubGVuZ3RoO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1heEJvbmVzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVMaWdodHMgKCBsaWdodHMgKSB7XG5cblx0XHR2YXIgbCwgbGwsIGxpZ2h0LCBkaXJMaWdodHMsIHBvaW50TGlnaHRzLCBtYXhEaXJMaWdodHMsIG1heFBvaW50TGlnaHRzO1xuXHRcdGRpckxpZ2h0cyA9IHBvaW50TGlnaHRzID0gbWF4RGlyTGlnaHRzID0gbWF4UG9pbnRMaWdodHMgPSAwO1xuXG5cdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsKysgKSB7XG5cblx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBkaXJMaWdodHMgKys7IC8vIGhhY2ssIG5vdCBhIHByb3BlciBzcG90bGlnaHRcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgZGlyTGlnaHRzICsrO1xuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSBwb2ludExpZ2h0cyArKztcblxuXHRcdH1cblxuXHRcdGlmICggKCBwb2ludExpZ2h0cyArIGRpckxpZ2h0cyApIDw9IF9tYXhMaWdodHMgKSB7XG5cblx0XHRcdG1heERpckxpZ2h0cyA9IGRpckxpZ2h0cztcblx0XHRcdG1heFBvaW50TGlnaHRzID0gcG9pbnRMaWdodHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXhEaXJMaWdodHMgPSBNYXRoLmNlaWwoIF9tYXhMaWdodHMgKiBkaXJMaWdodHMgLyAoIHBvaW50TGlnaHRzICsgZGlyTGlnaHRzICkgKTtcblx0XHRcdG1heFBvaW50TGlnaHRzID0gX21heExpZ2h0cyAtIG1heERpckxpZ2h0cztcblxuXHRcdH1cblxuXHRcdHJldHVybiB7ICdkaXJlY3Rpb25hbCcgOiBtYXhEaXJMaWdodHMsICdwb2ludCcgOiBtYXhQb2ludExpZ2h0cyB9O1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVTaGFkb3dzICggbGlnaHRzICkge1xuXG5cdFx0dmFyIGwsIGxsLCBsaWdodCwgbWF4U2hhZG93cyA9IDA7XG5cblx0XHRmb3IgKCBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwrKyApIHtcblxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGwgXTtcblxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCAmJiBsaWdodC5jYXN0U2hhZG93ICkgbWF4U2hhZG93cyArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXhTaGFkb3dzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gbWF4VmVydGV4VGV4dHVyZXMgKCkge1xuXG5cdFx0cmV0dXJuIF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblxuXHR9O1xuXG5cdC8vIEluaXRpYWxpemF0aW9uXG5cblx0ZnVuY3Rpb24gaW5pdFNwcml0ZXMgKCkge1xuXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKyA4ICk7XG5cdFx0X3Nwcml0ZS5mYWNlcyAgICA9IG5ldyBVaW50MTZBcnJheSggNiApO1xuXG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAtMTsgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAtMTtcdC8vIHZlcnRleCAwXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAwOyAgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1x0Ly8gdXYgMFxuXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAtMTtcdC8vIHZlcnRleCAxXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1x0Ly8gdXYgMVxuXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1x0Ly8gdmVydGV4IDJcblx0XHRfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDE7ICBfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDA7XHQvLyB1diAyXG5cblx0XHRfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IC0xOyBfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDE7XHQvLyB2ZXJ0ZXggM1xuXHRcdF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMDsgIF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMDtcdC8vIHV2IDNcblxuXHRcdGkgPSAwO1xuXG5cdFx0X3Nwcml0ZS5mYWNlc1sgaSsrIF0gPSAwOyBfc3ByaXRlLmZhY2VzWyBpKysgXSA9IDE7IF9zcHJpdGUuZmFjZXNbIGkrKyBdID0gMjtcblx0XHRfc3ByaXRlLmZhY2VzWyBpKysgXSA9IDA7IF9zcHJpdGUuZmFjZXNbIGkrKyBdID0gMjsgX3Nwcml0ZS5mYWNlc1sgaSsrIF0gPSAzO1xuXG5cdFx0X3Nwcml0ZS52ZXJ0ZXhCdWZmZXIgID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdF9zcHJpdGUuZWxlbWVudEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBfc3ByaXRlLnZlcnRleEJ1ZmZlciApO1xuXHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBfc3ByaXRlLnZlcnRpY2VzLCBfZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9zcHJpdGUuZWxlbWVudEJ1ZmZlciApO1xuXHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9zcHJpdGUuZmFjZXMsIF9nbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0X3Nwcml0ZS5wcm9ncmFtID0gX2dsLmNyZWF0ZVByb2dyYW0oKTtcblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBfc3ByaXRlLnByb2dyYW0sIGdldFNoYWRlciggXCJmcmFnbWVudFwiLCBUSFJFRS5TaGFkZXJMaWIuc3ByaXRlLmZyYWdtZW50U2hhZGVyICkgKTtcblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBfc3ByaXRlLnByb2dyYW0sIGdldFNoYWRlciggXCJ2ZXJ0ZXhcIiwgICBUSFJFRS5TaGFkZXJMaWIuc3ByaXRlLnZlcnRleFNoYWRlciAgICkgKTtcblx0XHRfZ2wubGlua1Byb2dyYW0oIF9zcHJpdGUucHJvZ3JhbSApO1xuXG5cdFx0X3Nwcml0ZS5hdHRyaWJ1dGVzID0ge307XG5cdFx0X3Nwcml0ZS51bmlmb3JtcyA9IHt9O1xuXG5cdFx0X3Nwcml0ZS5hdHRyaWJ1dGVzLnBvc2l0aW9uICAgICAgICAgICA9IF9nbC5nZXRBdHRyaWJMb2NhdGlvbiAoIF9zcHJpdGUucHJvZ3JhbSwgXCJwb3NpdGlvblwiICk7XG5cdFx0X3Nwcml0ZS5hdHRyaWJ1dGVzLnV2ICAgICAgICAgICAgICAgICA9IF9nbC5nZXRBdHRyaWJMb2NhdGlvbiAoIF9zcHJpdGUucHJvZ3JhbSwgXCJ1dlwiICk7XG5cblx0XHRfc3ByaXRlLnVuaWZvcm1zLnV2T2Zmc2V0ICAgICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInV2T2Zmc2V0XCIgKTtcblx0XHRfc3ByaXRlLnVuaWZvcm1zLnV2U2NhbGUgICAgICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInV2U2NhbGVcIiApO1xuXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5yb3RhdGlvbiAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJyb3RhdGlvblwiICk7XG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5zY2FsZSAgICAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJzY2FsZVwiICk7XG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5hbGlnbm1lbnQgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJhbGlnbm1lbnRcIiApO1xuXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5jb2xvciAgICAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJjb2xvclwiICk7XG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5tYXAgICAgICAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJtYXBcIiApO1xuXHRcdF9zcHJpdGUudW5pZm9ybXMub3BhY2l0eSAgICAgICAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwib3BhY2l0eVwiICk7XG5cblx0XHRfc3ByaXRlLnVuaWZvcm1zLnVzZVNjcmVlbkNvb3JkaW5hdGVzID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInVzZVNjcmVlbkNvb3JkaW5hdGVzXCIgKTtcblx0XHRfc3ByaXRlLnVuaWZvcm1zLmFmZmVjdGVkQnlEaXN0YW5jZSAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcImFmZmVjdGVkQnlEaXN0YW5jZVwiICk7XG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiAgICBcdCAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApO1xuXHRcdF9zcHJpdGUudW5pZm9ybXMubW9kZWxWaWV3TWF0cml4ICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwibW9kZWxWaWV3TWF0cml4XCIgKTtcblx0XHRfc3ByaXRlLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInByb2plY3Rpb25NYXRyaXhcIiApO1xuXG5cdFx0Ly9fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIF9zcHJpdGUuYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdC8vX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBfc3ByaXRlLmF0dHJpYnV0ZXMudXYgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXRTaGFkb3dtYXBzICgpIHtcblxuXHRcdHZhciBkZXB0aFNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkZXB0aFJHQkFcIiBdO1xuXHRcdHZhciBkZXB0aFVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggZGVwdGhTaGFkZXIudW5pZm9ybXMgKTtcblxuXHRcdF9kZXB0aE1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7IGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zIH0gKTtcblx0XHRfZGVwdGhNYXRlcmlhbE1vcnBoID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7IGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLCBtb3JwaFRhcmdldHM6IHRydWUgfSApO1xuXG5cdFx0X2RlcHRoTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGguX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpbml0R0wgKCkge1xuXG5cdFx0dmFyIGdsO1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0aWYgKCAhICggZ2wgPSBfY2FudmFzLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnLCB7IGFudGlhbGlhczogX2FudGlhbGlhcywgc3RlbmNpbDogX3N0ZW5jaWwsIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlciB9ICkgKSApIHtcblxuXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHRuYXZpZ2F0b3IudXNlckFnZW50ICsgXCIgfCBcIiArXG5cdFx0XHRcdGdsLmdldFBhcmFtZXRlciggZ2wuVkVSU0lPTiApICsgXCIgfCBcIiArXG5cdFx0XHRcdGdsLmdldFBhcmFtZXRlciggZ2wuVkVORE9SICkgKyBcIiB8IFwiICtcblx0XHRcdFx0Z2wuZ2V0UGFyYW1ldGVyKCBnbC5SRU5ERVJFUiApICsgXCIgfCBcIiArXG5cdFx0XHRcdGdsLmdldFBhcmFtZXRlciggZ2wuU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OIClcblx0XHRcdCk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2w7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXREZWZhdWx0R0xTdGF0ZSAoKSB7XG5cblx0XHRfZ2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xuXHRcdF9nbC5jbGVhckRlcHRoKCAxICk7XG5cdFx0X2dsLmNsZWFyU3RlbmNpbCggMCApO1xuXG5cdFx0X2dsLmVuYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcblx0XHRfZ2wuZGVwdGhGdW5jKCBfZ2wuTEVRVUFMICk7XG5cblx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcblx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG5cdFx0X2dsLmNsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cblx0fTtcblxufTtcbi8qKlxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICovXG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0dGhpcy53cmFwUyA9IG9wdGlvbnMud3JhcFMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHR0aGlzLndyYXBUID0gb3B0aW9ucy53cmFwVCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0dGhpcy5tYWdGaWx0ZXIgPSBvcHRpb25zLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cdHRoaXMubWluRmlsdGVyID0gb3B0aW9ucy5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG5cdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcblx0dGhpcy50eXBlID0gb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG5cdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcblx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xuXG59O1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuXHR2YXIgdG1wID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCApO1xuXG5cdHRtcC53cmFwUyA9IHRoaXMud3JhcFM7XG5cdHRtcC53cmFwVCA9IHRoaXMud3JhcFQ7XG5cblx0dG1wLm1hZ0ZpbHRlciA9IHRoaXMubWFnRmlsdGVyO1xuXHR0bXAubWluRmlsdGVyID0gdGhpcy5taW5GaWx0ZXI7XG5cblx0dG1wLm9mZnNldC5jb3B5KCB0aGlzLm9mZnNldCApO1xuXHR0bXAucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XG5cblx0dG1wLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuXHR0bXAudHlwZSA9IHRoaXMudHlwZTtcblxuXHR0bXAuZGVwdGhCdWZmZXIgPSB0aGlzLmRlcHRoQnVmZmVyO1xuXHR0bXAuc3RlbmNpbEJ1ZmZlciA9IHRoaXMuc3RlbmNpbEJ1ZmZlcjtcblxuXHRyZXR1cm4gdG1wO1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG5cdFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuXHR0aGlzLmFjdGl2ZUN1YmVGYWNlID0gMDsgLy8gUFggMCwgTlggMSwgUFkgMiwgTlkgMywgUFogNCwgTlogNVxuXG59O1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCk7XG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlO1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5SZW5kZXJhYmxlVmVydGV4ID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMucG9zaXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMucG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHZlcnRleCApIHtcblxuXHR0aGlzLnBvc2l0aW9uV29ybGQuY29weSggdmVydGV4LnBvc2l0aW9uV29ybGQgKTtcblx0dGhpcy5wb3NpdGlvblNjcmVlbi5jb3B5KCB2ZXJ0ZXgucG9zaXRpb25TY3JlZW4gKTtcblxufVxuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5SZW5kZXJhYmxlRmFjZTMgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy52MSA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XG5cdHRoaXMudjIgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xuXHR0aGlzLnYzID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcblxuXHR0aGlzLmNlbnRyb2lkV29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR0aGlzLmNlbnRyb2lkU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR0aGlzLm5vcm1hbFdvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzV29ybGQgPSBbIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCkgXTtcblxuXHR0aGlzLm1hdGVyaWFsID0gbnVsbDtcblx0dGhpcy5mYWNlTWF0ZXJpYWwgPSBudWxsO1xuXHR0aGlzLnV2cyA9IFtbXV07XG5cblx0dGhpcy56ID0gbnVsbDtcblxufTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUmVuZGVyYWJsZUZhY2U0ID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMudjEgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xuXHR0aGlzLnYyID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcblx0dGhpcy52MyA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XG5cdHRoaXMudjQgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xuXG5cdHRoaXMuY2VudHJvaWRXb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMuY2VudHJvaWRTY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHRoaXMubm9ybWFsV29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR0aGlzLnZlcnRleE5vcm1hbHNXb3JsZCA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xuXG5cdHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXHR0aGlzLmZhY2VNYXRlcmlhbCA9IG51bGw7XG5cdHRoaXMudXZzID0gW1tdXTtcblxuXHR0aGlzLnogPSBudWxsO1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5SZW5kZXJhYmxlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMub2JqZWN0ID0gbnVsbDtcblx0dGhpcy56ID0gbnVsbDtcblxufTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUmVuZGVyYWJsZVBhcnRpY2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMueCA9IG51bGw7XG5cdHRoaXMueSA9IG51bGw7XG5cdHRoaXMueiA9IG51bGw7XG5cblx0dGhpcy5yb3RhdGlvbiA9IG51bGw7XG5cdHRoaXMuc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5SZW5kZXJhYmxlTGluZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLnogPSBudWxsO1xuXG5cdHRoaXMudjEgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xuXHR0aGlzLnYyID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcblxuXHR0aGlzLm1hdGVyaWFsID0gbnVsbDtcblxufTtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Db2xvclV0aWxzID0ge1xuXG5cdGFkanVzdEhTViA6IGZ1bmN0aW9uICggY29sb3IsIGgsIHMsIHYgKSB7XG5cblx0XHR2YXIgaHN2ID0gVEhSRUUuQ29sb3JVdGlscy5fX2hzdjtcblxuXHRcdFRIUkVFLkNvbG9yVXRpbHMucmdiVG9Ic3YoIGNvbG9yLCBoc3YgKTtcblxuXHRcdGhzdi5oID0gVEhSRUUuTWF0aC5jbGFtcCggaHN2LmggKyBoLCAwLCAxICk7XG5cdFx0aHN2LnMgPSBUSFJFRS5NYXRoLmNsYW1wKCBoc3YucyArIHMsIDAsIDEgKTtcblx0XHRoc3YudiA9IFRIUkVFLk1hdGguY2xhbXAoIGhzdi52ICsgdiwgMCwgMSApO1xuXG5cdFx0Y29sb3Iuc2V0SFNWKCBoc3YuaCwgaHN2LnMsIGhzdi52ICk7XG5cblx0fSxcblxuXHQvLyBiYXNlZCBvbiBNb2NoaUtpdCBpbXBsZW1lbnRhdGlvbiBieSBCb2IgSXBwb2xpdG9cblxuXHRyZ2JUb0hzdiA6IGZ1bmN0aW9uICggY29sb3IsIGhzdiApIHtcblxuXHRcdHZhciByID0gY29sb3Iucjtcblx0XHR2YXIgZyA9IGNvbG9yLmc7XG5cdFx0dmFyIGIgPSBjb2xvci5iO1xuXG5cdFx0dmFyIG1heCA9IE1hdGgubWF4KCBNYXRoLm1heCggciwgZyApLCBiICk7XG5cdFx0dmFyIG1pbiA9IE1hdGgubWluKCBNYXRoLm1pbiggciwgZyApLCBiICk7XG5cblx0XHR2YXIgaHVlO1xuXHRcdHZhciBzYXR1cmF0aW9uO1xuXHRcdHZhciB2YWx1ZSA9IG1heDtcblxuXHRcdGlmICggbWluID09PSBtYXggKVx0e1xuXG5cdFx0XHRodWUgPSAwO1xuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGVsdGEgPSAoIG1heCAtIG1pbiApO1xuXHRcdFx0c2F0dXJhdGlvbiA9IGRlbHRhIC8gbWF4O1xuXG5cdFx0XHRpZiAoIHIgPT09IG1heCApIHtcblxuXHRcdFx0XHRodWUgPSAoIGcgLSBiICkgLyBkZWx0YTtcblxuXHRcdFx0fSBlbHNlIGlmICggZyA9PT0gbWF4ICkge1xuXG5cdFx0XHRcdGh1ZSA9IDIgKyAoICggYiAtIHIgKSAvIGRlbHRhICk7XG5cblx0XHRcdH0gZWxzZVx0e1xuXG5cdFx0XHRcdGh1ZSA9IDQgKyAoICggciAtIGcgKSAvIGRlbHRhICk7XG5cdFx0XHR9XG5cblx0XHRcdGh1ZSAvPSA2O1xuXG5cdFx0XHRpZiAoIGh1ZSA8IDAgKSB7XG5cblx0XHRcdFx0aHVlICs9IDE7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBodWUgPiAxICkge1xuXG5cdFx0XHRcdGh1ZSAtPSAxO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGhzdiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRoc3YgPSB7IGg6IDAsIHM6IDAsIHY6IDAgfTtcblxuXHRcdH1cblxuXHRcdGhzdi5oID0gaHVlO1xuXHRcdGhzdi5zID0gc2F0dXJhdGlvbjtcblx0XHRoc3YudiA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIGhzdjtcblxuXHR9XG5cbn07XG5cblRIUkVFLkNvbG9yVXRpbHMuX19oc3YgPSB7IGg6IDAsIHM6IDAsIHY6IDAgfTsvKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkdlb21ldHJ5VXRpbHMgPSB7XG5cblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnkxLCBvYmplY3QyIC8qIG1lc2ggfCBnZW9tZXRyeSAqLyApIHtcblxuXHRcdHZhciBtYXRyaXgsIG1hdHJpeFJvdGF0aW9uLFxuXHRcdHZlcnRleE9mZnNldCA9IGdlb21ldHJ5MS52ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0dXZQb3NpdGlvbiA9IGdlb21ldHJ5MS5mYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoLFxuXHRcdGdlb21ldHJ5MiA9IG9iamVjdDIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoID8gb2JqZWN0Mi5nZW9tZXRyeSA6IG9iamVjdDIsXG5cdFx0dmVydGljZXMxID0gZ2VvbWV0cnkxLnZlcnRpY2VzLFxuXHRcdHZlcnRpY2VzMiA9IGdlb21ldHJ5Mi52ZXJ0aWNlcyxcblx0XHRmYWNlczEgPSBnZW9tZXRyeTEuZmFjZXMsXG5cdFx0ZmFjZXMyID0gZ2VvbWV0cnkyLmZhY2VzLFxuXHRcdHV2czEgPSBnZW9tZXRyeTEuZmFjZVZlcnRleFV2c1sgMCBdLFxuXHRcdHV2czIgPSBnZW9tZXRyeTIuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0dmFyIGdlbzFNYXRlcmlhbHNNYXAgPSB7fTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGdlb21ldHJ5MS5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgaWQgPSBnZW9tZXRyeTEubWF0ZXJpYWxzWyBpIF0uaWQ7XG5cblx0XHRcdGdlbzFNYXRlcmlhbHNNYXBbIGlkIF0gPSBpO1xuXG5cdFx0fVxuXG5cblx0XHRpZiAoIG9iamVjdDIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG5cdFx0XHRvYmplY3QyLm1hdHJpeEF1dG9VcGRhdGUgJiYgb2JqZWN0Mi51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0bWF0cml4ID0gb2JqZWN0Mi5tYXRyaXg7XG5cdFx0XHRtYXRyaXhSb3RhdGlvbiA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0XHRtYXRyaXhSb3RhdGlvbi5leHRyYWN0Um90YXRpb24oIG1hdHJpeCwgb2JqZWN0Mi5zY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdmVydGljZXNcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcblxuXHRcdFx0dmFyIHZlcnRleENvcHkgPSBuZXcgVEhSRUUuVmVydGV4KCB2ZXJ0ZXgucG9zaXRpb24uY2xvbmUoKSApO1xuXG5cdFx0XHRpZiAoIG1hdHJpeCApIG1hdHJpeC5tdWx0aXBseVZlY3RvcjMoIHZlcnRleENvcHkucG9zaXRpb24gKTtcblxuXHRcdFx0dmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGZhY2VzXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXMyWyBpIF0sIGZhY2VDb3B5LCBub3JtYWwsIGNvbG9yLFxuXHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXG5cdFx0XHRmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xuXG5cdFx0XHRcdGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcblxuXHRcdFx0XHRmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlNCggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCwgZmFjZS5kICsgdmVydGV4T2Zmc2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdGlmICggbWF0cml4Um90YXRpb24gKSBtYXRyaXhSb3RhdGlvbi5tdWx0aXBseVZlY3RvcjMoIGZhY2VDb3B5Lm5vcm1hbCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xuXG5cdFx0XHRcdGlmICggbWF0cml4Um90YXRpb24gKSBtYXRyaXhSb3RhdGlvbi5tdWx0aXBseVZlY3RvcjMoIG5vcm1hbCApO1xuXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcblx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbDIgPSBnZW9tZXRyeTIubWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXTtcblx0XHRcdFx0dmFyIG1hdGVyaWFsSWQyID0gbWF0ZXJpYWwyLmlkO1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbEluZGV4ID0gZ2VvMU1hdGVyaWFsc01hcFsgbWF0ZXJpYWxJZDIgXTtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsSW5kZXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBnZW9tZXRyeTEubWF0ZXJpYWxzLmxlbmd0aDtcblx0XHRcdFx0XHRnZW9tZXRyeTEubWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYWNlQ29weS5jZW50cm9pZC5jb3B5KCBmYWNlLmNlbnRyb2lkICk7XG5cdFx0XHRpZiAoIG1hdHJpeCApIG1hdHJpeC5tdWx0aXBseVZlY3RvcjMoIGZhY2VDb3B5LmNlbnRyb2lkICk7XG5cblx0XHRcdGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXZzXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dXZDb3B5LnB1c2goIG5ldyBUSFJFRS5VViggdXZbIGogXS51LCB1dlsgaiBdLnYgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHV2czEucHVzaCggdXZDb3B5ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdHZhciBjbG9uZUdlbyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdFx0dmFyIGksIGlsO1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXG5cdFx0XHRmYWNlcyA9IGdlb21ldHJ5LmZhY2VzLFxuXHRcdFx0dXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0Ly8gbWF0ZXJpYWxzXG5cblx0XHRpZiAoIGdlb21ldHJ5Lm1hdGVyaWFscyApIHtcblxuXHRcdFx0Y2xvbmVHZW8ubWF0ZXJpYWxzID0gZ2VvbWV0cnkubWF0ZXJpYWxzLnNsaWNlKCk7XG5cblx0XHR9XG5cblx0XHQvLyB2ZXJ0aWNlc1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0dmFyIHZlcnRleENvcHkgPSBuZXcgVEhSRUUuVmVydGV4KCB2ZXJ0ZXgucG9zaXRpb24uY2xvbmUoKSApO1xuXG5cdFx0XHRjbG9uZUdlby52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XG5cblx0XHR9XG5cblx0XHQvLyBmYWNlc1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXG5cdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcblx0XHRcdGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuXHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XG5cblx0XHRcdFx0ZmFjZUNvcHkgPSBuZXcgVEhSRUUuRmFjZTMoIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xuXG5cdFx0XHRcdGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2U0KCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jLCBmYWNlLmQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF07XG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Q29sb3JzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xuXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZhY2VDb3B5Lm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdGZhY2VDb3B5LmNlbnRyb2lkLmNvcHkoIGZhY2UuY2VudHJvaWQgKTtcblxuXHRcdFx0Y2xvbmVHZW8uZmFjZXMucHVzaCggZmFjZUNvcHkgKTtcblxuXHRcdH1cblxuXHRcdC8vIHV2c1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdXZzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdXYgPSB1dnNbIGkgXSwgdXZDb3B5ID0gW107XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR1dkNvcHkucHVzaCggbmV3IFRIUkVFLlVWKCB1dlsgaiBdLnUsIHV2WyBqIF0udiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y2xvbmVHZW8uZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Q29weSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsb25lR2VvO1xuXG5cdH0sXG5cblx0Ly8gR2V0IHJhbmRvbSBwb2ludCBpbiB0cmlhbmdsZSAodmlhIGJhcnljZW50cmljIGNvb3JkaW5hdGVzKVxuXHQvLyBcdCh1bmlmb3JtIGRpc3RyaWJ1dGlvbilcblx0Ly8gXHRodHRwOi8vd3d3LmNnYWZhcS5pbmZvL3dpa2kvUmFuZG9tX1BvaW50X0luX1RyaWFuZ2xlXG5cblx0cmFuZG9tUG9pbnRJblRyaWFuZ2xlOiBmdW5jdGlvbiggdmVjdG9yQSwgdmVjdG9yQiwgdmVjdG9yQyApIHtcblxuXHRcdHZhciBhLCBiLCBjLFxuXHRcdFx0cG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0dG1wID0gVEhSRUUuR2VvbWV0cnlVdGlscy5fX3YxO1xuXG5cdFx0YSA9IFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tKCk7XG5cdFx0YiA9IFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tKCk7XG5cblx0XHRpZiAoICggYSArIGIgKSA+IDEgKSB7XG5cblx0XHRcdGEgPSAxIC0gYTtcblx0XHRcdGIgPSAxIC0gYjtcblxuXHRcdH1cblxuXHRcdGMgPSAxIC0gYSAtIGI7XG5cblx0XHRwb2ludC5jb3B5KCB2ZWN0b3JBICk7XG5cdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIGEgKTtcblxuXHRcdHRtcC5jb3B5KCB2ZWN0b3JCICk7XG5cdFx0dG1wLm11bHRpcGx5U2NhbGFyKCBiICk7XG5cblx0XHRwb2ludC5hZGRTZWxmKCB0bXAgKTtcblxuXHRcdHRtcC5jb3B5KCB2ZWN0b3JDICk7XG5cdFx0dG1wLm11bHRpcGx5U2NhbGFyKCBjICk7XG5cblx0XHRwb2ludC5hZGRTZWxmKCB0bXAgKTtcblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9LFxuXG5cdC8vIEdldCByYW5kb20gcG9pbnQgaW4gZmFjZSAodHJpYW5nbGUgLyBxdWFkKVxuXHQvLyAodW5pZm9ybSBkaXN0cmlidXRpb24pXG5cblx0cmFuZG9tUG9pbnRJbkZhY2U6IGZ1bmN0aW9uKCBmYWNlLCBnZW9tZXRyeSwgdXNlQ2FjaGVkQXJlYXMgKSB7XG5cblx0XHR2YXIgdkEsIHZCLCB2QywgdkQ7XG5cblx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcblxuXHRcdFx0dkEgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZmFjZS5hIF0ucG9zaXRpb247XG5cdFx0XHR2QiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBmYWNlLmIgXS5wb3NpdGlvbjtcblx0XHRcdHZDID0gZ2VvbWV0cnkudmVydGljZXNbIGZhY2UuYyBdLnBvc2l0aW9uO1xuXG5cdFx0XHRyZXR1cm4gVEhSRUUuR2VvbWV0cnlVdGlscy5yYW5kb21Qb2ludEluVHJpYW5nbGUoIHZBLCB2QiwgdkMgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcblxuXHRcdFx0dkEgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZmFjZS5hIF0ucG9zaXRpb247XG5cdFx0XHR2QiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBmYWNlLmIgXS5wb3NpdGlvbjtcblx0XHRcdHZDID0gZ2VvbWV0cnkudmVydGljZXNbIGZhY2UuYyBdLnBvc2l0aW9uO1xuXHRcdFx0dkQgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZmFjZS5kIF0ucG9zaXRpb247XG5cblx0XHRcdHZhciBhcmVhMSwgYXJlYTI7XG5cblx0XHRcdGlmICggdXNlQ2FjaGVkQXJlYXMgKSB7XG5cblx0XHRcdFx0aWYgKCBmYWNlLl9hcmVhMSAmJiBmYWNlLl9hcmVhMiApIHtcblxuXHRcdFx0XHRcdGFyZWExID0gZmFjZS5fYXJlYTE7XG5cdFx0XHRcdFx0YXJlYTIgPSBmYWNlLl9hcmVhMjtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YXJlYTEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkEsIHZCLCB2RCApO1xuXHRcdFx0XHRcdGFyZWEyID0gVEhSRUUuR2VvbWV0cnlVdGlscy50cmlhbmdsZUFyZWEoIHZCLCB2QywgdkQgKTtcblxuXHRcdFx0XHRcdGZhY2UuX2FyZWExID0gYXJlYTE7XG5cdFx0XHRcdFx0ZmFjZS5fYXJlYTIgPSBhcmVhMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YXJlYTEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkEsIHZCLCB2RCApLFxuXHRcdFx0XHRhcmVhMiA9IFRIUkVFLkdlb21ldHJ5VXRpbHMudHJpYW5nbGVBcmVhKCB2QiwgdkMsIHZEICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHIgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbSgpICogKCBhcmVhMSArIGFyZWEyICk7XG5cblx0XHRcdGlmICggciA8IGFyZWExICkge1xuXG5cdFx0XHRcdHJldHVybiBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbVBvaW50SW5UcmlhbmdsZSggdkEsIHZCLCB2RCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbVBvaW50SW5UcmlhbmdsZSggdkIsIHZDLCB2RCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHQvLyBHZXQgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIHJhbmRvbSBwb2ludHMgaW4gbWVzaFxuXHQvLyBcdC0gY3JlYXRlIGFycmF5IHdpdGggY3VtdWxhdGl2ZSBzdW1zIG9mIGZhY2UgYXJlYXNcblx0Ly8gIC0gcGljayByYW5kb20gbnVtYmVyIGZyb20gMCB0byB0b3RhbCBhcmVhXG5cdC8vICAtIGZpbmQgY29ycmVzcG9uZGluZyBwbGFjZSBpbiBhcmVhIGFycmF5IGJ5IGJpbmFyeSBzZWFyY2hcblx0Ly9cdC0gZ2V0IHJhbmRvbSBwb2ludCBpbiBmYWNlXG5cblx0cmFuZG9tUG9pbnRzSW5HZW9tZXRyeTogZnVuY3Rpb24oIGdlb21ldHJ5LCBuICkge1xuXG5cdFx0dmFyIGZhY2UsIGksXG5cdFx0XHRmYWNlcyA9IGdlb21ldHJ5LmZhY2VzLFxuXHRcdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcblx0XHRcdGlsID0gZmFjZXMubGVuZ3RoLFxuXHRcdFx0dG90YWxBcmVhID0gMCxcblx0XHRcdGN1bXVsYXRpdmVBcmVhcyA9IFtdLFxuXHRcdFx0dkEsIHZCLCB2QywgdkQ7XG5cblx0XHQvLyBwcmVjb21wdXRlIGZhY2UgYXJlYXNcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcblxuXHRcdFx0XHR2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5wb3NpdGlvbjtcblx0XHRcdFx0dkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF0ucG9zaXRpb247XG5cdFx0XHRcdHZDID0gdmVydGljZXNbIGZhY2UuYyBdLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGZhY2UuX2FyZWEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkEsIHZCLCB2QyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XG5cblx0XHRcdFx0dkEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF0ucG9zaXRpb247XG5cdFx0XHRcdHZCID0gdmVydGljZXNbIGZhY2UuYiBdLnBvc2l0aW9uO1xuXHRcdFx0XHR2QyA9IHZlcnRpY2VzWyBmYWNlLmMgXS5wb3NpdGlvbjtcblx0XHRcdFx0dkQgPSB2ZXJ0aWNlc1sgZmFjZS5kIF0ucG9zaXRpb247XG5cblx0XHRcdFx0ZmFjZS5fYXJlYTEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkEsIHZCLCB2RCApO1xuXHRcdFx0XHRmYWNlLl9hcmVhMiA9IFRIUkVFLkdlb21ldHJ5VXRpbHMudHJpYW5nbGVBcmVhKCB2QiwgdkMsIHZEICk7XG5cblx0XHRcdFx0ZmFjZS5fYXJlYSA9IGZhY2UuX2FyZWExICsgZmFjZS5fYXJlYTI7XG5cblx0XHRcdH1cblxuXHRcdFx0dG90YWxBcmVhICs9IGZhY2UuX2FyZWE7XG5cblx0XHRcdGN1bXVsYXRpdmVBcmVhc1sgaSBdID0gdG90YWxBcmVhO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYmluYXJ5IHNlYXJjaCBjdW11bGF0aXZlIGFyZWFzIGFycmF5XG5cblx0XHRmdW5jdGlvbiBiaW5hcnlTZWFyY2hJbmRpY2VzKCB2YWx1ZSApIHtcblxuXHRcdFx0ZnVuY3Rpb24gYmluYXJ5U2VhcmNoKCBzdGFydCwgZW5kICkge1xuXG5cdFx0XHRcdC8vIHJldHVybiBjbG9zZXN0IGxhcmdlciBpbmRleFxuXHRcdFx0XHQvLyBpZiBleGFjdCBudW1iZXIgaXMgbm90IGZvdW5kXG5cblx0XHRcdFx0aWYgKCBlbmQgPCBzdGFydCApXG5cdFx0XHRcdFx0cmV0dXJuIHN0YXJ0O1xuXG5cdFx0XHRcdHZhciBtaWQgPSBzdGFydCArIE1hdGguZmxvb3IoICggZW5kIC0gc3RhcnQgKSAvIDIgKTtcblxuXHRcdFx0XHRpZiAoIGN1bXVsYXRpdmVBcmVhc1sgbWlkIF0gPiB2YWx1ZSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBiaW5hcnlTZWFyY2goIHN0YXJ0LCBtaWQgLSAxICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VtdWxhdGl2ZUFyZWFzWyBtaWQgXSA8IHZhbHVlICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGJpbmFyeVNlYXJjaCggbWlkICsgMSwgZW5kICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBtaWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciByZXN1bHQgPSBiaW5hcnlTZWFyY2goIDAsIGN1bXVsYXRpdmVBcmVhcy5sZW5ndGggLSAxIClcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHQvLyBwaWNrIHJhbmRvbSBmYWNlIHdlaWdodGVkIGJ5IGZhY2UgYXJlYVxuXG5cdFx0dmFyIHIsIGluZGV4LFxuXHRcdFx0cmVzdWx0ID0gW107XG5cblx0XHR2YXIgc3RhdHMgPSB7fTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdFx0ciA9IFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tKCkgKiB0b3RhbEFyZWE7XG5cblx0XHRcdGluZGV4ID0gYmluYXJ5U2VhcmNoSW5kaWNlcyggciApO1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9IFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tUG9pbnRJbkZhY2UoIGZhY2VzWyBpbmRleCBdLCBnZW9tZXRyeSwgdHJ1ZSApO1xuXG5cdFx0XHRpZiAoICEgc3RhdHNbIGluZGV4IF0gKSB7XG5cblx0XHRcdFx0c3RhdHNbIGluZGV4IF0gPSAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN0YXRzWyBpbmRleCBdICs9IDE7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fSxcblxuXHQvLyBHZXQgdHJpYW5nbGUgYXJlYSAoYnkgSGVyb24ncyBmb3JtdWxhKVxuXHQvLyBcdGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVyb24lMjdzX2Zvcm11bGFcblxuXHR0cmlhbmdsZUFyZWE6IGZ1bmN0aW9uKCB2ZWN0b3JBLCB2ZWN0b3JCLCB2ZWN0b3JDICkge1xuXG5cdFx0dmFyIHMsIGEsIGIsIGMsXG5cdFx0XHR0bXAgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLl9fdjE7XG5cblx0XHR0bXAuc3ViKCB2ZWN0b3JBLCB2ZWN0b3JCICk7XG5cdFx0YSA9IHRtcC5sZW5ndGgoKTtcblxuXHRcdHRtcC5zdWIoIHZlY3RvckEsIHZlY3RvckMgKTtcblx0XHRiID0gdG1wLmxlbmd0aCgpO1xuXG5cdFx0dG1wLnN1YiggdmVjdG9yQiwgdmVjdG9yQyApO1xuXHRcdGMgPSB0bXAubGVuZ3RoKCk7XG5cblx0XHRzID0gMC41ICogKCBhICsgYiArIGMgKTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHMgKiAoIHMgLSBhICkgKiAoIHMgLSBiICkgKiAoIHMgLSBjICkgKTtcblxuXHR9LFxuXG5cdGNlbnRlcjogZnVuY3Rpb24oIGdlb21ldHJ5ICkge1xuXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdHZhciBkeCA9IC0wLjUgKiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94LnhbIDEgXSArIGdlb21ldHJ5LmJvdW5kaW5nQm94LnhbIDAgXSApO1xuXHRcdHZhciBkeSA9IC0wLjUgKiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94LnlbIDEgXSArIGdlb21ldHJ5LmJvdW5kaW5nQm94LnlbIDAgXSApO1xuXHRcdHZhciBkeiA9IC0wLjUgKiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94LnpbIDEgXSArIGdlb21ldHJ5LmJvdW5kaW5nQm94LnpbIDAgXSApO1xuXG5cdFx0bWF0cml4LnNldFRyYW5zbGF0aW9uKCBkeCwgZHksIGR6ICk7XG5cblx0XHRnZW9tZXRyeS5hcHBseU1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHR9XG5cblxufTtcblxuVEhSRUUuR2VvbWV0cnlVdGlscy5yYW5kb20gPSBUSFJFRS5NYXRoLnJhbmRvbTE2O1xuXG5USFJFRS5HZW9tZXRyeVV0aWxzLl9fdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5JbWFnZVV0aWxzID0ge1xuXG5cdGxvYWRUZXh0dXJlOiBmdW5jdGlvbiAoIHBhdGgsIG1hcHBpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0dmFyIGltYWdlID0gbmV3IEltYWdlKCksIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2UsIG1hcHBpbmcgKTtcblxuXHRcdGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7IGlmICggY2FsbGJhY2sgKSBjYWxsYmFjayggdGhpcyApOyB9O1xuXHRcdGltYWdlLmNyb3NzT3JpZ2luID0gJyc7XG5cdFx0aW1hZ2Uuc3JjID0gcGF0aDtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0bG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIGFycmF5LCBtYXBwaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdHZhciBpLCBsLCBpbWFnZXMgPSBbXSwgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBpbWFnZXMsIG1hcHBpbmcgKTtcblxuXHRcdGltYWdlcy5sb2FkQ291bnQgPSAwO1xuXG5cdFx0Zm9yICggaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArK2kgKSB7XG5cblx0XHRcdGltYWdlc1sgaSBdID0gbmV3IEltYWdlKCk7XG5cdFx0XHRpbWFnZXNbIGkgXS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aW1hZ2VzLmxvYWRDb3VudCArPSAxO1xuXHRcdFx0XHRpZiAoIGltYWdlcy5sb2FkQ291bnQgPT09IDYgKSB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHRcdH07XG5cblx0XHRcdGltYWdlc1sgaSBdLmNyb3NzT3JpZ2luID0gJyc7XG5cdFx0XHRpbWFnZXNbIGkgXS5zcmMgPSBhcnJheVsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXA6IGZ1bmN0aW9uICggaW1hZ2UsIGRlcHRoICkge1xuXG5cdFx0Ly8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL2xhYi9oZWlnaHRub3JtYWwvXG5cblx0XHR2YXIgY3Jvc3MgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHJldHVybiBbIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSwgYVsgMiBdICogYlsgMCBdIC0gYVsgMCBdICogYlsgMiBdLCBhWyAwIF0gKiBiWyAxIF0gLSBhWyAxIF0gKiBiWyAwIF0gXTtcblxuXHRcdH1cblxuXHRcdHZhciBzdWJ0cmFjdCA9IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC0gYlsgMCBdLCBhWyAxIF0gLSBiWyAxIF0sIGFbIDIgXSAtIGJbIDIgXSBdO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0dmFyIGwgPSBNYXRoLnNxcnQoIGFbIDAgXSAqIGFbIDAgXSArIGFbIDEgXSAqIGFbIDEgXSArIGFbIDIgXSAqIGFbIDIgXSApO1xuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC8gbCwgYVsgMSBdIC8gbCwgYVsgMiBdIC8gbCBdO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGRlcHRoID0gZGVwdGggfCAxO1xuXHRcdHZhciB3aWR0aCA9IGltYWdlLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCApO1xuXG5cdFx0dmFyIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgd2lkdGgsIGhlaWdodCApLmRhdGE7XG5cdFx0dmFyIGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKCB3aWR0aCwgaGVpZ2h0ICk7XG5cdFx0dmFyIG91dHB1dCA9IGltYWdlRGF0YS5kYXRhO1xuXG5cdFx0Zm9yICggdmFyIHggPSAwOyB4IDwgd2lkdGg7IHggKysgKSB7XG5cblx0XHRcdGZvciAoIHZhciB5ID0gMTsgeSA8IGhlaWdodDsgeSArKyApIHtcblxuXHRcdFx0XHR2YXIgbHkgPSB5IC0gMSA8IDAgPyBoZWlnaHQgLSAxIDogeSAtIDE7XG5cdFx0XHRcdHZhciB1eSA9ICggeSArIDEgKSAlIGhlaWdodDtcblx0XHRcdFx0dmFyIGx4ID0geCAtIDEgPCAwID8gd2lkdGggLSAxIDogeCAtIDE7XG5cdFx0XHRcdHZhciB1eCA9ICggeCArIDEgKSAlIHdpZHRoO1xuXG5cdFx0XHRcdHZhciBwb2ludHMgPSBbXTtcblx0XHRcdFx0dmFyIG9yaWdpbiA9IFsgMCwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAtIDEsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgLSAxLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDAsIC0gMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAgMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAxLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDAsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgLSAxLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXG5cdFx0XHRcdHZhciBub3JtYWxzID0gW107XG5cdFx0XHRcdHZhciBudW1fcG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1fcG9pbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHYxID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIHYyID0gcG9pbnRzWyAoIGkgKyAxICkgJSBudW1fcG9pbnRzIF07XG5cdFx0XHRcdFx0djEgPSBzdWJ0cmFjdCggdjEsIG9yaWdpbiApO1xuXHRcdFx0XHRcdHYyID0gc3VidHJhY3QoIHYyLCBvcmlnaW4gKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbGl6ZSggY3Jvc3MoIHYxLCB2MiApICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG5vcm1hbCA9IFsgMCwgMCwgMCBdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsWyAwIF0gKz0gbm9ybWFsc1sgaSBdWyAwIF07XG5cdFx0XHRcdFx0bm9ybWFsWyAxIF0gKz0gbm9ybWFsc1sgaSBdWyAxIF07XG5cdFx0XHRcdFx0bm9ybWFsWyAyIF0gKz0gbm9ybWFsc1sgaSBdWyAyIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5vcm1hbFsgMCBdIC89IG5vcm1hbHMubGVuZ3RoO1xuXHRcdFx0XHRub3JtYWxbIDEgXSAvPSBub3JtYWxzLmxlbmd0aDtcblx0XHRcdFx0bm9ybWFsWyAyIF0gLz0gbm9ybWFscy5sZW5ndGg7XG5cblx0XHRcdFx0dmFyIGlkeCA9ICggeSAqIHdpZHRoICsgeCApICogNDtcblxuXHRcdFx0XHRvdXRwdXRbIGlkeCBdID0gKCAoIG5vcm1hbFsgMCBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XG5cdFx0XHRcdG91dHB1dFsgaWR4ICsgMSBdID0gKCAoIG5vcm1hbFsgMSBdICsgMS4wIC8gMi4wICkgKiAyNTUgKSB8IDA7XG5cdFx0XHRcdG91dHB1dFsgaWR4ICsgMiBdID0gKCBub3JtYWxbIDIgXSAqIDI1NSApIHwgMDtcblx0XHRcdFx0b3V0cHV0WyBpZHggKyAzIF0gPSAyNTU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcblxuXHRcdHJldHVybiBjYW52YXM7XG5cblx0fVxuXG59O1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNjZW5lVXRpbHMgPSB7XG5cblx0c2hvd0hpZXJhcmNoeSA6IGZ1bmN0aW9uICggcm9vdCwgdmlzaWJsZSApIHtcblxuXHRcdFRIUkVFLlNjZW5lVXRpbHMudHJhdmVyc2VIaWVyYXJjaHkoIHJvb3QsIGZ1bmN0aW9uKCBub2RlICkgeyBub2RlLnZpc2libGUgPSB2aXNpYmxlOyB9ICk7XG5cblx0fSxcblxuXHR0cmF2ZXJzZUhpZXJhcmNoeSA6IGZ1bmN0aW9uICggcm9vdCwgY2FsbGJhY2sgKSB7XG5cblx0XHR2YXIgbiwgaSwgbCA9IHJvb3QuY2hpbGRyZW4ubGVuZ3RoO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRuID0gcm9vdC5jaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRjYWxsYmFjayggbiApO1xuXG5cdFx0XHRUSFJFRS5TY2VuZVV0aWxzLnRyYXZlcnNlSGllcmFyY2h5KCBuLCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y3JlYXRlTXVsdGlNYXRlcmlhbE9iamVjdCA6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFscyApIHtcblxuXHRcdHZhciBpLCBpbCA9IG1hdGVyaWFscy5sZW5ndGgsXG5cdFx0XHRncm91cCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG9iamVjdCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKTtcblx0XHRcdGdyb3VwLmFkZCggb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JvdXA7XG5cblx0fVxuXG59O1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKlxuICogU2hhZGVyVXRpbHMgY3VycmVudGx5IGNvbnRhaW5zOlxuICpcbiAqXHRmcmVzbmVsXG4gKlx0bm9ybWFsXG4gKiBcdGN1YmVcbiAqXG4gKi9cblxuaWYgKCBUSFJFRS5XZWJHTFJlbmRlcmVyICkge1xuXG5USFJFRS5TaGFkZXJVdGlscyA9IHtcblxuXHRsaWI6IHtcblxuXHRcdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvL1x0RnJlc25lbCBzaGFkZXJcblx0XHQvL1x0LSBiYXNlZCBvbiBOdmlkaWEgQ2cgdHV0b3JpYWxcblx0XHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdFx0J2ZyZXNuZWwnOiB7XG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cblx0XHRcdFx0XCJtUmVmcmFjdGlvblJhdGlvXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAyIH0sXG5cdFx0XHRcdFwibUZyZXNuZWxCaWFzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjEgfSxcblx0XHRcdFx0XCJtRnJlc25lbFBvd2VyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyLjAgfSxcblx0XHRcdFx0XCJtRnJlc25lbFNjYWxlXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcblx0XHRcdFx0XCJ0Q3ViZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogMSwgdGV4dHVyZTogbnVsbCB9XG5cblx0XHRcdH0sXG5cblx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxuXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMzIHZSZWZsZWN0O1wiLFxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2UmVmcmFjdFszXTtcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZSZWZsZWN0aW9uRmFjdG9yO1wiLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XCJ2ZWM0IHJlZmxlY3RlZENvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCAtdlJlZmxlY3QueCwgdlJlZmxlY3QueXogKSApO1wiLFxuXHRcdFx0XHRcdFwidmVjNCByZWZyYWN0ZWRDb2xvciA9IHZlYzQoIDEuMCwgMS4wLCAxLjAsIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0XCJyZWZyYWN0ZWRDb2xvci5yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCAtdlJlZnJhY3RbMF0ueCwgdlJlZnJhY3RbMF0ueXogKSApLnI7XCIsXG5cdFx0XHRcdFx0XCJyZWZyYWN0ZWRDb2xvci5nID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCAtdlJlZnJhY3RbMV0ueCwgdlJlZnJhY3RbMV0ueXogKSApLmc7XCIsXG5cdFx0XHRcdFx0XCJyZWZyYWN0ZWRDb2xvci5iID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCAtdlJlZnJhY3RbMl0ueCwgdlJlZnJhY3RbMl0ueXogKSApLmI7XCIsXG5cdFx0XHRcdFx0XCJyZWZyYWN0ZWRDb2xvci5hID0gMS4wO1wiLFxuXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBtaXgoIHJlZnJhY3RlZENvbG9yLCByZWZsZWN0ZWRDb2xvciwgY2xhbXAoIHZSZWZsZWN0aW9uRmFjdG9yLCAwLjAsIDEuMCApICk7XCIsXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgbVJlZnJhY3Rpb25SYXRpbztcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1GcmVzbmVsQmlhcztcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1GcmVzbmVsU2NhbGU7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBtRnJlc25lbFBvd2VyO1wiLFxuXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMzIHZSZWZsZWN0O1wiLFxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2UmVmcmFjdFszXTtcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZSZWZsZWN0aW9uRmFjdG9yO1wiLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XCJ2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cdFx0XHRcdFx0XCJ2ZWM0IG1Qb3NpdGlvbiA9IG9iamVjdE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFx0XHRcdFwidmVjMyBuV29ybGQgPSBub3JtYWxpemUgKCBtYXQzKCBvYmplY3RNYXRyaXhbMF0ueHl6LCBvYmplY3RNYXRyaXhbMV0ueHl6LCBvYmplY3RNYXRyaXhbMl0ueHl6ICkgKiBub3JtYWwgKTtcIixcblxuXHRcdFx0XHRcdFwidmVjMyBJID0gbVBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFx0XCJ2UmVmbGVjdCA9IHJlZmxlY3QoIEksIG5Xb3JsZCApO1wiLFxuXHRcdFx0XHRcdFwidlJlZnJhY3RbMF0gPSByZWZyYWN0KCBub3JtYWxpemUoIEkgKSwgbldvcmxkLCBtUmVmcmFjdGlvblJhdGlvICk7XCIsXG5cdFx0XHRcdFx0XCJ2UmVmcmFjdFsxXSA9IHJlZnJhY3QoIG5vcm1hbGl6ZSggSSApLCBuV29ybGQsIG1SZWZyYWN0aW9uUmF0aW8gKiAwLjk5ICk7XCIsXG5cdFx0XHRcdFx0XCJ2UmVmcmFjdFsyXSA9IHJlZnJhY3QoIG5vcm1hbGl6ZSggSSApLCBuV29ybGQsIG1SZWZyYWN0aW9uUmF0aW8gKiAwLjk4ICk7XCIsXG5cdFx0XHRcdFx0XCJ2UmVmbGVjdGlvbkZhY3RvciA9IG1GcmVzbmVsQmlhcyArIG1GcmVzbmVsU2NhbGUgKiBwb3coIDEuMCArIGRvdCggbm9ybWFsaXplKCBJICksIG5Xb3JsZCApLCBtRnJlc25lbFBvd2VyICk7XCIsXG5cblx0XHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0XHR9LFxuXG5cdFx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vXHROb3JtYWwgbWFwIHNoYWRlclxuXHRcdC8vXHRcdC0gQmxpbm4tUGhvbmdcblx0XHQvL1x0XHQtIG5vcm1hbCArIGRpZmZ1c2UgKyBzcGVjdWxhciArIEFPICsgZGlzcGxhY2VtZW50ICsgcmVmbGVjdGlvbiArIHNoYWRvdyBtYXBzXG5cdFx0Ly9cdFx0LSBwb2ludCBhbmQgZGlyZWN0aW9uYWwgbGlnaHRzICh1c2Ugd2l0aCBcImxpZ2h0czogdHJ1ZVwiIG1hdGVyaWFsIG9wdGlvbilcblx0XHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdFx0J25vcm1hbCcgOiB7XG5cblx0XHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuXHRcdFx0XHR7XG5cblx0XHRcdFx0XCJlbmFibGVBT1wiXHRcdCAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXHRcdFx0XHRcImVuYWJsZURpZmZ1c2VcIlx0ICA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cdFx0XHRcdFwiZW5hYmxlU3BlY3VsYXJcIiAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXHRcdFx0XHRcImVuYWJsZVJlZmxlY3Rpb25cIjogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblxuXHRcdFx0XHRcInREaWZmdXNlXCJcdCAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IDAsIHRleHR1cmU6IG51bGwgfSxcblx0XHRcdFx0XCJ0Q3ViZVwiXHRcdCAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IDEsIHRleHR1cmU6IG51bGwgfSxcblx0XHRcdFx0XCJ0Tm9ybWFsXCJcdCAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IDIsIHRleHR1cmU6IG51bGwgfSxcblx0XHRcdFx0XCJ0U3BlY3VsYXJcIlx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogMywgdGV4dHVyZTogbnVsbCB9LFxuXHRcdFx0XHRcInRBT1wiXHRcdCAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IDQsIHRleHR1cmU6IG51bGwgfSxcblx0XHRcdFx0XCJ0RGlzcGxhY2VtZW50XCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiA1LCB0ZXh0dXJlOiBudWxsIH0sXG5cblx0XHRcdFx0XCJ1Tm9ybWFsU2NhbGVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXG5cdFx0XHRcdFwidURpc3BsYWNlbWVudEJpYXNcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMCB9LFxuXHRcdFx0XHRcInVEaXNwbGFjZW1lbnRTY2FsZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cblx0XHRcdFx0XCJ1RGlmZnVzZUNvbG9yXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlICkgfSxcblx0XHRcdFx0XCJ1U3BlY3VsYXJDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXG5cdFx0XHRcdFwidUFtYmllbnRDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDA1MDUwNSApIH0sXG5cdFx0XHRcdFwidVNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfSxcblx0XHRcdFx0XCJ1T3BhY2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXG5cdFx0XHRcdFwidVJlZmxlY3Rpdml0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXG5cblx0XHRcdFx0XCJ1T2Zmc2V0XCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICkgfSxcblx0XHRcdFx0XCJ1UmVwZWF0XCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XSApLFxuXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHVBbWJpZW50Q29sb3I7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHVEaWZmdXNlQ29sb3I7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHVTcGVjdWxhckNvbG9yO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgdVNoaW5pbmVzcztcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1wiLFxuXG5cdFx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpZmZ1c2U7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZVNwZWN1bGFyO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gYm9vbCBlbmFibGVBTztcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGJvb2wgZW5hYmxlUmVmbGVjdGlvbjtcIixcblxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHROb3JtYWw7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdFNwZWN1bGFyO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHRBTztcIixcblxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XCIsXG5cblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVOb3JtYWxTY2FsZTtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVSZWZsZWN0aXZpdHk7XCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XCIsXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxuXG5cdFx0XHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1wiLFxuXHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlBvaW50TGlnaHRbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblx0XHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCAxLjAgKSwgdU9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRcdFwidmVjMyBzcGVjdWxhclRleCA9IHZlYzMoIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0XCJ2ZWMzIG5vcm1hbFRleCA9IHRleHR1cmUyRCggdE5vcm1hbCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1wiLFxuXHRcdFx0XHRcdFwibm9ybWFsVGV4Lnh5ICo9IHVOb3JtYWxTY2FsZTtcIixcblx0XHRcdFx0XHRcIm5vcm1hbFRleCA9IG5vcm1hbGl6ZSggbm9ybWFsVGV4ICk7XCIsXG5cblx0XHRcdFx0XHRcImlmKCBlbmFibGVEaWZmdXNlIClcIixcblx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXG5cblx0XHRcdFx0XHRcImlmKCBlbmFibGVBTyApXCIsXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogdGV4dHVyZTJEKCB0QU8sIHZVdiApLnh5ejtcIixcblxuXHRcdFx0XHRcdFwiaWYoIGVuYWJsZVNwZWN1bGFyIClcIixcblx0XHRcdFx0XHRcdFwic3BlY3VsYXJUZXggPSB0ZXh0dXJlMkQoIHRTcGVjdWxhciwgdlV2ICkueHl6O1wiLFxuXG5cdFx0XHRcdFx0XCJtYXQzIHRzYiA9IG1hdDMoIHZUYW5nZW50LCB2Qmlub3JtYWwsIHZOb3JtYWwgKTtcIixcblx0XHRcdFx0XHRcInZlYzMgZmluYWxOb3JtYWwgPSB0c2IgKiBub3JtYWxUZXg7XCIsXG5cblx0XHRcdFx0XHRcInZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBmaW5hbE5vcm1hbCApO1wiLFxuXHRcdFx0XHRcdFwidmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcIixcblxuXHRcdFx0XHRcdC8vIHBvaW50IGxpZ2h0c1xuXG5cdFx0XHRcdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcblxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHBvaW50U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0XCJmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwidmVjMyBwb2ludFZlY3RvciA9IG5vcm1hbGl6ZSggdlBvaW50TGlnaHRbIGkgXS54eXogKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHBvaW50SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggdlBvaW50TGlnaHRbIGkgXS54eXogKyB2aWV3UG9zaXRpb24gKTtcIixcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBwb2ludERpc3RhbmNlID0gdlBvaW50TGlnaHRbIGkgXS53O1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgcG9pbnREb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApO1wiLFxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50RGlmZnVzZVdlaWdodCA9IG1heCggZG90KCBub3JtYWwsIHBvaW50VmVjdG9yICksIDAuMCApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgcG9pbnRTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgdVNoaW5pbmVzcyApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwicG9pbnREaWZmdXNlICs9IHBvaW50RGlzdGFuY2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHVEaWZmdXNlQ29sb3IgKiBwb2ludERpZmZ1c2VXZWlnaHQ7XCIsXG5cdFx0XHRcdFx0XHRcdFwicG9pbnRTcGVjdWxhciArPSBwb2ludERpc3RhbmNlICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiB1U3BlY3VsYXJDb2xvciAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQ7XCIsXG5cblx0XHRcdFx0XHRcdFwifVwiLFxuXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XHRcdC8vIGRpcmVjdGlvbmFsIGxpZ2h0c1xuXG5cdFx0XHRcdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFx0XHRcdFwidmVjMyBkaXJEaWZmdXNlID0gdmVjMyggMC4wICk7XCIsXG5cdFx0XHRcdFx0XHRcInZlYzMgZGlyU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpKysgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0XHRcInZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZlYzMgZGlySGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKyB2aWV3UG9zaXRpb24gKTtcIixcblxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IGRpckRvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBkaXJIYWxmVmVjdG9yICksIDAuMCApO1wiLFxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IGRpckRpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdCggbm9ybWFsLCBkaXJWZWN0b3IgKSwgMC4wICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBwb3coIGRpckRvdE5vcm1hbEhhbGYsIHVTaGluaW5lc3MgKTtcIixcblxuXHRcdFx0XHRcdFx0XHRcImRpckRpZmZ1c2UgKz0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiB1RGlmZnVzZUNvbG9yICogZGlyRGlmZnVzZVdlaWdodDtcIixcblx0XHRcdFx0XHRcdFx0XCJkaXJTcGVjdWxhciArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIHVTcGVjdWxhckNvbG9yICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0O1wiLFxuXG5cdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XHQvLyBhbGwgbGlnaHRzIGNvbnRyaWJ1dGlvbiBzdW1tYXRpb25cblxuXHRcdFx0XHRcdFwidmVjMyB0b3RhbERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFx0XHRcInZlYzMgdG90YWxTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxuXG5cdFx0XHRcdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFx0XHRcdFwidG90YWxEaWZmdXNlICs9IGRpckRpZmZ1c2U7XCIsXG5cdFx0XHRcdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gZGlyU3BlY3VsYXI7XCIsXG5cblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcblxuXHRcdFx0XHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gcG9pbnREaWZmdXNlO1wiLFxuXHRcdFx0XHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XCIsXG5cblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiB1QW1iaWVudENvbG9yKSArIHRvdGFsU3BlY3VsYXI7XCIsXG5cblx0XHRcdFx0XHRcImlmICggZW5hYmxlUmVmbGVjdGlvbiApIHtcIixcblxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHdQb3MgPSBjYW1lcmFQb3NpdGlvbiAtIHZWaWV3UG9zaXRpb247XCIsXG5cdFx0XHRcdFx0XHRcInZlYzMgdlJlZmxlY3QgPSByZWZsZWN0KCBub3JtYWxpemUoIHdQb3MgKSwgbm9ybWFsICk7XCIsXG5cdFx0XHRcdFx0XHRcInZlYzQgY3ViZUNvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCAtdlJlZmxlY3QueCwgdlJlZmxlY3QueXogKSApO1wiLFxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBjdWJlQ29sb3IueHl6LCB1UmVmbGVjdGl2aXR5ICk7XCIsXG5cblx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oXCJcXG5cIiksXG5cblx0XHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzQgdGFuZ2VudDtcIixcblxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMiB1T2Zmc2V0O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMiB1UmVwZWF0O1wiLFxuXG5cdFx0XHRcdFwiI2lmZGVmIFZFUlRFWF9URVhUVVJFU1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlzcGxhY2VtZW50O1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCB1RGlzcGxhY2VtZW50U2NhbGU7XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVEaXNwbGFjZW1lbnRCaWFzO1wiLFxuXG5cdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XCIsXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXG5cblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjNCB2UG9pbnRMaWdodFsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxuXG5cdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XCJ2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFx0XHRcInZWaWV3UG9zaXRpb24gPSAtbXZQb3NpdGlvbi54eXo7XCIsXG5cblx0XHRcdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxuXG5cdFx0XHRcdFx0Ly8gdGFuZ2VudCBhbmQgYmlub3JtYWwgdmVjdG9yc1xuXG5cdFx0XHRcdFx0XCJ2VGFuZ2VudCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogdGFuZ2VudC54eXogKTtcIixcblxuXHRcdFx0XHRcdFwidkJpbm9ybWFsID0gY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50Lnc7XCIsXG5cdFx0XHRcdFx0XCJ2Qmlub3JtYWwgPSBub3JtYWxpemUoIHZCaW5vcm1hbCApO1wiLFxuXG5cdFx0XHRcdFx0XCJ2VXYgPSB1diAqIHVSZXBlYXQgKyB1T2Zmc2V0O1wiLFxuXG5cdFx0XHRcdFx0Ly8gcG9pbnQgbGlnaHRzXG5cblx0XHRcdFx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSsrICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwidmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgbERpc3RhbmNlID0gMS4wO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXG5cdFx0XHRcdFx0XHRcdFx0XCJsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0XHRcImxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcIixcblxuXHRcdFx0XHRcdFx0XHRcInZQb2ludExpZ2h0WyBpIF0gPSB2ZWM0KCBsVmVjdG9yLCBsRGlzdGFuY2UgKTtcIixcblxuXHRcdFx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFx0Ly8gZGlzcGxhY2VtZW50IG1hcHBpbmdcblxuXHRcdFx0XHRcdFwiI2lmZGVmIFZFUlRFWF9URVhUVVJFU1wiLFxuXG5cdFx0XHRcdFx0XHRcInZlYzMgZHYgPSB0ZXh0dXJlMkQoIHREaXNwbGFjZW1lbnQsIHV2ICkueHl6O1wiLFxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkZiA9IHVEaXNwbGFjZW1lbnRTY2FsZSAqIGR2LnggKyB1RGlzcGxhY2VtZW50QmlhcztcIixcblx0XHRcdFx0XHRcdFwidmVjNCBkaXNwbGFjZWRQb3NpdGlvbiA9IHZlYzQoIHZOb3JtYWwueHl6ICogZGYsIDAuMCApICsgbXZQb3NpdGlvbjtcIixcblx0XHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZGlzcGxhY2VkUG9zaXRpb247XCIsXG5cblx0XHRcdFx0XHRcIiNlbHNlXCIsXG5cblx0XHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oXCJcXG5cIilcblxuXHRcdH0sXG5cblx0XHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuXHRcdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0XHQnY3ViZSc6IHtcblxuXHRcdFx0dW5pZm9ybXM6IHsgXCJ0Q3ViZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogMSwgdGV4dHVyZTogbnVsbCB9LFxuXHRcdFx0XHRcdFx0XCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLTEgfSB9LFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XCJ2ZWM0IG1Qb3NpdGlvbiA9IG9iamVjdE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblx0XHRcdFx0XHRcInZWaWV3UG9zaXRpb24gPSBjYW1lcmFQb3NpdGlvbiAtIG1Qb3NpdGlvbi54eXo7XCIsXG5cblx0XHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oXCJcXG5cIiksXG5cblx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFwidmVjMyB3UG9zID0gY2FtZXJhUG9zaXRpb24gLSB2Vmlld1Bvc2l0aW9uO1wiLFxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHdQb3MueCwgd1Bvcy55eiApICk7XCIsXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG59Oy8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3RcbiAqIFxuICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFnZW50QXQodSlcbiAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXG4gKiAuZ2V0TGVuZ3RoKClcbiAqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgZm9sbG93aW5nIGNsYXNzZXM6XG4gKlxuICogLS0gMmQgY2xhc3NlcyAtLVxuICogVEhSRUUuQ3VydmVcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKiBUSFJFRS5BcmNDdXJ2ZVxuICpcbiAqIC0tIDNkIGNsYXNzZXMgLS1cbiAqIFRIUkVFLkxpbmVDdXJ2ZTNcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlM1xuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcbiAqIFRIUkVFLlNwbGluZUN1cnZlM1xuICpcbiAqKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0QWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZSA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLy8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXG4vL1x0LSB0IFswIC4uIDFdXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHRjb25zb2xlLmxvZyggXCJXYXJuaW5nLCBnZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZCFcIiApO1xuXHRyZXR1cm4gbnVsbDtcblxufTtcblxuLy8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXG4vLyAtIHUgWzAgLi4gMV1cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XG5cblx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB0ICk7XG5cbn07XG5cbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0aWYgKCAhZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcblxuXHR2YXIgZCwgcHRzID0gW107XG5cblx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0cHRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG5cdH07XG5cblx0cmV0dXJuIHB0cztcblxufTtcblxuLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cblx0dmFyIGQsIHB0cyA9IFtdO1xuXG5cdGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuXHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG5cdH07XG5cblx0cmV0dXJuIHB0cztcblxufTtcblxuLy8gR2V0IHRvdGFsIGN1cnZlIGxlbmd0aFxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cdHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcblxufTtcblxuLy8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldExlbmd0aHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRpZiAoICFkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAyMDA7XG5cblx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3RocyAmJiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PSBkaXZpc2lvbnMgKyAxICkgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCBcImNhY2hlZFwiLCB0aGlzLmNhY2hlQXJjTGVuZ3RocyApO1xuXHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuXHR9XG5cblx0dmFyIGNhY2hlID0gW107XG5cdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xuXHR2YXIgcCwgc3VtID0gMDtcblxuXHRjYWNoZS5wdXNoKCAwICk7XG5cblx0Zm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xuXG5cdFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQgKCBwIC8gZGl2aXNpb25zICk7XG5cdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuXHRcdGNhY2hlLnB1c2goIHN1bSApO1xuXHRcdGxhc3QgPSBjdXJyZW50O1xuXG5cdH1cblxuXHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG5cdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cblxufTtcblxuLy8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpIGRpc3RhbmNlXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRVdG9UbWFwcGluZyA9IGZ1bmN0aW9uICggdSwgZGlzdGFuY2UgKSB7XG5cblx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblxuXHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cblx0dmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XG5cblx0aWYgKCBkaXN0YW5jZSApIHtcblxuXHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cblx0fVxuXG5cdC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXG5cdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXG5cblx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcblxuXHRcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xuXG5cdCAgXHRjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xuXG5cdCAgXHRpZiAoIGNvbXBhcmlzb24gPCAwICkge1xuXG5cdFx0XHRsb3cgPSBpICsgMTtcblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XG5cblx0XHRcdGhpZ2ggPSBpIC0gMTtcblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aGlnaCA9IGk7XG5cdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gRE9ORVxuXG5cdFx0fVxuXG5cdH1cblxuXHRpID0gaGlnaDtcblxuXHQvL2NvbnNvbGUubG9nKCdiJyAsIGksIGxvdywgaGlnaCwgRGF0ZS5ub3coKS0gdGltZSk7XG5cblx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xuXG5cdFx0dmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcblx0XHRyZXR1cm4gdDtcblxuXHR9XG5cblx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuXG5cdHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XG4gICAgdmFyIGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1sgaSArIDEgXTtcblxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG4gICAgdmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG4gICAgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtMSApO1xuXG5cdHJldHVybiB0O1xuXG59O1xuXG4vLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IC8gbm9ybWFsIGZpbmRpbmcsXG4vLyB3ZSBnZXQgMiBwb2ludHMgd2l0aCBhIHNtYWxsIGRlbHRhIGFuZCBmaW5kIGEgZ3JhZGllbnQgb2YgdGhlIDIgcG9pbnRzXG4vLyB3aGljaCBzZWVtcyB0byBtYWtlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXROb3JtYWxWZWN0b3IgPSBmdW5jdGlvbiggdCApIHtcblxuXHR2YXIgdmVjID0gdGhpcy5nZXRUYW5nZW50KCB0ICk7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCAtdmVjLnkgLCB2ZWMueCApO1xuXG59O1xuXG4vLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cblx0dmFyIGRlbHRhID0gMC4wMDAxO1xuXHR2YXIgdDEgPSB0IC0gZGVsdGE7XG5cdHZhciB0MiA9IHQgKyBkZWx0YTtcblxuXHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXG5cblx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XG5cdGlmICggdDIgPiAxICkgdDIgPSAxO1xuXG5cdHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xuXHR2YXIgcHQyID0gdGhpcy5nZXRQb2ludCggdDIgKTtcblx0XG5cdHZhciB2ZWMgPSBwdDEuY2xvbmUoKS5zdWJTZWxmKHB0Mik7XG5cdHJldHVybiB2ZWMubm9ybWFsaXplKCk7XG5cbn07XG5cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuXHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCApO1xuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRMaW5lXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG5cdGlmICggISAoIHYxIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiApICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIGZvciBvbGQgY29uc3R1Y3RvciBzaWduYXR1cmUgLSBzaG91bGQgYmUgcmVtb3ZlZCBvdmVyIHRpbWVcblxuXHRcdFRIUkVFLkxpbmVDdXJ2ZS5vbGRDb25zdHJ1Y3Rvci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXHR0aGlzLnYxID0gdjE7XG5cdHRoaXMudjIgPSB2MjtcblxufTtcblxuVEhSRUUuTGluZUN1cnZlLm9sZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCB4MSwgeTEsIHgyLCB5MiApIHtcblxuXHR0aGlzLmNvbnN0cnVjdG9yKCBuZXcgVEhSRUUuVmVjdG9yMiggeDEsIHkxICksIG5ldyBUSFJFRS5WZWN0b3IyKCB4MiwgeTIgKSApO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlID0gbmV3IFRIUkVFLkN1cnZlKCk7XG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZUN1cnZlO1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdHZhciBwb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0cG9pbnQuc3ViKCB0aGlzLnYyLCB0aGlzLnYxICk7XG5cdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkU2VsZiggdGhpcy52MSApO1xuXG5cdHJldHVybiBwb2ludDtcblxufTtcblxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHR2YXIgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dGFuZ2VudC5zdWIoIHRoaXMudjIsIHRoaXMudjEgKTtcblx0dGFuZ2VudC5ub3JtYWxpemUoKTtcblxuXHRyZXR1cm4gdGFuZ2VudDtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0UXVhZHJhdGljIEJlemllciBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xuXG5cdGlmICggISggdjEgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyICkgKSB7XG5cblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuXHRcdHYwID0gbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICk7XG5cdFx0djEgPSBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMiBdLCBhcmdzWyAzIF0gKTtcblx0XHR2MiA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyA0IF0sIGFyZ3NbIDUgXSApO1xuXG5cdH1cblxuXHR0aGlzLnYwID0gdjA7XG5cdHRoaXMudjEgPSB2MTtcblx0dGhpcy52MiA9IHYyO1xuXG59O1xuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuQ3VydmUoKTtcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlO1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgdHgsIHR5O1xuXG5cdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcblx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XG5cbn07XG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHQvLyBpdGVyYXRlIHN1YiBzZWdtZW50c1xuXHQvLyBcdGdldCBsZW5ndGhzIGZvciBzdWIgc2VnbWVudHNcblx0Ly8gXHRpZiBzZWdtZW50IGlzIGJlemllclxuXHQvL1x0XHRwZXJmb3JtIHN1YmRpdmlzaW9uc1xuXG5cdHZhciB0eCwgdHk7XG5cblx0dHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG5cdHR5ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuXG5cdC8vIHJldHVybnMgdW5pdCB2ZWN0b3JcblxuXHR2YXIgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcblx0dGFuZ2VudC5ub3JtYWxpemUoKTtcblxuXHRyZXR1cm4gdGFuZ2VudDtcblxufTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdWJpYyBCZXppZXIgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XG5cblx0aWYgKCAhICggdjEgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyICkgKSB7XG5cblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuXHRcdHYwID0gbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICk7XG5cdFx0djEgPSBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMiBdLCBhcmdzWyAzIF0gKTtcblx0XHR2MiA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyA0IF0sIGFyZ3NbIDUgXSApO1xuXHRcdHYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDYgXSwgYXJnc1sgNyBdICk7XG5cblx0fVxuXG5cdHRoaXMudjAgPSB2MDtcblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cdHRoaXMudjMgPSB2MztcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuQ3VydmUoKTtcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHR4LCB0eTtcblxuXHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcblx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdHZhciB0eCwgdHk7XG5cblx0dHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuXHR0eSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cblx0Ly8gcmV0dXJuIG5vcm1hbCB1bml0IHZlY3RvclxuXG5cdHZhciB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xuXHR0YW5nZW50Lm5vcm1hbGl6ZSgpO1xuXG5cdHJldHVybiB0YW5nZW50O1xuXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdFNwbGluZSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5TcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XG5cblx0dGhpcy5wb2ludHMgPSAocG9pbnRzID09IHVuZGVmaW5lZCkgPyBbXSA6IHBvaW50cztcblxufTtcblxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gbmV3IFRIUkVFLkN1cnZlKCk7XG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGxpbmVDdXJ2ZTtcblxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIGMgPSBbXTtcblx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLCBwb2ludCwgaW50UG9pbnQsIHdlaWdodDtcblx0cG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuXHRjWyAwIF0gPSBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG5cdGNbIDEgXSA9IGludFBvaW50O1xuXHRjWyAyIF0gPSBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gaW50UG9pbnQgOiBpbnRQb2ludCArIDE7XG5cdGNbIDMgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMjtcblxuXHR2LnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnRzWyBjWyAwIF0gXS54LCBwb2ludHNbIGNbIDEgXSBdLngsIHBvaW50c1sgY1sgMiBdIF0ueCwgcG9pbnRzWyBjWyAzIF0gXS54LCB3ZWlnaHQgKTtcblx0di55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueSwgcG9pbnRzWyBjWyAxIF0gXS55LCBwb2ludHNbIGNbIDIgXSBdLnksIHBvaW50c1sgY1sgMyBdIF0ueSwgd2VpZ2h0ICk7XG5cblx0cmV0dXJuIHY7XG5cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFyYyBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLFxuXHRcdFx0XHRcdFx0XHRhQ2xvY2t3aXNlICkge1xuXG5cdHRoaXMuYVggPSBhWDtcblx0dGhpcy5hWSA9IGFZO1xuXG5cdHRoaXMuYVJhZGl1cyA9IGFSYWRpdXM7XG5cblx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xuXHR0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZTtcblxuXHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG59O1xuXG5USFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuQ3VydmUoKTtcblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFyY0N1cnZlO1xuXG5USFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XG5cblx0aWYgKCAhdGhpcy5hQ2xvY2t3aXNlICkge1xuXG5cdFx0dCA9IDEgLSB0O1xuXG5cdH1cblxuXHR2YXIgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cblx0dmFyIHR4ID0gdGhpcy5hWCArIHRoaXMuYVJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHR2YXIgdHkgPSB0aGlzLmFZICsgdGhpcy5hUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0VXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmUuVXRpbHMgPSB7XG5cblx0dGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiAoIHAxIC0gcDAgKSArIDIgKiB0ICogKCBwMiAtIHAxICk7XG5cblx0fSxcblxuXHQvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcblxuXHR0YW5nZW50Q3ViaWNCZXppZXI6IGZ1bmN0aW9uICh0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdHJldHVybiAtMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgICtcblx0XHRcdDMgKiBwMSAqICgxIC0gdCkgKiAoMS10KSAtIDYgKnQgKnAxICogKDEtdCkgK1xuXHRcdFx0NiAqIHQgKiAgcDIgKiAoMS10KSAtIDMgKiB0ICogdCAqIHAyICtcblx0XHRcdDMgKiB0ICogdCAqIHAzO1xuXHR9LFxuXG5cblx0dGFuZ2VudFNwbGluZTogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XG5cblx0XHR2YXIgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7IFx0Ly8gZGVyaXZlZCBmcm9tIDJ0XjMg4oiSIDN0XjIgKyAxXG5cdFx0dmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxuXHRcdHZhciBoMDEgPSAtNiAqIHQgKiB0ICsgNiAqIHQ7IFx0Ly8g4oiSIDJ0MyArIDN0MlxuXHRcdHZhciBoMTEgPSAzICogdCAqIHQgLSAyICogdDtcdC8vIHQzIOKIkiB0MlxuXG5cdFx0cmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcblxuXHR9LFxuXG5cdC8vIENhdG11bGwtUm9tXG5cblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgdCApIHtcblxuXHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xuXHRcdHZhciB2MSA9ICggcDMgLSBwMSApICogMC41O1xuXHRcdHZhciB0MiA9IHQgKiB0O1xuXHRcdHZhciB0MyA9IHQgKiB0Mjtcblx0XHRyZXR1cm4gKCAyICogcDEgLSAyICogcDIgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHR9XG5cbn07XG5cblxuLypcbmdldFBvaW50IERPTkVcbmdldExlbmd0aCBET05FXG5nZXRMZW5ndGhzIERPTkVcblxuY3VydmUuZ2V0UG9pbnRzKCk7IERPTkVcbmN1cnZlLmdldFBvaW50QXRBcmNMZW5ndGgodCk7IERPTkVcbmN1cnZlLnRyYW5zZm9ybShwYXJhbXMpO1xuY3VydmUuZ2V0VGFuZ2VudEF0KHQpOyBET05FXG4qL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHQzRCBDdXJ2ZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gQSBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbmV3IGN1cnZlIHN1YmNsYXNzZXNcblxuVEhSRUUuQ3VydmUuY3JlYXRlID0gZnVuY3Rpb24oIGNvbnN0cnVjdG9yLCBnZXRQb2ludEZ1bmMgKSB7XG5cbiAgICB2YXIgc3ViQ2xhc3MgPSBjb25zdHJ1Y3RvcjtcblxuXHRzdWJDbGFzcy5wcm90b3R5cGUgPSBuZXcgVEhSRUUuQ3VydmUoKTtcblxuXHRzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludEZ1bmM7XG5cblx0cmV0dXJuIHN1YkNsYXNzO1xuXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdExpbmUzRFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5MaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG5cdGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciByID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXG5cdFx0ci5zdWIoIHRoaXMudjIsIHRoaXMudjEgKTsgLy8gZGlmZlxuXHRcdHIubXVsdGlwbHlTY2FsYXIoIHQgKTtcblx0XHRyLmFkZFNlbGYoIHRoaXMudjEgKTtcblxuXHRcdHJldHVybiByO1xuXG5cdH1cblxuKTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XG5cblx0XHR0aGlzLnYwID0gdjA7XG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB0eCwgdHksIHR6O1xuXG5cdFx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuXHRcdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblx0XHR0eiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56ICk7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcblxuXHR9XG5cbik7XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdWJpYyBCZXppZXIgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXHRcdHRoaXMudjMgPSB2MztcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB0eCwgdHksIHR6O1xuXG5cdFx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG5cdFx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cdFx0dHogPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiwgdGhpcy52My56ICk7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcblxuXHR9XG5cbik7XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRTcGxpbmUgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5TcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0ZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLykge1xuXG5cdFx0dGhpcy5wb2ludHMgPSAocG9pbnRzID09IHVuZGVmaW5lZCkgPyBbXSA6IHBvaW50cztcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgYyA9IFtdO1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cywgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQ7XG5cdFx0cG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cblx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG5cdFx0Y1sgMSBdID0gaW50UG9pbnQ7XG5cdFx0Y1sgMiBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IGludFBvaW50IDogaW50UG9pbnQgKyAxO1xuXHRcdGNbIDMgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMjtcblxuXHRcdHYueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludHNbIGNbIDAgXSBdLngsIHBvaW50c1sgY1sgMSBdIF0ueCwgcG9pbnRzWyBjWyAyIF0gXS54LCBwb2ludHNbIGNbIDMgXSBdLngsIHdlaWdodCApO1xuXHRcdHYueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludHNbIGNbIDAgXSBdLnksIHBvaW50c1sgY1sgMSBdIF0ueSwgcG9pbnRzWyBjWyAyIF0gXS55LCBwb2ludHNbIGNbIDMgXSBdLnksIHdlaWdodCApO1xuXHRcdHYueiA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludHNbIGNbIDAgXSBdLnosIHBvaW50c1sgY1sgMSBdIF0ueiwgcG9pbnRzWyBjWyAyIF0gXS56LCBwb2ludHNbIGNbIDMgXSBdLnosIHdlaWdodCApO1xuXG5cdFx0cmV0dXJuIHY7XG5cblx0fVxuXG4pO1xuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICoqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZVBhdGggPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5jdXJ2ZXMgPSBbXTtcblx0dGhpcy5iZW5kcyA9IFtdO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlID0gbmV3IFRIUkVFLkN1cnZlKCk7XG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3VydmVQYXRoO1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggY3VydmUgKSB7XG5cblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblxufTtcblxuLy8gQWRkIGEgbGluZSBjdXJ2ZSAgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG4vLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cbi8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcbi8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblxuLy8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuLy8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXG4vLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG4vLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHR2YXIgaSA9IDAsIGRpZmYsIGN1cnZlO1xuXG5cdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG5cdHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XG5cblx0XHRpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XG5cblx0XHRcdGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XG5cdFx0XHRjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cblx0XHRcdHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcblxuXHRcdFx0cmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcblxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0aSArKztcblxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG5cblx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXG5cbn07XG5cbi8qXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcbn07Ki9cblxuXG4vLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXG4vLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcbi8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblxuXHR2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcblxufTtcblxuLy8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXG4vLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEN1cnZlTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuXHRpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XG5cblx0fTtcblxuXHQvLyBHZXQgbGVuZ3RoIG9mIHN1YnN1cnZlXG5cdC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxuXG5cdHZhciBsZW5ndGhzID0gW10sIHN1bXMgPSAwO1xuXHR2YXIgaSwgaWwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7XG5cblx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcblx0XHRsZW5ndGhzLnB1c2goIHN1bXMgKTtcblxuXHR9XG5cblx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG5cdHJldHVybiBsZW5ndGhzO1xuXG59O1xuXG5cblxuLy8gUmV0dXJucyBtaW4gYW5kIG1heCBjb29yZGluYXRlcywgYXMgd2VsbCBhcyBjZW50cm9pZFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xuXG5cdHZhciBtYXhYLCBtYXhZO1xuXHR2YXIgbWluWCwgbWluWTtcblxuXHRtYXhYID0gbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblx0bWluWCA9IG1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cblx0dmFyIHAsIGksIGlsLCBzdW07XG5cblx0c3VtID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRmb3IgKCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRwID0gcG9pbnRzWyBpIF07XG5cblx0XHRpZiAoIHAueCA+IG1heFggKSBtYXhYID0gcC54O1xuXHRcdGVsc2UgaWYgKCBwLnggPCBtaW5YICkgbWluWCA9IHAueDtcblxuXHRcdGlmICggcC55ID4gbWF4WSApIG1heFkgPSBwLnk7XG5cdFx0ZWxzZSBpZiAoIHAueSA8IG1heFkgKSBtaW5ZID0gcC55O1xuXG5cdFx0c3VtLmFkZFNlbGYoIHAueCwgcC55ICk7XG5cblx0fVxuXG5cdHJldHVybiB7XG5cblx0XHRtaW5YOiBtaW5YLFxuXHRcdG1pblk6IG1pblksXG5cdFx0bWF4WDogbWF4WCxcblx0XHRtYXhZOiBtYXhZLFxuXHRcdGNlbnRyb2lkOiBzdW0uZGl2aWRlU2NhbGFyKCBpbCApXG5cblx0fTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3JlYXRlIEdlb21ldHJpZXMgSGVscGVyc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUGFydGljbGVTeXN0ZW0gb2JqZWN0cylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgICB2YXIgcHRzID0gdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xuXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbn07XG5cbi8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbmNlIHNhbXBsaW5nIGFsb25nIHRoZSBwYXRoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG4gICAgdmFyIHB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBvaW50cyApIHtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSwgMCApICkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRCZW5kIC8gV3JhcCBIZWxwZXIgTWV0aG9kc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBXcmFwIHBhdGggLyBCZW5kIG1vZGlmaWVycz9cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGRXcmFwUGF0aCA9IGZ1bmN0aW9uICggYmVuZHBhdGggKSB7XG5cblx0dGhpcy5iZW5kcy5wdXNoKCBiZW5kcGF0aCApO1xuXG59O1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnRzID0gZnVuY3Rpb24oIHNlZ21lbnRzLCBiZW5kcyApIHtcblxuXHR2YXIgb2xkUHRzID0gdGhpcy5nZXRQb2ludHMoIHNlZ21lbnRzICk7IC8vIGdldFBvaW50cyBnZXRTcGFjZWRQb2ludHNcblx0dmFyIGksIGlsO1xuXG5cdGlmICggIWJlbmRzICkge1xuXG5cdFx0YmVuZHMgPSB0aGlzLmJlbmRzO1xuXG5cdH1cblxuXHRmb3IgKCBpID0gMCwgaWwgPSBiZW5kcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdG9sZFB0cyA9IHRoaXMuZ2V0V3JhcFBvaW50cyggb2xkUHRzLCBiZW5kc1sgaSBdICk7XG5cblx0fVxuXG5cdHJldHVybiBvbGRQdHM7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiggc2VnbWVudHMsIGJlbmRzICkge1xuXG5cdHZhciBvbGRQdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggc2VnbWVudHMgKTtcblxuXHR2YXIgaSwgaWw7XG5cblx0aWYgKCAhYmVuZHMgKSB7XG5cblx0XHRiZW5kcyA9IHRoaXMuYmVuZHM7XG5cblx0fVxuXG5cdGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0b2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gVGhpcyByZXR1cm5zIGdldFBvaW50cygpIGJlbmQvd3JhcHBlZCBhcm91bmQgdGhlIGNvbnRvdXIgb2YgYSBwYXRoLlxuLy8gUmVhZCBodHRwOi8vd3d3LnBsYW5ldGNsZWdnLmNvbS9wcm9qZWN0cy9XYXJwaW5nVGV4dFRvU3BsaW5lcy5odG1sXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0V3JhcFBvaW50cyA9IGZ1bmN0aW9uICggb2xkUHRzLCBwYXRoICkge1xuXG5cdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cblx0dmFyIGksIGlsLCBwLCBvbGRYLCBvbGRZLCB4Tm9ybTtcblxuXHRmb3IgKCBpID0gMCwgaWwgPSBvbGRQdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRwID0gb2xkUHRzWyBpIF07XG5cblx0XHRvbGRYID0gcC54O1xuXHRcdG9sZFkgPSBwLnk7XG5cblx0XHR2YXIgeE5vcm0gPSBvbGRYLyBib3VuZHMubWF4WDtcblxuXHRcdC8vIElmIHVzaW5nIGFjdHVhbCBkaXN0YW5jZSwgZm9yIGxlbmd0aCA+IHBhdGgsIHJlcXVpcmVzIGxpbmUgZXh0cnVzaW9uc1xuXHRcdC8veE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKHhOb3JtLCBvbGRYKTsgLy8gMyBzdHlsZXMuIDEpIHdyYXAgc3RyZXRjaGVkLiAyKSB3cmFwIHN0cmV0Y2ggYnkgYXJjIGxlbmd0aCAzKSB3YXJwIGJ5IGFjdHVhbCBkaXN0YW5jZVxuXG5cdFx0eE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKCB4Tm9ybSwgb2xkWCApO1xuXG5cdFx0Ly8gY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XG5cblx0XHR2YXIgcGF0aFB0ID0gcGF0aC5nZXRQb2ludCggeE5vcm0gKTtcblx0XHR2YXIgbm9ybWFsID0gcGF0aC5nZXROb3JtYWxWZWN0b3IoIHhOb3JtICkubXVsdGlwbHlTY2FsYXIoIG9sZFkgKTtcblxuXHRcdHAueCA9IHBhdGhQdC54ICsgbm9ybWFsLng7XG5cdFx0cC55ID0gcGF0aFB0LnkgKyBub3JtYWwueTtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBDcmVhdGVzIGZyZWUgZm9ybSAyZCBwYXRoIHVzaW5nIHNlcmllcyBvZiBwb2ludHMsIGxpbmVzIG9yIGN1cnZlcy5cbiAqXG4gKiovXG5cblRIUkVFLlBhdGggPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRUSFJFRS5DdXJ2ZVBhdGguY2FsbCh0aGlzKTtcblxuXHR0aGlzLmFjdGlvbnMgPSBbXTtcblxuXHRpZiAoIHBvaW50cyApIHtcblxuXHRcdHRoaXMuZnJvbVBvaW50cyggcG9pbnRzICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5DdXJ2ZVBhdGgoKTtcblRIUkVFLlBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGF0aDtcblxuXG5USFJFRS5QYXRoQWN0aW9ucyA9IHtcblxuXHRNT1ZFX1RPOiAnbW92ZVRvJyxcblx0TElORV9UTzogJ2xpbmVUbycsXG5cdFFVQURSQVRJQ19DVVJWRV9UTzogJ3F1YWRyYXRpY0N1cnZlVG8nLCAvLyBCZXppZXIgcXVhZHJhdGljIGN1cnZlXG5cdEJFWklFUl9DVVJWRV9UTzogJ2JlemllckN1cnZlVG8nLCBcdFx0Ly8gQmV6aWVyIGN1YmljIGN1cnZlXG5cdENTUExJTkVfVEhSVTogJ3NwbGluZVRocnUnLFx0XHRcdFx0Ly8gQ2F0bXVsbC1yb20gc3BsaW5lXG5cdEFSQzogJ2FyYydcdFx0XHRcdFx0XHRcdFx0Ly8gQ2lyY2xlXG5cbn07XG5cbi8vIFRPRE8gQ2xlYW4gdXAgUEFUSCBBUElcblxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXG4vLyAtIHZlY3RvcnM6IGFycmF5IG9mIFZlY3RvcjJcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHR0aGlzLm1vdmVUbyggdmVjdG9yc1sgMCBdLngsIHZlY3RvcnNbIDAgXS55ICk7XG5cblx0dmFyIHYsIHZsZW4gPSB2ZWN0b3JzLmxlbmd0aDtcblxuXHRmb3IgKCB2ID0gMTsgdiA8IHZsZW47IHYrKyApIHtcblxuXHRcdHRoaXMubGluZVRvKCB2ZWN0b3JzWyB2IF0ueCwgdmVjdG9yc1sgdiBdLnkgKTtcblxuXHR9O1xuXG59O1xuXG4vLyBzdGFydFBhdGgoKSBlbmRQYXRoKCk/XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkxpbmVDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLCBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApICk7XG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZICkgKTtcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiggYUNQMXgsIGFDUDF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ1AyeCwgYUNQMnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFYLCBhWSApIHtcblxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5DdWJpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZICkgKTtcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkJFWklFUl9DVVJWRV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnNwbGluZVRocnUgPSBmdW5jdGlvbiggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XG5cblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG4vLy0tLVxuXHR2YXIgbnB0cyA9IFsgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApIF07XG5cdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBucHRzLCBwdHMgKTtcblxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIG5wdHMgKTtcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVSwgYXJnczogYXJncyB9ICk7XG5cbn07XG5cbi8vIEZVVFVSRTogQ2hhbmdlIHRoZSBBUEkgb3IgZm9sbG93IGNhbnZhcyBBUEk/XG4vLyBUT0RPIEFSQyAoIHgsIHksIHggLSByYWRpdXMsIHkgLSByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIClcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkFyY0N1cnZlKCBhWCwgYVksIGFSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0Ly8gY29uc29sZS5sb2coICdhcmMnLCBhcmdzICk7XG5cblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5BUkMsIGFyZ3M6IGFyZ3MgfSApO1xuXG4gfTtcblxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuXHRpZiAoICFkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcblxuXHR2YXIgcG9pbnRzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpICsrICkge1xuXG5cdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0Ly9pZiggIXRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApIHRocm93IFwiRElFXCI7XG5cblx0fVxuXG5cdC8vIGlmICggY2xvc2VkUGF0aCApIHtcblx0Ly9cblx0Ly8gXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblx0Ly9cblx0Ly8gfVxuXG5cdHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8qIFJldHVybiBhbiBhcnJheSBvZiB2ZWN0b3JzIGJhc2VkIG9uIGNvbnRvdXIgb2YgdGhlIHBhdGggKi9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XG5cblx0dmFyIHBvaW50cyA9IFtdO1xuXG5cdHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xuXHR2YXIgY3B4LCBjcHksIGNweDIsIGNweTIsIGNweDEsIGNweTEsIGNweDAsIGNweTAsXG5cdFx0bGFzdGUsIGosXG5cdFx0dCwgdHgsIHR5O1xuXG5cdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcblxuXHRcdGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXHRcdGFyZ3MgPSBpdGVtLmFyZ3M7XG5cblx0XHRzd2l0Y2goIGFjdGlvbiApIHtcblxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpcblxuXHRcdFx0Ly8gcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOlxuXG5cdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpcblxuXHRcdFx0Y3B4ICA9IGFyZ3NbIDIgXTtcblx0XHRcdGNweSAgPSBhcmdzWyAzIF07XG5cblx0XHRcdGNweDEgPSBhcmdzWyAwIF07XG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xuXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0dCA9IGogLyBkaXZpc2lvbnM7XG5cblx0XHRcdFx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG5cdFx0XHRcdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdCAgXHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5CRVpJRVJfQ1VSVkVfVE86XG5cblx0XHRcdGNweCAgPSBhcmdzWyA0IF07XG5cdFx0XHRjcHkgID0gYXJnc1sgNSBdO1xuXG5cdFx0XHRjcHgxID0gYXJnc1sgMCBdO1xuXHRcdFx0Y3B5MSA9IGFyZ3NbIDEgXTtcblxuXHRcdFx0Y3B4MiA9IGFyZ3NbIDIgXTtcblx0XHRcdGNweTIgPSBhcmdzWyAzIF07XG5cblx0XHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0bGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XG5cdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cblx0XHRcdFx0Y3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG5cdFx0XHRcdGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0Zm9yICggaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdHQgPSBqIC8gZGl2aXNpb25zO1xuXG5cdFx0XHRcdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuXHRcdFx0XHR0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcblxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVTpcblxuXHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcblxuXHRcdFx0dmFyIGxhc3QgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXSwgbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXSApO1xuXHRcdFx0dmFyIHNwdHMgPSBbIGxhc3QgXTtcblxuXHRcdFx0dmFyIG4gPSBkaXZpc2lvbnMgKiBhcmdzWyAwIF0ubGVuZ3RoO1xuXG5cdFx0XHRzcHRzID0gc3B0cy5jb25jYXQoIGFyZ3NbIDAgXSApO1xuXG5cdFx0XHR2YXIgc3BsaW5lID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBzcHRzICk7XG5cblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IG47IGogKysgKSB7XG5cblx0XHRcdFx0cG9pbnRzLnB1c2goIHNwbGluZS5nZXRQb2ludEF0KCBqIC8gbiApICkgO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5BUkM6XG5cblx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cblx0XHRcdHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXG5cdFx0XHRcdGFSYWRpdXMgPSBhcmdzWyAyIF0sXG5cdFx0XHRcdGFTdGFydEFuZ2xlID0gYXJnc1sgMyBdLCBhRW5kQW5nbGUgPSBhcmdzWyA0IF0sXG5cdFx0XHRcdGFDbG9ja3dpc2UgPSAhIWFyZ3NbIDUgXTtcblxuXHRcdFx0dmFyIGxhc3R4ID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXSxcblx0XHRcdFx0bGFzdHkgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRpZiAoIGxhc3RlLmxlbmd0aCA9PSAwICkge1xuXG5cdFx0XHRcdGxhc3R4ID0gbGFzdHkgPSAwO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0dmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcblx0XHRcdHZhciBhbmdsZTtcblx0XHRcdHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcblx0XHRcdHZhciB0O1xuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdHQgPSBqIC8gdGRpdmlzaW9ucztcblxuXHRcdFx0XHRpZiAoICFhQ2xvY2t3aXNlICkge1xuXG5cdFx0XHRcdFx0dCA9IDEgLSB0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cblx0XHRcdFx0dHggPSBsYXN0eCArIGFYICsgYVJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHRcdFx0XHR0eSA9IGxhc3R5ICsgYVkgKyBhUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XG5cblx0XHQgIGJyZWFrO1xuXG5cdFx0fSAvLyBlbmQgc3dpdGNoXG5cblx0fVxuXG5cdGlmICggY2xvc2VkUGF0aCApIHtcblxuXHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG5cdH1cblxuXHRyZXR1cm4gcG9pbnRzO1xuXG59O1xuXG5cblxuLy8gVGhpcyB3YXMgdXNlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gU2hvdWxkIGJlIHJlbW92ZWQgc29vbi5cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oIHBhdGgsIHNlZ21lbnRzICkge1xuXG5cdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cdHZhciBvbGRQdHMgPSB0aGlzLmdldFBvaW50cyggc2VnbWVudHMgKTsgLy8gZ2V0UG9pbnRzIGdldFNwYWNlZFBvaW50c1xuXG5cdC8vY29uc29sZS5sb2coIHBhdGguY2FjaGVBcmNMZW5ndGhzKCkgKTtcblx0Ly9wYXRoLmdldExlbmd0aHMoNDAwKTtcblx0Ly9zZWdtZW50cyA9IDQwO1xuXG5cdHJldHVybiB0aGlzLmdldFdyYXBQb2ludHMoIG9sZFB0cywgcGF0aCApO1xuXG59O1xuXG4vLyBSZWFkIGh0dHA6Ly93d3cudGluYWphLmNvbS9nbGliL25vbmxpbmdyLnBkZlxuLy8gbm9ubGluZWFyIHRyYW5zZm9ybXNcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUubmx0cmFuc2Zvcm0gPSBmdW5jdGlvbiggYSwgYiwgYywgZCwgZSwgZiApIHtcblxuXHQvLyBhIC0gaG9yaXpvbnRhbCBzaXplXG5cdC8vIGIgLSBsZWFuXG5cdC8vIGMgLSB4IG9mZnNldFxuXHQvLyBkIC0gdmVydGljYWwgc2l6ZVxuXHQvLyBlIC0gY2xpbWJcblx0Ly8gZiAtIHkgb2Zmc2V0XG5cblx0dmFyIG9sZFB0cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XG5cblx0dmFyIGksIGlsLCBwLCBvbGRYLCBvbGRZO1xuXG5cdGZvciAoIGkgPSAwLCBpbCA9IG9sZFB0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdHAgPSBvbGRQdHNbaV07XG5cblx0XHRvbGRYID0gcC54O1xuXHRcdG9sZFkgPSBwLnk7XG5cblx0XHRwLnggPSBhICogb2xkWCArIGIgKiBvbGRZICsgYztcblx0XHRwLnkgPSBkICogb2xkWSArIGUgKiBvbGRYICsgZjtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuXG4vLyBGVVRVUkUgRXhwb3J0IEpTT04gRm9ybWF0XG5cbi8qIERyYXdzIHRoaXMgcGF0aCBvbnRvIGEgMmQgY2FudmFzIGVhc2lseSAqL1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uKCBjYW52YXMgKSB7XG5cblx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3goKTtcblxuXHRpZiAoICFjYW52YXMgKSB7XG5cblx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImNhbnZhc1wiICk7XG5cblx0XHRjYW52YXMuc2V0QXR0cmlidXRlKCAnd2lkdGgnLCAgYm91bmRzLm1heFggKyAxMDAgKTtcblx0XHRjYW52YXMuc2V0QXR0cmlidXRlKCAnaGVpZ2h0JywgYm91bmRzLm1heFkgKyAxMDAgKTtcblxuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGNhbnZhcyApO1xuXG5cdH1cblxuXHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoIFwiMmRcIiApO1xuXHRjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuXHRjdHguZmlsbFJlY3QoIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG5cdGN0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcblx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xuXG5cdC8vIERlYnVnIFBhdGhcblxuXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRpdGVtID0gdGhpcy5hY3Rpb25zWyBpIF07XG5cblx0XHRhcmdzID0gaXRlbS5hcmdzO1xuXHRcdGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXG5cdFx0Ly8gU2hvcnQgaGFuZCBmb3Igbm93XG5cblx0XHRpZiAoIGFjdGlvbiAhPSBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlUgKSB7XG5cblx0XHRcdGN0eFsgYWN0aW9uIF0uYXBwbHkoIGN0eCwgYXJncyApO1xuXG5cdFx0fVxuXG5cdFx0Lypcblx0XHRzd2l0Y2ggKCBhY3Rpb24gKSB7XG5cblx0XHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpcblxuXHRcdFx0XHRjdHhbIGFjdGlvbiBdKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOlxuXG5cdFx0XHRcdGN0eFsgYWN0aW9uIF0oIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpcblxuXHRcdFx0XHRjdHhbIGFjdGlvbiBdKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSwgYXJnc1sgMiBdLCBhcmdzWyAzIF0gKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQ1VCSUNfQ1VSVkVfVE86XG5cblx0XHRcdFx0Y3R4WyBhY3Rpb24gXSggYXJnc1sgMCBdLCBhcmdzWyAxIF0sIGFyZ3NbIDIgXSwgYXJnc1sgMyBdLCBhcmdzWyA0IF0sIGFyZ3NbIDUgXSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblx0XHQqL1xuXG5cdH1cblxuXHRjdHguc3Ryb2tlKCk7XG5cdGN0eC5jbG9zZVBhdGgoKTtcblxuXHQvLyBEZWJ1ZyBQb2ludHNcblxuXHRjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuXG5cdC8qIFRPIENMRUFOIFVQICovXG5cblx0dmFyIHAsIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XG5cblx0Ly92YXIgdGhldGEgPSAtOTAgLzE4MCAqIE1hdGguUEk7XG5cdC8vdmFyIHAsIHBvaW50cyA9IHRoaXMudHJhbnNmb3JtKCAwLjg2NiwgLSAwLjg2NiwwLCAwLjUwMCAsIDAuNTAsLTUwICk7XG5cblx0Ly8wLjg2NiwgLSAwLjg2NiwwLCAwLjUwMCAsIDAuNTAsLTUwXG5cblx0Ly8gTWF0aC5jb3ModGhldGEpLE1hdGguc2luKHRoZXRhKSwxMDAsXG5cdC8vIE1hdGguY29zKHRoZXRhKSwtTWF0aC5zaW4odGhldGEpLC01MFxuXG5cdC8vIHRyYW5zbGF0ZSwgc2NhbGUsIHJvdGF0aW9uXG5cblxuXHRmb3IgKCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRwID0gcG9pbnRzWyBpIF07XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyggcC54LCBwLnksIDEuNSwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlICk7XG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblxuXHR9XG5cbn07XG5cbi8vIEJyZWFrcyBwYXRoIGludG8gc2hhcGVzXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnRvU2hhcGVzID0gZnVuY3Rpb24oKSB7XG5cblx0dmFyIGksIGlsLCBpdGVtLCBhY3Rpb24sIGFyZ3M7XG5cblx0dmFyIHN1YlBhdGhzID0gW10sIGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcblxuXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRpdGVtID0gdGhpcy5hY3Rpb25zWyBpIF07XG5cblx0XHRhcmdzID0gaXRlbS5hcmdzO1xuXHRcdGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXG5cdFx0aWYgKCBhY3Rpb24gPT0gVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTyApIHtcblxuXHRcdFx0aWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPSAwICkge1xuXG5cdFx0XHRcdHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG5cdFx0XHRcdGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xuXG5cdH1cblxuXHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9IDAgKSB7XG5cblx0XHRzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xuXG5cdH1cblxuXHQvL2NvbnNvbGUubG9nKHN1YlBhdGhzKTtcblxuXHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PSAwICkgcmV0dXJuIFtdO1xuXG5cdHZhciBob2xlc0ZpcnN0ID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XG5cblx0dmFyIHRtcFBhdGgsIHRtcFNoYXBlLCBzaGFwZXMgPSBbXTtcblxuXHQvL2NvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cblx0aWYgKCBob2xlc0ZpcnN0ICkge1xuXG5cdFx0dG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcblxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdG1wUGF0aC5nZXRQb2ludHMoKSApICkge1xuXG5cdFx0XHRcdHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG5cdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG5cdFx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXHRcdFx0XHR0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wUGF0aCApO1xuXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2NjdycsIGkpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNoYXBlcyBmaXJzdFxuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xuXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB0bXBQYXRoLmdldFBvaW50cygpICkgKSB7XG5cblxuXHRcdFx0XHRpZiAoIHRtcFNoYXBlICkgc2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cblx0XHRcdFx0dG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcblx0XHRcdFx0dG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcblx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wUGF0aCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblxuXHR9XG5cblx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0cmV0dXJuIHNoYXBlcztcblxufTtcbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogRGVmaW5lcyBhIDJkIHNoYXBlIHBsYW5lIHVzaW5nIHBhdGhzLlxuICoqL1xuXG4vLyBTVEVQIDEgQ3JlYXRlIGEgcGF0aC5cbi8vIFNURVAgMiBUdXJuIHBhdGggaW50byBzaGFwZS5cbi8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXG4vLyBTVEVQIDNhIC0gRXh0cmFjdCBwb2ludHMgZnJvbSBlYWNoIHNoYXBlLCB0dXJuIHRvIHZlcnRpY2VzXG4vLyBTVEVQIDNiIC0gVHJpYW5ndWxhdGUgZWFjaCBzaGFwZSwgYWRkIGZhY2VzLlxuXG5USFJFRS5TaGFwZSA9IGZ1bmN0aW9uICggKSB7XG5cblx0VEhSRUUuUGF0aC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdHRoaXMuaG9sZXMgPSBbXTtcblxufTtcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlID0gbmV3IFRIUkVFLlBhdGgoKTtcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhdGg7XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gRXh0cnVkZUdlb21ldHJ5XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXG5cdHZhciBleHRydWRlZCA9IG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcblx0cmV0dXJuIGV4dHJ1ZGVkO1xuXG59O1xuXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLCBob2xlc1B0cyA9IFtdO1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFRyYW5zZm9ybWVkUG9pbnRzKCBkaXZpc2lvbnMsIHRoaXMuYmVuZHMgKTtcblxuXHR9XG5cblx0cmV0dXJuIGhvbGVzUHRzO1xuXG59O1xuXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzIChzcGFjZWQgYnkgcmVndWxhciBkaXN0YW5jZSlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0dmFyIGksIGlsID0gdGhpcy5ob2xlcy5sZW5ndGgsIGhvbGVzUHRzID0gW107XG5cblx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xuXG5cdH1cblxuXHRyZXR1cm4gaG9sZXNQdHM7XG5cbn07XG5cblxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0cmV0dXJuIHtcblxuXHRcdHNoYXBlOiB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCBkaXZpc2lvbnMgKSxcblx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuXHR9O1xuXG59O1xuXG4vL1xuLy8gVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHNXaXRoQmVuZCA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBiZW5kICkge1xuLy9cbi8vIFx0cmV0dXJuIHtcbi8vXG4vLyBcdFx0c2hhcGU6IHRoaXMudHJhbnNmb3JtKCBiZW5kLCBkaXZpc2lvbnMgKSxcbi8vIFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zLCBiZW5kIClcbi8vXG4vLyBcdH07XG4vL1xuLy8gfTtcblxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdHJldHVybiB7XG5cblx0XHRzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zICksXG5cdFx0aG9sZXM6IHRoaXMuZ2V0U3BhY2VkUG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cblx0fTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0VXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuU2hhcGUuVXRpbHMgPSB7XG5cblx0Lypcblx0XHRjb250b3VyIC0gYXJyYXkgb2YgdmVjdG9yMiBmb3IgY29udG91clxuXHRcdGhvbGVzICAgLSBhcnJheSBvZiBhcnJheSBvZiB2ZWN0b3IyXG5cdCovXG5cblx0cmVtb3ZlSG9sZXM6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XG5cblx0XHR2YXIgc2hhcGUgPSBjb250b3VyLmNvbmNhdCgpOyAvLyB3b3JrIG9uIHRoaXMgc2hhcGVcblx0XHR2YXIgYWxscG9pbnRzID0gc2hhcGUuY29uY2F0KCk7XG5cblx0XHQvKiBGb3IgZWFjaCBpc29sYXRlZCBzaGFwZSwgZmluZCB0aGUgY2xvc2VzdCBwb2ludHMgYW5kIGJyZWFrIHRvIHRoZSBob2xlIHRvIGFsbG93IHRyaWFuZ3VsYXRpb24gKi9cblxuXG5cdFx0dmFyIHByZXZTaGFwZVZlcnQsIG5leHRTaGFwZVZlcnQsXG5cdFx0XHRwcmV2SG9sZVZlcnQsIG5leHRIb2xlVmVydCxcblx0XHRcdGhvbGVJbmRleCwgc2hhcGVJbmRleCxcblx0XHRcdHNoYXBlSWQsIHNoYXBlR3JvdXAsXG5cdFx0XHRoLCBoMixcblx0XHRcdGhvbGUsIHNob3J0ZXN0LCBkLFxuXHRcdFx0cCwgcHRzMSwgcHRzMixcblx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxuXHRcdFx0dG1wSG9sZTEsIHRtcEhvbGUyLFxuXHRcdFx0dmVydHMgPSBbXTtcblxuXHRcdGZvciAoIGggPSAwOyBoIDwgaG9sZXMubGVuZ3RoOyBoICsrICkge1xuXG5cdFx0XHRob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdFx0Lypcblx0XHRcdHNoYXBlaG9sZXNbIGggXS5jb25jYXQoKTsgLy8gcHJlc2VydmVzIG9yaWdpbmFsXG5cdFx0XHRob2xlcy5wdXNoKCBob2xlICk7XG5cdFx0XHQqL1xuXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlICk7XG5cblx0XHRcdHNob3J0ZXN0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cblx0XHRcdC8vIEZpbmQgdGhlIHNob3J0ZXN0IHBhaXIgb2YgcHRzIGJldHdlZW4gc2hhcGUgYW5kIGhvbGVcblxuXHRcdFx0Ly8gTm90ZTogQWN0dWFsbHksIEknbSBub3Qgc3VyZSBub3cgaWYgd2UgY291bGQgb3B0aW1pemUgdGhpcyB0byBiZSBmYXN0ZXIgdGhhbiBPKG0qbilcblx0XHRcdC8vIFVzaW5nIGRpc3RhbmNlVG9TcXVhcmVkKCkgaW50ZWFkIG9mIGRpc3RhbmNlVG8oKSBzaG91bGQgc3BlZWQgYSBsaXR0bGVcblx0XHRcdC8vIHNpbmNlIHJ1bm5pbmcgc3F1YXJlIHJvb3RzIG9wZXJhdGlvbnMgYXJlIHJlZHVjZWQuXG5cblx0XHRcdGZvciAoIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIgKysgKSB7XG5cblx0XHRcdFx0cHRzMSA9IGhvbGVbIGgyIF07XG5cdFx0XHRcdHZhciBkaXN0ID0gW107XG5cblx0XHRcdFx0Zm9yICggcCA9IDA7IHAgPCBzaGFwZS5sZW5ndGg7IHArKyApIHtcblxuXHRcdFx0XHRcdHB0czIgPSBzaGFwZVsgcCBdO1xuXHRcdFx0XHRcdGQgPSBwdHMxLmRpc3RhbmNlVG9TcXVhcmVkKCBwdHMyICk7XG5cdFx0XHRcdFx0ZGlzdC5wdXNoKCBkICk7XG5cblx0XHRcdFx0XHRpZiAoIGQgPCBzaG9ydGVzdCApIHtcblxuXHRcdFx0XHRcdFx0c2hvcnRlc3QgPSBkO1xuXHRcdFx0XHRcdFx0aG9sZUluZGV4ID0gaDI7XG5cdFx0XHRcdFx0XHRzaGFwZUluZGV4ID0gcDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9jb25zb2xlLmxvZyhcInNob3J0ZXN0XCIsIHNob3J0ZXN0LCBkaXN0KTtcblxuXHRcdFx0cHJldlNoYXBlVmVydCA9ICggc2hhcGVJbmRleCAtIDEgKSA+PSAwID8gc2hhcGVJbmRleCAtIDEgOiBzaGFwZS5sZW5ndGggLSAxO1xuXHRcdFx0cHJldkhvbGVWZXJ0ID0gKCBob2xlSW5kZXggLSAxICkgPj0gMCA/IGhvbGVJbmRleCAtIDEgOiBob2xlLmxlbmd0aCAtIDE7XG5cblx0XHRcdHZhciBhcmVhYXB0cyA9IFtcblxuXHRcdFx0XHRob2xlWyBob2xlSW5kZXggXSxcblx0XHRcdFx0c2hhcGVbIHNoYXBlSW5kZXggXSxcblx0XHRcdFx0c2hhcGVbIHByZXZTaGFwZVZlcnQgXVxuXG5cdFx0XHRdO1xuXG5cdFx0XHR2YXIgYXJlYWEgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggYXJlYWFwdHMgKTtcblxuXHRcdFx0dmFyIGFyZWFicHRzID0gW1xuXG5cdFx0XHRcdGhvbGVbIGhvbGVJbmRleCBdLFxuXHRcdFx0XHRob2xlWyBwcmV2SG9sZVZlcnQgXSxcblx0XHRcdFx0c2hhcGVbIHNoYXBlSW5kZXggXVxuXG5cdFx0XHRdO1xuXG5cdFx0XHR2YXIgYXJlYWIgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggYXJlYWJwdHMgKTtcblxuXHRcdFx0dmFyIHNoYXBlT2Zmc2V0ID0gMTtcblx0XHRcdHZhciBob2xlT2Zmc2V0ID0gLTE7XG5cblx0XHRcdHZhciBvbGRTaGFwZUluZGV4ID0gc2hhcGVJbmRleCwgb2xkSG9sZUluZGV4ID0gaG9sZUluZGV4O1xuXHRcdFx0c2hhcGVJbmRleCArPSBzaGFwZU9mZnNldDtcblx0XHRcdGhvbGVJbmRleCArPSBob2xlT2Zmc2V0O1xuXG5cdFx0XHRpZiAoIHNoYXBlSW5kZXggPCAwICkgeyBzaGFwZUluZGV4ICs9IHNoYXBlLmxlbmd0aDsgIH1cblx0XHRcdHNoYXBlSW5kZXggJT0gc2hhcGUubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIGhvbGVJbmRleCA8IDAgKSB7IGhvbGVJbmRleCArPSBob2xlLmxlbmd0aDsgIH1cblx0XHRcdGhvbGVJbmRleCAlPSBob2xlLmxlbmd0aDtcblxuXHRcdFx0cHJldlNoYXBlVmVydCA9ICggc2hhcGVJbmRleCAtIDEgKSA+PSAwID8gc2hhcGVJbmRleCAtIDEgOiBzaGFwZS5sZW5ndGggLSAxO1xuXHRcdFx0cHJldkhvbGVWZXJ0ID0gKCBob2xlSW5kZXggLSAxICkgPj0gMCA/IGhvbGVJbmRleCAtIDEgOiBob2xlLmxlbmd0aCAtIDE7XG5cblx0XHRcdGFyZWFhcHRzID0gW1xuXG5cdFx0XHRcdGhvbGVbIGhvbGVJbmRleCBdLFxuXHRcdFx0XHRzaGFwZVsgc2hhcGVJbmRleCBdLFxuXHRcdFx0XHRzaGFwZVsgcHJldlNoYXBlVmVydCBdXG5cblx0XHRcdF07XG5cblx0XHRcdHZhciBhcmVhYTIgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggYXJlYWFwdHMgKTtcblxuXHRcdFx0YXJlYWJwdHMgPSBbXG5cblx0XHRcdFx0aG9sZVsgaG9sZUluZGV4IF0sXG5cdFx0XHRcdGhvbGVbIHByZXZIb2xlVmVydCBdLFxuXHRcdFx0XHRzaGFwZVsgc2hhcGVJbmRleCBdXG5cblx0XHRcdF07XG5cblx0XHRcdHZhciBhcmVhYjIgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggYXJlYWJwdHMgKTtcblx0XHRcdC8vY29uc29sZS5sb2coYXJlYWEsYXJlYWIgLGFyZWFhMixhcmVhYjIsICggYXJlYWEgKyBhcmVhYiApLCAgKCBhcmVhYTIgKyBhcmVhYjIgKSk7XG5cblx0XHRcdGlmICggKCBhcmVhYSArIGFyZWFiICkgPiAoIGFyZWFhMiArIGFyZWFiMiApICkge1xuXG5cdFx0XHRcdC8vIEluIGNhc2UgYXJlYXMgYXJlIG5vdCBjb3JyZWN0LlxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiVVNFIFRISVNcIik7XG5cblx0XHRcdFx0c2hhcGVJbmRleCA9IG9sZFNoYXBlSW5kZXg7XG5cdFx0XHRcdGhvbGVJbmRleCA9IG9sZEhvbGVJbmRleCA7XG5cblx0XHRcdFx0aWYgKCBzaGFwZUluZGV4IDwgMCApIHsgc2hhcGVJbmRleCArPSBzaGFwZS5sZW5ndGg7ICB9XG5cdFx0XHRcdHNoYXBlSW5kZXggJT0gc2hhcGUubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaG9sZUluZGV4IDwgMCApIHsgaG9sZUluZGV4ICs9IGhvbGUubGVuZ3RoOyAgfVxuXHRcdFx0XHRob2xlSW5kZXggJT0gaG9sZS5sZW5ndGg7XG5cblx0XHRcdFx0cHJldlNoYXBlVmVydCA9ICggc2hhcGVJbmRleCAtIDEgKSA+PSAwID8gc2hhcGVJbmRleCAtIDEgOiBzaGFwZS5sZW5ndGggLSAxO1xuXHRcdFx0XHRwcmV2SG9sZVZlcnQgPSAoIGhvbGVJbmRleCAtIDEgKSA+PSAwID8gaG9sZUluZGV4IC0gMSA6IGhvbGUubGVuZ3RoIC0gMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiVVNFIFRIQVQgXCIpXG5cblx0XHRcdH1cblxuXHRcdFx0dG1wU2hhcGUxID0gc2hhcGUuc2xpY2UoIDAsIHNoYXBlSW5kZXggKTtcblx0XHRcdHRtcFNoYXBlMiA9IHNoYXBlLnNsaWNlKCBzaGFwZUluZGV4ICk7XG5cdFx0XHR0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xuXHRcdFx0dG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXggKTtcblxuXHRcdFx0Ly8gU2hvdWxkIGNoZWNrIG9yZGVycyBoZXJlIGFnYWluP1xuXG5cdFx0XHR2YXIgdHJpYW5nbGVhID0gW1xuXG5cdFx0XHRcdGhvbGVbIGhvbGVJbmRleCBdLFxuXHRcdFx0XHRzaGFwZVsgc2hhcGVJbmRleCBdLFxuXHRcdFx0XHRzaGFwZVsgcHJldlNoYXBlVmVydCBdXG5cblx0XHRcdF07XG5cblx0XHRcdHZhciB0cmlhbmdsZWIgPSBbXG5cblx0XHRcdFx0aG9sZVsgaG9sZUluZGV4IF0gLFxuXHRcdFx0XHRob2xlWyBwcmV2SG9sZVZlcnQgXSxcblx0XHRcdFx0c2hhcGVbIHNoYXBlSW5kZXggXVxuXG5cdFx0XHRdO1xuXG5cdFx0XHR2ZXJ0cy5wdXNoKCB0cmlhbmdsZWEgKTtcblx0XHRcdHZlcnRzLnB1c2goIHRyaWFuZ2xlYiApO1xuXG5cdFx0XHRzaGFwZSA9IHRtcFNoYXBlMS5jb25jYXQoIHRtcEhvbGUxICkuY29uY2F0KCB0bXBIb2xlMiApLmNvbmNhdCggdG1wU2hhcGUyICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRzaGFwZTpzaGFwZSwgXHRcdC8qIHNoYXBlIHdpdGggbm8gaG9sZXMgKi9cblx0XHRcdGlzb2xhdGVkUHRzOiB2ZXJ0cywgLyogaXNvbGF0ZWQgZmFjZXMgKi9cblx0XHRcdGFsbHBvaW50czogYWxscG9pbnRzXG5cblx0XHR9XG5cblxuXHR9LFxuXG5cdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XG5cblx0XHR2YXIgc2hhcGVXaXRob3V0SG9sZXMgPSBUSFJFRS5TaGFwZS5VdGlscy5yZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKTtcblxuXHRcdHZhciBzaGFwZSA9IHNoYXBlV2l0aG91dEhvbGVzLnNoYXBlLFxuXHRcdFx0YWxscG9pbnRzID0gc2hhcGVXaXRob3V0SG9sZXMuYWxscG9pbnRzLFxuXHRcdFx0aXNvbGF0ZWRQdHMgPSBzaGFwZVdpdGhvdXRIb2xlcy5pc29sYXRlZFB0cztcblxuXHRcdHZhciB0cmlhbmdsZXMgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUoIHNoYXBlLCBmYWxzZSApOyAvLyBUcnVlIHJldHVybnMgaW5kaWNlcyBmb3IgcG9pbnRzIG9mIHNwb29sZWQgc2hhcGVcblxuXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cblxuXHRcdC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XG5cdFx0Ly9jb25zb2xlLmxvZyggXCJhbGxwb2ludHNcIixhbGxwb2ludHMsIGFsbHBvaW50cy5sZW5ndGggKTtcblxuXHRcdHZhciBpLCBpbCwgZiwgZmFjZSxcblx0XHRcdGtleSwgaW5kZXgsXG5cdFx0XHRhbGxQb2ludHNNYXAgPSB7fSxcblx0XHRcdGlzb2xhdGVkUG9pbnRzTWFwID0ge307XG5cblx0XHQvLyBwcmVwYXJlIGFsbCBwb2ludHMgbWFwXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBhbGxwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XG5cblx0XHRcdGlmICggYWxsUG9pbnRzTWFwWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCBcIkR1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhbGxQb2ludHNNYXBbIGtleSBdID0gaTtcblxuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGFsbCBmYWNlIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRyaWFuZ2xlc1sgaSBdO1xuXG5cdFx0XHRmb3IgKCBmID0gMDsgZiA8IDM7IGYgKysgKSB7XG5cblx0XHRcdFx0a2V5ID0gZmFjZVsgZiBdLnggKyBcIjpcIiArIGZhY2VbIGYgXS55O1xuXG5cdFx0XHRcdGluZGV4ID0gYWxsUG9pbnRzTWFwWyBrZXkgXTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRmYWNlWyBmIF0gPSBpbmRleDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGlzb2xhdGVkIHBvaW50cyB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBpc29sYXRlZFB0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0ZmFjZSA9IGlzb2xhdGVkUHRzWyBpIF07XG5cblx0XHRcdGZvciAoIGYgPSAwOyBmIDwgMzsgZiArKyApIHtcblxuXHRcdFx0XHRrZXkgPSBmYWNlWyBmIF0ueCArIFwiOlwiICsgZmFjZVsgZiBdLnk7XG5cblx0XHRcdFx0aW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xuXG5cdFx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGZhY2VbIGYgXSA9IGluZGV4O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoIGlzb2xhdGVkUHRzICk7XG5cblx0fSwgLy8gZW5kIHRyaWFuZ3VsYXRlIHNoYXBlc1xuXG5cdC8qXG5cdHRyaWFuZ3VsYXRlMiA6IGZ1bmN0aW9uKCBwdHMsIGhvbGVzICkge1xuXG5cdFx0Ly8gRm9yIHVzZSB3aXRoIFBvbHkyVHJpLmpzXG5cblx0XHR2YXIgYWxscHRzID0gcHRzLmNvbmNhdCgpO1xuXHRcdHZhciBzaGFwZSA9IFtdO1xuXHRcdGZvciAodmFyIHAgaW4gcHRzKSB7XG5cdFx0XHRzaGFwZS5wdXNoKG5ldyBqcy5wb2x5MnRyaS5Qb2ludChwdHNbcF0ueCwgcHRzW3BdLnkpKTtcblx0XHR9XG5cblx0XHR2YXIgc3djdHggPSBuZXcganMucG9seTJ0cmkuU3dlZXBDb250ZXh0KHNoYXBlKTtcblxuXHRcdGZvciAodmFyIGggaW4gaG9sZXMpIHtcblx0XHRcdHZhciBhSG9sZSA9IGhvbGVzW2hdO1xuXHRcdFx0dmFyIG5ld0hvbGUgPSBbXVxuXHRcdFx0Zm9yIChpIGluIGFIb2xlKSB7XG5cdFx0XHRcdG5ld0hvbGUucHVzaChuZXcganMucG9seTJ0cmkuUG9pbnQoYUhvbGVbaV0ueCwgYUhvbGVbaV0ueSkpO1xuXHRcdFx0XHRhbGxwdHMucHVzaChhSG9sZVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRzd2N0eC5BZGRIb2xlKG5ld0hvbGUpO1xuXHRcdH1cblxuXHRcdHZhciBmaW5kO1xuXHRcdHZhciBmaW5kSW5kZXhGb3JQdCA9IGZ1bmN0aW9uIChwdCkge1xuXHRcdFx0ZmluZCA9IG5ldyBUSFJFRS5WZWN0b3IyKHB0LngsIHB0LnkpO1xuXHRcdFx0dmFyIHA7XG5cdFx0XHRmb3IgKHA9MCwgcGwgPSBhbGxwdHMubGVuZ3RoOyBwPHBsOyBwKyspIHtcblx0XHRcdFx0aWYgKGFsbHB0c1twXS5lcXVhbHMoZmluZCkpIHJldHVybiBwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cblx0XHQvLyB0cmlhbmd1bGF0ZVxuXHRcdGpzLnBvbHkydHJpLnN3ZWVwLlRyaWFuZ3VsYXRlKHN3Y3R4KTtcblxuXHRcdHZhciB0cmlhbmdsZXMgPSAgc3djdHguR2V0VHJpYW5nbGVzKCk7XG5cdFx0dmFyIHRyIDtcblx0XHR2YXIgZmFjZXNQdHMgPSBbXTtcblx0XHRmb3IgKHZhciB0IGluIHRyaWFuZ2xlcykge1xuXHRcdFx0dHIgPSAgdHJpYW5nbGVzW3RdO1xuXHRcdFx0ZmFjZXNQdHMucHVzaChbXG5cdFx0XHRcdGZpbmRJbmRleEZvclB0KHRyLkdldFBvaW50KDApKSxcblx0XHRcdFx0ZmluZEluZGV4Rm9yUHQodHIuR2V0UG9pbnQoMSkpLFxuXHRcdFx0XHRmaW5kSW5kZXhGb3JQdCh0ci5HZXRQb2ludCgyKSlcblx0XHRcdFx0XHRdKTtcblx0XHR9XG5cblxuXHQvL1x0Y29uc29sZS5sb2coZmFjZXNQdHMpO1xuXHQvL1x0Y29uc29sZS5sb2coXCJ0cmlhbmdsZXNcIiwgdHJpYW5nbGVzLmxlbmd0aCwgdHJpYW5nbGVzKTtcblxuXHRcdC8vIFJldHVybnMgYXJyYXkgb2YgZmFjZXMgd2l0aCAzIGVsZW1lbnQgZWFjaFxuXHRyZXR1cm4gZmFjZXNQdHM7XG5cdH0sXG4qL1xuXG5cdGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcblxuXHRcdHJldHVybiBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggcHRzICkgPCAwO1xuXG5cdH0sXG5cblx0Ly8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcblxuXHQvLyBRdWFkIEJlemllciBGdW5jdGlvbnNcblxuXHRiMnAwOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cblx0XHR2YXIgayA9IDEgLSB0O1xuXHRcdHJldHVybiBrICogayAqIHA7XG5cblx0fSxcblxuXHRiMnAxOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cblx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xuXG5cdH0sXG5cblx0YjJwMjogZnVuY3Rpb24gKCB0LCBwICkge1xuXG5cdFx0cmV0dXJuIHQgKiB0ICogcDtcblxuXHR9LFxuXG5cdGIyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5iMnAwKCB0LCBwMCApICsgdGhpcy5iMnAxKCB0LCBwMSApICsgdGhpcy5iMnAyKCB0LCBwMiApO1xuXG5cdH0sXG5cblx0Ly8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xuXG5cdGIzcDA6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuXHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIGsgKiBrICogayAqIHA7XG5cblx0fSxcblxuXHRiM3AxOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cblx0XHR2YXIgayA9IDEgLSB0O1xuXHRcdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxuXHR9LFxuXG5cdGIzcDI6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuXHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xuXG5cdH0sXG5cblx0YjNwMzogZnVuY3Rpb24gKCB0LCBwICkge1xuXG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cblx0fSxcblxuXHRiMzogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdHJldHVybiB0aGlzLmIzcDAoIHQsIHAwICkgKyB0aGlzLmIzcDEoIHQsIHAxICkgKyB0aGlzLmIzcDIoIHQsIHAyICkgKyAgdGhpcy5iM3AzKCB0LCBwMyApO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICogVGV4dFBhdGhcbiAqXG4gKiovXG5cblRIUkVFLlRleHRQYXRoID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLlBhdGguY2FsbCggdGhpcyApO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0dGhpcy5zZXQoIHRleHQgKTtcblxufTtcblxuVEhSRUUuVGV4dFBhdGgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuXHR0aGlzLnRleHQgPSB0ZXh0O1xuXG5cdHZhciBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB0aGlzLnBhcmFtZXRlcnM7XG5cblx0dmFyIHNpemUgPSBwYXJhbWV0ZXJzLnNpemUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc2l6ZSA6IDEwMDtcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50czogNDtcblxuXHR2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5mb250IDogXCJoZWx2ZXRpa2VyXCI7XG5cdHZhciB3ZWlnaHQgPSBwYXJhbWV0ZXJzLndlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53ZWlnaHQgOiBcIm5vcm1hbFwiO1xuXHR2YXIgc3R5bGUgPSBwYXJhbWV0ZXJzLnN0eWxlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0eWxlIDogXCJub3JtYWxcIjtcblxuXHRUSFJFRS5Gb250VXRpbHMuc2l6ZSA9IHNpemU7XG5cdFRIUkVFLkZvbnRVdGlscy5kaXZpc2lvbnMgPSBjdXJ2ZVNlZ21lbnRzO1xuXG5cdFRIUkVFLkZvbnRVdGlscy5mYWNlID0gZm9udDtcblx0VEhSRUUuRm9udFV0aWxzLndlaWdodCA9IHdlaWdodDtcblx0VEhSRUUuRm9udFV0aWxzLnN0eWxlID0gc3R5bGU7XG5cbn07XG5cblxuXG5USFJFRS5UZXh0UGF0aC5wcm90b3R5cGUudG9TaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0Ly8gR2V0IGEgRm9udCBkYXRhIGpzb24gb2JqZWN0XG5cblx0dmFyIGRhdGEgPSBUSFJFRS5Gb250VXRpbHMuZHJhd1RleHQoIHRoaXMudGV4dCApO1xuXG5cdHZhciBwYXRocyA9IGRhdGEucGF0aHM7XG5cdHZhciBzaGFwZXMgPSBbXTtcblxuXHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggc2hhcGVzLCBwYXRoc1sgcCBdLnRvU2hhcGVzKCkgKTtcblxuXHR9XG5cblx0cmV0dXJuIHNoYXBlcztcblxuXHQvL2NvbnNvbGUubG9nKHBhdGgpO1xuXHQvL2NvbnNvbGUubG9nKGZvbnRTaGFwZXMpO1xuXG5cdC8vIEVpdGhlciBmaW5kIGFjdGlvbnMgb3IgY3VydmVzLlxuXG5cdC8vdmFyIHRleHQzZCA9IG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkoIHNoYXBlcyAsIHsgYW1vdW50OiAyMCwgYmV2ZWxFbmFibGVkOnRydWUsIGJldmVsVGhpY2tuZXNzOjNcdH0gKTtcblxuXHQvL3JldHVybiB0ZXh0M2Q7XG5cbn07XG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKi9cblxuVEhSRUUuQW5pbWF0aW9uSGFuZGxlciA9IChmdW5jdGlvbigpIHtcblxuXHR2YXIgcGxheWluZyA9IFtdO1xuXHR2YXIgbGlicmFyeSA9IHt9O1xuXHR2YXIgdGhhdCAgICA9IHt9O1xuXG5cblx0Ly8tLS0gdXBkYXRlIC0tLVxuXG5cdHRoYXQudXBkYXRlID0gZnVuY3Rpb24oIGRlbHRhVGltZU1TICkge1xuXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBwbGF5aW5nLmxlbmd0aDsgaSsrIClcblx0XHRcdHBsYXlpbmdbIGkgXS51cGRhdGUoIGRlbHRhVGltZU1TICk7XG5cblx0fTtcblxuXG5cdC8vLS0tIGFkZCAtLS1cblxuXHR0aGF0LmFkZFRvVXBkYXRlID0gZnVuY3Rpb24oIGFuaW1hdGlvbiApIHtcblxuXHRcdGlmKCBwbGF5aW5nLmluZGV4T2YoIGFuaW1hdGlvbiApID09PSAtMSApXG5cdFx0XHRwbGF5aW5nLnB1c2goIGFuaW1hdGlvbiApO1xuXG5cdH07XG5cblxuXHQvLy0tLSByZW1vdmUgLS0tXG5cblx0dGhhdC5yZW1vdmVGcm9tVXBkYXRlID0gZnVuY3Rpb24oIGFuaW1hdGlvbiApIHtcblxuXHRcdHZhciBpbmRleCA9IHBsYXlpbmcuaW5kZXhPZiggYW5pbWF0aW9uICk7XG5cblx0XHRpZiggaW5kZXggIT09IC0xIClcblx0XHRcdHBsYXlpbmcuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdH07XG5cblxuXHQvLy0tLSBhZGQgLS0tXG5cblx0dGhhdC5hZGQgPSBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdGlmKCBsaWJyYXJ5WyBkYXRhLm5hbWUgXSAhPT0gdW5kZWZpbmVkIClcblx0XHRcdGNvbnNvbGUubG9nKCBcIlRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkOiBXYXJuaW5nISBcIiArIGRhdGEubmFtZSArIFwiIGFscmVhZHkgZXhpc3RzIGluIGxpYnJhcnkuIE92ZXJ3cml0aW5nLlwiICk7XG5cblx0XHRsaWJyYXJ5WyBkYXRhLm5hbWUgXSA9IGRhdGE7XG5cdFx0aW5pdERhdGEoIGRhdGEgKTtcblxuXHR9O1xuXG5cblx0Ly8tLS0gZ2V0IC0tLVxuXG5cdHRoYXQuZ2V0ID0gZnVuY3Rpb24oIG5hbWUgKSB7XG5cblx0XHRpZiggdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdGlmKCBsaWJyYXJ5WyBuYW1lIF0gKSB7XG5cblx0XHRcdFx0cmV0dXJuIGxpYnJhcnlbIG5hbWUgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmxvZyggXCJUSFJFRS5BbmltYXRpb25IYW5kbGVyLmdldDogQ291bGRuJ3QgZmluZCBhbmltYXRpb24gXCIgKyBuYW1lICk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyB0b2RvOiBhZGQgc2ltcGxlIHR3ZWVuIGxpYnJhcnlcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vLS0tIHBhcnNlIC0tLVxuXG5cdHRoYXQucGFyc2UgPSBmdW5jdGlvbiggcm9vdCApIHtcblxuXHRcdC8vIHNldHVwIGhpZXJhcmNoeVxuXG5cdFx0dmFyIGhpZXJhcmNoeSA9IFtdO1xuXG5cdFx0aWYgKCByb290IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdGZvciggdmFyIGIgPSAwOyBiIDwgcm9vdC5ib25lcy5sZW5ndGg7IGIrKyApIHtcblxuXHRcdFx0XHRoaWVyYXJjaHkucHVzaCggcm9vdC5ib25lc1sgYiBdICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBhcnNlUmVjdXJzZUhpZXJhcmNoeSggcm9vdCwgaGllcmFyY2h5ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaGllcmFyY2h5O1xuXG5cdH07XG5cblx0dmFyIHBhcnNlUmVjdXJzZUhpZXJhcmNoeSA9IGZ1bmN0aW9uKCByb290LCBoaWVyYXJjaHkgKSB7XG5cblx0XHRoaWVyYXJjaHkucHVzaCggcm9vdCApO1xuXG5cdFx0Zm9yKCB2YXIgYyA9IDA7IGMgPCByb290LmNoaWxkcmVuLmxlbmd0aDsgYysrIClcblx0XHRcdHBhcnNlUmVjdXJzZUhpZXJhcmNoeSggcm9vdC5jaGlsZHJlblsgYyBdLCBoaWVyYXJjaHkgKTtcblxuXHR9XG5cblxuXHQvLy0tLSBpbml0IGRhdGEgLS0tXG5cblx0dmFyIGluaXREYXRhID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRpZiggZGF0YS5pbml0aWFsaXplZCA9PT0gdHJ1ZSApXG5cdFx0XHRyZXR1cm47XG5cblxuXHRcdC8vIGxvb3AgdGhyb3VnaCBhbGwga2V5c1xuXG5cdFx0Zm9yKCB2YXIgaCA9IDA7IGggPCBkYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGggKysgKSB7XG5cblx0XHRcdGZvciggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHQvLyByZW1vdmUgbWludXMgdGltZXNcblxuXHRcdFx0XHRpZiggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0udGltZSA8IDAgKVxuXHRcdFx0XHRcdGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPSAwO1xuXG5cblx0XHRcdFx0Ly8gY3JlYXRlIHF1YXRlcm5pb25zXG5cblx0XHRcdFx0aWYoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdCAhKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgaW5zdGFuY2VvZiBUSFJFRS5RdWF0ZXJuaW9uICkgKSB7XG5cblx0XHRcdFx0XHR2YXIgcXVhdCA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdDtcblx0XHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgPSBuZXcgVEhSRUUuUXVhdGVybmlvbiggcXVhdFswXSwgcXVhdFsxXSwgcXVhdFsyXSwgcXVhdFszXSApO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBwcmVwYXJlIG1vcnBoIHRhcmdldCBrZXlzXG5cblx0XHRcdGlmKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBnZXQgYWxsIHVzZWRcblxuXHRcdFx0XHR2YXIgdXNlZE1vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdFx0XHRcdGZvciggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRcdGZvciggdmFyIG0gPSAwOyBtIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0TmFtZSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdO1xuXHRcdFx0XHRcdFx0dXNlZE1vcnBoVGFyZ2V0c1sgbW9ycGhUYXJnZXROYW1lIF0gPSAtMTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS51c2VkTW9ycGhUYXJnZXRzID0gdXNlZE1vcnBoVGFyZ2V0cztcblxuXG5cdFx0XHRcdC8vIHNldCBhbGwgdXNlZCBvbiBhbGwgZnJhbWVzXG5cblx0XHRcdFx0Zm9yKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZmx1ZW5jZXMgPSB7fTtcblxuXHRcdFx0XHRcdGZvciggdmFyIG1vcnBoVGFyZ2V0TmFtZSBpbiB1c2VkTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0XHRmb3IoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdID09PSBtb3JwaFRhcmdldE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXNbIG0gXTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYoIG0gPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRcdFx0aW5mbHVlbmNlc1sgbW9ycGhUYXJnZXROYW1lIF0gPSAwO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNJbmZsdWVuY2VzID0gaW5mbHVlbmNlcztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0XHQvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgb24gdGhlIHNhbWUgdGltZVxuXG5cdFx0XHRmb3IoIHZhciBrID0gMTsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0aWYoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayAtIDEgXS50aW1lICkge1xuXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLnNwbGljZSggaywgMSApO1xuXHRcdFx0XHRcdGsgLS07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gc2V0IGluZGV4XG5cblx0XHRcdGZvciggdmFyIGsgPSAxOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5pbmRleCA9IGs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0Ly8gSklUXG5cblx0XHR2YXIgbGVuZ3RoSW5GcmFtZXMgPSBwYXJzZUludCggZGF0YS5sZW5ndGggKiBkYXRhLmZwcywgMTAgKTtcblxuXHRcdGRhdGEuSklUID0ge307XG5cdFx0ZGF0YS5KSVQuaGllcmFyY2h5ID0gW107XG5cblx0XHRmb3IoIHZhciBoID0gMDsgaCA8IGRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCArKyApXG5cdFx0XHRkYXRhLkpJVC5oaWVyYXJjaHkucHVzaCggbmV3IEFycmF5KCBsZW5ndGhJbkZyYW1lcyApICk7XG5cblxuXHRcdC8vIGRvbmVcblxuXHRcdGRhdGEuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdH07XG5cblxuXHQvLyBpbnRlcnBvbGF0aW9uIHR5cGVzXG5cblx0dGhhdC5MSU5FQVIgPSAwO1xuXHR0aGF0LkNBVE1VTExST00gPSAxO1xuXHR0aGF0LkNBVE1VTExST01fRk9SV0FSRCA9IDI7XG5cblx0cmV0dXJuIHRoYXQ7XG5cbn0oKSk7XG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5BbmltYXRpb24gPSBmdW5jdGlvbiggcm9vdCwgZGF0YSwgaW50ZXJwb2xhdGlvblR5cGUsIEpJVENvbXBpbGUgKSB7XG5cblx0dGhpcy5yb290ID0gcm9vdDtcblx0dGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoIGRhdGEgKTtcblx0dGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCByb290ICk7XG5cdHRoaXMuY3VycmVudFRpbWUgPSAwO1xuXHR0aGlzLnRpbWVTY2FsZSA9IDE7XG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXHR0aGlzLmxvb3AgPSB0cnVlO1xuXHR0aGlzLmludGVycG9sYXRpb25UeXBlID0gaW50ZXJwb2xhdGlvblR5cGUgIT09IHVuZGVmaW5lZCA/IGludGVycG9sYXRpb25UeXBlIDogVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVI7XG5cdHRoaXMuSklUQ29tcGlsZSA9IEpJVENvbXBpbGUgIT09IHVuZGVmaW5lZCA/IEpJVENvbXBpbGUgOiB0cnVlO1xuXG5cdHRoaXMucG9pbnRzID0gW107XG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuLy8gUGxheVxuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiggbG9vcCwgc3RhcnRUaW1lTVMgKSB7XG5cblx0aWYoICF0aGlzLmlzUGxheWluZyApIHtcblxuXHRcdHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblx0XHR0aGlzLmxvb3AgPSBsb29wICE9PSB1bmRlZmluZWQgPyBsb29wIDogdHJ1ZTtcblx0XHR0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lTVMgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZU1TIDogMDtcblxuXG5cdFx0Ly8gcmVzZXQga2V5IGNhY2hlXG5cblx0XHR2YXIgaCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGgsXG5cdFx0XHRvYmplY3Q7XG5cblx0XHRmb3IgKCBoID0gMDsgaCA8IGhsOyBoKysgKSB7XG5cblx0XHRcdG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG5cblx0XHRcdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSAhPT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnVzZVF1YXRlcm5pb24gPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPSB7fTtcblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSB7IHBvczogMCwgcm90OiAwLCBzY2w6IDAgfTtcblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSB7IHBvczogMCwgcm90OiAwLCBzY2w6IDAgfTtcblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4ID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSA/IG9iamVjdC5za2luTWF0cml4IDogb2JqZWN0Lm1hdHJpeDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcHJldktleSA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5wcmV2S2V5O1xuXHRcdFx0dmFyIG5leHRLZXkgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUubmV4dEtleTtcblxuXHRcdFx0cHJldktleS5wb3MgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXHRcdFx0cHJldktleS5yb3QgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXHRcdFx0cHJldktleS5zY2wgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXG5cdFx0XHRuZXh0S2V5LnBvcyA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIFwicG9zXCIsIGgsIDEgKTtcblx0XHRcdG5leHRLZXkucm90ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJyb3RcIiwgaCwgMSApO1xuXHRcdFx0bmV4dEtleS5zY2wgPSB0aGlzLmdldE5leHRLZXlXaXRoKCBcInNjbFwiLCBoLCAxICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZSggMCApO1xuXG5cdH1cblxuXHR0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cblx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5hZGRUb1VwZGF0ZSggdGhpcyApO1xuXG59O1xuXG5cblxuLy8gUGF1c2VcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdGlmKCB0aGlzLmlzUGF1c2VkICkge1xuXG5cdFx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5hZGRUb1VwZGF0ZSggdGhpcyApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZUZyb21VcGRhdGUoIHRoaXMgKTtcblxuXHR9XG5cblx0dGhpcy5pc1BhdXNlZCA9ICF0aGlzLmlzUGF1c2VkO1xuXG59O1xuXG5cbi8vIFN0b3BcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG5cblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblx0dGhpcy5pc1BhdXNlZCAgPSBmYWxzZTtcblx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5yZW1vdmVGcm9tVXBkYXRlKCB0aGlzICk7XG5cblxuXHQvLyByZXNldCBKSVQgbWF0cml4IGFuZCByZW1vdmUgY2FjaGVcblxuXHRmb3IgKCB2YXIgaCA9IDA7IGggPCB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGgrKyApIHtcblxuXHRcdGlmICggdGhpcy5oaWVyYXJjaHlbIGggXS5hbmltYXRpb25DYWNoZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiggdGhpcy5oaWVyYXJjaHlbIGggXSBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cblx0XHRcdFx0dGhpcy5oaWVyYXJjaHlbIGggXS5za2luTWF0cml4ID0gdGhpcy5oaWVyYXJjaHlbIGggXS5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmhpZXJhcmNoeVsgaCBdLm1hdHJpeCA9IHRoaXMuaGllcmFyY2h5WyBoIF0uYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRkZWxldGUgdGhpcy5oaWVyYXJjaHlbIGggXS5hbmltYXRpb25DYWNoZTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblxuLy8gVXBkYXRlXG5cblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oIGRlbHRhVGltZU1TICkge1xuXG5cdC8vIGVhcmx5IG91dFxuXG5cdGlmKCAhdGhpcy5pc1BsYXlpbmcgKSByZXR1cm47XG5cblxuXHQvLyB2YXJzXG5cblx0dmFyIHR5cGVzID0gWyBcInBvc1wiLCBcInJvdFwiLCBcInNjbFwiIF07XG5cdHZhciB0eXBlO1xuXHR2YXIgc2NhbGU7XG5cdHZhciB2ZWN0b3I7XG5cdHZhciBwcmV2WFlaLCBuZXh0WFlaO1xuXHR2YXIgcHJldktleSwgbmV4dEtleTtcblx0dmFyIG9iamVjdDtcblx0dmFyIGFuaW1hdGlvbkNhY2hlO1xuXHR2YXIgZnJhbWU7XG5cdHZhciBKSVRoaWVyYXJjaHkgPSB0aGlzLmRhdGEuSklULmhpZXJhcmNoeTtcblx0dmFyIGN1cnJlbnRUaW1lLCB1bmxvb3BlZEN1cnJlbnRUaW1lO1xuXHR2YXIgY3VycmVudFBvaW50LCBmb3J3YXJkUG9pbnQsIGFuZ2xlO1xuXG5cblx0Ly8gdXBkYXRlXG5cblx0dGhpcy5jdXJyZW50VGltZSArPSBkZWx0YVRpbWVNUyAqIHRoaXMudGltZVNjYWxlO1xuXG5cdHVubG9vcGVkQ3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuXHRjdXJyZW50VGltZSAgICAgICAgID0gdGhpcy5jdXJyZW50VGltZSA9IHRoaXMuY3VycmVudFRpbWUgJSB0aGlzLmRhdGEubGVuZ3RoO1xuXHRmcmFtZSAgICAgICAgICAgICAgID0gcGFyc2VJbnQoIE1hdGgubWluKCBjdXJyZW50VGltZSAqIHRoaXMuZGF0YS5mcHMsIHRoaXMuZGF0YS5sZW5ndGggKiB0aGlzLmRhdGEuZnBzICksIDEwICk7XG5cblxuXHQvLyB1cGRhdGVcblxuXHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcblxuXHRcdG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG5cdFx0YW5pbWF0aW9uQ2FjaGUgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGU7XG5cblx0XHQvLyB1c2UgSklUP1xuXG5cdFx0aWYgKCB0aGlzLkpJVENvbXBpbGUgJiYgSklUaGllcmFyY2h5WyBoIF1bIGZyYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnNraW5NYXRyaXggPSBKSVRoaWVyYXJjaHlbIGggXVsgZnJhbWUgXTtcblxuXHRcdFx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG9iamVjdC5tYXRyaXggPSBKSVRoaWVyYXJjaHlbIGggXVsgZnJhbWUgXTtcblxuXHRcdFx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdC8vIHVzZSBpbnRlcnBvbGF0aW9uXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBtYWtlIHN1cmUgc28gb3JpZ2luYWwgbWF0cml4IGFuZCBub3QgSklUIG1hdHJpeCBpcyBzZXRcblxuXHRcdFx0aWYgKCB0aGlzLkpJVENvbXBpbGUgKSB7XG5cblx0XHRcdFx0aWYoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cblx0XHRcdFx0XHRvYmplY3Quc2tpbk1hdHJpeCA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0b2JqZWN0Lm1hdHJpeCA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBsb29wIHRocm91Z2ggcG9zL3JvdC9zY2xcblxuXHRcdFx0Zm9yICggdmFyIHQgPSAwOyB0IDwgMzsgdCsrICkge1xuXG5cdFx0XHRcdC8vIGdldCBrZXlzXG5cblx0XHRcdFx0dHlwZSAgICA9IHR5cGVzWyB0IF07XG5cdFx0XHRcdHByZXZLZXkgPSBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF07XG5cdFx0XHRcdG5leHRLZXkgPSBhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF07XG5cblx0XHRcdFx0Ly8gc3dpdGNoIGtleXM/XG5cblx0XHRcdFx0aWYgKCBuZXh0S2V5LnRpbWUgPD0gdW5sb29wZWRDdXJyZW50VGltZSApIHtcblxuXHRcdFx0XHRcdC8vIGRpZCB3ZSBsb29wP1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50VGltZSA8IHVubG9vcGVkQ3VycmVudFRpbWUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5sb29wICkge1xuXG5cdFx0XHRcdFx0XHRcdHByZXZLZXkgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlKCBuZXh0S2V5LnRpbWUgPCBjdXJyZW50VGltZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHByZXZLZXkgPSBuZXh0S2V5O1xuXHRcdFx0XHRcdFx0XHRcdG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLnN0b3AoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRkbyB7XG5cblx0XHRcdFx0XHRcdFx0cHJldktleSA9IG5leHRLZXk7XG5cdFx0XHRcdFx0XHRcdG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xuXG5cdFx0XHRcdFx0XHR9IHdoaWxlKCBuZXh0S2V5LnRpbWUgPCBjdXJyZW50VGltZSApXG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF0gPSBwcmV2S2V5O1xuXHRcdFx0XHRcdGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXSA9IG5leHRLZXk7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0b2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0c2NhbGUgPSAoIGN1cnJlbnRUaW1lIC0gcHJldktleS50aW1lICkgLyAoIG5leHRLZXkudGltZSAtIHByZXZLZXkudGltZSApO1xuXHRcdFx0XHRwcmV2WFlaID0gcHJldktleVsgdHlwZSBdO1xuXHRcdFx0XHRuZXh0WFlaID0gbmV4dEtleVsgdHlwZSBdO1xuXG5cblx0XHRcdFx0Ly8gY2hlY2sgc2NhbGUgZXJyb3JcblxuXHRcdFx0XHRpZiAoIHNjYWxlIDwgMCB8fCBzY2FsZSA+IDEgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmxvZyggXCJUSFJFRS5BbmltYXRpb24udXBkYXRlOiBXYXJuaW5nISBTY2FsZSBvdXQgb2YgYm91bmRzOlwiICsgc2NhbGUgKyBcIiBvbiBib25lIFwiICsgaCApO1xuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgPCAwID8gMCA6IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGludGVycG9sYXRlXG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcInBvc1wiICkge1xuXG5cdFx0XHRcdFx0dmVjdG9yID0gb2JqZWN0LnBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0aWYoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSICkge1xuXG5cdFx0XHRcdFx0XHR2ZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcblx0XHRcdFx0XHRcdHZlY3Rvci55ID0gcHJldlhZWlsgMSBdICsgKCBuZXh0WFlaWyAxIF0gLSBwcmV2WFlaWyAxIF0gKSAqIHNjYWxlO1xuXHRcdFx0XHRcdFx0dmVjdG9yLnogPSBwcmV2WFlaWyAyIF0gKyAoIG5leHRYWVpbIDIgXSAtIHByZXZYWVpbIDIgXSApICogc2NhbGU7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcblx0XHRcdFx0XHRcdFx0ICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLnBvaW50c1sgMCBdID0gdGhpcy5nZXRQcmV2S2V5V2l0aCggXCJwb3NcIiwgaCwgcHJldktleS5pbmRleCAtIDEgKVsgXCJwb3NcIiBdO1xuXHRcdFx0XHRcdFx0dGhpcy5wb2ludHNbIDEgXSA9IHByZXZYWVo7XG5cdFx0XHRcdFx0XHR0aGlzLnBvaW50c1sgMiBdID0gbmV4dFhZWjtcblx0XHRcdFx0XHRcdHRoaXMucG9pbnRzWyAzIF0gPSB0aGlzLmdldE5leHRLZXlXaXRoKCBcInBvc1wiLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApWyBcInBvc1wiIF07XG5cblx0XHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgKiAwLjMzICsgMC4zMztcblxuXHRcdFx0XHRcdFx0Y3VycmVudFBvaW50ID0gdGhpcy5pbnRlcnBvbGF0ZUNhdG11bGxSb20oIHRoaXMucG9pbnRzLCBzY2FsZSApO1xuXG5cdFx0XHRcdFx0XHR2ZWN0b3IueCA9IGN1cnJlbnRQb2ludFsgMCBdO1xuXHRcdFx0XHRcdFx0dmVjdG9yLnkgPSBjdXJyZW50UG9pbnRbIDEgXTtcblx0XHRcdFx0XHRcdHZlY3Rvci56ID0gY3VycmVudFBvaW50WyAyIF07XG5cblx0XHRcdFx0XHRcdGlmKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3J3YXJkUG9pbnQgPSB0aGlzLmludGVycG9sYXRlQ2F0bXVsbFJvbSggdGhpcy5wb2ludHMsIHNjYWxlICogMS4wMSApO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMudGFyZ2V0LnNldCggZm9yd2FyZFBvaW50WyAwIF0sIGZvcndhcmRQb2ludFsgMSBdLCBmb3J3YXJkUG9pbnRbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRhcmdldC5zdWJTZWxmKCB2ZWN0b3IgKTtcblx0XHRcdFx0XHRcdFx0dGhpcy50YXJnZXQueSA9IDA7XG5cdFx0XHRcdFx0XHRcdHRoaXMudGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMiggdGhpcy50YXJnZXQueCwgdGhpcy50YXJnZXQueiApO1xuXHRcdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uc2V0KCAwLCBhbmdsZSwgMCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJyb3RcIiApIHtcblxuXHRcdFx0XHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIHByZXZYWVosIG5leHRYWVosIG9iamVjdC5xdWF0ZXJuaW9uLCBzY2FsZSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiggdHlwZSA9PT0gXCJzY2xcIiApIHtcblxuXHRcdFx0XHRcdHZlY3RvciA9IG9iamVjdC5zY2FsZTtcblxuXHRcdFx0XHRcdHZlY3Rvci54ID0gcHJldlhZWlsgMCBdICsgKCBuZXh0WFlaWyAwIF0gLSBwcmV2WFlaWyAwIF0gKSAqIHNjYWxlO1xuXHRcdFx0XHRcdHZlY3Rvci55ID0gcHJldlhZWlsgMSBdICsgKCBuZXh0WFlaWyAxIF0gLSBwcmV2WFlaWyAxIF0gKSAqIHNjYWxlO1xuXHRcdFx0XHRcdHZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyB1cGRhdGUgSklUP1xuXG5cdGlmICggdGhpcy5KSVRDb21waWxlICkge1xuXG5cdFx0aWYgKCBKSVRoaWVyYXJjaHlbIDAgXVsgZnJhbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmhpZXJhcmNoeVsgMCBdLnVwZGF0ZSggbnVsbCwgdHJ1ZSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGgrKyApIHtcblxuXHRcdFx0XHRpZiggdGhpcy5oaWVyYXJjaHlbIGggXSBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cblx0XHRcdFx0XHRKSVRoaWVyYXJjaHlbIGggXVsgZnJhbWUgXSA9IHRoaXMuaGllcmFyY2h5WyBoIF0uc2tpbk1hdHJpeC5jbG9uZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRKSVRoaWVyYXJjaHlbIGggXVsgZnJhbWUgXSA9IHRoaXMuaGllcmFyY2h5WyBoIF0ubWF0cml4LmNsb25lKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vLyBDYXRtdWxsLVJvbSBzcGxpbmVcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5pbnRlcnBvbGF0ZUNhdG11bGxSb20gPSBmdW5jdGlvbiAoIHBvaW50cywgc2NhbGUgKSB7XG5cblx0dmFyIGMgPSBbXSwgdjMgPSBbXSxcblx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3Myxcblx0cGEsIHBiLCBwYywgcGQ7XG5cblx0cG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiBzY2FsZTtcblx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG5cdGNbIDEgXSA9IGludFBvaW50O1xuXHRjWyAyIF0gPSBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gaW50UG9pbnQgOiBpbnRQb2ludCArIDE7XG5cdGNbIDMgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMjtcblxuXHRwYSA9IHBvaW50c1sgY1sgMCBdIF07XG5cdHBiID0gcG9pbnRzWyBjWyAxIF0gXTtcblx0cGMgPSBwb2ludHNbIGNbIDIgXSBdO1xuXHRwZCA9IHBvaW50c1sgY1sgMyBdIF07XG5cblx0dzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XG5cdHczID0gd2VpZ2h0ICogdzI7XG5cblx0djNbIDAgXSA9IHRoaXMuaW50ZXJwb2xhdGUoIHBhWyAwIF0sIHBiWyAwIF0sIHBjWyAwIF0sIHBkWyAwIF0sIHdlaWdodCwgdzIsIHczICk7XG5cdHYzWyAxIF0gPSB0aGlzLmludGVycG9sYXRlKCBwYVsgMSBdLCBwYlsgMSBdLCBwY1sgMSBdLCBwZFsgMSBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuXHR2M1sgMiBdID0gdGhpcy5pbnRlcnBvbGF0ZSggcGFbIDIgXSwgcGJbIDIgXSwgcGNbIDIgXSwgcGRbIDIgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcblxuXHRyZXR1cm4gdjM7XG5cbn07XG5cblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcblxuXHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcblx0XHR2MSA9ICggcDMgLSBwMSApICogMC41O1xuXG5cdHJldHVybiAoIDIgKiAoIHAxIC0gcDIgKSArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiAoIHAxIC0gcDIgKSAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG59O1xuXG5cblxuLy8gR2V0IG5leHQga2V5IHdpdGhcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5nZXROZXh0S2V5V2l0aCA9IGZ1bmN0aW9uKCB0eXBlLCBoLCBrZXkgKSB7XG5cblx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcblxuXHRpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuXHRcdCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuXHRcdGtleSA9IGtleSA8IGtleXMubGVuZ3RoIC0gMSA/IGtleSA6IGtleXMubGVuZ3RoIC0gMTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0a2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XG5cblx0fVxuXG5cdGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSsrICkge1xuXG5cdFx0aWYgKCBrZXlzWyBrZXkgXVsgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBrZXlzWyBrZXkgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XG5cbn07XG5cbi8vIEdldCBwcmV2aW91cyBrZXkgd2l0aFxuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLmdldFByZXZLZXlXaXRoID0gZnVuY3Rpb24oIHR5cGUsIGgsIGtleSApIHtcblxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG5cdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NIHx8XG5cdFx0IHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG5cdFx0a2V5ID0ga2V5ID4gMCA/IGtleSA6IDA7XG5cblx0fSBlbHNlIHtcblxuXHRcdGtleSA9IGtleSA+PSAwID8ga2V5IDoga2V5ICsga2V5cy5sZW5ndGg7XG5cblx0fVxuXG5cblx0Zm9yICggOyBrZXkgPj0gMDsga2V5LS0gKSB7XG5cblx0XHRpZiAoIGtleXNbIGtleSBdWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIGtleXNbIGtleSBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xuXG59O1xuLyoqXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcbiAqXHQtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uICggbmVhciwgZmFyLCBoZWlnaHRPZmZzZXQsIGN1YmVSZXNvbHV0aW9uICkge1xuXG5cdHRoaXMuaGVpZ2h0T2Zmc2V0ID0gaGVpZ2h0T2Zmc2V0O1xuXHR0aGlzLnBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodE9mZnNldCwgMCApO1xuXG5cdC8vIGNhbWVyYXNcblxuXHR2YXIgZm92ID0gOTAsIGFzcGVjdCA9IDE7XG5cblx0dGhpcy5jYW1lcmFQWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHR0aGlzLmNhbWVyYU5YID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cblx0dGhpcy5jYW1lcmFQWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHR0aGlzLmNhbWVyYU5ZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cblx0dGhpcy5jYW1lcmFQWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHR0aGlzLmNhbWVyYU5aID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cblx0dGhpcy5jYW1lcmFQWC5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG5cdHRoaXMuY2FtZXJhTlgucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuXG5cdHRoaXMuY2FtZXJhUFkucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuXHR0aGlzLmNhbWVyYU5ZLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcblxuXHR0aGlzLmNhbWVyYVBaLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcblx0dGhpcy5jYW1lcmFOWi5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG5cblx0dGhpcy5jYW1lcmFQWC51cC5zZXQoIDAsIC0xLCAwICk7XG5cdHRoaXMuY2FtZXJhTlgudXAuc2V0KCAwLCAtMSwgMCApO1xuXG5cdHRoaXMuY2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XG5cdHRoaXMuY2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtMSApO1xuXG5cdHRoaXMuY2FtZXJhUFoudXAuc2V0KCAwLCAtMSwgMCApO1xuXHR0aGlzLmNhbWVyYU5aLnVwLnNldCggMCwgLTEsIDAgKTtcblxuXHQvLyB0YXJnZXRzXG5cblx0dGhpcy50YXJnZXRQWCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICk7XG5cdHRoaXMudGFyZ2V0TlggPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApO1xuXG5cdHRoaXMudGFyZ2V0UFkgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApO1xuXHR0aGlzLnRhcmdldE5ZID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKTtcblxuXHR0aGlzLnRhcmdldFBaID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKTtcblx0dGhpcy50YXJnZXROWiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICk7XG5cblx0Ly8gY3ViZSByZW5kZXIgdGFyZ2V0XG5cblx0dGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCBjdWJlUmVzb2x1dGlvbiwgY3ViZVJlc29sdXRpb24sIHsgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciB9ICk7XG5cblx0dGhpcy51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICggcG9zaXRpb24gKSB7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHBvc2l0aW9uICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLnkgKz0gdGhpcy5oZWlnaHRPZmZzZXQ7XG5cblx0XHR0aGlzLnRhcmdldFBYLmNvcHkoIHRoaXMucG9zaXRpb24gKTtcblx0XHR0aGlzLnRhcmdldE5YLmNvcHkoIHRoaXMucG9zaXRpb24gKTtcblxuXHRcdHRoaXMudGFyZ2V0UFkuY29weSggdGhpcy5wb3NpdGlvbiApO1xuXHRcdHRoaXMudGFyZ2V0TlkuY29weSggdGhpcy5wb3NpdGlvbiApO1xuXG5cdFx0dGhpcy50YXJnZXRQWi5jb3B5KCB0aGlzLnBvc2l0aW9uICk7XG5cdFx0dGhpcy50YXJnZXROWi5jb3B5KCB0aGlzLnBvc2l0aW9uICk7XG5cblx0XHR0aGlzLnRhcmdldFBYLnggKz0gMTtcblx0XHR0aGlzLnRhcmdldE5YLnggLT0gMTtcblxuXHRcdHRoaXMudGFyZ2V0UFkueSArPSAxO1xuXHRcdHRoaXMudGFyZ2V0TlkueSAtPSAxO1xuXG5cdFx0dGhpcy50YXJnZXRQWi56ICs9IDE7XG5cdFx0dGhpcy50YXJnZXROWi56IC09IDE7XG5cblx0XHR0aGlzLmNhbWVyYVBYLmxvb2tBdCggdGhpcy50YXJnZXRQWCApO1xuXHRcdHRoaXMuY2FtZXJhTlgubG9va0F0KCB0aGlzLnRhcmdldE5YICk7XG5cblx0XHR0aGlzLmNhbWVyYVBZLmxvb2tBdCggdGhpcy50YXJnZXRQWSApO1xuXHRcdHRoaXMuY2FtZXJhTlkubG9va0F0KCB0aGlzLnRhcmdldE5ZICk7XG5cblx0XHR0aGlzLmNhbWVyYVBaLmxvb2tBdCggdGhpcy50YXJnZXRQWiApO1xuXHRcdHRoaXMuY2FtZXJhTloubG9va0F0KCB0aGlzLnRhcmdldE5aICk7XG5cblx0fTtcblxuXHR0aGlzLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcblxuXHRcdHZhciBjdWJlVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG5cblx0XHRjdWJlVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCB0aGlzLmNhbWVyYVBYLCBjdWJlVGFyZ2V0ICk7XG5cblx0XHRjdWJlVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCB0aGlzLmNhbWVyYU5YLCBjdWJlVGFyZ2V0ICk7XG5cblx0XHRjdWJlVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCB0aGlzLmNhbWVyYVBZLCBjdWJlVGFyZ2V0ICk7XG5cblx0XHRjdWJlVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCB0aGlzLmNhbWVyYU5ZLCBjdWJlVGFyZ2V0ICk7XG5cblx0XHRjdWJlVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCB0aGlzLmNhbWVyYVBaLCBjdWJlVGFyZ2V0ICk7XG5cblx0XHRjdWJlVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCB0aGlzLmNhbWVyYU5aLCBjdWJlVGFyZ2V0ICk7XG5cblx0fTtcblxufTtUSFJFRS5GaXJzdFBlcnNvbkNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcblxuXHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBGaXJzdFBlcnNvbkNhbWVyYSgpIGlzIEZpcnN0UGVyc29uQ29udHJvbHMoKS4nICk7XG5cbn07XG5USFJFRS5QYXRoQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXG5cdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IFBhdGhDYW1lcmEoKSBpcyBQYXRoQ29udHJvbHMoKS4nICk7XG5cbn07XG5USFJFRS5GbHlDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogRmx5Q2FtZXJhKCkgaXMgRmx5Q29udHJvbHMoKS4nICk7XG5cbn07XG5USFJFRS5Sb2xsQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXG5cdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IFJvbGxDYW1lcmEoKSBpcyBSb2xsQ29udHJvbHMoKS4nICk7XG5cbn07XG5USFJFRS5UcmFja2JhbGxDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogVHJhY2tiYWxsQ2FtZXJhKCkgaXMgVHJhY2tiYWxsQ29udHJvbHMoKS4nICk7XG5cbn07XG4vKlxuICpcdEBhdXRob3Igeno4NSAvIGh0dHA6Ly90d2l0dGVyLmNvbS9ibHVyc3BsaW5lIC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZyBcbiAqIFxuICpcdEEgaGFuZHkgZ2VuZXJhbCBwZXJwb3NlIGNhbWVyYSwgZm9yIHNldHRpbmcgRk9WLCBMZW5zIEZvY2FsIExlbmd0aCwgIFxuICpcdFx0YW5kIHN3aXRjaGluZyBiZXR3ZWVuIHBlcnNwZWN0aXZlIGFuZCBvcnRob2dyYXBoaWMgdmlld3MgZWFzaWx5LlxuICpcbiAqL1xuXG5cblRIUkVFLkNvbWJpbmVkQ2FtZXJhID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBmb3YsIG5lYXIsIGZhciwgb3J0aG9uZWFyLCBvcnRob2ZhciApIHtcblxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMuZm92ID0gZm92O1xuXHRcblx0dGhpcy5sZWZ0ID0gLXdpZHRoIC8gMjtcblx0dGhpcy5yaWdodCA9IHdpZHRoIC8gMlxuXHR0aGlzLnRvcCA9IGhlaWdodCAvIDI7XG5cdHRoaXMuYm90dG9tID0gLWhlaWdodCAvIDI7XG5cdFxuXHQvLyBXZSBjb3VsZCBhbHNvIGhhbmRsZSB0aGUgcHJvamVjdGlvbk1hdHJpeCBpbnRlcm5hbGx5LCBidXQganVzdCB3YW50ZWQgdG8gdGVzdCBuZXN0ZWQgY2FtZXJhIG9iamVjdHNcblx0dGhpcy5jYW1lcmFPID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggd2lkdGggLyAtIDIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgaGVpZ2h0IC8gLSAyLCBcdG9ydGhvbmVhciwgb3J0aG9mYXIgKTtcblx0dGhpcy5jYW1lcmFQID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIHdpZHRoL2hlaWdodCwgbmVhciwgZmFyICk7XG5cblx0dGhpcy56b29tID0gMTtcblx0XG5cdHRoaXMudG9QZXJzcGVjdGl2ZSgpO1xuXHRcblx0XG5cdHZhciBhc3BlY3QgPSB3aWR0aC9oZWlnaHQ7XG5cdFxuXHRcblxuXG59O1xuXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuQ2FtZXJhKCk7XG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Db29sQ2FtZXJhO1xuXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9QZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLm5lYXIgPSB0aGlzLmNhbWVyYVAubmVhcjtcblx0dGhpcy5mYXIgPSB0aGlzLmNhbWVyYVAuZmFyO1xuXHR0aGlzLmNhbWVyYVAuZm92ID0gIHRoaXMuZm92IC8gdGhpcy56b29tIDtcblx0dGhpcy5jYW1lcmFQLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5jYW1lcmFQLnByb2plY3Rpb25NYXRyaXg7XG5cdFxuXHR0aGlzLmluUGVyc2VwZWN0aXZlTW9kZSA9IHRydWU7XG5cdHRoaXMuaW5PcnRob2dyYXBoaWNNb2RlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b09ydGhvZ3JhcGhpYyA9IGZ1bmN0aW9uICgpIHtcblxuXHQvLyBPcnRob2dyYXBoaWMgZnJvbSBQZXJzcGVjdGl2ZVxuXHR2YXIgZm92ID0gdGhpcy5mb3Y7XG5cdHZhciBhc3BlY3QgPSB0aGlzLmNhbWVyYVAuYXNwZWN0O1xuXHR2YXIgbmVhciA9IHRoaXMuY2FtZXJhUC5uZWFyO1xuXHR2YXIgZmFyID0gdGhpcy5jYW1lcmFQLmZhcjtcblx0XG5cdFxuXHQvLyBKdXN0IHByZXRlbmQgd2Ugd2FudCB0aGUgbWlkIHBsYW5lIG9mIHRoZSB2aWV3aW5nIGZydXN0dW1cblx0dmFyIGh5cGVyZm9jdXMgPSAoIG5lYXIgKyBmYXIgKSAvIDI7IFxuXHRcblx0dmFyIGhhbGZIZWlnaHQgPSBNYXRoLnRhbiggZm92IC8gMiApICogaHlwZXJmb2N1cztcblx0dmFyIHBsYW5lSGVpZ2h0ID0gMiAqIGhhbGZIZWlnaHQ7XG5cdHZhciBwbGFuZVdpZHRoID0gcGxhbmVIZWlnaHQgKiBhc3BlY3Q7XG5cdHZhciBoYWxmV2lkdGggPSBwbGFuZVdpZHRoIC8gMjtcblx0XG5cdGhhbGZIZWlnaHQgLz0gdGhpcy56b29tO1xuXHRoYWxmV2lkdGggLz0gdGhpcy56b29tO1xuXHRcblx0dGhpcy5jYW1lcmFPLmxlZnQgPSAtaGFsZldpZHRoO1xuXHR0aGlzLmNhbWVyYU8ucmlnaHQgPSBoYWxmV2lkdGg7XG5cdHRoaXMuY2FtZXJhTy50b3AgPSBoYWxmSGVpZ2h0O1xuXHR0aGlzLmNhbWVyYU8uYm90dG9tID0gLWhhbGZIZWlnaHQ7XG5cdFxuXHQvLyB0aGlzLmNhbWVyYU8ubGVmdCA9IC1mYXJIYWxmV2lkdGg7XG5cdC8vIHRoaXMuY2FtZXJhTy5yaWdodCA9IGZhckhhbGZXaWR0aDtcblx0Ly8gdGhpcy5jYW1lcmFPLnRvcCA9IGZhckhhbGZIZWlnaHQ7XG5cdC8vIHRoaXMuY2FtZXJhTy5ib3R0b20gPSAtZmFySGFsZkhlaWdodDtcblxuXHQvLyB0aGlzLmNhbWVyYU8ubGVmdCA9IHRoaXMubGVmdCAvIHRoaXMuem9vbTtcblx0Ly8gdGhpcy5jYW1lcmFPLnJpZ2h0ID0gdGhpcy5yaWdodCAvIHRoaXMuem9vbTtcblx0Ly8gdGhpcy5jYW1lcmFPLnRvcCA9IHRoaXMudG9wIC8gdGhpcy56b29tO1xuXHQvLyB0aGlzLmNhbWVyYU8uYm90dG9tID0gdGhpcy5ib3R0b20gLyB0aGlzLnpvb207XG5cdFxuXHR0aGlzLmNhbWVyYU8udXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdHRoaXMubmVhciA9IHRoaXMuY2FtZXJhTy5uZWFyO1xuXHR0aGlzLmZhciA9IHRoaXMuY2FtZXJhTy5mYXI7XG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMuY2FtZXJhTy5wcm9qZWN0aW9uTWF0cml4O1xuXHRcblx0dGhpcy5pblBlcnNlcGVjdGl2ZU1vZGUgPSBmYWxzZTtcblx0dGhpcy5pbk9ydGhvZ3JhcGhpY01vZGUgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0Rm92ID0gZnVuY3Rpb24oZm92KSB7XHRcblx0dGhpcy5mb3YgPSBmb3Y7XG5cdFxuXHRpZiAodGhpcy5pblBlcnNlcGVjdGl2ZU1vZGUpIHtcblx0XHR0aGlzLnRvUGVyc3BlY3RpdmUoKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLnRvT3J0aG9ncmFwaGljKCk7XG5cdH1cblxufTtcblxuLypcbiogVXNlcyBGb2NhbCBMZW5ndGggKGluIG1tKSB0byBlc3RpbWF0ZSBhbmQgc2V0IEZPVlxuKiAzNW1tIChmdWxsZnJhbWUpIGNhbWVyYSBpcyB1c2VkIGlmIGZyYW1lIHNpemUgaXMgbm90IHNwZWNpZmllZDtcbiogRm9ybXVsYSBiYXNlZCBvbiBodHRwOi8vd3d3LmJvYmF0a2lucy5jb20vcGhvdG9ncmFwaHkvdGVjaG5pY2FsL2ZpZWxkX29mX3ZpZXcuaHRtbFxuKi9cblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS5zZXRMZW5zID0gZnVuY3Rpb24oZm9jYWxMZW5ndGgsIGZyYW1lc2l6ZSkge1xuXG5cdGlmICghZnJhbWVzaXplKSBmcmFtZXNpemUgPSA0My4yNTsgLy8gMzZ4MjRtbVxuXG5cdHZhciBmb3YgPSAyICogTWF0aC5hdGFuKCBmcmFtZXNpemUgLyAoZm9jYWxMZW5ndGggKiAyKSk7XG5cdGZvdiA9IDE4MCAvIE1hdGguUEkgKiBmb3Y7XG5cdHRoaXMuc2V0Rm92KGZvdik7XG5cblx0cmV0dXJuIGZvdjtcbn07XG5cblxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbih6b29tKSB7XG5cblx0dGhpcy56b29tID0gem9vbTtcblx0XG5cdGlmICh0aGlzLmluUGVyc2VwZWN0aXZlTW9kZSkge1xuXHRcdHRoaXMudG9QZXJzcGVjdGl2ZSgpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMudG9PcnRob2dyYXBoaWMoKTtcblx0fVxuXHRcblxufTtcblxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvRnJvbnRWaWV3ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMucm90YXRpb24ueCA9IDA7XG5cdHRoaXMucm90YXRpb24ueSA9IDA7XG5cdHRoaXMucm90YXRpb24ueiA9IDA7XG5cdFxuXHQvL1RPRE86IEJldHRlciB3YXkgdG8gZGlzYWJsZSBjYW1lcmEubG9va0F0KCk/XG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XG59O1xuXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9CYWNrVmlldyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJvdGF0aW9uLnggPSAwO1xuXHR0aGlzLnJvdGF0aW9uLnkgPSBNYXRoLlBJO1xuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xufTtcblx0XG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9MZWZ0VmlldyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJvdGF0aW9uLnggPSAwO1xuXHR0aGlzLnJvdGF0aW9uLnkgPSAtIE1hdGguUEkgLyAyO1xuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvUmlnaHRWaWV3ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMucm90YXRpb24ueCA9IDA7XG5cdHRoaXMucm90YXRpb24ueSA9IE1hdGguUEkgLyAyO1xuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvVG9wVmlldyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJvdGF0aW9uLnggPSAtIE1hdGguUEkgLyAyO1xuXHR0aGlzLnJvdGF0aW9uLnkgPSAwO1xuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvQm90dG9tVmlldyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJvdGF0aW9uLnggPSBNYXRoLlBJIC8gMjtcblx0dGhpcy5yb3RhdGlvbi55ID0gMDtcblx0dGhpcy5yb3RhdGlvbi56ID0gMDtcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHBhdWxpcmlzaCAvIGh0dHA6Ly9wYXVsaXJpc2guY29tL1xuICovXG5cblRIUkVFLkZpcnN0UGVyc29uQ29udHJvbHMgPSBmdW5jdGlvbiAoIG9iamVjdCwgZG9tRWxlbWVudCApIHtcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApO1xuXG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cblx0dGhpcy5tb3ZlbWVudFNwZWVkID0gMS4wO1xuXHR0aGlzLmxvb2tTcGVlZCA9IDAuMDA1O1xuXG5cdHRoaXMubm9GbHkgPSBmYWxzZTtcblx0dGhpcy5sb29rVmVydGljYWwgPSB0cnVlO1xuXHR0aGlzLmF1dG9Gb3J3YXJkID0gZmFsc2U7XG5cblx0dGhpcy5hY3RpdmVMb29rID0gdHJ1ZTtcblxuXHR0aGlzLmhlaWdodFNwZWVkID0gZmFsc2U7XG5cdHRoaXMuaGVpZ2h0Q29lZiA9IDEuMDtcblx0dGhpcy5oZWlnaHRNaW4gPSAwLjA7XG5cblx0dGhpcy5jb25zdHJhaW5WZXJ0aWNhbCA9IGZhbHNlO1xuXHR0aGlzLnZlcnRpY2FsTWluID0gMDtcblx0dGhpcy52ZXJ0aWNhbE1heCA9IE1hdGguUEk7XG5cblx0dGhpcy5hdXRvU3BlZWRGYWN0b3IgPSAwLjA7XG5cblx0dGhpcy5tb3VzZVggPSAwO1xuXHR0aGlzLm1vdXNlWSA9IDA7XG5cblx0dGhpcy5sYXQgPSAwO1xuXHR0aGlzLmxvbiA9IDA7XG5cdHRoaXMucGhpID0gMDtcblx0dGhpcy50aGV0YSA9IDA7XG5cblx0dGhpcy5tb3ZlRm9yd2FyZCA9IGZhbHNlO1xuXHR0aGlzLm1vdmVCYWNrd2FyZCA9IGZhbHNlO1xuXHR0aGlzLm1vdmVMZWZ0ID0gZmFsc2U7XG5cdHRoaXMubW92ZVJpZ2h0ID0gZmFsc2U7XG5cdHRoaXMuZnJlZXplID0gZmFsc2U7XG5cblx0dGhpcy5tb3VzZURyYWdPbiA9IGZhbHNlO1xuXG5cdGlmICggdGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCApIHtcblxuXHRcdHRoaXMudmlld0hhbGZYID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xuXHRcdHRoaXMudmlld0hhbGZZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMjtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy52aWV3SGFsZlggPSB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuXHRcdHRoaXMudmlld0hhbGZZID0gdGhpcy5kb21FbGVtZW50Lm9mZnNldEhlaWdodCAvIDI7XG5cdFx0dGhpcy5kb21FbGVtZW50LnNldEF0dHJpYnV0ZSggJ3RhYmluZGV4JywgLTEgKTtcblxuXHR9XG5cblx0dGhpcy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuZG9tRWxlbWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cblx0XHRcdHRoaXMuZG9tRWxlbWVudC5mb2N1cygpO1xuXG5cdFx0fVxuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdGlmICggdGhpcy5hY3RpdmVMb29rICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5idXR0b24gKSB7XG5cblx0XHRcdFx0Y2FzZSAwOiB0aGlzLm1vdmVGb3J3YXJkID0gdHJ1ZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMjogdGhpcy5tb3ZlQmFja3dhcmQgPSB0cnVlOyBicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5tb3VzZURyYWdPbiA9IHRydWU7XG5cblx0fTtcblxuXHR0aGlzLm9uTW91c2VVcCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0aWYgKCB0aGlzLmFjdGl2ZUxvb2sgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmJ1dHRvbiApIHtcblxuXHRcdFx0XHRjYXNlIDA6IHRoaXMubW92ZUZvcndhcmQgPSBmYWxzZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMjogdGhpcy5tb3ZlQmFja3dhcmQgPSBmYWxzZTsgYnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMubW91c2VEcmFnT24gPSBmYWxzZTtcblxuXHR9O1xuXG5cdHRoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ICkge1xuXG5cdFx0XHR0aGlzLm1vdXNlWCA9IGV2ZW50LnBhZ2VYIC0gdGhpcy52aWV3SGFsZlg7XG5cdFx0XHR0aGlzLm1vdXNlWSA9IGV2ZW50LnBhZ2VZIC0gdGhpcy52aWV3SGFsZlk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLm1vdXNlWCA9IGV2ZW50LnBhZ2VYIC0gdGhpcy5kb21FbGVtZW50Lm9mZnNldExlZnQgLSB0aGlzLnZpZXdIYWxmWDtcblx0XHRcdHRoaXMubW91c2VZID0gZXZlbnQucGFnZVkgLSB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0VG9wIC0gdGhpcy52aWV3SGFsZlk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLm9uS2V5RG93biA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRzd2l0Y2goIGV2ZW50LmtleUNvZGUgKSB7XG5cblx0XHRcdGNhc2UgMzg6IC8qdXAqL1xuXHRcdFx0Y2FzZSA4NzogLypXKi8gdGhpcy5tb3ZlRm9yd2FyZCA9IHRydWU7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDM3OiAvKmxlZnQqL1xuXHRcdFx0Y2FzZSA2NTogLypBKi8gdGhpcy5tb3ZlTGVmdCA9IHRydWU7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDQwOiAvKmRvd24qL1xuXHRcdFx0Y2FzZSA4MzogLypTKi8gdGhpcy5tb3ZlQmFja3dhcmQgPSB0cnVlOyBicmVhaztcblxuXHRcdFx0Y2FzZSAzOTogLypyaWdodCovXG5cdFx0XHRjYXNlIDY4OiAvKkQqLyB0aGlzLm1vdmVSaWdodCA9IHRydWU7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDgyOiAvKlIqLyB0aGlzLm1vdmVVcCA9IHRydWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSA3MDogLypGKi8gdGhpcy5tb3ZlRG93biA9IHRydWU7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDgxOiAvKlEqLyB0aGlzLmZyZWV6ZSA9ICF0aGlzLmZyZWV6ZTsgYnJlYWs7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLm9uS2V5VXAgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0c3dpdGNoKCBldmVudC5rZXlDb2RlICkge1xuXG5cdFx0XHRjYXNlIDM4OiAvKnVwKi9cblx0XHRcdGNhc2UgODc6IC8qVyovIHRoaXMubW92ZUZvcndhcmQgPSBmYWxzZTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgMzc6IC8qbGVmdCovXG5cdFx0XHRjYXNlIDY1OiAvKkEqLyB0aGlzLm1vdmVMZWZ0ID0gZmFsc2U7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDQwOiAvKmRvd24qL1xuXHRcdFx0Y2FzZSA4MzogLypTKi8gdGhpcy5tb3ZlQmFja3dhcmQgPSBmYWxzZTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgMzk6IC8qcmlnaHQqL1xuXHRcdFx0Y2FzZSA2ODogLypEKi8gdGhpcy5tb3ZlUmlnaHQgPSBmYWxzZTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgODI6IC8qUiovIHRoaXMubW92ZVVwID0gZmFsc2U7IGJyZWFrO1xuXHRcdFx0Y2FzZSA3MDogLypGKi8gdGhpcy5tb3ZlRG93biA9IGZhbHNlOyBicmVhaztcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24oIGRlbHRhICkge1xuXHRcdHZhciBhY3R1YWxNb3ZlU3BlZWQgPSAwO1xuXHRcdGlmICggIXRoaXMuZnJlZXplICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuaGVpZ2h0U3BlZWQgKSB7XG5cblx0XHRcdFx0dmFyIHkgPSBUSFJFRS5NYXRoLmNsYW1wKCB0aGlzLm9iamVjdC5wb3NpdGlvbi55LCB0aGlzLmhlaWdodE1pbiwgdGhpcy5oZWlnaHRNYXggKTtcblx0XHRcdFx0dmFyIGhlaWdodERlbHRhID0geSAtIHRoaXMuaGVpZ2h0TWluO1xuXG5cdFx0XHRcdHRoaXMuYXV0b1NwZWVkRmFjdG9yID0gZGVsdGEgKiAoIGhlaWdodERlbHRhICogdGhpcy5oZWlnaHRDb2VmICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5hdXRvU3BlZWRGYWN0b3IgPSAwLjA7XG5cblx0XHRcdH1cblxuXHRcdFx0YWN0dWFsTW92ZVNwZWVkID0gZGVsdGEgKiB0aGlzLm1vdmVtZW50U3BlZWQ7XG5cblx0XHRcdGlmICggdGhpcy5tb3ZlRm9yd2FyZCB8fCAoIHRoaXMuYXV0b0ZvcndhcmQgJiYgIXRoaXMubW92ZUJhY2t3YXJkICkgKSB0aGlzLm9iamVjdC50cmFuc2xhdGVaKCAtICggYWN0dWFsTW92ZVNwZWVkICsgdGhpcy5hdXRvU3BlZWRGYWN0b3IgKSApO1xuXHRcdFx0aWYgKCB0aGlzLm1vdmVCYWNrd2FyZCApIHRoaXMub2JqZWN0LnRyYW5zbGF0ZVooIGFjdHVhbE1vdmVTcGVlZCApO1xuXG5cdFx0XHRpZiAoIHRoaXMubW92ZUxlZnQgKSB0aGlzLm9iamVjdC50cmFuc2xhdGVYKCAtIGFjdHVhbE1vdmVTcGVlZCApO1xuXHRcdFx0aWYgKCB0aGlzLm1vdmVSaWdodCApIHRoaXMub2JqZWN0LnRyYW5zbGF0ZVgoIGFjdHVhbE1vdmVTcGVlZCApO1xuXG5cdFx0XHRpZiAoIHRoaXMubW92ZVVwICkgdGhpcy5vYmplY3QudHJhbnNsYXRlWSggYWN0dWFsTW92ZVNwZWVkICk7XG5cdFx0XHRpZiAoIHRoaXMubW92ZURvd24gKSB0aGlzLm9iamVjdC50cmFuc2xhdGVZKCAtIGFjdHVhbE1vdmVTcGVlZCApO1xuXG5cdFx0XHR2YXIgYWN0dWFsTG9va1NwZWVkID0gZGVsdGEgKiB0aGlzLmxvb2tTcGVlZDtcblxuXHRcdFx0aWYgKCAhdGhpcy5hY3RpdmVMb29rICkge1xuXG5cdFx0XHRcdGFjdHVhbExvb2tTcGVlZCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5sb24gKz0gdGhpcy5tb3VzZVggKiBhY3R1YWxMb29rU3BlZWQ7XG5cdFx0XHRpZiggdGhpcy5sb29rVmVydGljYWwgKSB0aGlzLmxhdCAtPSB0aGlzLm1vdXNlWSAqIGFjdHVhbExvb2tTcGVlZDtcblxuXHRcdFx0dGhpcy5sYXQgPSBNYXRoLm1heCggLSA4NSwgTWF0aC5taW4oIDg1LCB0aGlzLmxhdCApICk7XG5cdFx0XHR0aGlzLnBoaSA9ICggOTAgLSB0aGlzLmxhdCApICogTWF0aC5QSSAvIDE4MDtcblx0XHRcdHRoaXMudGhldGEgPSB0aGlzLmxvbiAqIE1hdGguUEkgLyAxODA7XG5cblx0XHRcdHZhciB0YXJnZXRQb3NpdGlvbiA9IHRoaXMudGFyZ2V0LFxuXHRcdFx0XHRwb3NpdGlvbiA9IHRoaXMub2JqZWN0LnBvc2l0aW9uO1xuXG5cdFx0XHR0YXJnZXRQb3NpdGlvbi54ID0gcG9zaXRpb24ueCArIDEwMCAqIE1hdGguc2luKCB0aGlzLnBoaSApICogTWF0aC5jb3MoIHRoaXMudGhldGEgKTtcblx0XHRcdHRhcmdldFBvc2l0aW9uLnkgPSBwb3NpdGlvbi55ICsgMTAwICogTWF0aC5jb3MoIHRoaXMucGhpICk7XG5cdFx0XHR0YXJnZXRQb3NpdGlvbi56ID0gcG9zaXRpb24ueiArIDEwMCAqIE1hdGguc2luKCB0aGlzLnBoaSApICogTWF0aC5zaW4oIHRoaXMudGhldGEgKTtcblxuXHRcdH1cblxuXHRcdHZhciB2ZXJ0aWNhbExvb2tSYXRpbyA9IDE7XG5cblx0XHRpZiAoIHRoaXMuY29uc3RyYWluVmVydGljYWwgKSB7XG5cblx0XHRcdHZlcnRpY2FsTG9va1JhdGlvID0gTWF0aC5QSSAvICggdGhpcy52ZXJ0aWNhbE1heCAtIHRoaXMudmVydGljYWxNaW4gKTtcblxuXHRcdH1cblxuXHRcdHRoaXMubG9uICs9IHRoaXMubW91c2VYICogYWN0dWFsTG9va1NwZWVkO1xuXHRcdGlmKCB0aGlzLmxvb2tWZXJ0aWNhbCApIHRoaXMubGF0IC09IHRoaXMubW91c2VZICogYWN0dWFsTG9va1NwZWVkICogdmVydGljYWxMb29rUmF0aW87XG5cblx0XHR0aGlzLmxhdCA9IE1hdGgubWF4KCAtIDg1LCBNYXRoLm1pbiggODUsIHRoaXMubGF0ICkgKTtcblx0XHR0aGlzLnBoaSA9ICggOTAgLSB0aGlzLmxhdCApICogTWF0aC5QSSAvIDE4MDtcblxuXHRcdHRoaXMudGhldGEgPSB0aGlzLmxvbiAqIE1hdGguUEkgLyAxODA7XG5cblx0XHRpZiAoIHRoaXMuY29uc3RyYWluVmVydGljYWwgKSB7XG5cblx0XHRcdHRoaXMucGhpID0gVEhSRUUuTWF0aC5tYXBMaW5lYXIoIHRoaXMucGhpLCAwLCBNYXRoLlBJLCB0aGlzLnZlcnRpY2FsTWluLCB0aGlzLnZlcnRpY2FsTWF4ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgdGFyZ2V0UG9zaXRpb24gPSB0aGlzLnRhcmdldCxcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5vYmplY3QucG9zaXRpb247XG5cblx0XHR0YXJnZXRQb3NpdGlvbi54ID0gcG9zaXRpb24ueCArIDEwMCAqIE1hdGguc2luKCB0aGlzLnBoaSApICogTWF0aC5jb3MoIHRoaXMudGhldGEgKTtcblx0XHR0YXJnZXRQb3NpdGlvbi55ID0gcG9zaXRpb24ueSArIDEwMCAqIE1hdGguY29zKCB0aGlzLnBoaSApO1xuXHRcdHRhcmdldFBvc2l0aW9uLnogPSBwb3NpdGlvbi56ICsgMTAwICogTWF0aC5zaW4oIHRoaXMucGhpICkgKiBNYXRoLnNpbiggdGhpcy50aGV0YSApO1xuXG5cdFx0dGhpcy5vYmplY3QubG9va0F0KCB0YXJnZXRQb3NpdGlvbiApO1xuXG5cdH07XG5cblxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKCBldmVudCApIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgfSwgZmFsc2UgKTtcblxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIGJpbmQoIHRoaXMsIHRoaXMub25Nb3VzZU1vdmUgKSwgZmFsc2UgKTtcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBiaW5kKCB0aGlzLCB0aGlzLm9uTW91c2VEb3duICksIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIGJpbmQoIHRoaXMsIHRoaXMub25Nb3VzZVVwICksIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIGJpbmQoIHRoaXMsIHRoaXMub25LZXlEb3duICksIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBiaW5kKCB0aGlzLCB0aGlzLm9uS2V5VXAgKSwgZmFsc2UgKTtcblxuXHRmdW5jdGlvbiBiaW5kKCBzY29wZSwgZm4gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRmbi5hcHBseSggc2NvcGUsIGFyZ3VtZW50cyApO1xuXG5cdFx0fTtcblxuXHR9O1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlBhdGhDb250cm9scyA9IGZ1bmN0aW9uICggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHR0aGlzLmRvbUVsZW1lbnQgPSAoIGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCApID8gZG9tRWxlbWVudCA6IGRvY3VtZW50O1xuXG5cdHRoaXMuaWQgPSBcIlBhdGhDb250cm9sc1wiICsgVEhSRUUuUGF0aENvbnRyb2xzSWRDb3VudGVyICsrO1xuXG5cdC8vIEFQSVxuXG5cdHRoaXMuZHVyYXRpb24gPSAxMCAqIDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuXHR0aGlzLndheXBvaW50cyA9IFtdO1xuXG5cdHRoaXMudXNlQ29uc3RhbnRTcGVlZCA9IHRydWU7XG5cdHRoaXMucmVzYW1wbGluZ0NvZWYgPSA1MDtcblxuXHR0aGlzLmRlYnVnUGF0aCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXHR0aGlzLmRlYnVnRHVtbXkgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHR0aGlzLmFuaW1hdGlvblBhcmVudCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG5cdHRoaXMubG9va1NwZWVkID0gMC4wMDU7XG5cdHRoaXMubG9va1ZlcnRpY2FsID0gdHJ1ZTtcblx0dGhpcy5sb29rSG9yaXpvbnRhbCA9IHRydWU7XG5cdHRoaXMudmVydGljYWxBbmdsZU1hcCAgID0geyBzcmNSYW5nZTogWyAwLCAyICogTWF0aC5QSSBdLCBkc3RSYW5nZTogWyAwLCAyICogTWF0aC5QSSBdIH07XG5cdHRoaXMuaG9yaXpvbnRhbEFuZ2xlTWFwID0geyBzcmNSYW5nZTogWyAwLCAyICogTWF0aC5QSSBdLCBkc3RSYW5nZTogWyAwLCAyICogTWF0aC5QSSBdIH07XG5cblx0Ly8gaW50ZXJuYWxzXG5cblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHR0aGlzLm1vdXNlWCA9IDA7XG5cdHRoaXMubW91c2VZID0gMDtcblxuXHR0aGlzLmxhdCA9IDA7XG5cdHRoaXMubG9uID0gMDtcblxuXHR0aGlzLnBoaSA9IDA7XG5cdHRoaXMudGhldGEgPSAwO1xuXG5cdGlmICggdGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCApIHtcblxuXHRcdHRoaXMudmlld0hhbGZYID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xuXHRcdHRoaXMudmlld0hhbGZZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMjtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy52aWV3SGFsZlggPSB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuXHRcdHRoaXMudmlld0hhbGZZID0gdGhpcy5kb21FbGVtZW50Lm9mZnNldEhlaWdodCAvIDI7XG5cdFx0dGhpcy5kb21FbGVtZW50LnNldEF0dHJpYnV0ZSggJ3RhYmluZGV4JywgLTEgKTtcblxuXHR9XG5cblx0dmFyIFBJMiA9IE1hdGguUEkgKiAyLFxuXHRcdFBJMTgwID0gTWF0aC5QSSAvIDE4MDtcblxuXHQvLyBtZXRob2RzXG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG5cdFx0dmFyIHNyY1JhbmdlLCBkc3RSYW5nZTtcblxuXHRcdGlmKCB0aGlzLmxvb2tIb3Jpem9udGFsICkgdGhpcy5sb24gKz0gdGhpcy5tb3VzZVggKiB0aGlzLmxvb2tTcGVlZCAqIGRlbHRhO1xuXHRcdGlmKCB0aGlzLmxvb2tWZXJ0aWNhbCApICAgdGhpcy5sYXQgLT0gdGhpcy5tb3VzZVkgKiB0aGlzLmxvb2tTcGVlZCAqIGRlbHRhO1xuXG5cdFx0dGhpcy5sb24gPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIDM2MCwgdGhpcy5sb24gKSApO1xuXHRcdHRoaXMubGF0ID0gTWF0aC5tYXgoIC0gODUsIE1hdGgubWluKCA4NSwgdGhpcy5sYXQgKSApO1xuXG5cdFx0dGhpcy5waGkgPSAoIDkwIC0gdGhpcy5sYXQgKSAqIFBJMTgwO1xuXHRcdHRoaXMudGhldGEgPSB0aGlzLmxvbiAqIFBJMTgwO1xuXG5cdFx0dGhpcy5waGkgPSBub3JtYWxpemVfYW5nbGVfcmFkKCB0aGlzLnBoaSApO1xuXG5cdFx0Ly8gY29uc3RyYWluIHZlcnRpY2FsIGxvb2sgYW5nbGVcblxuXHRcdHNyY1JhbmdlID0gdGhpcy52ZXJ0aWNhbEFuZ2xlTWFwLnNyY1JhbmdlO1xuXHRcdGRzdFJhbmdlID0gdGhpcy52ZXJ0aWNhbEFuZ2xlTWFwLmRzdFJhbmdlO1xuXG5cdFx0dmFyIHRtcFBoaSA9IFRIUkVFLk1hdGgubWFwTGluZWFyKCB0aGlzLnBoaSwgc3JjUmFuZ2VbIDAgXSwgc3JjUmFuZ2VbIDEgXSwgZHN0UmFuZ2VbIDAgXSwgZHN0UmFuZ2VbIDEgXSApO1xuXHRcdHZhciB0bXBQaGlGdWxsUmFuZ2UgPSBkc3RSYW5nZVsgMSBdIC0gZHN0UmFuZ2VbIDAgXTtcblx0XHR2YXIgdG1wUGhpTm9ybWFsaXplZCA9ICggdG1wUGhpIC0gZHN0UmFuZ2VbIDAgXSApIC8gdG1wUGhpRnVsbFJhbmdlO1xuXG5cdFx0dGhpcy5waGkgPSBRdWFkcmF0aWNFYXNlSW5PdXQoIHRtcFBoaU5vcm1hbGl6ZWQgKSAqIHRtcFBoaUZ1bGxSYW5nZSArIGRzdFJhbmdlWyAwIF07XG5cblx0XHQvLyBjb25zdHJhaW4gaG9yaXpvbnRhbCBsb29rIGFuZ2xlXG5cblx0XHRzcmNSYW5nZSA9IHRoaXMuaG9yaXpvbnRhbEFuZ2xlTWFwLnNyY1JhbmdlO1xuXHRcdGRzdFJhbmdlID0gdGhpcy5ob3Jpem9udGFsQW5nbGVNYXAuZHN0UmFuZ2U7XG5cblx0XHR2YXIgdG1wVGhldGEgPSBUSFJFRS5NYXRoLm1hcExpbmVhciggdGhpcy50aGV0YSwgc3JjUmFuZ2VbIDAgXSwgc3JjUmFuZ2VbIDEgXSwgZHN0UmFuZ2VbIDAgXSwgZHN0UmFuZ2VbIDEgXSApO1xuXHRcdHZhciB0bXBUaGV0YUZ1bGxSYW5nZSA9IGRzdFJhbmdlWyAxIF0gLSBkc3RSYW5nZVsgMCBdO1xuXHRcdHZhciB0bXBUaGV0YU5vcm1hbGl6ZWQgPSAoIHRtcFRoZXRhIC0gZHN0UmFuZ2VbIDAgXSApIC8gdG1wVGhldGFGdWxsUmFuZ2U7XG5cblx0XHR0aGlzLnRoZXRhID0gUXVhZHJhdGljRWFzZUluT3V0KCB0bXBUaGV0YU5vcm1hbGl6ZWQgKSAqIHRtcFRoZXRhRnVsbFJhbmdlICsgZHN0UmFuZ2VbIDAgXTtcblxuXHRcdHZhciB0YXJnZXRQb3NpdGlvbiA9IHRoaXMudGFyZ2V0LnBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLm9iamVjdC5wb3NpdGlvbjtcblxuXHRcdHRhcmdldFBvc2l0aW9uLnggPSAxMDAgKiBNYXRoLnNpbiggdGhpcy5waGkgKSAqIE1hdGguY29zKCB0aGlzLnRoZXRhICk7XG5cdFx0dGFyZ2V0UG9zaXRpb24ueSA9IDEwMCAqIE1hdGguY29zKCB0aGlzLnBoaSApO1xuXHRcdHRhcmdldFBvc2l0aW9uLnogPSAxMDAgKiBNYXRoLnNpbiggdGhpcy5waGkgKSAqIE1hdGguc2luKCB0aGlzLnRoZXRhICk7XG5cblx0XHR0aGlzLm9iamVjdC5sb29rQXQoIHRoaXMudGFyZ2V0LnBvc2l0aW9uICk7XG5cblx0fTtcblxuXHR0aGlzLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdGlmICggdGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCApIHtcblxuXHRcdFx0dGhpcy5tb3VzZVggPSBldmVudC5wYWdlWCAtIHRoaXMudmlld0hhbGZYO1xuXHRcdFx0dGhpcy5tb3VzZVkgPSBldmVudC5wYWdlWSAtIHRoaXMudmlld0hhbGZZO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tb3VzZVggPSBldmVudC5wYWdlWCAtIHRoaXMuZG9tRWxlbWVudC5vZmZzZXRMZWZ0IC0gdGhpcy52aWV3SGFsZlg7XG5cdFx0XHR0aGlzLm1vdXNlWSA9IGV2ZW50LnBhZ2VZIC0gdGhpcy5kb21FbGVtZW50Lm9mZnNldFRvcCAtIHRoaXMudmlld0hhbGZZO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gdXRpbHNcblxuXHRmdW5jdGlvbiBub3JtYWxpemVfYW5nbGVfcmFkKCBhICkge1xuXG5cdFx0dmFyIGIgPSBhICUgUEkyO1xuXHRcdHJldHVybiBiID49IDAgPyBiIDogYiArIFBJMjtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGRpc3RhbmNlKCBhLCBiICkge1xuXG5cdFx0dmFyIGR4ID0gYVsgMCBdIC0gYlsgMCBdLFxuXHRcdFx0ZHkgPSBhWyAxIF0gLSBiWyAxIF0sXG5cdFx0XHRkeiA9IGFbIDIgXSAtIGJbIDIgXTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeiApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gUXVhZHJhdGljRWFzZUluT3V0ICggayApIHtcblxuXHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogayAqIGs7XG5cdFx0cmV0dXJuIC0gMC41ICogKCAtLWsgKiAoIGsgLSAyICkgLSAxICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBiaW5kKCBzY29wZSwgZm4gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRmbi5hcHBseSggc2NvcGUsIGFyZ3VtZW50cyApO1xuXG5cdFx0fTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXRBbmltYXRpb25QYXRoKCBwYXJlbnQsIHNwbGluZSwgbmFtZSwgZHVyYXRpb24gKSB7XG5cblx0XHR2YXIgYW5pbWF0aW9uRGF0YSA9IHtcblxuXHRcdCAgIG5hbWU6IG5hbWUsXG5cdFx0ICAgZnBzOiAwLjYsXG5cdFx0ICAgbGVuZ3RoOiBkdXJhdGlvbixcblxuXHRcdCAgIGhpZXJhcmNoeTogW11cblxuXHRcdH07XG5cblx0XHR2YXIgaSxcblx0XHRcdHBhcmVudEFuaW1hdGlvbiwgY2hpbGRBbmltYXRpb24sXG5cdFx0XHRwYXRoID0gc3BsaW5lLmdldENvbnRyb2xQb2ludHNBcnJheSgpLFxuXHRcdFx0c2wgPSBzcGxpbmUuZ2V0TGVuZ3RoKCksXG5cdFx0XHRwbCA9IHBhdGgubGVuZ3RoLFxuXHRcdFx0dCA9IDAsXG5cdFx0XHRmaXJzdCA9IDAsXG5cdFx0XHRsYXN0ICA9IHBsIC0gMTtcblxuXHRcdHBhcmVudEFuaW1hdGlvbiA9IHsgcGFyZW50OiAtMSwga2V5czogW10gfTtcblx0XHRwYXJlbnRBbmltYXRpb24ua2V5c1sgZmlyc3QgXSA9IHsgdGltZTogMCwgICAgICAgIHBvczogcGF0aFsgZmlyc3QgXSwgcm90OiBbIDAsIDAsIDAsIDEgXSwgc2NsOiBbIDEsIDEsIDEgXSB9O1xuXHRcdHBhcmVudEFuaW1hdGlvbi5rZXlzWyBsYXN0ICBdID0geyB0aW1lOiBkdXJhdGlvbiwgcG9zOiBwYXRoWyBsYXN0IF0sICByb3Q6IFsgMCwgMCwgMCwgMSBdLCBzY2w6IFsgMSwgMSwgMSBdIH07XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IHBsIC0gMTsgaSsrICkge1xuXG5cdFx0XHQvLyByZWFsIGRpc3RhbmNlIChhcHByb3hpbWF0aW9uIHZpYSBsaW5lYXIgc2VnbWVudHMpXG5cblx0XHRcdHQgPSBkdXJhdGlvbiAqIHNsLmNodW5rc1sgaSBdIC8gc2wudG90YWw7XG5cblx0XHRcdC8vIGVxdWFsIGRpc3RhbmNlXG5cblx0XHRcdC8vdCA9IGR1cmF0aW9uICogKCBpIC8gcGwgKTtcblxuXHRcdFx0Ly8gbGluZWFyIGRpc3RhbmNlXG5cblx0XHRcdC8vdCArPSBkdXJhdGlvbiAqIGRpc3RhbmNlKCBwYXRoWyBpIF0sIHBhdGhbIGkgLSAxIF0gKSAvIHNsLnRvdGFsO1xuXG5cdFx0XHRwYXJlbnRBbmltYXRpb24ua2V5c1sgaSBdID0geyB0aW1lOiB0LCBwb3M6IHBhdGhbIGkgXSB9O1xuXG5cdFx0fVxuXG5cdFx0YW5pbWF0aW9uRGF0YS5oaWVyYXJjaHlbIDAgXSA9IHBhcmVudEFuaW1hdGlvbjtcblxuXHRcdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkKCBhbmltYXRpb25EYXRhICk7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbiggcGFyZW50LCBuYW1lLCBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCwgZmFsc2UgKTtcblxuXHR9O1xuXG5cblx0ZnVuY3Rpb24gY3JlYXRlU3BsaW5lR2VvbWV0cnkoIHNwbGluZSwgbl9zdWIgKSB7XG5cblx0XHR2YXIgaSwgaW5kZXgsIHBvc2l0aW9uLFxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgc3BsaW5lLnBvaW50cy5sZW5ndGggKiBuX3N1YjsgaSArKyApIHtcblxuXHRcdFx0aW5kZXggPSBpIC8gKCBzcGxpbmUucG9pbnRzLmxlbmd0aCAqIG5fc3ViICk7XG5cdFx0XHRwb3NpdGlvbiA9IHNwbGluZS5nZXRQb2ludCggaW5kZXggKTtcblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIGkgXSA9IG5ldyBUSFJFRS5WZXJ0ZXgoIG5ldyBUSFJFRS5WZWN0b3IzKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoIHBhcmVudCwgc3BsaW5lICkge1xuXG5cdFx0dmFyIGxpbmVHZW8gPSBjcmVhdGVTcGxpbmVHZW9tZXRyeSggc3BsaW5lLCAxMCApLFxuXHRcdFx0cGFydGljbGVHZW8gPSBjcmVhdGVTcGxpbmVHZW9tZXRyeSggc3BsaW5lLCAxMCApLFxuXHRcdFx0bGluZU1hdCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZjAwMDAsIGxpbmV3aWR0aDogMyB9ICksXG5cdFx0XHRsaW5lT2JqID0gbmV3IFRIUkVFLkxpbmUoIGxpbmVHZW8sIGxpbmVNYXQgKSxcblx0XHRcdHBhcnRpY2xlT2JqID0gbmV3IFRIUkVFLlBhcnRpY2xlU3lzdGVtKCBwYXJ0aWNsZUdlbywgbmV3IFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmFhMDAsIHNpemU6IDMgfSApICk7XG5cblx0XHRsaW5lT2JqLnNjYWxlLnNldCggMSwgMSwgMSApO1xuXHRcdHBhcmVudC5hZGQoIGxpbmVPYmogKTtcblxuXHRcdHBhcnRpY2xlT2JqLnNjYWxlLnNldCggMSwgMSwgMSApO1xuXHRcdHBhcmVudC5hZGQoIHBhcnRpY2xlT2JqICk7XG5cblx0XHR2YXIgd2F5cG9pbnQsXG5cdFx0XHRnZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIDEsIDE2LCA4ICksXG5cdFx0XHRtYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4MDBmZjAwIH0gKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNwbGluZS5wb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR3YXlwb2ludCA9IG5ldyBUSFJFRS5NZXNoKCBnZW8sIG1hdCApO1xuXHRcdFx0d2F5cG9pbnQucG9zaXRpb24uY29weSggc3BsaW5lLnBvaW50c1sgaSBdICk7XG5cdFx0XHRwYXJlbnQuYWRkKCB3YXlwb2ludCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCApIHtcblxuXHRcdC8vIGNvbnN0cnVjdG9yXG5cblx0XHR0aGlzLnNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmUoKTtcblx0XHR0aGlzLnNwbGluZS5pbml0RnJvbUFycmF5KCB0aGlzLndheXBvaW50cyApO1xuXG5cdFx0aWYgKCB0aGlzLnVzZUNvbnN0YW50U3BlZWQgKSB7XG5cblx0XHRcdHRoaXMuc3BsaW5lLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCggdGhpcy5yZXNhbXBsaW5nQ29lZiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNyZWF0ZURlYnVnRHVtbXkgKSB7XG5cblx0XHRcdHZhciBkdW1teVBhcmVudE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoIHsgY29sb3I6IDB4MDA3N2ZmIH0gKSxcblx0XHRcdGR1bW15Q2hpbGRNYXRlcmlhbCAgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCggeyBjb2xvcjogMHgwMGZmMDAgfSApLFxuXHRcdFx0ZHVtbXlQYXJlbnRHZW8gPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KCAxMCwgMTAsIDIwICksXG5cdFx0XHRkdW1teUNoaWxkR2VvICA9IG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoIDIsIDIsIDEwICk7XG5cblx0XHRcdHRoaXMuYW5pbWF0aW9uUGFyZW50ID0gbmV3IFRIUkVFLk1lc2goIGR1bW15UGFyZW50R2VvLCBkdW1teVBhcmVudE1hdGVyaWFsICk7XG5cblx0XHRcdHZhciBkdW1teUNoaWxkID0gbmV3IFRIUkVFLk1lc2goIGR1bW15Q2hpbGRHZW8sIGR1bW15Q2hpbGRNYXRlcmlhbCApO1xuXHRcdFx0ZHVtbXlDaGlsZC5wb3NpdGlvbi5zZXQoIDAsIDEwLCAwICk7XG5cblx0XHRcdHRoaXMuYW5pbWF0aW9uID0gaW5pdEFuaW1hdGlvblBhdGgoIHRoaXMuYW5pbWF0aW9uUGFyZW50LCB0aGlzLnNwbGluZSwgdGhpcy5pZCwgdGhpcy5kdXJhdGlvbiApO1xuXG5cdFx0XHR0aGlzLmFuaW1hdGlvblBhcmVudC5hZGQoIHRoaXMub2JqZWN0ICk7XG5cdFx0XHR0aGlzLmFuaW1hdGlvblBhcmVudC5hZGQoIHRoaXMudGFyZ2V0ICk7XG5cdFx0XHR0aGlzLmFuaW1hdGlvblBhcmVudC5hZGQoIGR1bW15Q2hpbGQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuYW5pbWF0aW9uID0gaW5pdEFuaW1hdGlvblBhdGgoIHRoaXMuYW5pbWF0aW9uUGFyZW50LCB0aGlzLnNwbGluZSwgdGhpcy5pZCwgdGhpcy5kdXJhdGlvbiApO1xuXHRcdFx0dGhpcy5hbmltYXRpb25QYXJlbnQuYWRkKCB0aGlzLnRhcmdldCApO1xuXHRcdFx0dGhpcy5hbmltYXRpb25QYXJlbnQuYWRkKCB0aGlzLm9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNyZWF0ZURlYnVnUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlUGF0aCggdGhpcy5kZWJ1Z1BhdGgsIHRoaXMuc3BsaW5lICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIGJpbmQoIHRoaXMsIHRoaXMub25Nb3VzZU1vdmUgKSwgZmFsc2UgKTtcblxuXHR9O1xuXG59O1xuXG5USFJFRS5QYXRoQ29udHJvbHNJZENvdW50ZXIgPSAwO1xuLyoqXG4gKiBAYXV0aG9yIEphbWVzIEJhaWNvaWFudSAvIGh0dHA6Ly93d3cuYmFpY29pYW51LmNvbS9cbiAqL1xuXG5USFJFRS5GbHlDb250cm9scyA9IGZ1bmN0aW9uICggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cdGlmICggZG9tRWxlbWVudCApIHRoaXMuZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoICd0YWJpbmRleCcsIC0xICk7XG5cblx0Ly8gQVBJXG5cblx0dGhpcy5tb3ZlbWVudFNwZWVkID0gMS4wO1xuXHR0aGlzLnJvbGxTcGVlZCA9IDAuMDA1O1xuXG5cdHRoaXMuZHJhZ1RvTG9vayA9IGZhbHNlO1xuXHR0aGlzLmF1dG9Gb3J3YXJkID0gZmFsc2U7XG5cblx0Ly8gZGlzYWJsZSBkZWZhdWx0IHRhcmdldCBvYmplY3QgYmVoYXZpb3JcblxuXHR0aGlzLm9iamVjdC51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcblxuXHQvLyBpbnRlcm5hbHNcblxuXHR0aGlzLnRtcFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdHRoaXMubW91c2VTdGF0dXMgPSAwO1xuXG5cdHRoaXMubW92ZVN0YXRlID0geyB1cDogMCwgZG93bjogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIGZvcndhcmQ6IDAsIGJhY2s6IDAsIHBpdGNoVXA6IDAsIHBpdGNoRG93bjogMCwgeWF3TGVmdDogMCwgeWF3UmlnaHQ6IDAsIHJvbGxMZWZ0OiAwLCByb2xsUmlnaHQ6IDAgfTtcblx0dGhpcy5tb3ZlVmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKTtcblx0dGhpcy5yb3RhdGlvblZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICk7XG5cblx0dGhpcy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiB0aGlzWyBldmVudC50eXBlIF0gPT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0dGhpc1sgZXZlbnQudHlwZSBdKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5rZXlkb3duID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBldmVudC5hbHRLZXkgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHN3aXRjaCggZXZlbnQua2V5Q29kZSApIHtcblxuXHRcdFx0Y2FzZSAxNjogLyogc2hpZnQgKi8gdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IC4xOyBicmVhaztcblxuXHRcdFx0Y2FzZSA4NzogLypXKi8gdGhpcy5tb3ZlU3RhdGUuZm9yd2FyZCA9IDE7IGJyZWFrO1xuXHRcdFx0Y2FzZSA4MzogLypTKi8gdGhpcy5tb3ZlU3RhdGUuYmFjayA9IDE7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDY1OiAvKkEqLyB0aGlzLm1vdmVTdGF0ZS5sZWZ0ID0gMTsgYnJlYWs7XG5cdFx0XHRjYXNlIDY4OiAvKkQqLyB0aGlzLm1vdmVTdGF0ZS5yaWdodCA9IDE7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDgyOiAvKlIqLyB0aGlzLm1vdmVTdGF0ZS51cCA9IDE7IGJyZWFrO1xuXHRcdFx0Y2FzZSA3MDogLypGKi8gdGhpcy5tb3ZlU3RhdGUuZG93biA9IDE7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDM4OiAvKnVwKi8gdGhpcy5tb3ZlU3RhdGUucGl0Y2hVcCA9IDE7IGJyZWFrO1xuXHRcdFx0Y2FzZSA0MDogLypkb3duKi8gdGhpcy5tb3ZlU3RhdGUucGl0Y2hEb3duID0gMTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgMzc6IC8qbGVmdCovIHRoaXMubW92ZVN0YXRlLnlhd0xlZnQgPSAxOyBicmVhaztcblx0XHRcdGNhc2UgMzk6IC8qcmlnaHQqLyB0aGlzLm1vdmVTdGF0ZS55YXdSaWdodCA9IDE7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDgxOiAvKlEqLyB0aGlzLm1vdmVTdGF0ZS5yb2xsTGVmdCA9IDE7IGJyZWFrO1xuXHRcdFx0Y2FzZSA2OTogLypFKi8gdGhpcy5tb3ZlU3RhdGUucm9sbFJpZ2h0ID0gMTsgYnJlYWs7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZU1vdmVtZW50VmVjdG9yKCk7XG5cdFx0dGhpcy51cGRhdGVSb3RhdGlvblZlY3RvcigpO1xuXG5cdH07XG5cblx0dGhpcy5rZXl1cCA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdHN3aXRjaCggZXZlbnQua2V5Q29kZSApIHtcblxuXHRcdFx0Y2FzZSAxNjogLyogc2hpZnQgKi8gdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IDE7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDg3OiAvKlcqLyB0aGlzLm1vdmVTdGF0ZS5mb3J3YXJkID0gMDsgYnJlYWs7XG5cdFx0XHRjYXNlIDgzOiAvKlMqLyB0aGlzLm1vdmVTdGF0ZS5iYWNrID0gMDsgYnJlYWs7XG5cblx0XHRcdGNhc2UgNjU6IC8qQSovIHRoaXMubW92ZVN0YXRlLmxlZnQgPSAwOyBicmVhaztcblx0XHRcdGNhc2UgNjg6IC8qRCovIHRoaXMubW92ZVN0YXRlLnJpZ2h0ID0gMDsgYnJlYWs7XG5cblx0XHRcdGNhc2UgODI6IC8qUiovIHRoaXMubW92ZVN0YXRlLnVwID0gMDsgYnJlYWs7XG5cdFx0XHRjYXNlIDcwOiAvKkYqLyB0aGlzLm1vdmVTdGF0ZS5kb3duID0gMDsgYnJlYWs7XG5cblx0XHRcdGNhc2UgMzg6IC8qdXAqLyB0aGlzLm1vdmVTdGF0ZS5waXRjaFVwID0gMDsgYnJlYWs7XG5cdFx0XHRjYXNlIDQwOiAvKmRvd24qLyB0aGlzLm1vdmVTdGF0ZS5waXRjaERvd24gPSAwOyBicmVhaztcblxuXHRcdFx0Y2FzZSAzNzogLypsZWZ0Ki8gdGhpcy5tb3ZlU3RhdGUueWF3TGVmdCA9IDA7IGJyZWFrO1xuXHRcdFx0Y2FzZSAzOTogLypyaWdodCovIHRoaXMubW92ZVN0YXRlLnlhd1JpZ2h0ID0gMDsgYnJlYWs7XG5cblx0XHRcdGNhc2UgODE6IC8qUSovIHRoaXMubW92ZVN0YXRlLnJvbGxMZWZ0ID0gMDsgYnJlYWs7XG5cdFx0XHRjYXNlIDY5OiAvKkUqLyB0aGlzLm1vdmVTdGF0ZS5yb2xsUmlnaHQgPSAwOyBicmVhaztcblxuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlTW92ZW1lbnRWZWN0b3IoKTtcblx0XHR0aGlzLnVwZGF0ZVJvdGF0aW9uVmVjdG9yKCk7XG5cblx0fTtcblxuXHR0aGlzLm1vdXNlZG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdGlmICggdGhpcy5kb21FbGVtZW50ICE9PSBkb2N1bWVudCApIHtcblxuXHRcdFx0dGhpcy5kb21FbGVtZW50LmZvY3VzKCk7XG5cblx0XHR9XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0aWYgKCB0aGlzLmRyYWdUb0xvb2sgKSB7XG5cblx0XHRcdHRoaXMubW91c2VTdGF0dXMgKys7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5idXR0b24gKSB7XG5cblx0XHRcdFx0Y2FzZSAwOiB0aGlzLm9iamVjdC5tb3ZlRm9yd2FyZCA9IHRydWU7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6IHRoaXMub2JqZWN0Lm1vdmVCYWNrd2FyZCA9IHRydWU7IGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLm1vdXNlbW92ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdGlmICggIXRoaXMuZHJhZ1RvTG9vayB8fCB0aGlzLm1vdXNlU3RhdHVzID4gMCApIHtcblxuXHRcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyRGltZW5zaW9ucygpO1xuXHRcdFx0dmFyIGhhbGZXaWR0aCAgPSBjb250YWluZXIuc2l6ZVsgMCBdIC8gMjtcblx0XHRcdHZhciBoYWxmSGVpZ2h0ID0gY29udGFpbmVyLnNpemVbIDEgXSAvIDI7XG5cblx0XHRcdHRoaXMubW92ZVN0YXRlLnlhd0xlZnQgICA9IC0gKCAoIGV2ZW50LnBhZ2VYIC0gY29udGFpbmVyLm9mZnNldFsgMCBdICkgLSBoYWxmV2lkdGggICkgLyBoYWxmV2lkdGg7XG5cdFx0XHR0aGlzLm1vdmVTdGF0ZS5waXRjaERvd24gPSAgICggKCBldmVudC5wYWdlWSAtIGNvbnRhaW5lci5vZmZzZXRbIDEgXSApIC0gaGFsZkhlaWdodCApIC8gaGFsZkhlaWdodDtcblxuXHRcdFx0dGhpcy51cGRhdGVSb3RhdGlvblZlY3RvcigpO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5tb3VzZXVwID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdGlmICggdGhpcy5kcmFnVG9Mb29rICkge1xuXG5cdFx0XHR0aGlzLm1vdXNlU3RhdHVzIC0tO1xuXG5cdFx0XHR0aGlzLm1vdmVTdGF0ZS55YXdMZWZ0ID0gdGhpcy5tb3ZlU3RhdGUucGl0Y2hEb3duID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmJ1dHRvbiApIHtcblxuXHRcdFx0XHRjYXNlIDA6IHRoaXMubW92ZUZvcndhcmQgPSBmYWxzZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMjogdGhpcy5tb3ZlQmFja3dhcmQgPSBmYWxzZTsgYnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlUm90YXRpb25WZWN0b3IoKTtcblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24oIGRlbHRhICkge1xuXG5cdFx0dmFyIG1vdmVNdWx0ID0gZGVsdGEgKiB0aGlzLm1vdmVtZW50U3BlZWQ7XG5cdFx0dmFyIHJvdE11bHQgPSBkZWx0YSAqIHRoaXMucm9sbFNwZWVkO1xuXG5cdFx0dGhpcy5vYmplY3QudHJhbnNsYXRlWCggdGhpcy5tb3ZlVmVjdG9yLnggKiBtb3ZlTXVsdCApO1xuXHRcdHRoaXMub2JqZWN0LnRyYW5zbGF0ZVkoIHRoaXMubW92ZVZlY3Rvci55ICogbW92ZU11bHQgKTtcblx0XHR0aGlzLm9iamVjdC50cmFuc2xhdGVaKCB0aGlzLm1vdmVWZWN0b3IueiAqIG1vdmVNdWx0ICk7XG5cblx0XHR0aGlzLnRtcFF1YXRlcm5pb24uc2V0KCB0aGlzLnJvdGF0aW9uVmVjdG9yLnggKiByb3RNdWx0LCB0aGlzLnJvdGF0aW9uVmVjdG9yLnkgKiByb3RNdWx0LCB0aGlzLnJvdGF0aW9uVmVjdG9yLnogKiByb3RNdWx0LCAxICkubm9ybWFsaXplKCk7XG5cdFx0dGhpcy5vYmplY3QucXVhdGVybmlvbi5tdWx0aXBseVNlbGYoIHRoaXMudG1wUXVhdGVybmlvbiApO1xuXG5cdFx0dGhpcy5vYmplY3QubWF0cml4LnNldFBvc2l0aW9uKCB0aGlzLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdHRoaXMub2JqZWN0Lm1hdHJpeC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCB0aGlzLm9iamVjdC5xdWF0ZXJuaW9uICk7XG5cdFx0dGhpcy5vYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlTW92ZW1lbnRWZWN0b3IgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBmb3J3YXJkID0gKCB0aGlzLm1vdmVTdGF0ZS5mb3J3YXJkIHx8ICggdGhpcy5hdXRvRm9yd2FyZCAmJiAhdGhpcy5tb3ZlU3RhdGUuYmFjayApICkgPyAxIDogMDtcblxuXHRcdHRoaXMubW92ZVZlY3Rvci54ID0gKCAtdGhpcy5tb3ZlU3RhdGUubGVmdCAgICArIHRoaXMubW92ZVN0YXRlLnJpZ2h0ICk7XG5cdFx0dGhpcy5tb3ZlVmVjdG9yLnkgPSAoIC10aGlzLm1vdmVTdGF0ZS5kb3duICAgICsgdGhpcy5tb3ZlU3RhdGUudXAgKTtcblx0XHR0aGlzLm1vdmVWZWN0b3IueiA9ICggLWZvcndhcmQgKyB0aGlzLm1vdmVTdGF0ZS5iYWNrICk7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnbW92ZTonLCBbIHRoaXMubW92ZVZlY3Rvci54LCB0aGlzLm1vdmVWZWN0b3IueSwgdGhpcy5tb3ZlVmVjdG9yLnogXSApO1xuXG5cdH07XG5cblx0dGhpcy51cGRhdGVSb3RhdGlvblZlY3RvciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5yb3RhdGlvblZlY3Rvci54ID0gKCAtdGhpcy5tb3ZlU3RhdGUucGl0Y2hEb3duICsgdGhpcy5tb3ZlU3RhdGUucGl0Y2hVcCApO1xuXHRcdHRoaXMucm90YXRpb25WZWN0b3IueSA9ICggLXRoaXMubW92ZVN0YXRlLnlhd1JpZ2h0ICArIHRoaXMubW92ZVN0YXRlLnlhd0xlZnQgKTtcblx0XHR0aGlzLnJvdGF0aW9uVmVjdG9yLnogPSAoIC10aGlzLm1vdmVTdGF0ZS5yb2xsUmlnaHQgKyB0aGlzLm1vdmVTdGF0ZS5yb2xsTGVmdCApO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ3JvdGF0ZTonLCBbIHRoaXMucm90YXRpb25WZWN0b3IueCwgdGhpcy5yb3RhdGlvblZlY3Rvci55LCB0aGlzLnJvdGF0aW9uVmVjdG9yLnogXSApO1xuXG5cdH07XG5cblx0dGhpcy5nZXRDb250YWluZXJEaW1lbnNpb25zID0gZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAoIHRoaXMuZG9tRWxlbWVudCAhPSBkb2N1bWVudCApIHtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2l6ZVx0OiBbIHRoaXMuZG9tRWxlbWVudC5vZmZzZXRXaWR0aCwgdGhpcy5kb21FbGVtZW50Lm9mZnNldEhlaWdodCBdLFxuXHRcdFx0XHRvZmZzZXRcdDogWyB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0TGVmdCwgIHRoaXMuZG9tRWxlbWVudC5vZmZzZXRUb3AgXVxuXHRcdFx0fTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNpemVcdDogWyB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0IF0sXG5cdFx0XHRcdG9mZnNldFx0OiBbIDAsIDAgXVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGJpbmQoIHNjb3BlLCBmbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGZuLmFwcGx5KCBzY29wZSwgYXJndW1lbnRzICk7XG5cblx0XHR9O1xuXG5cdH07XG5cblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBiaW5kKCB0aGlzLCB0aGlzLm1vdXNlbW92ZSApLCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIGJpbmQoIHRoaXMsIHRoaXMubW91c2Vkb3duICksIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsICAgYmluZCggdGhpcywgdGhpcy5tb3VzZXVwICksIGZhbHNlICk7XG5cblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgYmluZCggdGhpcywgdGhpcy5rZXlkb3duICksIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCAgIGJpbmQoIHRoaXMsIHRoaXMua2V5dXAgKSwgZmFsc2UgKTtcblxuXHR0aGlzLnVwZGF0ZU1vdmVtZW50VmVjdG9yKCk7XG5cdHRoaXMudXBkYXRlUm90YXRpb25WZWN0b3IoKTtcblxufTtcbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuUm9sbENvbnRyb2xzID0gZnVuY3Rpb24gKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XG5cblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cblx0Ly8gQVBJXG5cblx0dGhpcy5tb3VzZUxvb2sgPSB0cnVlO1xuXHR0aGlzLmF1dG9Gb3J3YXJkID0gZmFsc2U7XG5cblx0dGhpcy5sb29rU3BlZWQgPSAxO1xuXHR0aGlzLm1vdmVtZW50U3BlZWQgPSAxO1xuXHR0aGlzLnJvbGxTcGVlZCA9IDE7XG5cblx0dGhpcy5jb25zdHJhaW5WZXJ0aWNhbCA9IFsgLTAuOSwgMC45IF07XG5cblx0Ly8gZGlzYWJsZSBkZWZhdWx0IHRhcmdldCBvYmplY3QgYmVoYXZpb3JcblxuXHR0aGlzLm9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0Ly8gaW50ZXJuYWxzXG5cblx0dGhpcy5mb3J3YXJkID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblx0dGhpcy5yb2xsID0gMDtcblxuXHR2YXIgeFRlbXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgeVRlbXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgelRlbXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgcm9sbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0dmFyIGRvUm9sbCA9IGZhbHNlLCByb2xsRGlyZWN0aW9uID0gMSwgZm9yd2FyZFNwZWVkID0gMCwgc2lkZVNwZWVkID0gMCwgdXBTcGVlZCA9IDA7XG5cblx0dmFyIG1vdXNlWCA9IDAsIG1vdXNlWSA9IDA7XG5cblx0dmFyIHdpbmRvd0hhbGZYID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xuXHR2YXIgd2luZG93SGFsZlkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xuXG5cdC8vIGN1c3RvbSB1cGRhdGVcblxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cblx0XHRpZiAoIHRoaXMubW91c2VMb29rICkge1xuXG5cdFx0XHR2YXIgYWN0dWFsTG9va1NwZWVkID0gZGVsdGEgKiB0aGlzLmxvb2tTcGVlZDtcblxuXHRcdFx0dGhpcy5yb3RhdGVIb3Jpem9udGFsbHkoIGFjdHVhbExvb2tTcGVlZCAqIG1vdXNlWCApO1xuXHRcdFx0dGhpcy5yb3RhdGVWZXJ0aWNhbGx5KCBhY3R1YWxMb29rU3BlZWQgKiBtb3VzZVkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBhY3R1YWxTcGVlZCA9IGRlbHRhICogdGhpcy5tb3ZlbWVudFNwZWVkO1xuXHRcdHZhciBmb3J3YXJkT3JBdXRvID0gKCBmb3J3YXJkU3BlZWQgPiAwIHx8ICggdGhpcy5hdXRvRm9yd2FyZCAmJiAhICggZm9yd2FyZFNwZWVkIDwgMCApICkgKSA/IDEgOiBmb3J3YXJkU3BlZWQ7XG5cblx0XHR0aGlzLm9iamVjdC50cmFuc2xhdGVaKCAtYWN0dWFsU3BlZWQgKiBmb3J3YXJkT3JBdXRvICk7XG5cdFx0dGhpcy5vYmplY3QudHJhbnNsYXRlWCggYWN0dWFsU3BlZWQgKiBzaWRlU3BlZWQgKTtcblx0XHR0aGlzLm9iamVjdC50cmFuc2xhdGVZKCBhY3R1YWxTcGVlZCAqIHVwU3BlZWQgKTtcblxuXHRcdGlmKCBkb1JvbGwgKSB7XG5cblx0XHRcdHRoaXMucm9sbCArPSB0aGlzLnJvbGxTcGVlZCAqIGRlbHRhICogcm9sbERpcmVjdGlvbjtcblxuXHRcdH1cblxuXHRcdC8vIGNhcCBmb3J3YXJkIHVwIC8gZG93blxuXG5cdFx0aWYoIHRoaXMuZm9yd2FyZC55ID4gdGhpcy5jb25zdHJhaW5WZXJ0aWNhbFsgMSBdICkge1xuXG5cdFx0XHR0aGlzLmZvcndhcmQueSA9IHRoaXMuY29uc3RyYWluVmVydGljYWxbIDEgXTtcblx0XHRcdHRoaXMuZm9yd2FyZC5ub3JtYWxpemUoKTtcblxuXHRcdH0gZWxzZSBpZiggdGhpcy5mb3J3YXJkLnkgPCB0aGlzLmNvbnN0cmFpblZlcnRpY2FsWyAwIF0gKSB7XG5cblx0XHRcdHRoaXMuZm9yd2FyZC55ID0gdGhpcy5jb25zdHJhaW5WZXJ0aWNhbFsgMCBdO1xuXHRcdFx0dGhpcy5mb3J3YXJkLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fVxuXG5cblx0XHQvLyBjb25zdHJ1Y3QgdW5yb2xsZWQgY2FtZXJhIG1hdHJpeFxuXG5cdFx0elRlbXAuY29weSggdGhpcy5mb3J3YXJkICk7XG5cdFx0eVRlbXAuc2V0KCAwLCAxLCAwICk7XG5cblx0XHR4VGVtcC5jcm9zcyggeVRlbXAsIHpUZW1wICkubm9ybWFsaXplKCk7XG5cdFx0eVRlbXAuY3Jvc3MoIHpUZW1wLCB4VGVtcCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0dGhpcy5vYmplY3QubWF0cml4Lm4xMSA9IHhUZW1wLng7IHRoaXMub2JqZWN0Lm1hdHJpeC5uMTIgPSB5VGVtcC54OyB0aGlzLm9iamVjdC5tYXRyaXgubjEzID0gelRlbXAueDtcblx0XHR0aGlzLm9iamVjdC5tYXRyaXgubjIxID0geFRlbXAueTsgdGhpcy5vYmplY3QubWF0cml4Lm4yMiA9IHlUZW1wLnk7IHRoaXMub2JqZWN0Lm1hdHJpeC5uMjMgPSB6VGVtcC55O1xuXHRcdHRoaXMub2JqZWN0Lm1hdHJpeC5uMzEgPSB4VGVtcC56OyB0aGlzLm9iamVjdC5tYXRyaXgubjMyID0geVRlbXAuejsgdGhpcy5vYmplY3QubWF0cml4Lm4zMyA9IHpUZW1wLno7XG5cblx0XHQvLyBjYWxjdWxhdGUgcm9sbCBtYXRyaXhcblxuXHRcdHJvbGxNYXRyaXguaWRlbnRpdHkoKTtcblx0XHRyb2xsTWF0cml4Lm4xMSA9IE1hdGguY29zKCB0aGlzLnJvbGwgKTsgcm9sbE1hdHJpeC5uMTIgPSAtTWF0aC5zaW4oIHRoaXMucm9sbCApO1xuXHRcdHJvbGxNYXRyaXgubjIxID0gTWF0aC5zaW4oIHRoaXMucm9sbCApOyByb2xsTWF0cml4Lm4yMiA9ICBNYXRoLmNvcyggdGhpcy5yb2xsICk7XG5cblx0XHQvLyBtdWx0aXBseSBjYW1lcmEgd2l0aCByb2xsXG5cblx0XHR0aGlzLm9iamVjdC5tYXRyaXgubXVsdGlwbHlTZWxmKCByb2xsTWF0cml4ICk7XG5cdFx0dGhpcy5vYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHQvLyBzZXQgcG9zaXRpb25cblxuXHRcdHRoaXMub2JqZWN0Lm1hdHJpeC5uMTQgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi54O1xuXHRcdHRoaXMub2JqZWN0Lm1hdHJpeC5uMjQgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi55O1xuXHRcdHRoaXMub2JqZWN0Lm1hdHJpeC5uMzQgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi56O1xuXG5cblx0fTtcblxuXHR0aGlzLnRyYW5zbGF0ZVggPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueCArPSB0aGlzLm9iamVjdC5tYXRyaXgubjExICogZGlzdGFuY2U7XG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueSArPSB0aGlzLm9iamVjdC5tYXRyaXgubjIxICogZGlzdGFuY2U7XG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueiArPSB0aGlzLm9iamVjdC5tYXRyaXgubjMxICogZGlzdGFuY2U7XG5cblx0fTtcblxuXHR0aGlzLnRyYW5zbGF0ZVkgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueCArPSB0aGlzLm9iamVjdC5tYXRyaXgubjEyICogZGlzdGFuY2U7XG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueSArPSB0aGlzLm9iamVjdC5tYXRyaXgubjIyICogZGlzdGFuY2U7XG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueiArPSB0aGlzLm9iamVjdC5tYXRyaXgubjMyICogZGlzdGFuY2U7XG5cblx0fTtcblxuXHR0aGlzLnRyYW5zbGF0ZVogPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueCAtPSB0aGlzLm9iamVjdC5tYXRyaXgubjEzICogZGlzdGFuY2U7XG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueSAtPSB0aGlzLm9iamVjdC5tYXRyaXgubjIzICogZGlzdGFuY2U7XG5cdFx0dGhpcy5vYmplY3QucG9zaXRpb24ueiAtPSB0aGlzLm9iamVjdC5tYXRyaXgubjMzICogZGlzdGFuY2U7XG5cblx0fTtcblxuXG5cdHRoaXMucm90YXRlSG9yaXpvbnRhbGx5ID0gZnVuY3Rpb24gKCBhbW91bnQgKSB7XG5cblx0XHQvLyBwbGVhc2Ugbm90ZSB0aGF0IHRoZSBhbW91bnQgaXMgTk9UIGRlZ3JlZXMsIGJ1dCBhIHNjYWxlIHZhbHVlXG5cblx0XHR4VGVtcC5zZXQoIHRoaXMub2JqZWN0Lm1hdHJpeC5uMTEsIHRoaXMub2JqZWN0Lm1hdHJpeC5uMjEsIHRoaXMub2JqZWN0Lm1hdHJpeC5uMzEgKTtcblx0XHR4VGVtcC5tdWx0aXBseVNjYWxhciggYW1vdW50ICk7XG5cblx0XHR0aGlzLmZvcndhcmQuc3ViU2VsZiggeFRlbXAgKTtcblx0XHR0aGlzLmZvcndhcmQubm9ybWFsaXplKCk7XG5cblx0fTtcblxuXHR0aGlzLnJvdGF0ZVZlcnRpY2FsbHkgPSBmdW5jdGlvbiAoIGFtb3VudCApIHtcblxuXHRcdC8vIHBsZWFzZSBub3RlIHRoYXQgdGhlIGFtb3VudCBpcyBOT1QgZGVncmVlcywgYnV0IGEgc2NhbGUgdmFsdWVcblxuXHRcdHlUZW1wLnNldCggdGhpcy5vYmplY3QubWF0cml4Lm4xMiwgdGhpcy5vYmplY3QubWF0cml4Lm4yMiwgdGhpcy5vYmplY3QubWF0cml4Lm4zMiApO1xuXHRcdHlUZW1wLm11bHRpcGx5U2NhbGFyKCBhbW91bnQgKTtcblxuXHRcdHRoaXMuZm9yd2FyZC5hZGRTZWxmKCB5VGVtcCApO1xuXHRcdHRoaXMuZm9yd2FyZC5ub3JtYWxpemUoKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIG9uS2V5RG93biggZXZlbnQgKSB7XG5cblx0XHRzd2l0Y2goIGV2ZW50LmtleUNvZGUgKSB7XG5cblx0XHRcdGNhc2UgMzg6IC8qdXAqL1xuXHRcdFx0Y2FzZSA4NzogLypXKi8gZm9yd2FyZFNwZWVkID0gMTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgMzc6IC8qbGVmdCovXG5cdFx0XHRjYXNlIDY1OiAvKkEqLyBzaWRlU3BlZWQgPSAtMTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgNDA6IC8qZG93biovXG5cdFx0XHRjYXNlIDgzOiAvKlMqLyBmb3J3YXJkU3BlZWQgPSAtMTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgMzk6IC8qcmlnaHQqL1xuXHRcdFx0Y2FzZSA2ODogLypEKi8gc2lkZVNwZWVkID0gMTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgODE6IC8qUSovIGRvUm9sbCA9IHRydWU7IHJvbGxEaXJlY3Rpb24gPSAxOyBicmVhaztcblx0XHRcdGNhc2UgNjk6IC8qRSovIGRvUm9sbCA9IHRydWU7IHJvbGxEaXJlY3Rpb24gPSAtMTsgYnJlYWs7XG5cblx0XHRcdGNhc2UgODI6IC8qUiovIHVwU3BlZWQgPSAxOyBicmVhaztcblx0XHRcdGNhc2UgNzA6IC8qRiovIHVwU3BlZWQgPSAtMTsgYnJlYWs7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBvbktleVVwKCBldmVudCApIHtcblxuXHRcdHN3aXRjaCggZXZlbnQua2V5Q29kZSApIHtcblxuXHRcdFx0Y2FzZSAzODogLyp1cCovXG5cdFx0XHRjYXNlIDg3OiAvKlcqLyBmb3J3YXJkU3BlZWQgPSAwOyBicmVhaztcblxuXHRcdFx0Y2FzZSAzNzogLypsZWZ0Ki9cblx0XHRcdGNhc2UgNjU6IC8qQSovIHNpZGVTcGVlZCA9IDA7IGJyZWFrO1xuXG5cdFx0XHRjYXNlIDQwOiAvKmRvd24qL1xuXHRcdFx0Y2FzZSA4MzogLypTKi8gZm9yd2FyZFNwZWVkID0gMDsgYnJlYWs7XG5cblx0XHRcdGNhc2UgMzk6IC8qcmlnaHQqL1xuXHRcdFx0Y2FzZSA2ODogLypEKi8gc2lkZVNwZWVkID0gMDsgYnJlYWs7XG5cblx0XHRcdGNhc2UgODE6IC8qUSovIGRvUm9sbCA9IGZhbHNlOyBicmVhaztcblx0XHRcdGNhc2UgNjk6IC8qRSovIGRvUm9sbCA9IGZhbHNlOyBicmVhaztcblxuXHRcdFx0Y2FzZSA4MjogLypSKi8gdXBTcGVlZCA9IDA7IGJyZWFrO1xuXHRcdFx0Y2FzZSA3MDogLypGKi8gdXBTcGVlZCA9IDA7IGJyZWFrO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xuXG5cdFx0bW91c2VYID0gKCBldmVudC5jbGllbnRYIC0gd2luZG93SGFsZlggKSAvIHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdG1vdXNlWSA9ICggZXZlbnQuY2xpZW50WSAtIHdpbmRvd0hhbGZZICkgLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBvbk1vdXNlRG93biAoIGV2ZW50ICkge1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LmJ1dHRvbiApIHtcblxuXHRcdFx0Y2FzZSAwOiBmb3J3YXJkU3BlZWQgPSAxOyBicmVhaztcblx0XHRcdGNhc2UgMjogZm9yd2FyZFNwZWVkID0gLTE7IGJyZWFrO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gb25Nb3VzZVVwICggZXZlbnQgKSB7XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0c3dpdGNoICggZXZlbnQuYnV0dG9uICkge1xuXG5cdFx0XHRjYXNlIDA6IGZvcndhcmRTcGVlZCA9IDA7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiBmb3J3YXJkU3BlZWQgPSAwOyBicmVhaztcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoIGV2ZW50ICkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBmYWxzZSApO1xuXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgb25LZXlVcCwgZmFsc2UgKTtcblxufTtcbi8qKlxuICogQGF1dGhvciBFYmVyaGFyZCBHcmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICovXG5cblRIUkVFLlRyYWNrYmFsbENvbnRyb2xzID0gZnVuY3Rpb24gKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XG5cblx0dmFyIF90aGlzID0gdGhpcyxcblx0U1RBVEUgPSB7IE5PTkUgOiAtMSwgUk9UQVRFIDogMCwgWk9PTSA6IDEsIFBBTiA6IDIgfTtcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0dGhpcy5kb21FbGVtZW50ID0gKCBkb21FbGVtZW50ICE9PSB1bmRlZmluZWQgKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblxuXHQvLyBBUElcblxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdHRoaXMuc2NyZWVuID0geyB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LCBvZmZzZXRMZWZ0OiAwLCBvZmZzZXRUb3A6IDAgfTtcblx0dGhpcy5yYWRpdXMgPSAoIHRoaXMuc2NyZWVuLndpZHRoICsgdGhpcy5zY3JlZW4uaGVpZ2h0ICkgLyA0O1xuXG5cdHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XG5cdHRoaXMuem9vbVNwZWVkID0gMS4yO1xuXHR0aGlzLnBhblNwZWVkID0gMC4zO1xuXG5cdHRoaXMubm9Sb3RhdGUgPSBmYWxzZTtcblx0dGhpcy5ub1pvb20gPSBmYWxzZTtcblx0dGhpcy5ub1BhbiA9IGZhbHNlO1xuXG5cdHRoaXMuc3RhdGljTW92aW5nID0gZmFsc2U7XG5cdHRoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IgPSAwLjI7XG5cblx0dGhpcy5taW5EaXN0YW5jZSA9IDA7XG5cdHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuXHR0aGlzLmtleXMgPSBbIDY1IC8qQSovLCA4MyAvKlMqLywgNjggLypEKi8gXTtcblxuXHQvLyBpbnRlcm5hbHNcblxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICk7XG5cblx0dmFyIF9rZXlQcmVzc2VkID0gZmFsc2UsXG5cdF9zdGF0ZSA9IFNUQVRFLk5PTkUsXG5cblx0X2V5ZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cblx0X3JvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0X3JvdGF0ZUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cblx0X3pvb21TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG5cdF96b29tRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcblxuXHRfcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuXHRfcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXG5cdC8vIG1ldGhvZHNcblxuXHR0aGlzLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdGlmICggdHlwZW9mIHRoaXNbIGV2ZW50LnR5cGUgXSA9PSAnZnVuY3Rpb24nICkge1xuXG5cdFx0XHR0aGlzWyBldmVudC50eXBlIF0oIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmdldE1vdXNlT25TY3JlZW4gPSBmdW5jdGlvbiggY2xpZW50WCwgY2xpZW50WSApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcblx0XHRcdCggY2xpZW50WCAtIF90aGlzLnNjcmVlbi5vZmZzZXRMZWZ0ICkgLyBfdGhpcy5yYWRpdXMgKiAwLjUsXG5cdFx0XHQoIGNsaWVudFkgLSBfdGhpcy5zY3JlZW4ub2Zmc2V0VG9wICkgLyBfdGhpcy5yYWRpdXMgKiAwLjVcblx0XHQpO1xuXG5cdH07XG5cblx0dGhpcy5nZXRNb3VzZVByb2plY3Rpb25PbkJhbGwgPSBmdW5jdGlvbiggY2xpZW50WCwgY2xpZW50WSApIHtcblxuXHRcdHZhciBtb3VzZU9uQmFsbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdFx0KCBjbGllbnRYIC0gX3RoaXMuc2NyZWVuLndpZHRoICogMC41IC0gX3RoaXMuc2NyZWVuLm9mZnNldExlZnQgKSAvIF90aGlzLnJhZGl1cyxcblx0XHRcdCggX3RoaXMuc2NyZWVuLmhlaWdodCAqIDAuNSArIF90aGlzLnNjcmVlbi5vZmZzZXRUb3AgLSBjbGllbnRZICkgLyBfdGhpcy5yYWRpdXMsXG5cdFx0XHQwLjBcblx0XHQpO1xuXG5cdFx0dmFyIGxlbmd0aCA9IG1vdXNlT25CYWxsLmxlbmd0aCgpO1xuXG5cdFx0aWYgKCBsZW5ndGggPiAxLjAgKSB7XG5cblx0XHRcdG1vdXNlT25CYWxsLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bW91c2VPbkJhbGwueiA9IE1hdGguc3FydCggMS4wIC0gbGVuZ3RoICogbGVuZ3RoICk7XG5cblx0XHR9XG5cblx0XHRfZXllLmNvcHkoIF90aGlzLm9iamVjdC5wb3NpdGlvbiApLnN1YlNlbGYoIF90aGlzLnRhcmdldCApO1xuXG5cdFx0dmFyIHByb2plY3Rpb24gPSBfdGhpcy5vYmplY3QudXAuY2xvbmUoKS5zZXRMZW5ndGgoIG1vdXNlT25CYWxsLnkgKTtcblx0XHRwcm9qZWN0aW9uLmFkZFNlbGYoIF90aGlzLm9iamVjdC51cC5jbG9uZSgpLmNyb3NzU2VsZiggX2V5ZSApLnNldExlbmd0aCggbW91c2VPbkJhbGwueCApICk7XG5cdFx0cHJvamVjdGlvbi5hZGRTZWxmKCBfZXllLnNldExlbmd0aCggbW91c2VPbkJhbGwueiApICk7XG5cblx0XHRyZXR1cm4gcHJvamVjdGlvbjtcblxuXHR9O1xuXG5cdHRoaXMucm90YXRlQ2FtZXJhID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgYW5nbGUgPSBNYXRoLmFjb3MoIF9yb3RhdGVTdGFydC5kb3QoIF9yb3RhdGVFbmQgKSAvIF9yb3RhdGVTdGFydC5sZW5ndGgoKSAvIF9yb3RhdGVFbmQubGVuZ3RoKCkgKTtcblxuXHRcdGlmICggYW5nbGUgKSB7XG5cblx0XHRcdHZhciBheGlzID0gKCBuZXcgVEhSRUUuVmVjdG9yMygpICkuY3Jvc3MoIF9yb3RhdGVTdGFydCwgX3JvdGF0ZUVuZCApLm5vcm1hbGl6ZSgpLFxuXHRcdFx0XHRxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdFx0YW5nbGUgKj0gX3RoaXMucm90YXRlU3BlZWQ7XG5cblx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgLWFuZ2xlICk7XG5cblx0XHRcdHF1YXRlcm5pb24ubXVsdGlwbHlWZWN0b3IzKCBfZXllICk7XG5cdFx0XHRxdWF0ZXJuaW9uLm11bHRpcGx5VmVjdG9yMyggX3RoaXMub2JqZWN0LnVwICk7XG5cblx0XHRcdHF1YXRlcm5pb24ubXVsdGlwbHlWZWN0b3IzKCBfcm90YXRlRW5kICk7XG5cblx0XHRcdGlmICggX3RoaXMuc3RhdGljTW92aW5nICkge1xuXG5cdFx0XHRcdF9yb3RhdGVTdGFydCA9IF9yb3RhdGVFbmQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSAqICggX3RoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IgLSAxLjAgKSApO1xuXHRcdFx0XHRxdWF0ZXJuaW9uLm11bHRpcGx5VmVjdG9yMyggX3JvdGF0ZVN0YXJ0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuem9vbUNhbWVyYSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGZhY3RvciA9IDEuMCArICggX3pvb21FbmQueSAtIF96b29tU3RhcnQueSApICogX3RoaXMuem9vbVNwZWVkO1xuXG5cdFx0aWYgKCBmYWN0b3IgIT09IDEuMCAmJiBmYWN0b3IgPiAwLjAgKSB7XG5cblx0XHRcdF9leWUubXVsdGlwbHlTY2FsYXIoIGZhY3RvciApO1xuXG5cdFx0XHRpZiAoIF90aGlzLnN0YXRpY01vdmluZyApIHtcblxuXHRcdFx0XHRfem9vbVN0YXJ0ID0gX3pvb21FbmQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3pvb21TdGFydC55ICs9ICggX3pvb21FbmQueSAtIF96b29tU3RhcnQueSApICogdGhpcy5keW5hbWljRGFtcGluZ0ZhY3RvcjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5wYW5DYW1lcmEgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBtb3VzZUNoYW5nZSA9IF9wYW5FbmQuY2xvbmUoKS5zdWJTZWxmKCBfcGFuU3RhcnQgKTtcblxuXHRcdGlmICggbW91c2VDaGFuZ2UubGVuZ3RoU3EoKSApIHtcblxuXHRcdFx0bW91c2VDaGFuZ2UubXVsdGlwbHlTY2FsYXIoIF9leWUubGVuZ3RoKCkgKiBfdGhpcy5wYW5TcGVlZCApO1xuXG5cdFx0XHR2YXIgcGFuID0gX2V5ZS5jbG9uZSgpLmNyb3NzU2VsZiggX3RoaXMub2JqZWN0LnVwICkuc2V0TGVuZ3RoKCBtb3VzZUNoYW5nZS54ICk7XG5cdFx0XHRwYW4uYWRkU2VsZiggX3RoaXMub2JqZWN0LnVwLmNsb25lKCkuc2V0TGVuZ3RoKCBtb3VzZUNoYW5nZS55ICkgKTtcblxuXHRcdFx0X3RoaXMub2JqZWN0LnBvc2l0aW9uLmFkZFNlbGYoIHBhbiApO1xuXHRcdFx0X3RoaXMudGFyZ2V0LmFkZFNlbGYoIHBhbiApO1xuXG5cdFx0XHRpZiAoIF90aGlzLnN0YXRpY01vdmluZyApIHtcblxuXHRcdFx0XHRfcGFuU3RhcnQgPSBfcGFuRW5kO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9wYW5TdGFydC5hZGRTZWxmKCBtb3VzZUNoYW5nZS5zdWIoIF9wYW5FbmQsIF9wYW5TdGFydCApLm11bHRpcGx5U2NhbGFyKCBfdGhpcy5keW5hbWljRGFtcGluZ0ZhY3RvciApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuY2hlY2tEaXN0YW5jZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdGlmICggIV90aGlzLm5vWm9vbSB8fCAhX3RoaXMubm9QYW4gKSB7XG5cblx0XHRcdGlmICggX3RoaXMub2JqZWN0LnBvc2l0aW9uLmxlbmd0aFNxKCkgPiBfdGhpcy5tYXhEaXN0YW5jZSAqIF90aGlzLm1heERpc3RhbmNlICkge1xuXG5cdFx0XHRcdF90aGlzLm9iamVjdC5wb3NpdGlvbi5zZXRMZW5ndGgoIF90aGlzLm1heERpc3RhbmNlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBfZXllLmxlbmd0aFNxKCkgPCBfdGhpcy5taW5EaXN0YW5jZSAqIF90aGlzLm1pbkRpc3RhbmNlICkge1xuXG5cdFx0XHRcdF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGQoIF90aGlzLnRhcmdldCwgX2V5ZS5zZXRMZW5ndGgoIF90aGlzLm1pbkRpc3RhbmNlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuXHRcdF9leWUuY29weSggX3RoaXMub2JqZWN0LnBvc2l0aW9uICkuc3ViU2VsZiggdGhpcy50YXJnZXQgKTtcblxuXHRcdGlmICggIV90aGlzLm5vUm90YXRlICkge1xuXG5cdFx0XHRfdGhpcy5yb3RhdGVDYW1lcmEoKTtcblxuXHRcdH1cblx0XHRcblx0XHRpZiAoICFfdGhpcy5ub1pvb20gKSB7XG5cblx0XHRcdF90aGlzLnpvb21DYW1lcmEoKTtcblxuXHRcdH1cblxuXHRcdGlmICggIV90aGlzLm5vUGFuICkge1xuXG5cdFx0XHRfdGhpcy5wYW5DYW1lcmEoKTtcblxuXHRcdH1cblxuXHRcdF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGQoIF90aGlzLnRhcmdldCwgX2V5ZSApO1xuXG5cdFx0X3RoaXMuY2hlY2tEaXN0YW5jZXMoKTtcblxuXHRcdF90aGlzLm9iamVjdC5sb29rQXQoIF90aGlzLnRhcmdldCApO1xuXG5cdH07XG5cblxuXHQvLyBsaXN0ZW5lcnNcblxuXHRmdW5jdGlvbiBrZXlkb3duKCBldmVudCApIHtcblxuXHRcdGlmICggISBfdGhpcy5lbmFibGVkICkgcmV0dXJuO1xuXG5cdFx0aWYgKCBfc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbIFNUQVRFLlJPVEFURSBdICYmICFfdGhpcy5ub1JvdGF0ZSApIHtcblxuXHRcdFx0X3N0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG5cdFx0fSBlbHNlIGlmICggZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1sgU1RBVEUuWk9PTSBdICYmICFfdGhpcy5ub1pvb20gKSB7XG5cblx0XHRcdF9zdGF0ZSA9IFNUQVRFLlpPT007XG5cblx0XHR9IGVsc2UgaWYgKCBldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzWyBTVEFURS5QQU4gXSAmJiAhX3RoaXMubm9QYW4gKSB7XG5cblx0XHRcdF9zdGF0ZSA9IFNUQVRFLlBBTjtcblxuXHRcdH1cblxuXHRcdGlmICggX3N0YXRlICE9PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRfa2V5UHJlc3NlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBrZXl1cCggZXZlbnQgKSB7XG5cblx0XHRpZiAoICEgX3RoaXMuZW5hYmxlZCApIHJldHVybjtcblxuXHRcdGlmICggX3N0YXRlICE9PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRfc3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gbW91c2Vkb3duKCBldmVudCApIHtcblxuXHRcdGlmICggISBfdGhpcy5lbmFibGVkICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdGlmICggX3N0YXRlID09PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRfc3RhdGUgPSBldmVudC5idXR0b247XG5cblx0XHRcdGlmICggX3N0YXRlID09PSBTVEFURS5ST1RBVEUgJiYgIV90aGlzLm5vUm90YXRlICkge1xuXG5cdFx0XHRcdF9yb3RhdGVTdGFydCA9IF9yb3RhdGVFbmQgPSBfdGhpcy5nZXRNb3VzZVByb2plY3Rpb25PbkJhbGwoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggX3N0YXRlID09PSBTVEFURS5aT09NICYmICFfdGhpcy5ub1pvb20gKSB7XG5cblx0XHRcdFx0X3pvb21TdGFydCA9IF96b29tRW5kID0gX3RoaXMuZ2V0TW91c2VPblNjcmVlbiggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAhdGhpcy5ub1BhbiApIHtcblxuXHRcdFx0XHRfcGFuU3RhcnQgPSBfcGFuRW5kID0gX3RoaXMuZ2V0TW91c2VPblNjcmVlbiggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBtb3VzZW1vdmUoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCAhIF90aGlzLmVuYWJsZWQgKSByZXR1cm47XG5cblx0XHRpZiAoIF9rZXlQcmVzc2VkICkge1xuXG5cdFx0XHRfcm90YXRlU3RhcnQgPSBfcm90YXRlRW5kID0gX3RoaXMuZ2V0TW91c2VQcm9qZWN0aW9uT25CYWxsKCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cdFx0XHRfem9vbVN0YXJ0ID0gX3pvb21FbmQgPSBfdGhpcy5nZXRNb3VzZU9uU2NyZWVuKCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cdFx0XHRfcGFuU3RhcnQgPSBfcGFuRW5kID0gX3RoaXMuZ2V0TW91c2VPblNjcmVlbiggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHRfa2V5UHJlc3NlZCA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBfc3RhdGUgPT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH0gZWxzZSBpZiAoIF9zdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICYmICFfdGhpcy5ub1JvdGF0ZSApIHtcblxuXHRcdFx0X3JvdGF0ZUVuZCA9IF90aGlzLmdldE1vdXNlUHJvamVjdGlvbk9uQmFsbCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fSBlbHNlIGlmICggX3N0YXRlID09PSBTVEFURS5aT09NICYmICFfdGhpcy5ub1pvb20gKSB7XG5cblx0XHRcdF96b29tRW5kID0gX3RoaXMuZ2V0TW91c2VPblNjcmVlbiggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fSBlbHNlIGlmICggX3N0YXRlID09PSBTVEFURS5QQU4gJiYgIV90aGlzLm5vUGFuICkge1xuXG5cdFx0XHRfcGFuRW5kID0gX3RoaXMuZ2V0TW91c2VPblNjcmVlbiggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gbW91c2V1cCggZXZlbnQgKSB7XG5cblx0XHRpZiAoICEgX3RoaXMuZW5hYmxlZCApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRfc3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdH07XG5cblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIGZ1bmN0aW9uICggZXZlbnQgKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH0sIGZhbHNlICk7XG5cblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBtb3VzZW1vdmUsIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgbW91c2Vkb3duLCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBtb3VzZXVwLCBmYWxzZSApO1xuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIGtleWRvd24sIGZhbHNlICk7XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBrZXl1cCwgZmFsc2UgKTtcblxufTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xuICovXG5cblRIUkVFLkN1YmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHNlZ21lbnRzV2lkdGgsIHNlZ21lbnRzSGVpZ2h0LCBzZWdtZW50c0RlcHRoLCBtYXRlcmlhbHMsIHNpZGVzICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR2YXIgc2NvcGUgPSB0aGlzLFxuXHR3aWR0aF9oYWxmID0gd2lkdGggLyAyLFxuXHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXG5cdGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XG5cblx0dmFyIG1weCwgbXB5LCBtcHosIG1ueCwgbW55LCBtbno7XG5cblx0aWYgKCBtYXRlcmlhbHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cblx0XHRcdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbHMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLm1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bXB4ID0gMDsgbW54ID0gMTsgbXB5ID0gMjsgbW55ID0gMzsgbXB6ID0gNDsgbW56ID0gNTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5tYXRlcmlhbHMgPSBbXTtcblxuXHR9XG5cblx0dGhpcy5zaWRlcyA9IHsgcHg6IHRydWUsIG54OiB0cnVlLCBweTogdHJ1ZSwgbnk6IHRydWUsIHB6OiB0cnVlLCBuejogdHJ1ZSB9O1xuXG5cdGlmICggc2lkZXMgIT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Zm9yICggdmFyIHMgaW4gc2lkZXMgKSB7XG5cblx0XHRcdGlmICggdGhpcy5zaWRlc1sgcyBdICE9IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLnNpZGVzWyBzIF0gPSBzaWRlc1sgcyBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuc2lkZXMucHggJiYgYnVpbGRQbGFuZSggJ3onLCAneScsIC0gMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aF9oYWxmLCBtcHggKTsgLy8gcHhcblx0dGhpcy5zaWRlcy5ueCAmJiBidWlsZFBsYW5lKCAneicsICd5JywgICAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIC0gd2lkdGhfaGFsZiwgbW54ICk7IC8vIG54XG5cdHRoaXMuc2lkZXMucHkgJiYgYnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgICAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodF9oYWxmLCBtcHkgKTsgLy8gcHlcblx0dGhpcy5zaWRlcy5ueSAmJiBidWlsZFBsYW5lKCAneCcsICd6JywgICAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgLSBoZWlnaHRfaGFsZiwgbW55ICk7IC8vIG55XG5cdHRoaXMuc2lkZXMucHogJiYgYnVpbGRQbGFuZSggJ3gnLCAneScsICAgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aF9oYWxmLCBtcHogKTsgLy8gcHpcblx0dGhpcy5zaWRlcy5ueiAmJiBidWlsZFBsYW5lKCAneCcsICd5JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGhfaGFsZiwgbW56ICk7IC8vIG56XG5cblx0ZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIG1hdGVyaWFsICkge1xuXG5cdFx0dmFyIHcsIGl4LCBpeSxcblx0XHRncmlkWCA9IHNlZ21lbnRzV2lkdGggfHwgMSxcblx0XHRncmlkWSA9IHNlZ21lbnRzSGVpZ2h0IHx8IDEsXG5cdFx0d2lkdGhfaGFsZiA9IHdpZHRoIC8gMixcblx0XHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXG5cdFx0b2Zmc2V0ID0gc2NvcGUudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0aWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcblxuXHRcdFx0dyA9ICd6JztcblxuXHRcdH0gZWxzZSBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd6JyApIHx8ICggdSA9PT0gJ3onICYmIHYgPT09ICd4JyApICkge1xuXG5cdFx0XHR3ID0gJ3knO1xuXHRcdFx0Z3JpZFkgPSBzZWdtZW50c0RlcHRoIHx8IDE7XG5cblx0XHR9IGVsc2UgaWYgKCAoIHUgPT09ICd6JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneicgKSApIHtcblxuXHRcdFx0dyA9ICd4Jztcblx0XHRcdGdyaWRYID0gc2VnbWVudHNEZXB0aCB8fCAxO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMSxcblx0XHRncmlkWTEgPSBncmlkWSArIDEsXG5cdFx0c2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFgsXG5cdFx0c2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWSxcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0bm9ybWFsWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xuXG5cdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHR2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcblx0XHRcdFx0dmVjdG9yWyB2IF0gPSAoIGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZiApICogdmRpcjtcblx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aDtcblxuXHRcdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCB2ZWN0b3IgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5KysgKSB7XG5cblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXgrKyApIHtcblxuXHRcdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlNCggYSArIG9mZnNldCwgYiArIG9mZnNldCwgYyArIG9mZnNldCwgZCArIG9mZnNldCApO1xuXHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XG5cdFx0XHRcdGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsO1xuXG5cdFx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcblx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlVWKCBpeCAvIGdyaWRYLCBpeSAvIGdyaWRZICksXG5cdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5VViggaXggLyBncmlkWCwgKCBpeSArIDEgKSAvIGdyaWRZICksXG5cdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5VViggKCBpeCArIDEgKSAvIGdyaWRYLCAoIGl5ICsgMSApIC8gZ3JpZFkgKSxcblx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlVWKCAoIGl4ICsgMSApIC8gZ3JpZFgsIGl5IC8gZ3JpZFkgKVxuXHRcdFx0XHRcdFx0XSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufTtcblxuVEhSRUUuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuVEhSRUUuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVHZW9tZXRyeTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgc2VnbWVudHNSYWRpdXMsIHNlZ21lbnRzSGVpZ2h0LCBvcGVuRW5kZWQgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHZhciByYWRpdXNUb3AgPSByYWRpdXNUb3AgIT0gbnVsbCA/IHJhZGl1c1RvcCA6IDIwO1xuXHR2YXIgcmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9IG51bGwgPyByYWRpdXNCb3R0b20gOiAyMDtcblx0dmFyIGhlaWdodCA9IGhlaWdodCB8fCAxMDA7XG5cdHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblx0dmFyIHNlZ21lbnRzWCA9IHNlZ21lbnRzUmFkaXVzIHx8IDg7XG5cdHZhciBzZWdtZW50c1kgPSBzZWdtZW50c0hlaWdodCB8fCAxO1xuXG5cdHZhciB4LCB5LCB2ZXJ0aWNlcyA9IFtdLCB1dnMgPSBbXTtcblxuXHRmb3IgKCB5ID0gMDsgeSA8PSBzZWdtZW50c1k7IHkgKysgKSB7XG5cblx0XHR2YXIgdmVydGljZXNSb3cgPSBbXTtcblx0XHR2YXIgdXZzUm93ID0gW107XG5cblx0XHR2YXIgdiA9IHkgLyBzZWdtZW50c1k7XG5cdFx0dmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xuXG5cdFx0Zm9yICggeCA9IDA7IHggPD0gc2VnbWVudHNYOyB4ICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IHggLyBzZWdtZW50c1g7XG5cblx0XHRcdHZhciB4cG9zID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKiBNYXRoLlBJICogMiApO1xuXHRcdFx0dmFyIHlwb3MgPSAtIHYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xuXHRcdFx0dmFyIHpwb3MgPSByYWRpdXMgKiBNYXRoLmNvcyggdSAqIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlcnRleCggbmV3IFRIUkVFLlZlY3RvcjMoIHhwb3MsIHlwb3MsIHpwb3MgKSApICk7XG5cblx0XHRcdHZlcnRpY2VzUm93LnB1c2goIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSApO1xuXHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5VViggdSwgdiApICk7XG5cblx0XHR9XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXHRcdHV2cy5wdXNoKCB1dnNSb3cgKTtcblxuXHR9XG5cblx0Zm9yICggeSA9IDA7IHkgPCBzZWdtZW50c1k7IHkgKysgKSB7XG5cblx0XHRmb3IgKCB4ID0gMDsgeCA8IHNlZ21lbnRzWDsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCBdO1xuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcblx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xuXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblxuXHRcdFx0Ly8gRklYTUU6IFRoZXNlIG5vcm1hbHMgYXJlbid0IHJpZ2h0IGZvciBjb25lcy5cblxuXHRcdFx0dmFyIG4xID0gdGhpcy52ZXJ0aWNlc1sgdjEgXS5wb3NpdGlvbi5jbG9uZSgpLnNldFkoIDAgKS5ub3JtYWxpemUoKTtcblx0XHRcdHZhciBuMiA9IHRoaXMudmVydGljZXNbIHYyIF0ucG9zaXRpb24uY2xvbmUoKS5zZXRZKCAwICkubm9ybWFsaXplKCk7XG5cdFx0XHR2YXIgbjMgPSB0aGlzLnZlcnRpY2VzWyB2MyBdLnBvc2l0aW9uLmNsb25lKCkuc2V0WSggMCApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dmFyIG40ID0gdGhpcy52ZXJ0aWNlc1sgdjQgXS5wb3NpdGlvbi5jbG9uZSgpLnNldFkoIDAgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0dmFyIHV2MSA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgKyAxIF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2NCA9IHV2c1sgeSBdWyB4ICsgMSBdLmNsb25lKCk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCB2MSwgdjIsIHYzLCB2NCwgWyBuMSwgbjIsIG4zLCBuNCBdICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MywgdXY0IF0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gdG9wIGNhcFxuXG5cdGlmICggIW9wZW5FbmRlZCAmJiByYWRpdXNUb3AgPiAwICkge1xuXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgaGVpZ2h0SGFsZiwgMCApICkgKTtcblxuXHRcdGZvciAoIHggPSAwOyB4IDwgc2VnbWVudHNYOyB4ICsrICkge1xuXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgMCBdWyB4IF07XG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdO1xuXHRcdFx0dmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG5cdFx0XHR2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblx0XHRcdHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cblx0XHRcdHZhciB1djEgPSB1dnNbIDAgXVsgeCBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYyID0gdXZzWyAwIF1bIHggKyAxIF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djMgPSBuZXcgVEhSRUUuVVYoIHV2Mi51LCAwICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBib3R0b20gY2FwXG5cblx0aWYgKCAhb3BlbkVuZGVkICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZXJ0ZXgoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIGhlaWdodEhhbGYsIDAgKSApICk7XG5cblx0XHRmb3IgKCB4ID0gMDsgeCA8IHNlZ21lbnRzWDsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlVWKCB1djIudSwgMSApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0gKSApO1xuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzIF0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn1cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN5bGluZGVyR2VvbWV0cnk7XG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIHNpemU6IFx0XHRcdDxmbG9hdD4sIFx0Ly8gc2l6ZSBvZiB0aGUgdGV4dFxuICogIGhlaWdodDogXHRcdDxmbG9hdD4sIFx0Ly8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxuICogIGN1cnZlU2VnbWVudHM6IFx0PGludD4sXHRcdC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICogIHN0ZXBzOiBcdFx0XHQ8aW50PixcdFx0Ly8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnNcbiAqXG4gKiAgZm9udDogXHRcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgbmFtZVxuICogIHdlaWdodDogXHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHdlaWdodCAobm9ybWFsLCBib2xkKVxuICogIHN0eWxlOiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBzdHlsZSAgKG5vcm1hbCwgaXRhbGljcylcbiAqXG4gKiAgYmV2ZWxFbmFibGVkOlx0PGJvb2w+LFx0XHRcdC8vIHR1cm4gb24gYmV2ZWxcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgXHRcdC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXG4gKiAgYmV2ZWxTaXplOlx0XHQ8ZmxvYXQ+LCBcdFx0Ly8gaG93IGZhciBmcm9tIHRleHQgb3V0bGluZSBpcyBiZXZlbFxuICogIGJldmVsU2VnbWVudHM6XHQ8aW50PiwgXHRcdFx0Ly8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xuICpcbiAqICBleHRydWRlUGF0aDpcdDxUSFJFRS5DdXJ2ZVBhdGg+XHQvLyBwYXRoIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmdcbiAqICBiZW5kUGF0aDpcdFx0PFRIUkVFLkN1cnZlUGF0aD4gXHQvLyBwYXRoIHRvIGJlbmQgdGhlIGdlb21ldHJ5IGFyb3VuZFxuICpcbiAqICBtYXRlcmlhbDpcdFx0IDxUSFJFRS5NYXRlcmlhbD5cdC8vIG1hdGVyaWFsIGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xuICogIGV4dHJ1ZGVNYXRlcmlhbDogPFRIUkVFLk1hdGVyaWFsPlx0Ly8gbWF0ZXJpYWwgZm9yIGV4dHJ1c2lvbiBhbmQgYmV2ZWxlZCBmYWNlc1xuICpcbiAqICB9XG4gICoqL1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkgPSBmdW5jdGlvbiggc2hhcGVzLCBvcHRpb25zICkge1xuXG5cdGlmKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xuXG5cdFx0c2hhcGVzID0gW107XG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0c2hhcGVzID0gc2hhcGVzIGluc3RhbmNlb2YgQXJyYXkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xuXG5cdHZhciBzLCBzbCA9IHNoYXBlcy5sZW5ndGgsIHNoYXBlO1xuXG5cdHRoaXMuc2hhcGViYiA9IHNoYXBlc1sgc2wgLSAxIF0uZ2V0Qm91bmRpbmdCb3goKTtcblxuXHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xuXG5cdFx0c2hhcGUgPSBzaGFwZXNbIHMgXTtcblxuXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XG5cblx0fVxuXG5cblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0Ly8gY2FuJ3QgcmVhbGx5IHVzZSBhdXRvbWF0aWMgdmVydGV4IG5vcm1hbHNcblx0Ly8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXG5cdC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcblxuXHQvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHQvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcblxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTtcblxuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oIHNoYXBlLCBvcHRpb25zICkge1xuXG5cdHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XG5cblx0dmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXG5cdHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcblx0dmFyIGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cblx0dmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXG5cblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXG5cdHZhciBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXG5cdHZhciBiZW5kUGF0aCA9IG9wdGlvbnMuYmVuZFBhdGg7XG5cblx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcblx0dmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblxuXHR2YXIgdXNlU3BhY2VkUG9pbnRzID0gb3B0aW9ucy51c2VTcGFjZWRQb2ludHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudXNlU3BhY2VkUG9pbnRzIDogZmFsc2U7XG5cblx0dmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcblx0dmFyIGV4dHJ1ZGVNYXRlcmlhbCA9IG9wdGlvbnMuZXh0cnVkZU1hdGVyaWFsO1xuXG5cdHZhciBzaGFwZWJiID0gdGhpcy5zaGFwZWJiO1xuXHQvL3NoYXBlYmIgPSBzaGFwZS5nZXRCb3VuZGluZ0JveCgpO1xuXG5cblx0aWYgKCBleHRydWRlUGF0aCApIHtcblxuXHRcdGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblx0XHRzdGVwcyA9IGV4dHJ1ZGVQdHMubGVuZ3RoO1xuXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuXHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuXHR9XG5cblx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0aWYgKCAhYmV2ZWxFbmFibGVkICkge1xuXG5cdFx0YmV2ZWxTZWdtZW50cyA9IDA7XG5cdFx0YmV2ZWxUaGlja25lc3MgPSAwO1xuXHRcdGJldmVsU2l6ZSA9IDA7XG5cblx0fVxuXG5cblx0Ly8gVE9ETywgZXh0cnVkZSBieSBwYXRoJ3MgdGFuZ2VudHM/IGFsc28gdmlhIDNkIHBhdGg/XG5cblx0Ly8gVmFyaWFibGVzIGluaXRhbGl6YXRpb25cblxuXHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cdHZhciBiZXZlbFBvaW50cyA9IFtdO1xuXG5cdHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuXG5cdGlmICggYmVuZFBhdGggKSB7XG5cblx0XHRzaGFwZS5hZGRXcmFwUGF0aCggYmVuZFBhdGggKTtcblxuXHR9XG5cblx0dmFyIHNoYXBlUG9pbnRzO1xuXG5cdGlmICggIXVzZVNwYWNlZFBvaW50cyApIHtcblxuXHQgIFx0c2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0QWxsUG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7IC8vXG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFFOIC0gV291bGQgaXQgYmUgYmV0dGVyIHRvIHBhc3MgdXNlU3BhY2VQb2ludHMgcGFyYW1ldGVyIHRvIHNoYXBlLCBqdXN0IGxpa2UgYmVuZHBhdGggP1xuXG5cdFx0c2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0QWxsU3BhY2VkUG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICkgLy8gZm9yIHBvaW50cyB3aXRoIGVxdWFsIGRpdmlzaW9uc1xuXG5cdH1cblxuICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuXHR2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblxuXHR2YXIgcmV2ZXJzZSA9ICFUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKSA7XG5cblx0aWYgKCByZXZlcnNlICkge1xuXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cblx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcblxuXHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXG5cblx0fVxuXG5cblx0dmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSAoIHZlcnRpY2VzLCBob2xlcyApO1xuXHQvL3ZhciBmYWNlcyA9IFRIUkVFLlNoYXBlLlV0aWxzLnRyaWFuZ3VsYXRlMiggdmVydGljZXMsIGhvbGVzICk7XG5cblx0Ly8gV291bGQgaXQgYmUgYmV0dGVyIHRvIG1vdmUgcG9pbnRzIGFmdGVyIHRyaWFuZ3VsYXRpb24/XG5cdC8vIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdEFsbFBvaW50c1dpdGhCZW5kKCBjdXJ2ZVNlZ21lbnRzLCBiZW5kUGF0aCApO1xuXHQvLyBcdHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdC8vIFx0aG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblxuXHQvL2NvbnNvbGUubG9nKGZhY2VzKTtcblxuXHQvLy8vXG5cdC8vLyAgIEhhbmRsZSBWZXJ0aWNlc1xuXHQvLy8vXG5cblx0dmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcblxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7ICBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcblxuXHR9XG5cblxuXHR2YXIgaSwgaWw7XG5cblx0ZnVuY3Rpb24gc2NhbGVQdDIgKCBwdCwgdmVjLCBzaXplICkge1xuXG5cdFx0aWYgKCAhdmVjICkgY29uc29sZS5sb2coIFwiZGllXCIgKTtcblxuXHRcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZFNlbGYoIHB0ICk7XG5cblx0fVxuXG5cdHZhciBiLCBicywgdCwgeixcblx0XHR2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxuXHRcdGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGgsXG5cdFx0Y29udCwgY2xlbiA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cblx0Ly8tLS0tLS1cblx0Ly8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxuXHQvL1xuXG5cdHZhciBSQURfVE9fREVHUkVFUyA9IDE4MCAvIE1hdGguUEk7XG5cblxuXHRmdW5jdGlvbiBnZXRCZXZlbFZlYyggcHRfaSwgcHRfaiwgcHRfayApIHtcblxuXHRcdC8vIEFsZ29yaXRobSAyXG5cblx0XHRyZXR1cm4gZ2V0QmV2ZWxWZWMyKCBwdF9pLCBwdF9qLCBwdF9rICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJldmVsVmVjMSggcHRfaSwgcHRfaiwgcHRfayApIHtcblxuXHRcdHZhciBhbmdsZWEgPSBNYXRoLmF0YW4yKCBwdF9qLnkgLSBwdF9pLnksIHB0X2oueCAtIHB0X2kueCApO1xuXHRcdHZhciBhbmdsZWIgPSBNYXRoLmF0YW4yKCBwdF9rLnkgLSBwdF9pLnksIHB0X2sueCAtIHB0X2kueCApO1xuXG5cdFx0aWYgKCBhbmdsZWEgPiBhbmdsZWIgKSB7XG5cblx0XHRcdGFuZ2xlYiArPSBNYXRoLlBJICogMjtcblxuXHRcdH1cblxuXHRcdHZhciBhbmdsZWMgPSAoIGFuZ2xlYSArIGFuZ2xlYiApIC8gMjtcblxuXG5cdFx0Ly9jb25zb2xlLmxvZygnYW5nbGUxJywgYW5nbGVhICogUkFEX1RPX0RFR1JFRVMsJ2FuZ2xlMicsIGFuZ2xlYiAqIFJBRF9UT19ERUdSRUVTLCAnYW5nbGVjJywgYW5nbGVjICpSQURfVE9fREVHUkVFUyk7XG5cblx0XHR2YXIgeCA9IC0gTWF0aC5jb3MoIGFuZ2xlYyApO1xuXHRcdHZhciB5ID0gLSBNYXRoLnNpbiggYW5nbGVjICk7XG5cblx0XHR2YXIgdmVjID0gbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKTsgLy8ubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdmVjO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCZXZlbFZlYzIoIHB0X2ksIHB0X2osIHB0X2sgKSB7XG5cblx0XHR2YXIgYSA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3YxLFxuXHRcdFx0YiA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3YyLFxuXHRcdFx0dl9oYXQgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnkuX192Myxcblx0XHRcdHdfaGF0ID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjQsXG5cdFx0XHRwID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjUsXG5cdFx0XHRxID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjYsXG5cdFx0XHR2LCB3LFxuXHRcdFx0dl9kb3Rfd19oYXQsIHFfc3ViX3BfZG90X3dfaGF0LFxuXHRcdFx0cywgaW50ZXJzZWN0aW9uO1xuXG5cdFx0Ly8gZ29vZCByZWFkaW5nIGZvciBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uXG5cdFx0Ly8gaHR0cDovL3NwdXRzb2Z0LmNvbS9ibG9nLzIwMTAvMDMvbGluZS1saW5lLWludGVyc2VjdGlvbi5odG1sXG5cblx0XHQvLyBkZWZpbmUgYSBhcyB2ZWN0b3Igai0+aVxuXHRcdC8vIGRlZmluZSBiIGFzIHZlY3RvdCBrLT5pXG5cblx0XHRhLnNldCggcHRfaS54IC0gcHRfai54LCBwdF9pLnkgLSBwdF9qLnkgKTtcblx0XHRiLnNldCggcHRfaS54IC0gcHRfay54LCBwdF9pLnkgLSBwdF9rLnkgKTtcblxuXHRcdC8vIGdldCB1bml0IHZlY3RvcnNcblxuXHRcdHYgPSBhLm5vcm1hbGl6ZSgpO1xuXHRcdHcgPSBiLm5vcm1hbGl6ZSgpO1xuXG5cdFx0Ly8gbm9ybWFscyBmcm9tIHB0IGlcblxuXHRcdHZfaGF0LnNldCggLXYueSwgdi54ICk7XG5cdFx0d19oYXQuc2V0KCB3LnksIC13LnggKTtcblxuXHRcdC8vIHB0cyBmcm9tIGlcblxuXHRcdHAuY29weSggcHRfaSApLmFkZFNlbGYoIHZfaGF0ICk7XG5cdFx0cS5jb3B5KCBwdF9pICkuYWRkU2VsZiggd19oYXQgKTtcblxuXHRcdGlmICggcC5lcXVhbHMoIHEgKSApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBzdHJhaWdodFwiKTtcblx0XHRcdHJldHVybiB3X2hhdC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gUG9pbnRzIGZyb20gaiwgay4gaGVscHMgcHJldmVudHMgcG9pbnRzIGNyb3NzIG92ZXJvdmVyIG1vc3Qgb2YgdGhlIHRpbWVcblxuXHRcdHAuY29weSggcHRfaiApLmFkZFNlbGYoIHZfaGF0ICk7XG5cdFx0cS5jb3B5KCBwdF9rICkuYWRkU2VsZiggd19oYXQgKTtcblxuXHRcdHZfZG90X3dfaGF0ID0gdi5kb3QoIHdfaGF0ICk7XG5cdFx0cV9zdWJfcF9kb3Rfd19oYXQgPSBxLnN1YlNlbGYoIHAgKS5kb3QoIHdfaGF0ICk7XG5cblx0XHQvLyBXZSBzaG91bGQgbm90IHJlYWNoIHRoZXNlIGNvbmRpdGlvbnNcblxuXHRcdGlmICggdl9kb3Rfd19oYXQgPT09IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBcIkVpdGhlciBpbmZpbml0ZSBvciBubyBzb2x1dGlvbnMhXCIgKTtcblxuXHRcdFx0aWYgKCBxX3N1Yl9wX2RvdF93X2hhdCA9PT0gMCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmxvZyggXCJJdHMgZmluaXRlIHNvbHV0aW9ucy5cIiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCBcIlRvbyBiYWQsIG5vIHNvbHV0aW9ucy5cIiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzID0gcV9zdWJfcF9kb3Rfd19oYXQgLyB2X2RvdF93X2hhdDtcblxuXHRcdGlmICggcyA8IDAgKSB7XG5cblx0XHRcdC8vIGluIGNhc2Ugb2YgZW1lcmdlY3ksIHJldmVydCB0byBhbGdvcml0aG0gMS5cblxuXHRcdFx0cmV0dXJuIGdldEJldmVsVmVjMSggcHRfaSwgcHRfaiwgcHRfayApO1xuXG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0aW9uID0gdi5tdWx0aXBseVNjYWxhciggcyApLmFkZFNlbGYoIHAgKTtcblxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb24uc3ViU2VsZiggcHRfaSApLmNsb25lKCk7IC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG5cblx0fVxuXG5cdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbC0xLCBrID0gaSArIDE7IGkgPCBpbDsgaSsrLCBqKyssIGsrKyApIHtcblxuXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cblx0XHR2YXIgcHRfaSA9IGNvbnRvdXJbIGkgXTtcblx0XHR2YXIgcHRfaiA9IGNvbnRvdXJbIGogXTtcblx0XHR2YXIgcHRfayA9IGNvbnRvdXJbIGsgXTtcblxuXHRcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXT0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcblxuXHR9XG5cblx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xuXG5cdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSsrLCBqKyssIGsrKyApIHtcblxuXHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG5cdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF09IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XG5cblx0XHR9XG5cblx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cdFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcblxuXHR9XG5cblxuXHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcblxuXHRmb3IgKCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xuXG5cdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuXHRcdHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcblxuXHRcdC8veiA9IGJldmVsVGhpY2tuZXNzICogdDtcblx0XHRicyA9IGJldmVsU2l6ZSAqICggTWF0aC5zaW4gKCB0ICogTWF0aC5QSS8yICkgKSA7IC8vIGN1cnZlZFxuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiB0IDsgLy8gbGluZWFyXG5cblx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblx0XHRcdC8vdmVydCA9IHNjYWxlUHQoIGNvbnRvdXJbIGkgXSwgY29udG91ckNlbnRyb2lkLCBicywgZmFsc2UgKTtcblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XG5cblx0XHR9XG5cblx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XG5cblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xuXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXHRcdFx0XHQvL3ZlcnQgPSBzY2FsZVB0KCBhaG9sZVsgaSBdLCBob2xlc0NlbnRyb2lkc1sgaCBdLCBicywgdHJ1ZSApO1xuXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLXogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRicyA9IGJldmVsU2l6ZTtcblxuXHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRpZiAoICFleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cblx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG5cdHZhciBzO1xuXG5cdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG5cdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRpZiAoICFleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXG5cblx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXHRmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcblxuXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG5cdFx0Ly9icyA9IGJldmVsU2l6ZSAqICggMS1NYXRoLnNpbiAoICggMSAtIHQgKSAqIE1hdGguUEkvMiApICk7XG5cdFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJLzIgKSA7XG5cblx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZXhwYW5kIGhvbGVzXG5cblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0aWYgKCAhZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cblx0Ly8vL1xuXHQvLy8gICBIYW5kbGUgRmFjZXNcblx0Ly8vL1xuXG5cdC8vIEJvdHRvbSBmYWNlc1xuXG5cdGlmICggYmV2ZWxFbmFibGVkICkge1xuXG5cdFx0dmFyIGxheWVyID0gMCA7IC8vIHN0ZXBzICsgMVxuXHRcdHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0ZjMoIGZhY2VbIDIgXSsgb2Zmc2V0LCBmYWNlWyAxIF0rIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XG5cblx0XHR9XG5cblx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XG5cblx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHZhciB0bXBQdDtcblx0dmFyIGosIGssIGwsIG07XG5cblx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcblxuXHQvLyBTaWRlcyBmYWNlc1xuXG5cdHNpZGV3YWxscyggY29udG91ciApO1xuXHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7ICBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0c2lkZXdhbGxzKCBhaG9sZSApO1xuXG5cdFx0Ly8sIHRydWVcblx0XHRsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XG5cblx0fVxuXG5cdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyICkge1xuXG5cdFx0aSA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCAtLWkgPj0gMCApIHtcblxuXHRcdFx0dG1wUHQgPSBjb250b3VyWyBpIF07XG5cblx0XHRcdGogPSBpO1xuXHRcdFx0ayA9IGkgLSAxO1xuXG5cdFx0XHRpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XG5cblx0XHRcdHZhciBzID0gMCwgc2wgPSBzdGVwcyAgKyBiZXZlbFNlZ21lbnRzICogMjtcblxuXHRcdFx0Zm9yICggcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcblxuXHRcdFx0XHR2YXIgc2xlbjEgPSB2bGVuICogcztcblx0XHRcdFx0dmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcblx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcblx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG5cdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuXHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuXHRcdFx0XHRmNCggYSwgYiwgYywgZCApO1xuXG5cdFx0XHRcdGlmICggZXh0cnVkZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0dmFyIHYxID0gcyAvIHNsO1xuXHRcdFx0XHRcdHZhciB2MiA9ICggcyArIDEgKSAvIHNsO1xuXG5cdFx0XHRcdFx0dmFyIHp0b2wgPSAoIGFtb3VudCArIGJldmVsVGhpY2tuZXNzICogMiApO1xuXG5cdFx0XHRcdFx0dmFyIHUxID0gKCBzY29wZS52ZXJ0aWNlc1sgYSBdLnBvc2l0aW9uLnogKyBiZXZlbFRoaWNrbmVzcyApIC8genRvbDtcblx0XHRcdFx0XHR2YXIgdTIgPSAoIHNjb3BlLnZlcnRpY2VzWyBkIF0ucG9zaXRpb24ueiArIGJldmVsVGhpY2tuZXNzICkgLyB6dG9sO1xuXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyh2eTEsIHZ5Mik7XG5cblx0XHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXHRcdFx0XHRcdFx0bmV3IFRIUkVFLlVWKCB1MSwgdjEgKSxcblx0XHRcdFx0XHRcdG5ldyBUSFJFRS5VViggdTIsIHYxICksXG5cdFx0XHRcdFx0XHRuZXcgVEhSRUUuVVYoIHUyLCB2MiApLFxuXHRcdFx0XHRcdFx0bmV3IFRIUkVFLlVWKCB1MSwgdjIgKVxuXHRcdFx0XHRcdF0gKTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblxuXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG5cdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlcnRleCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xuXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YyArPSBzaGFwZXNPZmZzZXQ7XG5cblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcblx0XHQvL25vcm1hbCwgY29sb3IsIG1hdGVyaWFsc1xuXG5cdFx0aWYgKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0dmFyIG14ID0gc2hhcGViYi5taW5YLCBteSA9IHNoYXBlYmIubWluWTtcblxuXHRcdFx0dmFyIHV5ID0gc2hhcGViYi5tYXhZOyAvLyAtIHNoYXBlYmIubWluWTtcblx0XHRcdHZhciB1eCA9IHNoYXBlYmIubWF4WDsgLy8gLSBzaGFwZWJiLm1pblg7XG5cblx0XHRcdHZhciBheCA9IHNjb3BlLnZlcnRpY2VzWyBhIF0ucG9zaXRpb24ueCxcblx0XHRcdFx0YXkgPSBzY29wZS52ZXJ0aWNlc1sgYSBdLnBvc2l0aW9uLnksXG5cblx0XHRcdFx0YnggPSBzY29wZS52ZXJ0aWNlc1sgYiBdLnBvc2l0aW9uLngsXG5cdFx0XHRcdGJ5ID0gc2NvcGUudmVydGljZXNbIGIgXS5wb3NpdGlvbi55LFxuXG5cdFx0XHRcdGN4ID0gc2NvcGUudmVydGljZXNbIGMgXS5wb3NpdGlvbi54LFxuXHRcdFx0XHRjeSA9IHNjb3BlLnZlcnRpY2VzWyBjIF0ucG9zaXRpb24ueTtcblxuXHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcblxuXHRcdFx0XHRuZXcgVEhSRUUuVVYoIGF4IC8gdXgsIGF5IC8gdXkgKSxcblx0XHRcdFx0bmV3IFRIUkVFLlVWKCBieCAvIHV4LCBieSAvIHV5ICksXG5cdFx0XHRcdG5ldyBUSFJFRS5VViggY3ggLyB1eCwgY3kgLyB1eSApXG5cblx0XHRcdF0gKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkICkge1xuXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YyArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0ZCArPSBzaGFwZXNPZmZzZXQ7XG5cbiBcdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBjLCBkLCBudWxsLCBudWxsLCBleHRydWRlTWF0ZXJpYWwgKSApO1xuXG5cdH1cblxufTtcblxuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192MiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192NCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192NSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192NiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG5cbiAqIHV2cyBhcmUgbWVzc2VkIHVwIGluIHRoaXMgb25lLCBhbmQgY29tbWVudGVkIGF3YXkgZm9yIG5vdy4gVGhlcmUgaXMgYW4gdWdseSBcInNlYW1cIiBieSB0aGUgc2hhcmVkIHZlcnRpY2VzXG4gKiB3aGVuIGl0IFwid3JhcHNcIiBhcm91bmQsIHRoYXQgbmVlZHMgdG8gYmUgZml4ZWQuIEl077+9cyBiZWNhdXNlIHRoZXkgc2hhcmUgdGhlIGZpcnN0IGFuZCB0aGUgbGFzdCB2ZXJ0aWNlc1xuICogc28gaXQgZHJhd3MgdGhlIGVudGlyZSB0ZXh0dXJlIG9uIHRoZSBzZWFtLWZhY2VzLCBJIHRoaW5rLi4uXG4gKi9cblxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggc3ViZGl2aXNpb25zICkge1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cdHZhciB0ZW1wU2NvcGUgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0dmFyIHRlbXBGYWNlcztcblx0dGhpcy5zdWJkaXZpc2lvbnMgPSBzdWJkaXZpc2lvbnMgfHwgMDtcblxuXHQvL3ZhciB0ZW1wX3V2ID0gW107XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuXHQvLyBjcmVhdGUgMTIgdmVydGljZXMgb2YgYSBJY29zYWhlZHJvblxuXHR2YXIgdCA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cblx0digtMSwgIHQsICAwKTtcblx0diggMSwgIHQsICAwKTtcblx0digtMSwgLXQsICAwKTtcblx0diggMSwgLXQsICAwKTtcblxuXHR2KCAwLCAtMSwgIHQpO1xuXHR2KCAwLCAgMSwgIHQpO1xuXHR2KCAwLCAtMSwgLXQpO1xuXHR2KCAwLCAgMSwgLXQpO1xuXG5cdHYoIHQsICAwLCAtMSk7XG5cdHYoIHQsICAwLCAgMSk7XG5cdHYoLXQsICAwLCAtMSk7XG5cdHYoLXQsICAwLCAgMSk7XG5cblx0Ly8gNSBmYWNlcyBhcm91bmQgcG9pbnQgMFxuXHRmMygwLCAxMSwgNSwgdGVtcFNjb3BlKTtcblx0ZjMoMCwgNSwgMSwgdGVtcFNjb3BlKTtcblx0ZjMoMCwgMSwgNywgdGVtcFNjb3BlKTtcblx0ZjMoMCwgNywgMTAsIHRlbXBTY29wZSk7XG5cdGYzKDAsIDEwLCAxMSwgdGVtcFNjb3BlKTtcblxuXHQvLyA1IGFkamFjZW50IGZhY2VzXG5cdGYzKDEsIDUsIDksIHRlbXBTY29wZSk7XG5cdGYzKDUsIDExLCA0LCB0ZW1wU2NvcGUpO1xuXHRmMygxMSwgMTAsIDIsIHRlbXBTY29wZSk7XG5cdGYzKDEwLCA3LCA2LCB0ZW1wU2NvcGUpO1xuXHRmMyg3LCAxLCA4LCB0ZW1wU2NvcGUpO1xuXG5cdC8vIDUgZmFjZXMgYXJvdW5kIHBvaW50IDNcblx0ZjMoMywgOSwgNCwgdGVtcFNjb3BlKTtcblx0ZjMoMywgNCwgMiwgdGVtcFNjb3BlKTtcblx0ZjMoMywgMiwgNiwgdGVtcFNjb3BlKTtcblx0ZjMoMywgNiwgOCwgdGVtcFNjb3BlKTtcblx0ZjMoMywgOCwgOSwgdGVtcFNjb3BlKTtcblxuXHQvLyA1IGFkamFjZW50IGZhY2VzXG5cdGYzKDQsIDksIDUsIHRlbXBTY29wZSk7XG5cdGYzKDIsIDQsIDExLCB0ZW1wU2NvcGUpO1xuXHRmMyg2LCAyLCAxMCwgdGVtcFNjb3BlKTtcblx0ZjMoOCwgNiwgNywgdGVtcFNjb3BlKTtcblx0ZjMoOSwgOCwgMSwgdGVtcFNjb3BlKTtcblxuXHQvLyBzdWJkaXZpZGUgZmFjZXMgdG8gcmVmaW5lIHRoZSB0cmlhbmdsZXNcblx0Zm9yICh2YXIgaT0wOyBpIDwgdGhpcy5zdWJkaXZpc2lvbnM7IGkrKykge1xuXHRcdHRlbXBGYWNlcyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRcdGZvciAodmFyIHRyaSBpbiB0ZW1wU2NvcGUuZmFjZXMpIHtcblx0XHRcdC8vIHJlcGxhY2UgZWFjaCB0cmlhbmdsZSBieSA0IHRyaWFuZ2xlc1xuXHRcdFx0dmFyIGEgPSBnZXRNaWRkbGVQb2ludCh0ZW1wU2NvcGUuZmFjZXNbdHJpXS5hLCB0ZW1wU2NvcGUuZmFjZXNbdHJpXS5iKTtcblx0XHRcdHZhciBiID0gZ2V0TWlkZGxlUG9pbnQodGVtcFNjb3BlLmZhY2VzW3RyaV0uYiwgdGVtcFNjb3BlLmZhY2VzW3RyaV0uYyk7XG5cdFx0XHR2YXIgYyA9IGdldE1pZGRsZVBvaW50KHRlbXBTY29wZS5mYWNlc1t0cmldLmMsIHRlbXBTY29wZS5mYWNlc1t0cmldLmEpO1xuXG5cdFx0XHRmMyh0ZW1wU2NvcGUuZmFjZXNbdHJpXS5hLCBhLCBjLCB0ZW1wRmFjZXMpO1xuXHRcdFx0ZjModGVtcFNjb3BlLmZhY2VzW3RyaV0uYiwgYiwgYSwgdGVtcEZhY2VzKTtcblx0XHRcdGYzKHRlbXBTY29wZS5mYWNlc1t0cmldLmMsIGMsIGIsIHRlbXBGYWNlcyk7XG5cdFx0XHRmMyhhLCBiLCBjLCB0ZW1wRmFjZXMpO1xuXHRcdH1cblx0XHR0ZW1wU2NvcGUuZmFjZXMgPSB0ZW1wRmFjZXMuZmFjZXM7XG5cdFx0dGVtcFNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXSA9IHRlbXBGYWNlcy5mYWNlVmVydGV4VXZzWyAwIF07XG5cdH1cblxuXHRzY29wZS5mYWNlcyA9IHRlbXBTY29wZS5mYWNlcztcblx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdID0gdGVtcFNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoIHRydWUgKTtcblxuXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG5cdFx0dmFyIGxlbmd0aCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuXHRcdHZhciBpID0gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlcnRleCggbmV3IFRIUkVFLlZlY3RvcjMoIHgvbGVuZ3RoLCB5L2xlbmd0aCwgei9sZW5ndGggKSApICk7XG5cblx0XHRyZXR1cm4gaS0xO1xuXHR9XG5cblx0ZnVuY3Rpb24gZjMoIGEsIGIsIGMsIGluc2NvcGUgKSB7XG5cblx0XHR2YXIgdjEgPSBzY29wZS52ZXJ0aWNlc1sgYSBdLnBvc2l0aW9uO1xuXHRcdHZhciB2MiA9IHNjb3BlLnZlcnRpY2VzWyBiIF0ucG9zaXRpb247XG5cdFx0dmFyIHYzID0gc2NvcGUudmVydGljZXNbIGMgXS5wb3NpdGlvbjtcblxuXHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjICk7XG5cdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIHYxLmNsb25lKCkubm9ybWFsaXplKCksIHYyLmNsb25lKCkubm9ybWFsaXplKCksIHYzLmNsb25lKCkubm9ybWFsaXplKCkgKTtcblxuXHRcdGluc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0aW5zY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXHRcdFx0bmV3IFRIUkVFLlVWKCAxIC0gKCAoICggTWF0aC5hdGFuMiggdjEueiwgdjEueCApICsgTWF0aC5QSSApICUgTWF0aC5QSSApIC8gTWF0aC5QSSAqIDAuNSApLCAwLjUgLSB2MS55IC8gMiApLFxuXHRcdFx0bmV3IFRIUkVFLlVWKCAxIC0gKCAoICggTWF0aC5hdGFuMiggdjIueiwgdjIueCApICsgTWF0aC5QSSApICUgTWF0aC5QSSApIC8gTWF0aC5QSSAqIDAuNSApLCAwLjUgLSB2Mi55IC8gMiApLFxuXHRcdFx0bmV3IFRIUkVFLlVWKCAxIC0gKCAoICggTWF0aC5hdGFuMiggdjMueiwgdjMueCApICsgTWF0aC5QSSApICUgTWF0aC5QSSApIC8gTWF0aC5QSSAqIDAuNSApLCAwLjUgLSB2My55IC8gMiApXG5cdFx0XSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRNaWRkbGVQb2ludChwMSxwMikge1xuXHRcdHZhciBwb3MxID0gc2NvcGUudmVydGljZXNbcDFdLnBvc2l0aW9uO1xuXHRcdHZhciBwb3MyID0gc2NvcGUudmVydGljZXNbcDJdLnBvc2l0aW9uO1xuXG5cdFx0dmFyIHggPSAocG9zMS54ICsgcG9zMi54KSAvIDI7XG5cdFx0dmFyIHkgPSAocG9zMS55ICsgcG9zMi55KSAvIDI7XG5cdFx0dmFyIHogPSAocG9zMS56ICsgcG9zMi56KSAvIDI7XG5cblx0XHR2YXIgaSA9IHYoeCwgeSwgeik7XG5cdFx0cmV0dXJuIGk7XG5cdH1cblxufVxuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5O1xuLyoqXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuICovXG5cblRIUkVFLkxhdGhlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBvaW50cywgc3RlcHMsIGFuZ2xlICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnN0ZXBzID0gc3RlcHMgfHwgMTI7XG5cdHRoaXMuYW5nbGUgPSBhbmdsZSB8fCAyICogTWF0aC5QSTtcblxuXHR2YXIgc3RlcFNpemUgPSB0aGlzLmFuZ2xlIC8gdGhpcy5zdGVwcyxcblx0bmV3ViA9IFtdLCBvbGRJbmRzID0gW10sIG5ld0luZHMgPSBbXSwgc3RhcnRJbmRzID0gW10sXG5cdG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCkuc2V0Um90YXRpb25aKCBzdGVwU2l6ZSApO1xuXG5cdGZvciAoIHZhciBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZXJ0ZXgoIHBvaW50c1sgaiBdICkgKTtcblxuXHRcdG5ld1ZbIGogXSA9IHBvaW50c1sgaiBdLmNsb25lKCk7XG5cdFx0b2xkSW5kc1sgaiBdID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG5cdH1cblxuXHRmb3IgKCB2YXIgciA9IDA7IHIgPD0gdGhpcy5hbmdsZSArIDAuMDAxOyByICs9IHN0ZXBTaXplICkgeyAvLyBuZWVkIHRoZSArMC4wMDEgZm9yIGl0IGdvIHVwIHRvIGFuZ2xlXG5cblx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBuZXdWLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0aWYgKCByIDwgdGhpcy5hbmdsZSApIHtcblxuXHRcdFx0XHRuZXdWWyBqIF0gPSBtYXRyaXgubXVsdGlwbHlWZWN0b3IzKCBuZXdWWyBqIF0uY2xvbmUoKSApO1xuXHRcdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZXJ0ZXgoIG5ld1ZbIGogXSApICk7XG5cdFx0XHRcdG5ld0luZHNbIGogXSA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRuZXdJbmRzID0gc3RhcnRJbmRzOyAvLyB3cmFwIGl0IHVwIVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHIgPT0gMCApIHN0YXJ0SW5kcyA9IG9sZEluZHM7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBvbGRJbmRzLmxlbmd0aCAtIDE7IGogKysgKSB7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCBuZXdJbmRzWyBqIF0sIG5ld0luZHNbIGogKyAxIF0sIG9sZEluZHNbIGogKyAxIF0sIG9sZEluZHNbIGogXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cblx0XHRcdFx0bmV3IFRIUkVFLlVWKCAxIC0gciAvIHRoaXMuYW5nbGUsIGogLyBwb2ludHMubGVuZ3RoICksXG5cdFx0XHRcdG5ldyBUSFJFRS5VViggMSAtIHIgLyB0aGlzLmFuZ2xlLCAoIGogKyAxICkgLyBwb2ludHMubGVuZ3RoICksXG5cdFx0XHRcdG5ldyBUSFJFRS5VViggMSAtICggciAtIHN0ZXBTaXplICkgLyB0aGlzLmFuZ2xlLCAoIGogKyAxICkgLyBwb2ludHMubGVuZ3RoICksXG5cdFx0XHRcdG5ldyBUSFJFRS5VViggMSAtICggciAtIHN0ZXBTaXplICkgLyB0aGlzLmFuZ2xlLCBqIC8gcG9pbnRzLmxlbmd0aCApXG5cblx0XHRcdF0gKTtcblxuXHRcdH1cblxuXHRcdG9sZEluZHMgPSBuZXdJbmRzO1xuXHRcdG5ld0luZHMgPSBbXTtcblxuXHR9XG5cblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGF0aGVHZW9tZXRyeTtcbi8qKlxuICogT2N0YWhlZHJvbnMgaGF2ZSA4IHNpZGVzLiBUaGlzIG9jdGFoZWRyb24gc3VwcG9ydHMgc3ViZGl2aXNpb24uXG4gKiBcbiAqIFZlcnRpY2VzIGhhdmUgJ3Ntb290aCcgbm9ybWFscywgXG4gKiB0byBtYWtlIGEgc2hhcnAgZWRnZSBjaG9vc2UgYSBtYXRlcmlhbCB0aGF0IHVzZXMgZmFjZSBub3JtYWxzIGluc3RlYWQuXG4gKlxuICogQGF1dGhvciBkYW5pZWwuZGVhZHlAa25lY3Rhci5jb21cbiAqIEBwYXJhbSByYWRpdXNcbiAqIEBwYXJhbSBkZXRhaWwgRmluYWwgbnVtYmVyIG9mIHRyaWFuZ2xlcyA9IDReZGV0YWlsICogOFxuICovXG5cblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdGRldGFpbCA9IGRldGFpbCB8fCAwO1xuXG5cdHZhciB0aGF0ID0gdGhpczsgLy8gdWdseSBzY29wZSBoYWNrXG5cblx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoICsxLCAwLCAwICkgKTsgLy8gcmlnaHRcblx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIC0xLCAwLCAwICkgKTsgLy8gbGVmdFxuXHRwcmVwYXJlKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgKzEsIDAgKSApOyAvLyB1cFxuXHRwcmVwYXJlKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLTEsIDAgKSApOyAvLyBkb3duXG5cdHByZXBhcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCArMSApICk7IC8vIGZyb250XG5cdHByZXBhcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtMSApICk7IC8vIGJhY2tcblx0dmFyIG1pZHBvaW50cyA9IFtdLCBwID0gdGhpcy52ZXJ0aWNlcztcblxuXHQvLyBjYXJlZnVsIHRvIG91dHB1dCBmYWNlcyBjb3VudGVyLWNsb2Nrd2lzZSwgdGhhdCBpcyByZXF1aXJlZCBmb3IgbWVzaGVzXG5cdG1ha2UoIHBbMF0sIHBbMl0sIHBbNF0sIGRldGFpbCApO1xuXHRtYWtlKCBwWzBdLCBwWzRdLCBwWzNdLCBkZXRhaWwgKTtcblx0bWFrZSggcFswXSwgcFszXSwgcFs1XSwgZGV0YWlsICk7XG5cdG1ha2UoIHBbMF0sIHBbNV0sIHBbMl0sIGRldGFpbCApO1xuXHRtYWtlKCBwWzFdLCBwWzJdLCBwWzVdLCBkZXRhaWwgKTtcblx0bWFrZSggcFsxXSwgcFs1XSwgcFszXSwgZGV0YWlsICk7XG5cdG1ha2UoIHBbMV0sIHBbM10sIHBbNF0sIGRldGFpbCApO1xuXHRtYWtlKCBwWzFdLCBwWzRdLCBwWzJdLCBkZXRhaWwgKTtcblxuXHQvKipcblx0ICogUHJvamVjdCB2ZWN0b3Igb250byBzcGhlcmUncyBzdXJmYWNlXG5cdCAqL1xuXHRmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XG5cblx0XHR2YXIgbm9ybWFsID0gdmVjdG9yLmNsb25lKCkubm9ybWFsaXplKCk7XG5cdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZXJ0ZXgoIG5vcm1hbC5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCByYWRpdXMgKSApO1xuXHRcdHZlcnRleC5pbmRleCA9IHRoYXQudmVydGljZXMucHVzaCggdmVydGV4ICkgLSAxO1xuXG5cdFx0Ly8gVGV4dHVyZSBjb29yZHMgYXJlIGVxdWl2YWxlbnQgdG8gbWFwIGNvb3JkcywgY2FsY3VsYXRlIGFuZ2xlIGFuZCBjb252ZXJ0IHRvIGZyYWN0aW9uIG9mIGEgY2lyY2xlLlxuXHRcdHZhciB1ID0gYXppbXV0aCggdmVjdG9yICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcblx0XHR2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZWN0b3IgKSAvIE1hdGguUEkgKyAwLjU7XG5cdFx0dmVydGV4LnV2ID0gbmV3IFRIUkVFLlVWKCB1LCB2ICk7XG5cblx0XHRyZXR1cm4gdmVydGV4O1xuXG5cdH1cblxuXHQvKipcblx0ICogQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cblx0ICovXG5cdGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMsIGRldGFpbCApIHtcblxuXHRcdGlmICggZGV0YWlsIDwgMSApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEucG9zaXRpb24sIHYyLnBvc2l0aW9uLCB2My5wb3NpdGlvbiBdICk7XG5cdFx0XHRmYWNlLmNlbnRyb2lkLmFkZFNlbGYoIHYxLnBvc2l0aW9uICkuYWRkU2VsZiggdjIucG9zaXRpb24gKS5hZGRTZWxmKCB2My5wb3NpdGlvbiApLmRpdmlkZVNjYWxhciggMyApO1xuXHRcdFx0ZmFjZS5ub3JtYWwgPSBmYWNlLmNlbnRyb2lkLmNsb25lKCkubm9ybWFsaXplKCk7XG5cdFx0XHR0aGF0LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuXHRcdFx0dmFyIGF6aSA9IGF6aW11dGgoIGZhY2UuY2VudHJvaWQgKTtcblx0XHRcdHRoYXQuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgXG5cdFx0XHRcdGNvcnJlY3RVViggdjEudXYsIHYxLnBvc2l0aW9uLCBhemkgKSxcblx0XHRcdFx0Y29ycmVjdFVWKCB2Mi51diwgdjIucG9zaXRpb24sIGF6aSApLFxuXHRcdFx0XHRjb3JyZWN0VVYoIHYzLnV2LCB2My5wb3NpdGlvbiwgYXppIClcblx0XHRcdF0gKTtcblxuXHRcdH1cblx0XHRlbHNlIHtcblxuXHRcdFx0ZGV0YWlsIC09IDE7XG5cdFx0XHQvLyBzcGxpdCB0cmlhbmdsZSBpbnRvIDQgc21hbGxlciB0cmlhbmdsZXNcblx0XHRcdG1ha2UoIHYxLCBtaWRwb2ludCggdjEsIHYyICksIG1pZHBvaW50KCB2MSwgdjMgKSwgZGV0YWlsICk7IC8vIHRvcCBxdWFkcmFudFxuXHRcdFx0bWFrZSggbWlkcG9pbnQoIHYxLCB2MiApLCB2MiwgbWlkcG9pbnQoIHYyLCB2MyApLCBkZXRhaWwgKTsgLy8gbGVmdCBxdWFkcmFudFxuXHRcdFx0bWFrZSggbWlkcG9pbnQoIHYxLCB2MyApLCBtaWRwb2ludCggdjIsIHYzICksIHYzLCBkZXRhaWwgKTsgLy8gcmlnaHQgcXVhZHJhbnRcblx0XHRcdG1ha2UoIG1pZHBvaW50KCB2MSwgdjIgKSwgbWlkcG9pbnQoIHYyLCB2MyApLCBtaWRwb2ludCggdjEsIHYzICksIGRldGFpbCApOyAvLyBjZW50ZXIgcXVhZHJhbnRcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gbWlkcG9pbnQoIHYxLCB2MiApIHtcblxuXHRcdGlmICggIW1pZHBvaW50c1sgdjEuaW5kZXggXSApIG1pZHBvaW50c1sgdjEuaW5kZXggXSA9IFtdO1xuXHRcdGlmICggIW1pZHBvaW50c1sgdjIuaW5kZXggXSApIG1pZHBvaW50c1sgdjIuaW5kZXggXSA9IFtdO1xuXHRcdHZhciBtaWQgPSBtaWRwb2ludHNbIHYxLmluZGV4IF1bIHYyLmluZGV4IF07XG5cdFx0aWYgKCBtaWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIGdlbmVyYXRlIG1lYW4gcG9pbnQgYW5kIHByb2plY3QgdG8gc3VyZmFjZSB3aXRoIHByZXBhcmUoKVxuXHRcdFx0bWlkcG9pbnRzWyB2MS5pbmRleCBdWyB2Mi5pbmRleCBdID0gbWlkcG9pbnRzWyB2Mi5pbmRleCBdWyB2MS5pbmRleCBdID0gbWlkID0gcHJlcGFyZSggXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCkuYWRkKCB2MS5wb3NpdGlvbiwgdjIucG9zaXRpb24gKS5kaXZpZGVTY2FsYXIoIDIgKSBcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBtaWQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cdCAqL1xuXHRmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC12ZWN0b3IueCApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcblxuXHRcdHJldHVybiBNYXRoLmF0YW4yKCAtdmVjdG9yLnksIE1hdGguc3FydCggKCB2ZWN0b3IueCAqIHZlY3Rvci54ICkgKyAoIHZlY3Rvci56ICogdmVjdG9yLnogKSApICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUZXh0dXJlIGZpeGluZyBoZWxwZXIuIFNwaGVyZXMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvdXJzLlxuXHQgKi9cblx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xuXG5cdFx0aWYgKCAoYXppbXV0aCA8IDApICYmICh1di51ID09PSAxKSApIHV2ID0gbmV3IFRIUkVFLlVWKCB1di51IC0gMSwgdXYudiApO1xuXHRcdGlmICggKHZlY3Rvci54ID09PSAwKSAmJiAodmVjdG9yLnogPT09IDApICkgdXYgPSBuZXcgVEhSRUUuVVYoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYudiApO1xuXHRcdHJldHVybiB1djtcblxuXHR9XG5cblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IHsgcmFkaXVzOiByYWRpdXMgfTtcblxufTtcblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeTtcbi8qKlxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcbiAqL1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBzZWdtZW50c1dpZHRoLCBzZWdtZW50c0hlaWdodCApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dmFyIGl4LCBpeSxcblx0d2lkdGhfaGFsZiA9IHdpZHRoIC8gMixcblx0aGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyLFxuXHRncmlkWCA9IHNlZ21lbnRzV2lkdGggfHwgMSxcblx0Z3JpZFkgPSBzZWdtZW50c0hlaWdodCB8fCAxLFxuXHRncmlkWDEgPSBncmlkWCArIDEsXG5cdGdyaWRZMSA9IGdyaWRZICsgMSxcblx0c2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFgsXG5cdHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXG5cdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkrKyApIHtcblxuXHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4KysgKSB7XG5cblx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcblx0XHRcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZXJ0ZXgoIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCAtIHksIDAgKSApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkrKyApIHtcblxuXHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXgrKyApIHtcblxuXHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuXHRcdFx0dmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBjLCBkICk7XG5cdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcblx0XHRcdFx0XHRcdG5ldyBUSFJFRS5VViggaXggLyBncmlkWCwgaXkgLyBncmlkWSApLFxuXHRcdFx0XHRcdFx0bmV3IFRIUkVFLlVWKCBpeCAvIGdyaWRYLCAoIGl5ICsgMSApIC8gZ3JpZFkgKSxcblx0XHRcdFx0XHRcdG5ldyBUSFJFRS5VViggKCBpeCArIDEgKSAvIGdyaWRYLCAoIGl5ICsgMSApIC8gZ3JpZFkgKSxcblx0XHRcdFx0XHRcdG5ldyBUSFJFRS5VViggKCBpeCArIDEgKSAvIGdyaWRYLCBpeSAvIGdyaWRZIClcblx0XHRcdFx0XHRdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xuXG59O1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUdlb21ldHJ5O1xuLyoqXG4gKiBAYXV0aG9yIG1yLmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50c1dpZHRoLCBzZWdtZW50c0hlaWdodCwgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHZhciByYWRpdXMgPSByYWRpdXMgfHwgNTA7XG5cdHZhciBzZWdtZW50c1ggPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggc2VnbWVudHNXaWR0aCApIHx8IDggKTtcblx0dmFyIHNlZ21lbnRzWSA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBzZWdtZW50c0hlaWdodCApIHx8IDYgKTtcblxuXHR2YXIgcGhpU3RhcnQgPSBwaGlTdGFydCAhPSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XG5cdHZhciBwaGlMZW5ndGggPSBwaGlMZW5ndGggIT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cblx0dmFyIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuXHR2YXIgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XG5cblx0dmFyIHgsIHksIHZlcnRpY2VzID0gW10sIHV2cyA9IFtdO1xuXG5cdGZvciAoIHkgPSAwOyB5IDw9IHNlZ21lbnRzWTsgeSArKyApIHtcblxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuXHRcdHZhciB1dnNSb3cgPSBbXTtcblxuXHRcdGZvciAoIHggPSAwOyB4IDw9IHNlZ21lbnRzWDsgeCArKyApIHtcblxuXHRcdFx0dmFyIHUgPSB4IC8gc2VnbWVudHNYO1xuXHRcdFx0dmFyIHYgPSB5IC8gc2VnbWVudHNZO1xuXG5cdFx0XHR2YXIgeHBvcyA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdHZhciB5cG9zID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdHZhciB6cG9zID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggeHBvcywgeXBvcywgenBvcyApICkgKTtcblxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XG5cdFx0XHR1dnNSb3cucHVzaCggbmV3IFRIUkVFLlVWKCB1LCB2ICkgKTtcblxuXHRcdH1cblxuXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cdFx0dXZzLnB1c2goIHV2c1JvdyApO1xuXG5cdH1cblxuXHRmb3IgKCB5ID0gMDsgeSA8IHNlZ21lbnRzWTsgeSArKyApIHtcblxuXHRcdGZvciAoIHggPSAwOyB4IDwgc2VnbWVudHNYOyB4ICsrICkge1xuXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xuXHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcblx0XHRcdHZhciB2NCA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xuXG5cdFx0XHR2YXIgbjEgPSB0aGlzLnZlcnRpY2VzWyB2MSBdLnBvc2l0aW9uLmNsb25lKCkubm9ybWFsaXplKCk7XG5cdFx0XHR2YXIgbjIgPSB0aGlzLnZlcnRpY2VzWyB2MiBdLnBvc2l0aW9uLmNsb25lKCkubm9ybWFsaXplKCk7XG5cdFx0XHR2YXIgbjMgPSB0aGlzLnZlcnRpY2VzWyB2MyBdLnBvc2l0aW9uLmNsb25lKCkubm9ybWFsaXplKCk7XG5cdFx0XHR2YXIgbjQgPSB0aGlzLnZlcnRpY2VzWyB2NCBdLnBvc2l0aW9uLmNsb25lKCkubm9ybWFsaXplKCk7XG5cblx0XHRcdHZhciB1djEgPSB1dnNbIHkgXVsgeCArIDEgXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MiA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djMgPSB1dnNbIHkgKyAxIF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2NCA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB0aGlzLnZlcnRpY2VzWyB2MSBdLnBvc2l0aW9uLnkgKSA9PSByYWRpdXMgKSB7XG5cblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MywgdjQsIFsgbjEsIG4zLCBuNCBdICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MywgdXY0IF0gKTtcblxuXHRcdFx0fSBlbHNlIGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYzIF0ucG9zaXRpb24ueSApID09ICByYWRpdXMgKSB7XG5cblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzIF0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlNCggdjEsIHYyLCB2MywgdjQsIFsgbjEsIG4yLCBuMywgbjQgXSApICk7XG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MywgdXY0IF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0geyByYWRpdXM6IHJhZGl1cyB9O1xuXG59O1xuXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUdlb21ldHJ5O1xuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZvciBjcmVhdGluZyAzRCB0ZXh0IGdlb21ldHJ5IGluIHRocmVlLmpzXG4gKlxuICogVGV4dCA9IDNEIFRleHRcbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIHNpemU6IFx0XHRcdDxmbG9hdD4sIFx0Ly8gc2l6ZSBvZiB0aGUgdGV4dFxuICogIGhlaWdodDogXHRcdDxmbG9hdD4sIFx0Ly8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxuICogIGN1cnZlU2VnbWVudHM6IFx0PGludD4sXHRcdC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICpcbiAqICBmb250OiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBuYW1lXG4gKiAgd2VpZ2h0OiBcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgd2VpZ2h0IChub3JtYWwsIGJvbGQpXG4gKiAgc3R5bGU6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHN0eWxlICAobm9ybWFsLCBpdGFsaWNzKVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6XHQ8Ym9vbD4sXHRcdFx0Ly8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCBcdFx0Ly8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6XHRcdDxmbG9hdD4sIFx0XHQvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXG4gKlxuICogIGJlbmQ6XHRcdFx0PGJvb2w+XHRcdFx0Ly8gYmVuZCBhY2NvcmRpbmcgdG8gaGFyZGNvZGVkIGN1cnZlIChnZW5lcmF0ZXMgYmVuZFBhdGgpXG4gKiAgYmVuZFBhdGg6ICAgICAgIDxjdXJ2ZT4gICAgICAgICAvLyB3cmFwcyB0ZXh0IGFjY29yZGluZyB0byBiZW5kIFBhdGhcbiAqICB9XG4gKlxuICogSXQgdXNlcyB0ZWNobmlxdWVzIHVzZWQgaW46XG4gKlxuICogXHR0eXBlZmFjZS5qcyBhbmQgY2FudmFzdGV4dFxuICogXHRcdEZvciBjb252ZXJ0aW5nIGZvbnRzIGFuZCByZW5kZXJpbmcgd2l0aCBqYXZhc2NyaXB0XG4gKlx0XHRodHRwOi8vdHlwZWZhY2UubmVvY3JhY3kub3JnXG4gKlxuICpcdFRyaWFuZ3VsYXRpb24gcG9ydGVkIGZyb20gQVMzXG4gKlx0XHRTaW1wbGUgUG9seWdvbiBUcmlhbmd1bGF0aW9uXG4gKlx0XHRodHRwOi8vYWN0aW9uc25pcHBldC5jb20vP3A9MTQ2MlxuICpcbiAqIFx0QSBNZXRob2QgdG8gdHJpYW5ndWxhdGUgc2hhcGVzIHdpdGggaG9sZXNcbiAqXHRcdGh0dHA6Ly93d3cuc2FrcmkubmV0L2Jsb2cvMjAwOS8wNi8xMi9hbi1hcHByb2FjaC10by10cmlhbmd1bGF0aW5nLXBvbHlnb25zLXdpdGgtaG9sZXMvXG4gKlxuICovXG4vKlx0VXNhZ2UgRXhhbXBsZXNcblx0XG5cdC8vIFRleHRHZW9tZXRyeSB3cmFwcGVyXG5cblx0dmFyIHRleHQzZCA9IG5ldyBUZXh0R2VvbWV0cnkoIHRleHQsIG9wdGlvbnMgKTtcblxuXHQvLyBDb21wbGV0ZSBtYW5uZXJcblxuXHR2YXIgdGV4dFBhdGggPSBuZXcgVEhSRUUuVGV4dFBhdGgoIHRleHQsIG9wdGlvbnMgKTtcblx0dmFyIHRleHRTaGFwZXMgPSB0ZXh0UGF0aC50b1NoYXBlcygpO1xuXHR2YXIgdGV4dDNkID0gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggdGV4dFNoYXBlcywgb3B0aW9ucyApO1xuXHRcbiovXG5cblxuVEhSRUUuVGV4dEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xuXG5cdHZhciB0ZXh0UGF0aCA9IG5ldyBUSFJFRS5UZXh0UGF0aCggdGV4dCwgcGFyYW1ldGVycyApO1xuXHR2YXIgdGV4dFNoYXBlcyA9IHRleHRQYXRoLnRvU2hhcGVzKCk7XG5cblx0Ly8gdHJhbnNsYXRlIHBhcmFtZXRlcnMgdG8gRXh0cnVkZUdlb21ldHJ5IEFQSVxuXG5cdHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XG5cblx0Ly8gZGVmYXVsdHNcblxuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPSAxMDtcblx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFNpemUgPSA4O1xuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xuXG5cdGlmICggcGFyYW1ldGVycy5iZW5kICkge1xuXG5cdFx0dmFyIGIgPSB0ZXh0U2hhcGVzWyB0ZXh0U2hhcGVzLmxlbmd0aCAtIDEgXS5nZXRCb3VuZGluZ0JveCgpO1xuXHRcdHZhciBtYXggPSBiLm1heFg7XG5cblx0XHRwYXJhbWV0ZXJzLmJlbmRQYXRoID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBuZXcgVEhSRUUuVmVjdG9yMiggbWF4IC8gMiwgMTIwICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIG5ldyBUSFJFRS5WZWN0b3IyKCBtYXgsIDAgKSApO1xuXG5cdH1cblxuXHRUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgdGV4dFNoYXBlcywgcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlID0gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSgpO1xuVEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRleHRHZW9tZXRyeTtcblxuXG5USFJFRS5Gb250VXRpbHMgPSB7XG5cblx0ZmFjZXMgOiB7fSxcblxuXHQvLyBKdXN0IGZvciBub3cuIGZhY2Vbd2VpZ2h0XVtzdHlsZV1cblxuXHRmYWNlIDogXCJoZWx2ZXRpa2VyXCIsXG5cdHdlaWdodDogXCJub3JtYWxcIixcblx0c3R5bGUgOiBcIm5vcm1hbFwiLFxuXHRzaXplIDogMTUwLFxuXHRkaXZpc2lvbnMgOiAxMCxcblxuXHRnZXRGYWNlIDogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mYWNlc1sgdGhpcy5mYWNlIF1bIHRoaXMud2VpZ2h0IF1bIHRoaXMuc3R5bGUgXTtcblxuXHR9LFxuXG5cdGxvYWRGYWNlIDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHR2YXIgZmFtaWx5ID0gZGF0YS5mYW1pbHlOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHR2YXIgVGhyZWVGb250ID0gdGhpcztcblxuXHRcdFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdIHx8IHt9O1xuXG5cdFx0VGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSB8fCB7fTtcblx0XHRUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XG5cblx0XHR2YXIgZmFjZSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH0sXG5cblx0ZHJhd1RleHQgOiBmdW5jdGlvbiggdGV4dCApIHtcblxuXHRcdHZhciBjaGFyYWN0ZXJQdHMgPSBbXSwgYWxsUHRzID0gW107XG5cblx0XHQvLyBSZW5kZXJUZXh0XG5cblx0XHR2YXIgaSwgcCxcblx0XHRcdGZhY2UgPSB0aGlzLmdldEZhY2UoKSxcblx0XHRcdHNjYWxlID0gdGhpcy5zaXplIC8gZmFjZS5yZXNvbHV0aW9uLFxuXHRcdFx0b2Zmc2V0ID0gMCxcblx0XHRcdGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICksXG5cdFx0XHRsZW5ndGggPSBjaGFycy5sZW5ndGg7XG5cblx0XHR2YXIgZm9udFBhdGhzID0gW107XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG5cdFx0XHR2YXIgcmV0ID0gdGhpcy5leHRyYWN0R2x5cGhQb2ludHMoIGNoYXJzWyBpIF0sIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKTtcblx0XHRcdG9mZnNldCArPSByZXQub2Zmc2V0O1xuXHRcdFx0Ly9jaGFyYWN0ZXJQdHMucHVzaCggcmV0LnBvaW50cyApO1xuXHRcdFx0Ly9hbGxQdHMgPSBhbGxQdHMuY29uY2F0KCByZXQucG9pbnRzICk7XG5cdFx0XHRmb250UGF0aHMucHVzaCggcmV0LnBhdGggKTtcblxuXHRcdH1cblxuXHRcdC8vIGdldCB0aGUgd2lkdGhcblxuXHRcdHZhciB3aWR0aCA9IG9mZnNldCAvIDI7XG5cdFx0Ly9cblx0XHQvLyBmb3IgKCBwID0gMDsgcCA8IGFsbFB0cy5sZW5ndGg7IHArKyApIHtcblx0XHQvL1xuXHRcdC8vIFx0YWxsUHRzWyBwIF0ueCAtPSB3aWR0aDtcblx0XHQvL1xuXHRcdC8vIH1cblxuXHRcdC8vdmFyIGV4dHJhY3QgPSB0aGlzLmV4dHJhY3RQb2ludHMoIGFsbFB0cywgY2hhcmFjdGVyUHRzICk7XG5cdFx0Ly9leHRyYWN0LmNvbnRvdXIgPSBhbGxQdHM7XG5cblx0XHQvL2V4dHJhY3QucGF0aHMgPSBmb250UGF0aHM7XG5cdFx0Ly9leHRyYWN0Lm9mZnNldCA9IHdpZHRoO1xuXG5cdFx0cmV0dXJuIHsgcGF0aHMgOiBmb250UGF0aHMsIG9mZnNldCA6IHdpZHRoIH07XG5cblx0fSxcblxuXG5cblxuXHRleHRyYWN0R2x5cGhQb2ludHMgOiBmdW5jdGlvbiggYywgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApIHtcblxuXHRcdHZhciBwdHMgPSBbXTtcblxuXHRcdHZhciBpLCBpMiwgZGl2aXNpb25zLFxuXHRcdFx0b3V0bGluZSwgYWN0aW9uLCBsZW5ndGgsXG5cdFx0XHRzY2FsZVgsIHNjYWxlWSxcblx0XHRcdHgsIHksIGNweCwgY3B5LCBjcHgwLCBjcHkwLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLFxuXHRcdFx0bGFzdGUsXG5cdFx0XHRnbHlwaCA9IGZhY2UuZ2x5cGhzWyBjIF0gfHwgZmFjZS5nbHlwaHNbICc/JyBdO1xuXG5cdFx0aWYgKCAhZ2x5cGggKSByZXR1cm47XG5cblx0XHRpZiAoIGdseXBoLm8gKSB7XG5cblx0XHRcdG91dGxpbmUgPSBnbHlwaC5fY2FjaGVkT3V0bGluZSB8fCAoIGdseXBoLl9jYWNoZWRPdXRsaW5lID0gZ2x5cGguby5zcGxpdCggJyAnICkgKTtcblx0XHRcdGxlbmd0aCA9IG91dGxpbmUubGVuZ3RoO1xuXG5cdFx0XHRzY2FsZVggPSBzY2FsZTtcblx0XHRcdHNjYWxlWSA9IHNjYWxlO1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgKSB7XG5cblx0XHRcdFx0YWN0aW9uID0gb3V0bGluZVsgaSArKyBdO1xuXG5cdFx0XHRcdC8vY29uc29sZS5sb2coIGFjdGlvbiApO1xuXG5cdFx0XHRcdHN3aXRjaCggYWN0aW9uICkge1xuXG5cdFx0XHRcdGNhc2UgJ20nOlxuXG5cdFx0XHRcdFx0Ly8gTW92ZSBUb1xuXG5cdFx0XHRcdFx0eCA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdHkgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcblxuXHRcdFx0XHRcdHB0cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApICk7XG5cblx0XHRcdFx0XHRwYXRoLm1vdmVUbyggeCwgeSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2wnOlxuXG5cdFx0XHRcdFx0Ly8gTGluZSBUb1xuXG5cdFx0XHRcdFx0eCA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdHkgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcblx0XHRcdFx0XHRwdHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKSApO1xuXHRcdFx0XHRcdHBhdGgubGluZVRvKHgseSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncSc6XG5cblx0XHRcdFx0XHQvLyBRdWFkcmF0aWNDdXJ2ZVRvXG5cblx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG5cdFx0XHRcdFx0Y3B5ICA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xuXHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcblx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XG5cblx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oY3B4MSwgY3B5MSwgY3B4LCBjcHkpO1xuXG5cdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xuXG5cdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcblx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG5cdFx0XHRcdFx0XHRcdHZhciB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXHRcdFx0XHRcdFx0XHRwdHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cblx0XHRcdFx0XHQgIH1cblxuXHRcdFx0XHQgIH1cblxuXHRcdFx0XHQgIGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2InOlxuXG5cdFx0XHRcdFx0Ly8gQ3ViaWMgQmV6aWVyIEN1cnZlXG5cblx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweSAgPSBvdXRsaW5lWyBpKysgXSAqICBzY2FsZVk7XG5cdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkrKyBdICogIHNjYWxlWCArIG9mZnNldDtcblx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSsrIF0gKiAtc2NhbGVZO1xuXHRcdFx0XHRcdGNweDIgPSBvdXRsaW5lWyBpKysgXSAqICBzY2FsZVggKyBvZmZzZXQ7XG5cdFx0XHRcdFx0Y3B5MiA9IG91dGxpbmVbIGkrKyBdICogLXNjYWxlWTtcblxuXHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyggY3B4LCBjcHksIGNweDEsIGNweTEsIGNweDIsIGNweTIgKTtcblxuXHRcdFx0XHRcdGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcblxuXHRcdFx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XG5cdFx0XHRcdFx0XHRjcHkwID0gbGFzdGUueTtcblxuXHRcdFx0XHRcdFx0Zm9yICggaTIgPSAxLCBkaXZpc2lvbnMgPSB0aGlzLmRpdmlzaW9uczsgaTIgPD0gZGl2aXNpb25zOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xuXHRcdFx0XHRcdFx0XHR2YXIgdHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XG5cdFx0XHRcdFx0XHRcdHZhciB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcblx0XHRcdFx0XHRcdFx0cHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblxuXG5cdFx0cmV0dXJuIHsgb2Zmc2V0OiBnbHlwaC5oYSpzY2FsZSwgcG9pbnRzOnB0cywgcGF0aDpwYXRofTtcblx0fVxuXG59O1xuXG5cblxuLyoqXG4gKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xuICogZmxpcGNvZGUuY29tIGJ5IEpvaG4gVy4gUmF0Y2xpZmYgIC8vIEp1bHkgMjIsIDIwMDBcbiAqIFNlZSBvcmlnaW5hbCBjb2RlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGhlcmU6XG4gKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXG4gKlxuICogcG9ydGVkIHRvIGFjdGlvbnNjcmlwdCBieSBaZXZhbiBSb3NzZXJcbiAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxuICpcbiAqIHBvcnRlZCB0byBqYXZhc2NyaXB0IGJ5IEpvc2h1YSBLb29cbiAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKi9cblxuXG4oIGZ1bmN0aW9uKCBuYW1lc3BhY2UgKSB7XG5cblx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cblx0Ly8gdGFrZXMgaW4gYW4gY29udG91ciBhcnJheSBhbmQgcmV0dXJuc1xuXG5cdHZhciBwcm9jZXNzID0gZnVuY3Rpb24oIGNvbnRvdXIsIGluZGljZXMgKSB7XG5cblx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0aWYgKCBuIDwgMyApIHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0dmVydHMgPSBbXSxcblx0XHRcdHZlcnRJbmRpY2VzID0gW107XG5cblx0XHQvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xuXG5cdFx0dmFyIHUsIHYsIHc7XG5cblx0XHRpZiAoIGFyZWEoIGNvbnRvdXIgKSA+IDAuMCApIHtcblxuXHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2KysgKSB2ZXJ0c1sgdiBdID0gdjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdisrICkgdmVydHNbIHYgXSA9ICggbiAtIDEgKSAtIHY7XG5cblx0XHR9XG5cblx0XHR2YXIgbnYgPSBuO1xuXG5cdFx0LyogIHJlbW92ZSBudiAtIDIgdmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZSAqL1xuXG5cdFx0dmFyIGNvdW50ID0gMiAqIG52OyAgIC8qIGVycm9yIGRldGVjdGlvbiAqL1xuXG5cdFx0Zm9yKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xuXG5cdFx0XHQvKiBpZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiAqL1xuXG5cdFx0XHRpZiAoICggY291bnQtLSApIDw9IDAgKSB7XG5cblx0XHRcdFx0Ly8qKiBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcblxuXHRcdFx0XHQvL3Rocm93ICggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xuXHRcdFx0XHQvL3JldHVybiBudWxsO1xuXHRcdFx0XHQvLyBTb21ldGltZXMgd2FybmluZyBpcyBmaW5lLCBlc3BlY2lhbGx5IHBvbHlnb25zIGFyZSB0cmlhbmd1bGF0ZWQgaW4gcmV2ZXJzZS5cblx0XHRcdFx0Y29uc29sZS5sb2coIFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIgKTtcblxuXHRcdFx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRcdH1cblxuXHRcdFx0LyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXG5cblx0XHRcdHUgPSB2OyBcdCBcdGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cblx0XHRcdHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cblx0XHRcdHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cblxuXHRcdFx0aWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcblxuXHRcdFx0XHR2YXIgYSwgYiwgYywgcywgdDtcblxuXHRcdFx0XHQvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xuXG5cdFx0XHRcdGEgPSB2ZXJ0c1sgdSBdO1xuXHRcdFx0XHRiID0gdmVydHNbIHYgXTtcblx0XHRcdFx0YyA9IHZlcnRzWyB3IF07XG5cblx0XHRcdFx0Lyogb3V0cHV0IFRyaWFuZ2xlICovXG5cblx0XHRcdFx0Lypcblx0XHRcdFx0cmVzdWx0LnB1c2goIGNvbnRvdXJbIGEgXSApO1xuXHRcdFx0XHRyZXN1bHQucHVzaCggY29udG91clsgYiBdICk7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKCBjb250b3VyWyBjIF0gKTtcblx0XHRcdFx0Ki9cblx0XHRcdFx0cmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxuXHRcdFx0XHRcdGNvbnRvdXJbIGIgXSxcblx0XHRcdFx0XHRjb250b3VyWyBjIF0gXSApO1xuXG5cblx0XHRcdFx0dmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcblxuXHRcdFx0XHQvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xuXG5cdFx0XHRcdGZvciggcyA9IHYsIHQgPSB2ICsgMTsgdCA8IG52OyBzKyssIHQrKyApIHtcblxuXHRcdFx0XHRcdHZlcnRzWyBzIF0gPSB2ZXJ0c1sgdCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRudi0tO1xuXG5cdFx0XHRcdC8qIHJlc2V0IGVycm9yIGRldGVjdGlvbiBjb3VudGVyICovXG5cblx0XHRcdFx0Y291bnQgPSAyICogbnY7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH07XG5cblx0Ly8gY2FsY3VsYXRlIGFyZWEgb2YgdGhlIGNvbnRvdXIgcG9seWdvblxuXG5cdHZhciBhcmVhID0gZnVuY3Rpb24gKCBjb250b3VyICkge1xuXG5cdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcblx0XHR2YXIgYSA9IDAuMDtcblxuXHRcdGZvciggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSsrICkge1xuXG5cdFx0XHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGEgKiAwLjU7XG5cblx0fTtcblxuXHQvLyBzZWUgaWYgcCBpcyBpbnNpZGUgdHJpYW5nbGUgYWJjXG5cblx0dmFyIGluc2lkZVRyaWFuZ2xlID0gZnVuY3Rpb24oIGF4LCBheSxcblx0XHRcdFx0XHRcdFx0XHQgICBieCwgYnksXG5cdFx0XHRcdFx0XHRcdFx0ICAgY3gsIGN5LFxuXHRcdFx0XHRcdFx0XHRcdCAgIHB4LCBweSApIHtcblxuXHRcdCAgdmFyIGFYLCBhWSwgYlgsIGJZO1xuXHRcdCAgdmFyIGNYLCBjWSwgYXB4LCBhcHk7XG5cdFx0ICB2YXIgYnB4LCBicHksIGNweCwgY3B5O1xuXHRcdCAgdmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XG5cblx0XHQgIGFYID0gY3ggLSBieDsgIGFZID0gY3kgLSBieTtcblx0XHQgIGJYID0gYXggLSBjeDsgIGJZID0gYXkgLSBjeTtcblx0XHQgIGNYID0gYnggLSBheDsgIGNZID0gYnkgLSBheTtcblx0XHQgIGFweD0gcHggIC1heDsgIGFweT0gcHkgLSBheTtcblx0XHQgIGJweD0gcHggLSBieDsgIGJweT0gcHkgLSBieTtcblx0XHQgIGNweD0gcHggLSBjeDsgIGNweT0gcHkgLSBjeTtcblxuXHRcdCAgYUNST1NTYnAgPSBhWCpicHkgLSBhWSpicHg7XG5cdFx0ICBjQ1JPU1NhcCA9IGNYKmFweSAtIGNZKmFweDtcblx0XHQgIGJDUk9TU2NwID0gYlgqY3B5IC0gYlkqY3B4O1xuXG5cdFx0ICByZXR1cm4gKCAoYUNST1NTYnAgPj0gMC4wKSAmJiAoYkNST1NTY3AgPj0gMC4wKSAmJiAoY0NST1NTYXAgPj0gMC4wKSApO1xuXG5cdH07XG5cblxuXHR2YXIgc25pcCA9IGZ1bmN0aW9uICggY29udG91ciwgdSwgdiwgdywgbiwgdmVydHMgKSB7XG5cblx0XHR2YXIgcDtcblx0XHR2YXIgYXgsIGF5LCBieCwgYnk7XG5cdFx0dmFyIGN4LCBjeSwgcHgsIHB5O1xuXG5cdFx0YXggPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueDtcblx0XHRheSA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS55O1xuXG5cdFx0YnggPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueDtcblx0XHRieSA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS55O1xuXG5cdFx0Y3ggPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueDtcblx0XHRjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xuXG5cdFx0aWYgKCBFUFNJTE9OID4gKCgoYngtYXgpKihjeS1heSkpIC0gKChieS1heSkqKGN4LWF4KSkpICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRmb3IgKCBwID0gMDsgcCA8IG47IHArKyApIHtcblxuXHRcdFx0XHRpZiggKHAgPT0gdSkgfHwgKHAgPT0gdikgfHwgKHAgPT0gdykgKSBjb250aW51ZTtcblxuXHRcdFx0XHRweCA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS54XG5cdFx0XHRcdHB5ID0gY29udG91clsgdmVydHNbIHAgXSBdLnlcblxuXHRcdFx0XHRpZiAoIGluc2lkZVRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gdHJ1ZTtcblxuXHR9O1xuXG5cblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlID0gcHJvY2Vzcztcblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlLmFyZWEgPSBhcmVhO1xuXG5cdHJldHVybiBuYW1lc3BhY2U7XG5cbn0pKFRIUkVFLkZvbnRVdGlscyk7XG5cbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXG5zZWxmLl90eXBlZmFjZV9qcyA9IHsgZmFjZXM6IFRIUkVFLkZvbnRVdGlscy5mYWNlcywgbG9hZEZhY2U6IFRIUkVFLkZvbnRVdGlscy5sb2FkRmFjZSB9O1xuLyoqXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0RMaXRlL3NyYy9hd2F5M2RsaXRlL3ByaW1pdGl2ZXMvVG9ydXMuYXM/cj0yODg4XG4gKi9cblxuVEhSRUUuVG9ydXNHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCBzZWdtZW50c1IsIHNlZ21lbnRzVCwgYXJjICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcblx0dGhpcy50dWJlID0gdHViZSB8fCA0MDtcblx0dGhpcy5zZWdtZW50c1IgPSBzZWdtZW50c1IgfHwgODtcblx0dGhpcy5zZWdtZW50c1QgPSBzZWdtZW50c1QgfHwgNjtcblx0dGhpcy5hcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cblx0dmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHV2cyA9IFtdLCBub3JtYWxzID0gW107XG5cblx0Zm9yICggdmFyIGogPSAwOyBqIDw9IHRoaXMuc2VnbWVudHNSOyBqICsrICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IHRoaXMuc2VnbWVudHNUOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IGkgLyB0aGlzLnNlZ21lbnRzVCAqIHRoaXMuYXJjO1xuXHRcdFx0dmFyIHYgPSBqIC8gdGhpcy5zZWdtZW50c1IgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0Y2VudGVyLnggPSB0aGlzLnJhZGl1cyAqIE1hdGguY29zKCB1ICk7XG5cdFx0XHRjZW50ZXIueSA9IHRoaXMucmFkaXVzICogTWF0aC5zaW4oIHUgKTtcblxuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2ZWN0b3IueCA9ICggdGhpcy5yYWRpdXMgKyB0aGlzLnR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0dmVjdG9yLnkgPSAoIHRoaXMucmFkaXVzICsgdGhpcy50dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5zaW4oIHUgKTtcblx0XHRcdHZlY3Rvci56ID0gdGhpcy50dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCB2ZWN0b3IgKSApO1xuXG5cdFx0XHR1dnMucHVzaCggbmV3IFRIUkVFLlVWKCBpIC8gdGhpcy5zZWdtZW50c1QsIDEgLSBqIC8gdGhpcy5zZWdtZW50c1IgKSApO1xuXHRcdFx0bm9ybWFscy5wdXNoKCB2ZWN0b3IuY2xvbmUoKS5zdWJTZWxmKCBjZW50ZXIgKS5ub3JtYWxpemUoKSApO1xuXG5cdFx0fVxuXHR9XG5cblxuXHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gdGhpcy5zZWdtZW50c1I7IGogKysgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdGhpcy5zZWdtZW50c1Q7IGkgKysgKSB7XG5cblx0XHRcdHZhciBhID0gKCB0aGlzLnNlZ21lbnRzVCArIDEgKSAqIGogKyBpIC0gMTtcblx0XHRcdHZhciBiID0gKCB0aGlzLnNlZ21lbnRzVCArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xuXHRcdFx0dmFyIGMgPSAoIHRoaXMuc2VnbWVudHNUICsgMSApICogKCBqIC0gMSApICsgaTtcblx0XHRcdHZhciBkID0gKCB0aGlzLnNlZ21lbnRzVCArIDEgKSAqIGogKyBpO1xuXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlNCggYSwgYiwgYywgZCwgWyBub3JtYWxzWyBhIF0sIG5vcm1hbHNbIGIgXSwgbm9ybWFsc1sgYyBdLCBub3JtYWxzWyBkIF0gXSApO1xuXHRcdFx0ZmFjZS5ub3JtYWwuYWRkU2VsZiggbm9ybWFsc1sgYSBdICk7XG5cdFx0XHRmYWNlLm5vcm1hbC5hZGRTZWxmKCBub3JtYWxzWyBiIF0gKTtcblx0XHRcdGZhY2Uubm9ybWFsLmFkZFNlbGYoIG5vcm1hbHNbIGMgXSApO1xuXHRcdFx0ZmFjZS5ub3JtYWwuYWRkU2VsZiggbm9ybWFsc1sgZCBdICk7XG5cdFx0XHRmYWNlLm5vcm1hbC5ub3JtYWxpemUoKTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XG5cblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcblxufTtcblxuVEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNHZW9tZXRyeTtcbi8qKlxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcbiAqL1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCBzZWdtZW50c1IsIHNlZ21lbnRzVCwgcCwgcSwgaGVpZ2h0U2NhbGUgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMjAwO1xuXHR0aGlzLnR1YmUgPSB0dWJlIHx8IDQwO1xuXHR0aGlzLnNlZ21lbnRzUiA9IHNlZ21lbnRzUiB8fCA2NDtcblx0dGhpcy5zZWdtZW50c1QgPSBzZWdtZW50c1QgfHwgODtcblx0dGhpcy5wID0gcCB8fCAyO1xuXHR0aGlzLnEgPSBxIHx8IDM7XG5cdHRoaXMuaGVpZ2h0U2NhbGUgPSBoZWlnaHRTY2FsZSB8fCAxO1xuXHR0aGlzLmdyaWQgPSBuZXcgQXJyYXkodGhpcy5zZWdtZW50c1IpO1xuXG5cdHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuc2VnbWVudHNSOyArKyBpICkge1xuXG5cdFx0dGhpcy5ncmlkWyBpIF0gPSBuZXcgQXJyYXkoIHRoaXMuc2VnbWVudHNUICk7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRzVDsgKysgaiApIHtcblxuXHRcdFx0dmFyIHUgPSBpIC8gdGhpcy5zZWdtZW50c1IgKiAyICogdGhpcy5wICogTWF0aC5QSTtcblx0XHRcdHZhciB2ID0gaiAvIHRoaXMuc2VnbWVudHNUICogMiAqIE1hdGguUEk7XG5cdFx0XHR2YXIgcCA9IGdldFBvcyggdSwgdiwgdGhpcy5xLCB0aGlzLnAsIHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodFNjYWxlICk7XG5cdFx0XHR2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCB2LCB0aGlzLnEsIHRoaXMucCwgdGhpcy5yYWRpdXMsIHRoaXMuaGVpZ2h0U2NhbGUgKTtcblx0XHRcdHZhciBjeCwgY3k7XG5cblx0XHRcdHRhbmcueCA9IHAyLnggLSBwLng7IHRhbmcueSA9IHAyLnkgLSBwLnk7IHRhbmcueiA9IHAyLnogLSBwLno7XG5cdFx0XHRuLnggPSBwMi54ICsgcC54OyBuLnkgPSBwMi55ICsgcC55OyBuLnogPSBwMi56ICsgcC56OyBcblx0XHRcdGJpdGFuLmNyb3NzKCB0YW5nLCBuICk7XG5cdFx0XHRuLmNyb3NzKCBiaXRhbiwgdGFuZyApO1xuXHRcdFx0Yml0YW4ubm9ybWFsaXplKCk7XG5cdFx0XHRuLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRjeCA9IC0gdGhpcy50dWJlICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cblx0XHRcdGN5ID0gdGhpcy50dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0cC54ICs9IGN4ICogbi54ICsgY3kgKiBiaXRhbi54O1xuXHRcdFx0cC55ICs9IGN4ICogbi55ICsgY3kgKiBiaXRhbi55O1xuXHRcdFx0cC56ICs9IGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xuXG5cdFx0XHR0aGlzLmdyaWRbIGkgXVsgaiBdID0gdmVydCggcC54LCBwLnksIHAueiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnNlZ21lbnRzUjsgKysgaSApIHtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHRoaXMuc2VnbWVudHNUOyArKyBqICkge1xuXG5cdFx0XHR2YXIgaXAgPSAoIGkgKyAxICkgJSB0aGlzLnNlZ21lbnRzUjtcblx0XHRcdHZhciBqcCA9ICggaiArIDEgKSAlIHRoaXMuc2VnbWVudHNUO1xuXHRcdFx0dmFyIGEgPSB0aGlzLmdyaWRbIGkgXVsgaiBdOyBcblx0XHRcdHZhciBiID0gdGhpcy5ncmlkWyBpcCBdWyBqIF07XG5cdFx0XHR2YXIgYyA9IHRoaXMuZ3JpZFsgaXAgXVsganAgXTtcblx0XHRcdHZhciBkID0gdGhpcy5ncmlkWyBpIF1bIGpwIF07IFxuXG5cdFx0XHR2YXIgdXZhID0gbmV3IFRIUkVFLlVWKCBpIC8gdGhpcy5zZWdtZW50c1IsIGogLyB0aGlzLnNlZ21lbnRzVCApO1xuXHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5VViggKCBpICsgMSApIC8gdGhpcy5zZWdtZW50c1IsIGogLyB0aGlzLnNlZ21lbnRzVCApO1xuXHRcdFx0dmFyIHV2YyA9IG5ldyBUSFJFRS5VViggKCBpICsgMSApIC8gdGhpcy5zZWdtZW50c1IsICggaiArIDEgKSAvIHRoaXMuc2VnbWVudHNUICk7XG5cdFx0XHR2YXIgdXZkID0gbmV3IFRIUkVFLlVWKCBpIC8gdGhpcy5zZWdtZW50c1IsICggaiArIDEgKSAvIHRoaXMuc2VnbWVudHNUICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBjLCBkICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLHV2Yix1dmMsIHV2ZCBdICk7XG5cblx0XHR9XG5cdH1cblxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XG5cblx0XHRyZXR1cm4gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlcnRleCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApICkgLSAxO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQb3MoIHUsIHYsIGluX3EsIGluX3AsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKSB7XG5cblx0XHR2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xuXHRcdHZhciBjdiA9IE1hdGguY29zKCB2ICk7XG5cdFx0dmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcblx0XHR2YXIgcXVPdmVyUCA9IGluX3EgLyBpbl9wICogdTtcblx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG5cdFx0dmFyIHR4ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuXHRcdHZhciB0eSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcblx0XHR2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk7XG4vKlxuICpcdEBhdXRob3Igeno4NSAvIGh0dHA6Ly90d2l0dGVyLmNvbS9ibHVyc3BsaW5lIC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZyBcbiAqIFxuICpcdFN1YmRpdmlzaW9uIEdlb21ldHJ5IE1vZGlmaWVyIFxuICpcdFx0dXNpbmcgQ2F0bXVsbC1DbGFyayBTdWJkaXZpc2lvbiBTdXJmYWNlc1xuICpcdFx0Zm9yIGNyZWF0aW5nIHNtb290aCBnZW9tZXRyeSBtZXNoZXNcbiAqXG4gKlx0Tm90ZTogYSBtb2RpZmllciBtb2RpZmllcyB2ZXJ0aWNlcyBhbmQgZmFjZXMgb2YgZ2VvbWV0cnksXG4gKlx0XHRzbyB1c2UgVEhSRUUuR2VvbWV0cnlVdGlscy5jbG9uZSgpIGlmIG9yaWduYWwgZ2VvZW10cnkgbmVlZHMgdG8gYmUgcmV0YWluZWRcbiAqIFxuICpcdFJlYWRpbmdzOiBcbiAqXHRcdGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F0bXVsbCVFMiU4MCU5M0NsYXJrX3N1YmRpdmlzaW9uX3N1cmZhY2VcbiAqXHRcdGh0dHA6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDA4LzA4LzAxL2NhdG11bGwtY2xhcmstc3ViZGl2aXNpb24tdGhlLWJhc2ljcy9cbiAqXHRcdGh0dHA6Ly94cnQud2lraWRvdC5jb20vYmxvZzozMVxuICpcdFx0XCJTdWJkaXZpc2lvbiBTdXJmYWNlcyBpbiBDaGFyYWN0ZXIgQW5pbWF0aW9uXCJcbiAqXG4gKlx0U3VwcG9ydHM6XG4gKlx0XHRDbG9zZWQgYW5kIE9wZW4gZ2VvbWV0cmllcy5cbiAqXG4gKlx0VE9ETzogXG4gKlx0XHRjcmVhc2UgdmVydGV4IGFuZCBcInNlbWktc2hhcnBcIiBmZWF0dXJlc1xuICpcdFx0c2VsZWN0aXZlIHN1YmRpdmlzaW9uXG4gKi9cblxuVEhSRUUuU3ViZGl2aXNpb25Nb2RpZmllciA9IGZ1bmN0aW9uKCBzdWJkaXZpc2lvbnMgKSB7XG5cdFxuXHR0aGlzLnN1YmRpdmlzaW9ucyA9IChzdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApID8gMSA6IHN1YmRpdmlzaW9ucztcblx0XG5cdC8vIFNldHRpbmdzXG5cdHRoaXMudXNlT2xkVmVydGV4Q29sb3JzID0gZmFsc2U7XG5cdHRoaXMuc3VwcG9ydFVWcyA9IHRydWU7XG5cdFxufTtcblxuLy9USFJFRS5TdWJkaXZpc2lvbk1vZGlmaWVyLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5Nb2RpZmllcigpO1xuXG5USFJFRS5TdWJkaXZpc2lvbk1vZGlmaWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlN1YmRpdmlzaW9uTW9kaWZpZXI7XG5cbi8vIEFwcGxpZXMgdGhlIFwibW9kaWZ5XCIgcGF0dGVyblxuVEhSRUUuU3ViZGl2aXNpb25Nb2RpZmllci5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblx0XG5cdHZhciByZXBlYXRzID0gdGhpcy5zdWJkaXZpc2lvbnM7XG5cdFxuXHR3aGlsZSAoIHJlcGVhdHMtLSA+IDAgKSB7XG5cdFx0dGhpcy5zbW9vdGgoIGdlb21ldHJ5ICk7XG5cdH1cblx0XG59O1xuXG4vLyBQZXJmb3JtcyBhbiBpdGVyYXRpb24gb2YgQ2F0bXVsbC1DbGFyayBTdWJkaXZpc2lvblxuVEhSRUUuU3ViZGl2aXNpb25Nb2RpZmllci5wcm90b3R5cGUuc21vb3RoID0gZnVuY3Rpb24gKCBvbGRHZW9tZXRyeSApIHtcblx0XG5cdC8vY29uc29sZS5sb2coICdydW5uaW5nIHNtb290aCcgKTtcblx0XG5cdC8vIE5ldyBzZXQgb2YgdmVydGljZXMsIGZhY2VzIGFuZCB1dnNcblx0dmFyIG5ld1ZlcnRpY2VzID0gW10sIG5ld0ZhY2VzID0gW10sIG5ld1VWcyA9IFtdO1xuXHRcblx0ZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcblx0XHRuZXdWZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgKTtcblx0fVxuXHRcblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgb2xkRmFjZSwgb3JkZXJzICkge1xuXHRcdFxuXHRcdC8vIFRPRE8gbW92ZSB2ZXJ0ZXggc2VsZWN0aW9uIG92ZXIgaGVyZSFcblx0XHRcblx0XHR2YXIgbmV3RmFjZSA9IG5ldyBUSFJFRS5GYWNlNCggYSwgYiwgYywgZCwgbnVsbCwgb2xkRmFjZS5jb2xvciwgb2xkRmFjZS5tYXRlcmlhbCApO1xuXHRcdFxuXHRcdGlmIChzY29wZS51c2VPbGRWZXJ0ZXhDb2xvcnMpIHtcblx0XHRcdFxuXHRcdFx0bmV3RmFjZS52ZXJ0ZXhDb2xvcnMgPSBbXTsgXG5cdFx0XHRcblx0XHRcdHZhciBjb2xvciwgdG1wQ29sb3IsIG9yZGVyO1xuXHRcdFx0Zm9yICh2YXIgaT0wO2k8NDtpKyspIHtcblx0XHRcdFx0b3JkZXIgPSBvcmRlcnNbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLFxuXHRcdFx0XHRjb2xvci5zZXRSR0IoMCwwLDApO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaj0wLCBqbD0wOyBqPG9yZGVyLmxlbmd0aDtqKyspIHtcblx0XHRcdFx0XHR0bXBDb2xvciA9IG9sZEZhY2UudmVydGV4Q29sb3JzW29yZGVyW2pdLTFdO1xuXHRcdFx0XHRcdGNvbG9yLnIgKz0gdG1wQ29sb3Iucjtcblx0XHRcdFx0XHRjb2xvci5nICs9IHRtcENvbG9yLmc7XG5cdFx0XHRcdFx0Y29sb3IuYiArPSB0bXBDb2xvci5iO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb2xvci5yIC89IG9yZGVyLmxlbmd0aDtcblx0XHRcdFx0Y29sb3IuZyAvPSBvcmRlci5sZW5ndGg7XG5cdFx0XHRcdGNvbG9yLmIgLz0gb3JkZXIubGVuZ3RoO1xuXHRcdFx0XHRcblx0XHRcdFx0bmV3RmFjZS52ZXJ0ZXhDb2xvcnNbaV0gPSBjb2xvcjtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9XG5cdFx0XG5cdFx0bmV3RmFjZXMucHVzaCggbmV3RmFjZSApO1xuXHRcdFxuXHRcdGlmICghc2NvcGUuc3VwcG9ydFVWcyB8fCB1dkZvclZlcnRpY2VzLmxlbmd0aCE9MCkge1xuXHRcdFx0bmV3VVZzLnB1c2goIFtcblx0XHRcdFx0dXZGb3JWZXJ0aWNlc1thXSxcblx0XHRcdFx0dXZGb3JWZXJ0aWNlc1tiXSxcblx0XHRcdFx0dXZGb3JWZXJ0aWNlc1tjXSxcblx0XHRcdFx0dXZGb3JWZXJ0aWNlc1tkXVxuXHRcdFx0XSApO1xuXHRcdFx0XG5cdFx0fVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBlZGdlX2hhc2goIGEsIGIgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5taW4oIGEsIGIgKSArIFwiX1wiICsgTWF0aC5tYXgoIGEsIGIgKTtcblxuXHR9O1xuXHRcblx0ZnVuY3Rpb24gY29tcHV0ZUVkZ2VGYWNlcyggZ2VvbWV0cnkgKSB7XG5cblx0XHRmdW5jdGlvbiBhZGRUb01hcCggbWFwLCBoYXNoLCBpICkge1xuXG5cdFx0XHRpZiAoIG1hcFsgaGFzaCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWFwWyBoYXNoIF0gPSBbXTtcblx0XHRcdFx0XG5cdFx0XHR9IFxuXHRcdFx0XG5cdFx0XHRtYXBbIGhhc2ggXS5wdXNoKCBpICk7XG5cblx0XHR9O1xuXG5cdFx0dmFyIGksIGlsLCB2MSwgdjIsIGosIGssXG5cdFx0XHRmYWNlLCBmYWNlSW5kaWNlcywgZmFjZUluZGV4LFxuXHRcdFx0ZWRnZSxcblx0XHRcdGhhc2gsXG5cdFx0XHR2Zk1hcCA9IHt9O1xuXG5cdFx0Ly8gY29uc3RydWN0IHZlcnRleCAtPiBmYWNlIG1hcFxuXG5cdFx0Zm9yKCBpID0gMCwgaWwgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0ZmFjZSA9IGdlb21ldHJ5LmZhY2VzWyBpIF07XG5cblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xuXG5cdFx0XHRcdGhhc2ggPSBlZGdlX2hhc2goIGZhY2UuYSwgZmFjZS5iICk7XG5cdFx0XHRcdGFkZFRvTWFwKCB2Zk1hcCwgaGFzaCwgaSApO1xuXG5cdFx0XHRcdGhhc2ggPSBlZGdlX2hhc2goIGZhY2UuYiwgZmFjZS5jICk7XG5cdFx0XHRcdGFkZFRvTWFwKCB2Zk1hcCwgaGFzaCwgaSApO1xuXG5cdFx0XHRcdGhhc2ggPSBlZGdlX2hhc2goIGZhY2UuYywgZmFjZS5hICk7XG5cdFx0XHRcdGFkZFRvTWFwKCB2Zk1hcCwgaGFzaCwgaSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XG5cblx0XHRcdFx0aGFzaCA9IGVkZ2VfaGFzaCggZmFjZS5hLCBmYWNlLmIgKTtcblx0XHRcdFx0YWRkVG9NYXAoIHZmTWFwLCBoYXNoLCBpICk7XG5cblx0XHRcdFx0aGFzaCA9IGVkZ2VfaGFzaCggZmFjZS5iLCBmYWNlLmMgKTtcblx0XHRcdFx0YWRkVG9NYXAoIHZmTWFwLCBoYXNoLCBpICk7XG5cblx0XHRcdFx0aGFzaCA9IGVkZ2VfaGFzaCggZmFjZS5jLCBmYWNlLmQgKTtcblx0XHRcdFx0YWRkVG9NYXAoIHZmTWFwLCBoYXNoLCBpICk7XG5cdFx0XHRcdFxuXHRcdFx0XHRoYXNoID0gZWRnZV9oYXNoKCBmYWNlLmQsIGZhY2UuYSApO1xuXHRcdFx0XHRhZGRUb01hcCggdmZNYXAsIGhhc2gsIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZXh0cmFjdCBmYWNlc1xuXHRcdFxuXHRcdC8vIHZhciBlZGdlcyA9IFtdO1xuXHRcdC8vIFxuXHRcdC8vIHZhciBudW1PZkVkZ2VzID0gMDtcblx0XHQvLyBmb3IgKGkgaW4gdmZNYXApIHtcblx0XHQvLyBcdG51bU9mRWRnZXMrKztcblx0XHQvLyBcdFxuXHRcdC8vIFx0ZWRnZSA9IHZmTWFwW2ldO1xuXHRcdC8vIFx0ZWRnZXMucHVzaChlZGdlKTtcblx0XHQvLyBcdFxuXHRcdC8vIH1cblx0XHRcblx0XHQvL2NvbnNvbGUubG9nKCd2Zk1hcCcsIHZmTWFwLCAnZ2VvbWV0cnkuZWRnZXMnLGdlb21ldHJ5LmVkZ2VzLCAnbnVtT2ZFZGdlcycsIG51bU9mRWRnZXMpO1xuXG5cdFx0cmV0dXJuIHZmTWFwO1xuXG5cdH07XG5cdFxuXHR2YXIgb3JpZ2luYWxQb2ludHMgPSBvbGRHZW9tZXRyeS52ZXJ0aWNlcztcblx0dmFyIG9yaWdpbmFsRmFjZXMgPSBvbGRHZW9tZXRyeS5mYWNlcztcblx0XG5cdHZhciBuZXdQb2ludHMgPSBvcmlnaW5hbFBvaW50cy5jb25jYXQoKTsgLy8gVmVydGljZXNcblx0XHRcblx0dmFyIGZhY2VQb2ludHMgPSBbXSwgZWRnZVBvaW50cyA9IHt9O1xuXHRcblx0dmFyIHNoYXJwRWRnZXMgPSB7fSwgc2hhcnBWZXJ0aWNlcyA9IFtdLCBzaGFycEZhY2VzID0gW107XG5cdFxuXHR2YXIgdXZGb3JWZXJ0aWNlcyA9IFtdO1xuXHRcblx0Ly8gU3RlcCAxXG5cdC8vXHRGb3IgZWFjaCBmYWNlLCBhZGQgYSBmYWNlIHBvaW50XG5cdC8vXHRTZXQgZWFjaCBmYWNlIHBvaW50IHRvIGJlIHRoZSBjZW50cm9pZCBvZiBhbGwgb3JpZ2luYWwgcG9pbnRzIGZvciB0aGUgcmVzcGVjdGl2ZSBmYWNlLlxuXHRcblx0dmFyIGksIGlsLCBqLCBqbCwgZmFjZTtcblx0XG5cdC8vIEZvciBVdnNcblx0dmFyIHV2cyA9IG9sZEdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbMF07XG5cdHZhciBhYmNkID0gJ2FiY2QnLCB2ZXJ0aWNlO1xuXHRcblx0Zm9yIChpPTAsIGlsID0gdXZzLmxlbmd0aDsgaTxpbDsgaSsrICkge1xuXHRcdGZvciAoaj0wLGpsPXV2c1tpXS5sZW5ndGg7ajxqbDtqKyspIHtcblx0XHRcdHZlcnRpY2UgPSBvcmlnaW5hbEZhY2VzW2ldW2FiY2QuY2hhckF0KGopXTtcblx0XHRcdFxuXHRcdFx0aWYgKCF1dkZvclZlcnRpY2VzW3ZlcnRpY2VdKSB7XG5cdFx0XHRcdHV2Rm9yVmVydGljZXNbdmVydGljZV0gPSB1dnNbaV1bal07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdkdXAnLCBcdHV2Rm9yVmVydGljZXNbdmVydGljZV0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XHR9XG5cdH1cblx0XHRcdFxuXHR2YXIgYXZnVXYgO1xuXHRmb3IgKGk9MCwgaWwgPSBvcmlnaW5hbEZhY2VzLmxlbmd0aDsgaTxpbCA7aSsrKSB7XG5cdFx0ZmFjZSA9IG9yaWdpbmFsRmFjZXNbaV07XG5cdFx0ZmFjZVBvaW50cy5wdXNoKGZhY2UuY2VudHJvaWQpO1xuXHRcdG5ld1BvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KGZhY2UuY2VudHJvaWQpICk7XG5cdFx0XG5cdFx0XG5cdFx0aWYgKCFzY29wZS5zdXBwb3J0VVZzIHx8IHV2Rm9yVmVydGljZXMubGVuZ3RoPT0wKSBjb250aW51ZTtcblx0XHRcblx0XHQvLyBQcmVwYXJlIHN1YmRpdmlkZWQgdXZcblx0XHRcblx0XHRhdmdVdiA9IG5ldyBUSFJFRS5VVigpO1xuXHRcdFxuXHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xuXHRcdFx0YXZnVXYudSA9IHV2Rm9yVmVydGljZXNbZmFjZS5hXS51ICsgdXZGb3JWZXJ0aWNlc1tmYWNlLmJdLnUgKyB1dkZvclZlcnRpY2VzW2ZhY2UuY10udTtcblx0XHRcdGF2Z1V2LnYgPSB1dkZvclZlcnRpY2VzW2ZhY2UuYV0udiArIHV2Rm9yVmVydGljZXNbZmFjZS5iXS52ICsgdXZGb3JWZXJ0aWNlc1tmYWNlLmNdLnY7XG5cdFx0XHRhdmdVdi51IC89IDM7XG5cdFx0XHRhdmdVdi52IC89IDM7XG5cdFx0XHRcblx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XG5cdFx0XHRhdmdVdi51ID0gdXZGb3JWZXJ0aWNlc1tmYWNlLmFdLnUgKyB1dkZvclZlcnRpY2VzW2ZhY2UuYl0udSArIHV2Rm9yVmVydGljZXNbZmFjZS5jXS51ICsgdXZGb3JWZXJ0aWNlc1tmYWNlLmRdLnU7XG5cdFx0XHRhdmdVdi52ID0gdXZGb3JWZXJ0aWNlc1tmYWNlLmFdLnYgKyB1dkZvclZlcnRpY2VzW2ZhY2UuYl0udiArIHV2Rm9yVmVydGljZXNbZmFjZS5jXS52ICsgdXZGb3JWZXJ0aWNlc1tmYWNlLmRdLnY7XG5cdFx0XHRhdmdVdi51IC89IDQ7XG5cdFx0XHRhdmdVdi52IC89IDQ7XG5cdFx0fVxuXHRcblx0XHR1dkZvclZlcnRpY2VzLnB1c2goYXZnVXYpO1xuXHR9XG5cblx0Ly8gU3RlcCAyXG5cdC8vXHRGb3IgZWFjaCBlZGdlLCBhZGQgYW4gZWRnZSBwb2ludC5cblx0Ly9cdFNldCBlYWNoIGVkZ2UgcG9pbnQgdG8gYmUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBuZWlnaGJvdXJpbmcgZmFjZSBwb2ludHMgYW5kIGl0cyB0d28gb3JpZ2luYWwgZW5kcG9pbnRzLlxuXHRcblx0dmFyIHZmTWFwID0gY29tcHV0ZUVkZ2VGYWNlcyAoIG9sZEdlb21ldHJ5ICk7XG5cdHZhciBlZGdlLCBmYWNlSW5kZXhBLCBmYWNlSW5kZXhCLCBhdmc7XG5cdFxuXHQvL2NvbnNvbGUubG9nKCd2Zk1hcCcsIHZmTWFwKTtcblxuXHR2YXIgZWRnZUNvdW50ID0gMDtcblx0dmFyIG9yaWdpbmFsVmVydGljZXNMZW5ndGggPSBvcmlnaW5hbFBvaW50cy5sZW5ndGg7XG5cdHZhciBlZGdlVmVydGV4LCBlZGdlVmVydGV4QSwgZWRnZVZlcnRleEI7XG5cdFxuXHQvLy8vXG5cdFxuXHR2YXIgdmVydGV4RWRnZU1hcCA9IHt9O1xuXHR2YXIgdmVydGV4RmFjZU1hcCA9IHt9O1xuXHRcblx0dmFyIGFkZFZlcnRleEVkZ2VNYXAgPSBmdW5jdGlvbih2ZXJ0ZXgsIGVkZ2UpIHtcblx0XHRpZiAodmVydGV4RWRnZU1hcFt2ZXJ0ZXhdPT09dW5kZWZpbmVkKSB7XG5cdFx0XHR2ZXJ0ZXhFZGdlTWFwW3ZlcnRleF0gPSBbXTtcblx0XHR9XG5cdFx0XG5cdFx0dmVydGV4RWRnZU1hcFt2ZXJ0ZXhdLnB1c2goZWRnZSk7XG5cdH07XG5cdFxuXHR2YXIgYWRkVmVydGV4RmFjZU1hcCA9IGZ1bmN0aW9uKHZlcnRleCwgZmFjZSwgZWRnZSkge1xuXHRcdGlmICh2ZXJ0ZXhGYWNlTWFwW3ZlcnRleF09PT11bmRlZmluZWQpIHtcblx0XHRcdHZlcnRleEZhY2VNYXBbdmVydGV4XSA9IHt9O1xuXHRcdH1cblx0XHRcblx0XHQvL3ZlcnRleEZhY2VNYXBbdmVydGV4XVtmYWNlXSA9IGVkZ2U7XG5cdFx0dmVydGV4RmFjZU1hcFt2ZXJ0ZXhdW2ZhY2VdID0gbnVsbDtcblx0fTtcblx0XG5cdC8vIFByZXBhcmVzIHZlcnRleEVkZ2VNYXAgYW5kIHZlcnRleEZhY2VNYXBcblx0Zm9yIChpIGluIHZmTWFwKSB7IC8vIFRoaXMgaXMgZm9yIGV2ZXJ5IGVkZ2Vcblx0XHRlZGdlID0gdmZNYXBbaV07XG5cdFx0XG5cdFx0ZWRnZVZlcnRleCA9IGkuc3BsaXQoJ18nKTtcblx0XHRlZGdlVmVydGV4QSA9IGVkZ2VWZXJ0ZXhbMF07XG5cdFx0ZWRnZVZlcnRleEIgPSBlZGdlVmVydGV4WzFdO1xuXHRcdFxuXHRcdC8vIE1hcHMgYW4gZWRnZVZlcnRleCB0byBjb25uZWN0aW5nIGVkZ2VzXG5cdFx0YWRkVmVydGV4RWRnZU1hcChlZGdlVmVydGV4QSwgW2VkZ2VWZXJ0ZXhBLCBlZGdlVmVydGV4Ql0gKTtcblx0XHRhZGRWZXJ0ZXhFZGdlTWFwKGVkZ2VWZXJ0ZXhCLCBbZWRnZVZlcnRleEEsIGVkZ2VWZXJ0ZXhCXSApO1xuXHRcdFxuXHRcdFxuXHRcdC8vIGZhY2VJbmRleEEgPSBlZGdlWzBdOyAvLyBmYWNlIGluZGV4IGFcblx0XHQvLyBmYWNlSW5kZXhCID0gZWRnZVsxXTsgLy8gZmFjZSBpbmRleCBiXG5cdFx0Ly8gXG5cdFx0Ly8gLy8gQWRkIGNvbm5lY3RpbmcgZmFjZXMgZm9yIGVkZ2Vcblx0XHQvLyBhZGRWZXJ0ZXhGYWNlTWFwKGVkZ2VWZXJ0ZXhBLCBmYWNlSW5kZXhBKTtcblx0XHQvLyBhZGRWZXJ0ZXhGYWNlTWFwKGVkZ2VWZXJ0ZXhCLCBmYWNlSW5kZXhBKTtcblx0XHQvLyBcblx0XHQvLyBcblx0XHQvLyBpZiAoZmFjZUluZGV4Qikge1xuXHRcdC8vIFx0YWRkVmVydGV4RmFjZU1hcChlZGdlVmVydGV4QSwgZmFjZUluZGV4Qik7XG5cdFx0Ly8gXHRhZGRWZXJ0ZXhGYWNlTWFwKGVkZ2VWZXJ0ZXhCLCBmYWNlSW5kZXhCKTtcblx0XHQvLyB9IGVsc2Uge1xuXHRcdC8vIFx0YWRkVmVydGV4RmFjZU1hcChlZGdlVmVydGV4QSwgZmFjZUluZGV4QSk7XG5cdFx0Ly8gXHRhZGRWZXJ0ZXhGYWNlTWFwKGVkZ2VWZXJ0ZXhCLCBmYWNlSW5kZXhBKTtcblx0XHQvLyB9XG5cdFx0XG5cdFx0Zm9yIChqPTAsamw9ZWRnZS5sZW5ndGg7ajxqbDtqKyspIHtcblx0XHRcdGZhY2UgPSBlZGdlW2pdO1xuXHRcdFx0XG5cdFx0XHRhZGRWZXJ0ZXhGYWNlTWFwKGVkZ2VWZXJ0ZXhBLCBmYWNlLCBpKTtcblx0XHRcdGFkZFZlcnRleEZhY2VNYXAoZWRnZVZlcnRleEIsIGZhY2UsIGkpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoZWRnZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBlZGdlIGlzIFwic2hhcnBcIjtcblx0XHRcdHNoYXJwRWRnZXNbaV0gPSB0cnVlO1xuXHRcdFx0c2hhcnBWZXJ0aWNlc1tlZGdlVmVydGV4QV0gPSB0cnVlO1xuXHRcdFx0c2hhcnBWZXJ0aWNlc1tlZGdlVmVydGV4Ql0gPSB0cnVlO1xuXHRcdFx0XG5cdFx0fVxuXHRcdFxuXHR9XG5cdFxuXHRcblx0XG5cdC8vY29uc29sZS5sb2coJ3ZlcnRleEVkZ2VNYXAnLHZlcnRleEVkZ2VNYXAsICd2ZXJ0ZXhGYWNlTWFwJywgdmVydGV4RmFjZU1hcCk7XG5cdFxuXHRcblx0Zm9yIChpIGluIHZmTWFwKSB7XG5cdFx0ZWRnZSA9IHZmTWFwW2ldO1xuXHRcdFxuXHRcdGZhY2VJbmRleEEgPSBlZGdlWzBdOyAvLyBmYWNlIGluZGV4IGFcblx0XHRmYWNlSW5kZXhCID0gZWRnZVsxXTsgLy8gZmFjZSBpbmRleCBiXG5cdFx0XG5cdFx0ZWRnZVZlcnRleCA9IGkuc3BsaXQoJ18nKTtcblx0XHRlZGdlVmVydGV4QSA9IGVkZ2VWZXJ0ZXhbMF07XG5cdFx0ZWRnZVZlcnRleEIgPSBlZGdlVmVydGV4WzFdO1xuXHRcdFxuXHRcdFxuXHRcdGF2ZyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XG5cdFx0Ly9jb25zb2xlLmxvZyhpLCBmYWNlSW5kZXhCLGZhY2VQb2ludHNbZmFjZUluZGV4Ql0pO1xuXHRcdFxuXHRcdGlmIChzaGFycEVkZ2VzW2ldKSB7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCd3YXJuaW5nLCAnLCBpLCAnZWRnZSBoYXMgb25seSAxIGNvbm5lY3RpbmcgZmFjZScsIGVkZ2UpO1xuXHRcdFx0XG5cdFx0XHQvLyBGb3IgYSBzaGFycCBlZGdlLCBhdmVyYWdlIHRoZSBlZGdlIGVuZCBwb2ludHMuXG5cdFx0XHRhdmcuYWRkU2VsZihvcmlnaW5hbFBvaW50c1tlZGdlVmVydGV4QV0ucG9zaXRpb24pO1xuXHRcdFx0YXZnLmFkZFNlbGYob3JpZ2luYWxQb2ludHNbZWRnZVZlcnRleEJdLnBvc2l0aW9uKTtcblx0XHRcdFxuXHRcdFx0YXZnLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cdFx0XHRcblx0XHRcdHNoYXJwVmVydGljZXNbbmV3UG9pbnRzLmxlbmd0aF0gPSB0cnVlO1xuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcblx0XHRcdGF2Zy5hZGRTZWxmKGZhY2VQb2ludHNbZmFjZUluZGV4QV0pO1xuXHRcdFx0YXZnLmFkZFNlbGYoZmFjZVBvaW50c1tmYWNlSW5kZXhCXSk7XG5cdFx0XG5cdFx0XHRhdmcuYWRkU2VsZihvcmlnaW5hbFBvaW50c1tlZGdlVmVydGV4QV0ucG9zaXRpb24pO1xuXHRcdFx0YXZnLmFkZFNlbGYob3JpZ2luYWxQb2ludHNbZWRnZVZlcnRleEJdLnBvc2l0aW9uKTtcblx0XHRcblx0XHRcdGF2Zy5tdWx0aXBseVNjYWxhcigwLjI1KTtcblx0XHRcblx0XHR9XG5cdFx0XG5cdFx0ZWRnZVBvaW50c1tpXSA9IG9yaWdpbmFsVmVydGljZXNMZW5ndGggKyBvcmlnaW5hbEZhY2VzLmxlbmd0aCArIGVkZ2VDb3VudDtcblx0XHQvL2NvbnNvbGUubG9nKGVkZ2VQb2ludHNbaV0sIG5ld1BvaW50cy5sZW5ndGgpO1xuXHRcdFxuXHRcdG5ld1BvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KGF2ZykgKTtcblx0XG5cdFx0ZWRnZUNvdW50ICsrO1xuXHRcdFxuXHRcdGlmICghc2NvcGUuc3VwcG9ydFVWcyB8fCB1dkZvclZlcnRpY2VzLmxlbmd0aD09MCkgY29udGludWU7XG5cdFx0XG5cdFx0Ly8gUHJlcGFyZSBzdWJkaXZpZGVkIHV2XG5cdFx0XG5cdFx0YXZnVXYgPSBuZXcgVEhSRUUuVVYoKTtcblx0XHRcblx0XHRhdmdVdi51ID0gdXZGb3JWZXJ0aWNlc1tlZGdlVmVydGV4QV0udSArIHV2Rm9yVmVydGljZXNbZWRnZVZlcnRleEJdLnU7XG5cdFx0YXZnVXYudiA9IHV2Rm9yVmVydGljZXNbZWRnZVZlcnRleEFdLnYgKyB1dkZvclZlcnRpY2VzW2VkZ2VWZXJ0ZXhCXS52O1xuXHRcdGF2Z1V2LnUgLz0gMjtcblx0XHRhdmdVdi52IC89IDI7XG5cdFxuXHRcdHV2Rm9yVmVydGljZXMucHVzaChhdmdVdik7XG5cdFx0XG5cdH1cblx0XG5cdC8vIFN0ZXAgM1xuXHQvL1x0Rm9yIGVhY2ggZmFjZSBwb2ludCwgYWRkIGFuIGVkZ2UgZm9yIGV2ZXJ5IGVkZ2Ugb2YgdGhlIGZhY2UsIFxuXHQvL1x0Y29ubmVjdGluZyB0aGUgZmFjZSBwb2ludCB0byBlYWNoIGVkZ2UgcG9pbnQgZm9yIHRoZSBmYWNlLlxuXHRcblx0XG5cdHZhciBmYWNlUHQsIGN1cnJlbnRWZXJ0aWNlSW5kZXg7XG5cdFxuXHR2YXIgaGFzaEFCLCBoYXNoQkMsIGhhc2hDRCwgaGFzaERBLCBoYXNoQ0E7XG5cdFxuXHR2YXIgYWJjMTIzID0gWycxMjMnLCAnMTInLCAnMicsICcyMyddO1xuXHR2YXIgYmNhMTIzID0gWycxMjMnLCAnMjMnLCAnMycsICczMSddO1xuXHR2YXIgY2FiMTIzID0gWycxMjMnLCAnMzEnLCAnMScsICcxMiddO1xuXHR2YXIgYWJjMTIzNCA9IFsnMTIzNCcsICcxMicsICcyJywgJzIzJ107XG5cdHZhciBiY2QxMjM0ID0gWycxMjM0JywgJzIzJywgJzMnLCAnMzQnXTtcblx0dmFyIGNkYTEyMzQgPSBbJzEyMzQnLCAnMzQnLCAnNCcsICc0MSddO1xuXHR2YXIgZGFiMTIzNCA9IFsnMTIzNCcsICc0MScsICcxJywgJzEyJ107XG5cdFxuXHRcblx0Zm9yIChpPTAsIGlsID0gZmFjZVBvaW50cy5sZW5ndGg7IGk8aWwgO2krKykgeyAvLyBmb3IgZXZlcnkgZmFjZVxuXHRcdGZhY2VQdCA9IGZhY2VQb2ludHNbaV07XG5cdFx0ZmFjZSA9IG9yaWdpbmFsRmFjZXNbaV07XG5cdFx0Y3VycmVudFZlcnRpY2VJbmRleCA9IG9yaWdpbmFsVmVydGljZXNMZW5ndGgrIGk7XG5cdFx0XG5cdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XG5cdFx0XHRcblx0XHRcdC8vIGNyZWF0ZSAzIGZhY2U0c1xuXHRcdFx0XG5cdFx0XHRoYXNoQUIgPSBlZGdlX2hhc2goIGZhY2UuYSwgZmFjZS5iICk7XG5cdFx0XHRoYXNoQkMgPSBlZGdlX2hhc2goIGZhY2UuYiwgZmFjZS5jICk7XG5cdFx0XHRoYXNoQ0EgPSBlZGdlX2hhc2goIGZhY2UuYywgZmFjZS5hICk7XG5cdFx0XHRcblx0XHRcdGY0KCBjdXJyZW50VmVydGljZUluZGV4LCBlZGdlUG9pbnRzW2hhc2hBQl0sIGZhY2UuYiwgZWRnZVBvaW50c1toYXNoQkNdLCBmYWNlLCBhYmMxMjMgKTtcblx0XHRcdGY0KCBjdXJyZW50VmVydGljZUluZGV4LCBlZGdlUG9pbnRzW2hhc2hCQ10sIGZhY2UuYywgZWRnZVBvaW50c1toYXNoQ0FdLCBmYWNlLCBiY2ExMjMgKTtcblx0XHRcdGY0KCBjdXJyZW50VmVydGljZUluZGV4LCBlZGdlUG9pbnRzW2hhc2hDQV0sIGZhY2UuYSwgZWRnZVBvaW50c1toYXNoQUJdLCBmYWNlLCBjYWIxMjMgKTtcblx0XHRcdFxuXHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcblx0XHRcdC8vIGNyZWF0ZSA0IGZhY2U0c1xuXHRcdFx0XG5cdFx0XHRoYXNoQUIgPSBlZGdlX2hhc2goIGZhY2UuYSwgZmFjZS5iICk7XG5cdFx0XHRoYXNoQkMgPSBlZGdlX2hhc2goIGZhY2UuYiwgZmFjZS5jICk7XG5cdFx0XHRoYXNoQ0QgPSBlZGdlX2hhc2goIGZhY2UuYywgZmFjZS5kICk7XG5cdFx0XHRoYXNoREEgPSBlZGdlX2hhc2goIGZhY2UuZCwgZmFjZS5hICk7XG5cdFx0XHRcblx0XHRcdGY0KCBjdXJyZW50VmVydGljZUluZGV4LCBlZGdlUG9pbnRzW2hhc2hBQl0sIGZhY2UuYiwgZWRnZVBvaW50c1toYXNoQkNdLCBmYWNlLCBhYmMxMjM0ICk7XG5cdFx0XHRmNCggY3VycmVudFZlcnRpY2VJbmRleCwgZWRnZVBvaW50c1toYXNoQkNdLCBmYWNlLmMsIGVkZ2VQb2ludHNbaGFzaENEXSwgZmFjZSwgYmNkMTIzNCApO1xuXHRcdFx0ZjQoIGN1cnJlbnRWZXJ0aWNlSW5kZXgsIGVkZ2VQb2ludHNbaGFzaENEXSwgZmFjZS5kLCBlZGdlUG9pbnRzW2hhc2hEQV0sIGZhY2UsIGNkYTEyMzQgKTtcblx0XHRcdGY0KCBjdXJyZW50VmVydGljZUluZGV4LCBlZGdlUG9pbnRzW2hhc2hEQV0sIGZhY2UuYSwgZWRnZVBvaW50c1toYXNoQUJdLCBmYWNlLCBkYWIxMjM0ICApO1xuXG5cdFx0XHRcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZygnZmFjZSBzaG91bGQgYmUgYSBmYWNlIScsIGZhY2UpO1xuXHRcdH1cblx0fVxuXHRcblx0bmV3VmVydGljZXMgPSBuZXdQb2ludHM7XG5cdFxuXHQvLyBjb25zb2xlLmxvZygnb3JpZ2luYWwgJywgb2xkR2VvbWV0cnkudmVydGljZXMubGVuZ3RoLCBvbGRHZW9tZXRyeS5mYWNlcy5sZW5ndGggKTtcblx0Ly8gY29uc29sZS5sb2coJ25ldyBwb2ludHMnLCBuZXdQb2ludHMubGVuZ3RoLCAnZmFjZXMnLCBuZXdGYWNlcy5sZW5ndGggKTtcblx0XG5cdC8vIFN0ZXAgNFxuXHRcblx0Ly9cdEZvciBlYWNoIG9yaWdpbmFsIHBvaW50IFAsIFxuXHQvL1x0XHR0YWtlIHRoZSBhdmVyYWdlIEYgb2YgYWxsIG4gZmFjZSBwb2ludHMgZm9yIGZhY2VzIHRvdWNoaW5nIFAsIFxuXHQvL1x0XHRhbmQgdGFrZSB0aGUgYXZlcmFnZSBSIG9mIGFsbCBuIGVkZ2UgbWlkcG9pbnRzIGZvciBlZGdlcyB0b3VjaGluZyBQLCBcblx0Ly9cdFx0d2hlcmUgZWFjaCBlZGdlIG1pZHBvaW50IGlzIHRoZSBhdmVyYWdlIG9mIGl0cyB0d28gZW5kcG9pbnQgdmVydGljZXMuIFxuXHQvL1x0TW92ZSBlYWNoIG9yaWdpbmFsIHBvaW50IHRvIHRoZSBwb2ludFxuXG5cdFxuXHR2YXIgRiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBSID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR2YXIgbjtcblx0Zm9yIChpPTAsIGlsID0gb3JpZ2luYWxQb2ludHMubGVuZ3RoOyBpPGlsOyBpKyspIHtcblx0XHQvLyAoRiArIDJSICsgKG4tMylQKSAvIG5cblx0XHRcblx0XHRpZiAodmVydGV4RWRnZU1hcFtpXT09PXVuZGVmaW5lZCkgY29udGludWU7XG5cdFx0XG5cdFx0Ri5zZXQoMCwwLDApO1xuXHRcdFIuc2V0KDAsMCwwKTtcblx0XHR2YXIgbmV3UG9zID0gIG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwwKTtcblx0XHRcblx0XHR2YXIgZiA9MDtcblx0XHRmb3IgKGogaW4gdmVydGV4RmFjZU1hcFtpXSkge1xuXHRcdFx0Ri5hZGRTZWxmKGZhY2VQb2ludHNbal0pO1xuXHRcdFx0ZisrO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgc2hhcnBFZGdlQ291bnQgPSAwO1xuXHRcdFxuXHRcdG4gPSB2ZXJ0ZXhFZGdlTWFwW2ldLmxlbmd0aDtcblx0XHRcblx0XHRmb3IgKGo9MDtqPG47aisrKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHNoYXJwRWRnZXNbXG5cdFx0XHRcdFx0ZWRnZV9oYXNoKHZlcnRleEVkZ2VNYXBbaV1bal1bMF0sdmVydGV4RWRnZU1hcFtpXVtqXVsxXSlcblx0XHRcdFx0XSkge1xuXHRcdFx0XHRcdHNoYXJwRWRnZUNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKCBzaGFycEVkZ2VDb3VudD09MiApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0Ly8gRG8gbm90IG1vdmUgdmVydGV4IGlmIHRoZXJlJ3MgMiBjb25uZWN0aW5nIHNoYXJwIGVkZ2VzLlxuXHRcdH1cblxuXHRcdC8qXG5cdFx0aWYgKHNoYXJwRWRnZUNvdW50PjIpIHtcblx0XHRcdC8vIFRPRE9cblx0XHR9XG5cdFx0Ki9cblx0XHRcblx0XHRGLmRpdmlkZVNjYWxhcihmKTtcblx0XHRcblx0XHRcblx0XHRcblx0XHRmb3IgKGo9MDsgajxuO2orKykge1xuXHRcdFx0ZWRnZSA9IHZlcnRleEVkZ2VNYXBbaV1bal07XG5cdFx0XHR2YXIgbWlkUHQgPSBvcmlnaW5hbFBvaW50c1tlZGdlWzBdXS5wb3NpdGlvbi5jbG9uZSgpLmFkZFNlbGYob3JpZ2luYWxQb2ludHNbZWRnZVsxXV0ucG9zaXRpb24pLmRpdmlkZVNjYWxhcigyKTtcblx0XHRcdFIuYWRkU2VsZihtaWRQdCk7XG5cdFx0XHQvLyBSLmFkZFNlbGYob3JpZ2luYWxQb2ludHNbZWRnZVswXV0ucG9zaXRpb24pO1xuXHRcdFx0Ly8gUi5hZGRTZWxmKG9yaWdpbmFsUG9pbnRzW2VkZ2VbMV1dLnBvc2l0aW9uKTtcblx0XHR9XG5cdFx0XG5cdFx0Ui5kaXZpZGVTY2FsYXIobilcblx0XHRcblx0XHRuZXdQb3MuYWRkU2VsZihvcmlnaW5hbFBvaW50c1tpXS5wb3NpdGlvbik7XG5cdFx0bmV3UG9zLm11bHRpcGx5U2NhbGFyKG4gLSAzKTtcblx0XHRcblx0XHRuZXdQb3MuYWRkU2VsZihGKTtcblx0XHRuZXdQb3MuYWRkU2VsZihSLm11bHRpcGx5U2NhbGFyKDIpKTtcblx0XHRuZXdQb3MuZGl2aWRlU2NhbGFyKG4pO1xuXHRcdFxuXHRcdG5ld1ZlcnRpY2VzW2ldLnBvc2l0aW9uID0gbmV3UG9zO1xuXHRcdFxuXHRcdFxuXHR9XG5cdFxuXHR2YXIgbmV3R2VvbWV0cnkgPSBvbGRHZW9tZXRyeTsgLy8gTGV0J3MgcHJldGVuZCB0aGUgb2xkIGdlb21ldHJ5IGlzIG5vdyBuZXcgOlBcblx0XG5cdG5ld0dlb21ldHJ5LnZlcnRpY2VzID0gbmV3VmVydGljZXM7XG5cdG5ld0dlb21ldHJ5LmZhY2VzID0gbmV3RmFjZXM7XG5cdG5ld0dlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXSA9IG5ld1VWcztcblx0XG5cdGRlbGV0ZSBuZXdHZW9tZXRyeS5fX3RtcFZlcnRpY2VzOyAvLyBtYWtlcyBfX3RtcFZlcnRpY2VzIHVuZGVmaW5lZCA6UFxuXHRcblx0bmV3R2VvbWV0cnkuY29tcHV0ZUNlbnRyb2lkcygpO1xuXHRuZXdHZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0bmV3R2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblx0XG59O1xuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTG9hZGVyID0gZnVuY3Rpb24gKCBzaG93U3RhdHVzICkge1xyXG5cclxuXHR0aGlzLnNob3dTdGF0dXMgPSBzaG93U3RhdHVzO1xyXG5cdHRoaXMuc3RhdHVzRG9tRWxlbWVudCA9IHNob3dTdGF0dXMgPyBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmFkZFN0YXR1c0VsZW1lbnQoKSA6IG51bGw7XHJcblxyXG5cdHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24oKSB7fTtcclxuXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkxvYWRlcixcclxuXHJcblx0YWRkU3RhdHVzRWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xyXG5cclxuXHRcdGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcblx0XHRlLnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcclxuXHRcdGUuc3R5bGUudG9wID0gXCIwcHhcIjtcclxuXHRcdGUuc3R5bGUuZm9udFNpemUgPSBcIjAuOGVtXCI7XHJcblx0XHRlLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG5cdFx0ZS5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZ2JhKDAsMCwwLDAuMjUpXCI7XHJcblx0XHRlLnN0eWxlLmNvbG9yID0gXCIjZmZmXCI7XHJcblx0XHRlLnN0eWxlLndpZHRoID0gXCIxMjBweFwiO1xyXG5cdFx0ZS5zdHlsZS5wYWRkaW5nID0gXCIwLjVlbSAwLjVlbSAwLjVlbSAwLjVlbVwiO1xyXG5cdFx0ZS5zdHlsZS56SW5kZXggPSAxMDAwO1xyXG5cclxuXHRcdGUuaW5uZXJIVE1MID0gXCJMb2FkaW5nIC4uLlwiO1xyXG5cclxuXHRcdHJldHVybiBlO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVQcm9ncmVzczogZnVuY3Rpb24gKCBwcm9ncmVzcyApIHtcclxuXHJcblx0XHR2YXIgbWVzc2FnZSA9IFwiTG9hZGVkIFwiO1xyXG5cclxuXHRcdGlmICggcHJvZ3Jlc3MudG90YWwgKSB7XHJcblxyXG5cdFx0XHRtZXNzYWdlICs9ICggMTAwICogcHJvZ3Jlc3MubG9hZGVkIC8gcHJvZ3Jlc3MudG90YWwgKS50b0ZpeGVkKDApICsgXCIlXCI7XHJcblxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtZXNzYWdlICs9ICggcHJvZ3Jlc3MubG9hZGVkIC8gMTAwMCApLnRvRml4ZWQoMikgKyBcIiBLQlwiO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnN0YXR1c0RvbUVsZW1lbnQuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdFVybGJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XHJcblx0XHRwYXJ0cy5wb3AoKTtcclxuXHRcdHJldHVybiBwYXJ0cy5sZW5ndGggPCAxID8gJycgOiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcclxuXHJcblx0fSxcclxuXHJcblx0aW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBzY29wZSwgbWF0ZXJpYWxzLCB0ZXh0dXJlX3BhdGggKSB7XHJcblxyXG5cdFx0c2NvcGUubWF0ZXJpYWxzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRcdHNjb3BlLm1hdGVyaWFsc1sgaSBdID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxzWyBpIF0sIHRleHR1cmVfcGF0aCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0aGFzTm9ybWFsczogZnVuY3Rpb24gKCBzY29wZSApIHtcclxuXHJcblx0XHR2YXIgbSwgaSwgaWwgPSBzY29wZS5tYXRlcmlhbHMubGVuZ3RoO1xyXG5cclxuXHRcdGZvciggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdG0gPSBzY29wZS5tYXRlcmlhbHNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggbSBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsICkgcmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uICggbSwgdGV4dHVyZV9wYXRoICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGlzX3BvdzIoIG4gKSB7XHJcblxyXG5cdFx0XHR2YXIgbCA9IE1hdGgubG9nKCBuICkgLyBNYXRoLkxOMjtcclxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoIGwgKSA9PSBsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBuZWFyZXN0X3BvdzIoIG4gKSB7XHJcblxyXG5cdFx0XHR2YXIgbCA9IE1hdGgubG9nKCBuICkgLyBNYXRoLkxOMjtcclxuXHRcdFx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLnJvdW5kKCAgbCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGxvYWRfaW1hZ2UoIHdoZXJlLCB1cmwgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHJcblx0XHRcdGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhaXNfcG93MiggdGhpcy53aWR0aCApIHx8ICFpc19wb3cyKCB0aGlzLmhlaWdodCApICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB3ID0gbmVhcmVzdF9wb3cyKCB0aGlzLndpZHRoICksXHJcblx0XHRcdFx0XHRcdGggPSBuZWFyZXN0X3BvdzIoIHRoaXMuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0d2hlcmUuaW1hZ2Uud2lkdGggPSB3O1xyXG5cdFx0XHRcdFx0d2hlcmUuaW1hZ2UuaGVpZ2h0ID0gaDtcclxuXHRcdFx0XHRcdHdoZXJlLmltYWdlLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UoIHRoaXMsIDAsIDAsIHcsIGggKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR3aGVyZS5pbWFnZSA9IHRoaXM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0d2hlcmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGltYWdlLnNyYyA9IHVybDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlX3RleHR1cmUoIHdoZXJlLCBuYW1lLCBzb3VyY2VGaWxlLCByZXBlYXQsIG9mZnNldCwgd3JhcCApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuXHJcblx0XHRcdHdoZXJlWyBuYW1lIF0gPSBuZXcgVEhSRUUuVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cdFx0XHR3aGVyZVsgbmFtZSBdLnNvdXJjZUZpbGUgPSBzb3VyY2VGaWxlO1xyXG5cclxuXHRcdFx0aWYoIHJlcGVhdCApIHtcclxuXHJcblx0XHRcdFx0d2hlcmVbIG5hbWUgXS5yZXBlYXQuc2V0KCByZXBlYXRbIDAgXSwgcmVwZWF0WyAxIF0gKTtcclxuXHJcblx0XHRcdFx0aWYgKCByZXBlYXRbIDAgXSAhPSAxICkgd2hlcmVbIG5hbWUgXS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdGlmICggcmVwZWF0WyAxIF0gIT0gMSApIHdoZXJlWyBuYW1lIF0ud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdHdoZXJlWyBuYW1lIF0ub2Zmc2V0LnNldCggb2Zmc2V0WyAwIF0sIG9mZnNldFsgMSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiggd3JhcCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHdyYXBNYXAgPSB7XHJcblx0XHRcdFx0XCJyZXBlYXRcIiBcdDogVEhSRUUuUmVwZWF0V3JhcHBpbmcsXHJcblx0XHRcdFx0XCJtaXJyb3JcIlx0OiBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHdyYXBNYXBbIHdyYXBbIDAgXSBdICE9PSB1bmRlZmluZWQgKSB3aGVyZVsgbmFtZSBdLndyYXBTID0gd3JhcE1hcFsgd3JhcFsgMCBdIF07XHJcblx0XHRcdFx0aWYgKCB3cmFwTWFwWyB3cmFwWyAxIF0gXSAhPT0gdW5kZWZpbmVkICkgd2hlcmVbIG5hbWUgXS53cmFwVCA9IHdyYXBNYXBbIHdyYXBbIDEgXSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bG9hZF9pbWFnZSggd2hlcmVbIG5hbWUgXSwgdGV4dHVyZV9wYXRoICsgXCIvXCIgKyBzb3VyY2VGaWxlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJnYjJoZXgoIHJnYiApIHtcclxuXHJcblx0XHRcdHJldHVybiAoIHJnYlsgMCBdICogMjU1IDw8IDE2ICkgKyAoIHJnYlsgMSBdICogMjU1IDw8IDggKSArIHJnYlsgMiBdICogMjU1O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWF0ZXJpYWwsIG10eXBlLCBtcGFycyxcclxuXHRcdFx0Y29sb3IsIHNwZWN1bGFyLCBhbWJpZW50LFxyXG5cdFx0XHR2ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0Ly8gZGVmYXVsdHNcclxuXHJcblx0XHRtdHlwZSA9IFwiTWVzaExhbWJlcnRNYXRlcmlhbFwiO1xyXG5cclxuXHRcdC8vIHZlcnRleENvbG9yc1xyXG5cclxuXHRcdG1wYXJzID0geyBjb2xvcjogMHhlZWVlZWUsIG9wYWNpdHk6IDEuMCwgbWFwOiBudWxsLCBsaWdodE1hcDogbnVsbCwgbm9ybWFsTWFwOiBudWxsLCB3aXJlZnJhbWU6IG0ud2lyZWZyYW1lIH07XHJcblxyXG5cdFx0Ly8gcGFyYW1ldGVycyBmcm9tIG1vZGVsIGZpbGVcclxuXHJcblx0XHRpZiAoIG0uc2hhZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggbS5zaGFkaW5nID09IFwiUGhvbmdcIiApIG10eXBlID0gXCJNZXNoUGhvbmdNYXRlcmlhbFwiO1xyXG5cdFx0XHRlbHNlIGlmICggbS5zaGFkaW5nID09IFwiQmFzaWNcIiApIG10eXBlID0gXCJNZXNoQmFzaWNNYXRlcmlhbFwiO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uYmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0uYmxlbmRpbmcgPT0gXCJBZGRpdGl2ZVwiICkgbXBhcnMuYmxlbmRpbmcgPSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nO1xyXG5cdFx0XHRlbHNlIGlmICggbS5ibGVuZGluZyA9PSBcIlN1YnRyYWN0aXZlXCIgKSBtcGFycy5ibGVuZGluZyA9IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmc7XHJcblx0XHRcdGVsc2UgaWYgKCBtLmJsZW5kaW5nID09IFwiTXVsdGlwbHlcIiApIG1wYXJzLmJsZW5kaW5nID0gVEhSRUUuTXVsdGlwbHlCbGVuZGluZztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgfHwgbS5vcGFjaXR5IDwgMS4wICkge1xyXG5cclxuXHRcdFx0bXBhcnMudHJhbnNwYXJlbnQgPSBtLnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5kZXB0aFRlc3QgPSBtLmRlcHRoVGVzdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBtLnZlcnRleENvbG9ycyA9PSBcImZhY2VcIiApIHtcclxuXHJcblx0XHRcdFx0bXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG0udmVydGV4Q29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRtcGFycy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5WZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdGlmICggbS5jb2xvckRpZmZ1c2UgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5jb2xvciA9IHJnYjJoZXgoIG0uY29sb3JEaWZmdXNlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbS5EYmdDb2xvciApIHtcclxuXHJcblx0XHRcdG1wYXJzLmNvbG9yID0gbS5EYmdDb2xvcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLmNvbG9yU3BlY3VsYXIgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5zcGVjdWxhciA9IHJnYjJoZXgoIG0uY29sb3JTcGVjdWxhciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uY29sb3JBbWJpZW50ICkge1xyXG5cclxuXHRcdFx0bXBhcnMuYW1iaWVudCA9IHJnYjJoZXgoIG0uY29sb3JBbWJpZW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vZGlmaWVyc1xyXG5cclxuXHRcdGlmICggbS50cmFuc3BhcmVuY3kgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5vcGFjaXR5ID0gbS50cmFuc3BhcmVuY3k7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5zcGVjdWxhckNvZWYgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5zaGluaW5lc3MgPSBtLnNwZWN1bGFyQ29lZjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGV4dHVyZXNcclxuXHJcblx0XHRpZiAoIG0ubWFwRGlmZnVzZSAmJiB0ZXh0dXJlX3BhdGggKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsIFwibWFwXCIsIG0ubWFwRGlmZnVzZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLm1hcExpZ2h0ICYmIHRleHR1cmVfcGF0aCApIHtcclxuXHJcblx0XHRcdGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgXCJsaWdodE1hcFwiLCBtLm1hcExpZ2h0LCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ubWFwTm9ybWFsICYmIHRleHR1cmVfcGF0aCApIHtcclxuXHJcblx0XHRcdGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgXCJub3JtYWxNYXBcIiwgbS5tYXBOb3JtYWwsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5tYXBTcGVjdWxhciAmJiB0ZXh0dXJlX3BhdGggKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsIFwic3BlY3VsYXJNYXBcIiwgbS5tYXBTcGVjdWxhciwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBub3JtYWwgbWFwcGVkIG1hdGVyaWFsXHJcblxyXG5cdFx0aWYgKCBtLm1hcE5vcm1hbCApIHtcclxuXHJcblx0XHRcdHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJVdGlscy5saWJbIFwibm9ybWFsXCIgXTtcclxuXHRcdFx0dmFyIHVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0XHR2YXIgZGlmZnVzZSA9IG1wYXJzLmNvbG9yO1xyXG5cdFx0XHR2YXIgc3BlY3VsYXIgPSBtcGFycy5zcGVjdWxhcjtcclxuXHRcdFx0dmFyIGFtYmllbnQgPSBtcGFycy5hbWJpZW50O1xyXG5cdFx0XHR2YXIgc2hpbmluZXNzID0gbXBhcnMuc2hpbmluZXNzO1xyXG5cclxuXHRcdFx0dW5pZm9ybXNbIFwidE5vcm1hbFwiIF0udGV4dHVyZSA9IG1wYXJzLm5vcm1hbE1hcDtcclxuXHJcblx0XHRcdGlmICggbS5tYXBOb3JtYWxGYWN0b3IgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInVOb3JtYWxTY2FsZVwiIF0udmFsdWUgPSBtLm1hcE5vcm1hbEZhY3RvcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbXBhcnMubWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0RGlmZnVzZVwiIF0udGV4dHVyZSA9IG1wYXJzLm1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVEaWZmdXNlXCIgXS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1wYXJzLnNwZWN1bGFyTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0U3BlY3VsYXJcIiBdLnRleHR1cmUgPSBtcGFycy5zcGVjdWxhck1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVTcGVjdWxhclwiIF0udmFsdWUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtcGFycy5saWdodE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidEFPXCIgXS50ZXh0dXJlID0gbXBhcnMubGlnaHRNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlQU9cIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGZvciB0aGUgbW9tZW50IGRvbid0IGhhbmRsZSBkaXNwbGFjZW1lbnQgdGV4dHVyZVxyXG5cclxuXHRcdFx0dW5pZm9ybXNbIFwidURpZmZ1c2VDb2xvclwiIF0udmFsdWUuc2V0SGV4KCBkaWZmdXNlICk7XHJcblx0XHRcdHVuaWZvcm1zWyBcInVTcGVjdWxhckNvbG9yXCIgXS52YWx1ZS5zZXRIZXgoIHNwZWN1bGFyICk7XHJcblx0XHRcdHVuaWZvcm1zWyBcInVBbWJpZW50Q29sb3JcIiBdLnZhbHVlLnNldEhleCggYW1iaWVudCApO1xyXG5cclxuXHRcdFx0dW5pZm9ybXNbIFwidVNoaW5pbmVzc1wiIF0udmFsdWUgPSBzaGluaW5lc3M7XHJcblxyXG5cdFx0XHRpZiAoIG1wYXJzLm9wYWNpdHkgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInVPcGFjaXR5XCIgXS52YWx1ZSA9IG1wYXJzLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHsgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogdW5pZm9ybXMsIGxpZ2h0czogdHJ1ZSwgZm9nOiB0cnVlIH07XHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRVsgbXR5cGUgXSggbXBhcnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQmluYXJ5TG9hZGVyID0gZnVuY3Rpb24gKCBzaG93U3RhdHVzICkge1xuXG5cdFRIUkVFLkxvYWRlci5jYWxsKCB0aGlzLCBzaG93U3RhdHVzICk7XG5cbn07XG5cblRIUkVFLkJpbmFyeUxvYWRlci5wcm90b3R5cGUgPSBuZXcgVEhSRUUuTG9hZGVyKCk7XG5USFJFRS5CaW5hcnlMb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQmluYXJ5TG9hZGVyO1xuVEhSRUUuQmluYXJ5TG9hZGVyLnByb3RvdHlwZS5zdXByID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZTtcblxuXG4vLyBMb2FkIG1vZGVscyBnZW5lcmF0ZWQgYnkgc2xpbSBPQkogY29udmVydGVyIHdpdGggQklOQVJZIG9wdGlvbiAoY29udmVydGVyX29ial90aHJlZV9zbGltLnB5IC10IGJpbmFyeSlcbi8vICAtIGJpbmFyeSBtb2RlbHMgY29uc2lzdCBvZiB0d28gZmlsZXM6IEpTIGFuZCBCSU5cbi8vICAtIHBhcmFtZXRlcnNcbi8vXHRcdC0gdXJsIChyZXF1aXJlZClcbi8vXHRcdC0gY2FsbGJhY2sgKHJlcXVpcmVkKVxuLy9cdFx0LSB0ZXh0dXJlUGF0aCAob3B0aW9uYWw6IGlmIG5vdCBzcGVjaWZpZWQsIHRleHR1cmVzIHdpbGwgYmUgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSBmb2xkZXIgYXMgSlMgbW9kZWwgZmlsZSlcbi8vXHRcdC0gYmluYXJ5UGF0aCAob3B0aW9uYWw6IGlmIG5vdCBzcGVjaWZpZWQsIGJpbmFyeSBmaWxlIHdpbGwgYmUgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSBmb2xkZXIgYXMgSlMgbW9kZWwgZmlsZSlcblxuVEhSRUUuQmluYXJ5TG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoLCBiaW5hcnlQYXRoICkge1xuXG5cdGlmICggdXJsIGluc3RhbmNlb2YgT2JqZWN0ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogQmluYXJ5TG9hZGVyKCBwYXJhbWV0ZXJzICkgaXMgbm93IEJpbmFyeUxvYWRlciggdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGgsIGJpbmFyeVBhdGggKS4nICk7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHVybDtcblxuXHRcdHVybCA9IHBhcmFtZXRlcnMubW9kZWw7XG5cdFx0Y2FsbGJhY2sgPSBwYXJhbWV0ZXJzLmNhbGxiYWNrO1xuXHRcdHRleHR1cmVQYXRoID0gcGFyYW1ldGVycy50ZXh0dXJlX3BhdGg7XG5cdFx0YmluYXJ5UGF0aCA9IHBhcmFtZXRlcnMuYmluX3BhdGg7XG5cblx0fVxuXG5cdHRleHR1cmVQYXRoID0gdGV4dHVyZVBhdGggPyB0ZXh0dXJlUGF0aCA6IHRoaXMuZXh0cmFjdFVybGJhc2UoIHVybCApO1xuXHRiaW5hcnlQYXRoID0gYmluYXJ5UGF0aCA/IGJpbmFyeVBhdGggOiB0aGlzLmV4dHJhY3RVcmxiYXNlKCB1cmwgKTtcblxuXHR2YXIgY2FsbGJhY2tQcm9ncmVzcyA9IHRoaXMuc2hvd1Byb2dyZXNzID8gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS51cGRhdGVQcm9ncmVzcyA6IG51bGw7XG5cblx0dGhpcy5vbkxvYWRTdGFydCgpO1xuXG5cdC8vICMxIGxvYWQgSlMgcGFydCB2aWEgd2ViIHdvcmtlclxuXG5cdHRoaXMubG9hZEFqYXhKU09OKCB0aGlzLCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCwgYmluYXJ5UGF0aCwgY2FsbGJhY2tQcm9ncmVzcyApO1xuXG59O1xuXG5USFJFRS5CaW5hcnlMb2FkZXIucHJvdG90eXBlLmxvYWRBamF4SlNPTiA9IGZ1bmN0aW9uKCBjb250ZXh0LCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCwgYmluYXJ5UGF0aCwgY2FsbGJhY2tQcm9ncmVzcyApIHtcblxuXHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PSA0ICkge1xuXG5cdFx0XHRpZiAoIHhoci5zdGF0dXMgPT0gMjAwIHx8IHhoci5zdGF0dXMgPT0gMCApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB4aHIucmVzcG9uc2VUZXh0ICk7XG5cblx0XHRcdFx0XHRpZiAoIGpzb24ubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1ldGFkYXRhLmZvcm1hdFZlcnNpb24gPT09IHVuZGVmaW5lZCB8fCBqc29uLm1ldGFkYXRhLmZvcm1hdFZlcnNpb24gIT09IDMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdEZXByZWNhdGVkIGZpbGUgZm9ybWF0LicgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vICMyIGxvYWQgQklOIHBhcnQgdmlhIEFqYXhcblxuXHRcdFx0XHRcdGNvbnRleHQubG9hZEFqYXhCdWZmZXJzKCBqc29uLCBjYWxsYmFjaywgYmluYXJ5UGF0aCwgdGV4dHVyZVBhdGgsIGNhbGxiYWNrUHJvZ3Jlc3MgKTtcblxuXHRcdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJERVBSRUNBVEVEOiBbXCIgKyB1cmwgKyBcIl0gc2VlbXMgdG8gYmUgdXNpbmcgb2xkIG1vZGVsIGZvcm1hdFwiICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiQ291bGRuJ3QgbG9hZCBbXCIgKyB1cmwgKyBcIl0gW1wiICsgeGhyLnN0YXR1cyArIFwiXVwiICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdHhoci5vcGVuKCBcIkdFVFwiLCB1cmwsIHRydWUgKTtcblx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIFwidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZFwiICk7XG5cdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvcGxhaW5cIiApO1xuXHR4aHIuc2VuZCggbnVsbCApO1xuXG59O1xuXG5USFJFRS5CaW5hcnlMb2FkZXIucHJvdG90eXBlLmxvYWRBamF4QnVmZmVycyA9IGZ1bmN0aW9uKCBqc29uLCBjYWxsYmFjaywgYmluYXJ5UGF0aCwgdGV4dHVyZVBhdGgsIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XG5cblx0dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuXHRcdHVybCA9IGJpbmFyeVBhdGggKyBcIi9cIiArIGpzb24uYnVmZmVycztcblxuXHR2YXIgbGVuZ3RoID0gMDtcblxuXHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09IDQgKSB7XG5cblx0XHRcdGlmICggeGhyLnN0YXR1cyA9PSAyMDAgfHwgeGhyLnN0YXR1cyA9PSAwICkge1xuXG5cdFx0XHRcdFRIUkVFLkJpbmFyeUxvYWRlci5wcm90b3R5cGUuY3JlYXRlQmluTW9kZWwoIHhoci5yZXNwb25zZSwgY2FsbGJhY2ssIHRleHR1cmVQYXRoLCBqc29uLm1hdGVyaWFscyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiQ291bGRuJ3QgbG9hZCBbXCIgKyB1cmwgKyBcIl0gW1wiICsgeGhyLnN0YXR1cyArIFwiXVwiICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09IDMgKSB7XG5cblx0XHRcdGlmICggY2FsbGJhY2tQcm9ncmVzcyApIHtcblxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PSAwICkge1xuXG5cdFx0XHRcdFx0bGVuZ3RoID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtTGVuZ3RoXCIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2tQcm9ncmVzcyggeyB0b3RhbDogbGVuZ3RoLCBsb2FkZWQ6IHhoci5yZXNwb25zZVRleHQubGVuZ3RoIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT0gMiApIHtcblxuXHRcdFx0bGVuZ3RoID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtTGVuZ3RoXCIgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHhoci5vcGVuKCBcIkdFVFwiLCB1cmwsIHRydWUgKTtcblx0eGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblx0eGhyLnNlbmQoIG51bGwgKTtcblxufTtcblxuLy8gQmluYXJ5IEFKQVggcGFyc2VyXG5cblRIUkVFLkJpbmFyeUxvYWRlci5wcm90b3R5cGUuY3JlYXRlQmluTW9kZWwgPSBmdW5jdGlvbiAoIGRhdGEsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCwgbWF0ZXJpYWxzICkge1xuXG5cdHZhciBNb2RlbCA9IGZ1bmN0aW9uICggdGV4dHVyZVBhdGggKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzLFxuXHRcdFx0Y3VycmVudE9mZnNldCA9IDAsXG5cdFx0XHRtZCxcblx0XHRcdG5vcm1hbHMgPSBbXSxcblx0XHRcdHV2cyA9IFtdLFxuXHRcdFx0c3RhcnRfdHJpX2ZsYXQsIHN0YXJ0X3RyaV9zbW9vdGgsIHN0YXJ0X3RyaV9mbGF0X3V2LCBzdGFydF90cmlfc21vb3RoX3V2LFxuXHRcdFx0c3RhcnRfcXVhZF9mbGF0LCBzdGFydF9xdWFkX3Ntb290aCwgc3RhcnRfcXVhZF9mbGF0X3V2LCBzdGFydF9xdWFkX3Ntb290aF91dixcblx0XHRcdHRyaV9zaXplLCBxdWFkX3NpemUsXG5cdFx0XHRsZW5fdHJpX2ZsYXQsIGxlbl90cmlfc21vb3RoLCBsZW5fdHJpX2ZsYXRfdXYsIGxlbl90cmlfc21vb3RoX3V2LFxuXHRcdFx0bGVuX3F1YWRfZmxhdCwgbGVuX3F1YWRfc21vb3RoLCBsZW5fcXVhZF9mbGF0X3V2LCBsZW5fcXVhZF9zbW9vdGhfdXY7XG5cblxuXHRcdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdFRIUkVFLkxvYWRlci5wcm90b3R5cGUuaW5pdE1hdGVyaWFscyggc2NvcGUsIG1hdGVyaWFscywgdGV4dHVyZVBhdGggKTtcblxuXHRcdG1kID0gcGFyc2VNZXRhRGF0YSggZGF0YSwgY3VycmVudE9mZnNldCApO1xuXG5cdFx0aWYgKCBtZC5zaWduYXR1cmUgIT09IFwiVGhyZWUuanMgMDAzXCIgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggXCJERVBSRUNBVEVEOiBiaW5hcnkgbW9kZWwgc2VlbXMgdG8gYmUgdXNpbmcgb2xkIGZvcm1hdFwiICk7XG5cblx0XHR9XG5cblx0XHRjdXJyZW50T2Zmc2V0ICs9IG1kLmhlYWRlcl9ieXRlcztcbi8qXG5cdFx0bWQudmVydGV4X2luZGV4X2J5dGVzID0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG5cdFx0bWQubWF0ZXJpYWxfaW5kZXhfYnl0ZXMgPSBVaW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRtZC5ub3JtYWxfaW5kZXhfYnl0ZXMgPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRtZC51dl9pbmRleF9ieXRlcyA9IFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuKi9cblx0XHQvLyBidWZmZXJzIHNpemVzXG5cblx0XHR0cmlfc2l6ZSA9ICBtZC52ZXJ0ZXhfaW5kZXhfYnl0ZXMgKiAzICsgbWQubWF0ZXJpYWxfaW5kZXhfYnl0ZXM7XG5cdFx0cXVhZF9zaXplID0gbWQudmVydGV4X2luZGV4X2J5dGVzICogNCArIG1kLm1hdGVyaWFsX2luZGV4X2J5dGVzO1xuXG5cdFx0bGVuX3RyaV9mbGF0ICAgICAgPSBtZC5udHJpX2ZsYXQgICAgICAqICggdHJpX3NpemUgKTtcblx0XHRsZW5fdHJpX3Ntb290aCAgICA9IG1kLm50cmlfc21vb3RoICAgICogKCB0cmlfc2l6ZSArIG1kLm5vcm1hbF9pbmRleF9ieXRlcyAqIDMgKTtcblx0XHRsZW5fdHJpX2ZsYXRfdXYgICA9IG1kLm50cmlfZmxhdF91diAgICogKCB0cmlfc2l6ZSArIG1kLnV2X2luZGV4X2J5dGVzICogMyApO1xuXHRcdGxlbl90cmlfc21vb3RoX3V2ID0gbWQubnRyaV9zbW9vdGhfdXYgKiAoIHRyaV9zaXplICsgbWQubm9ybWFsX2luZGV4X2J5dGVzICogMyArIG1kLnV2X2luZGV4X2J5dGVzICogMyApO1xuXG5cdFx0bGVuX3F1YWRfZmxhdCAgICAgID0gbWQubnF1YWRfZmxhdCAgICAgICogKCBxdWFkX3NpemUgKTtcblx0XHRsZW5fcXVhZF9zbW9vdGggICAgPSBtZC5ucXVhZF9zbW9vdGggICAgKiAoIHF1YWRfc2l6ZSArIG1kLm5vcm1hbF9pbmRleF9ieXRlcyAqIDQgKTtcblx0XHRsZW5fcXVhZF9mbGF0X3V2ICAgPSBtZC5ucXVhZF9mbGF0X3V2ICAgKiAoIHF1YWRfc2l6ZSArIG1kLnV2X2luZGV4X2J5dGVzICogNCApO1xuXHRcdGxlbl9xdWFkX3Ntb290aF91diA9IG1kLm5xdWFkX3Ntb290aF91diAqICggcXVhZF9zaXplICsgbWQubm9ybWFsX2luZGV4X2J5dGVzICogNCArIG1kLnV2X2luZGV4X2J5dGVzICogNCApO1xuXG5cdFx0Ly8gcmVhZCBidWZmZXJzXG5cblx0XHRjdXJyZW50T2Zmc2V0ICs9IGluaXRfdmVydGljZXMoIGN1cnJlbnRPZmZzZXQgKTtcblxuXHRcdGN1cnJlbnRPZmZzZXQgKz0gaW5pdF9ub3JtYWxzKCBjdXJyZW50T2Zmc2V0ICk7XG5cdFx0Y3VycmVudE9mZnNldCArPSBoYW5kbGVQYWRkaW5nKCBtZC5ubm9ybWFscyAqIDMgKTtcblxuXHRcdGN1cnJlbnRPZmZzZXQgKz0gaW5pdF91dnMoIGN1cnJlbnRPZmZzZXQgKTtcblxuXHRcdHN0YXJ0X3RyaV9mbGF0IFx0XHQ9IGN1cnJlbnRPZmZzZXQ7XG5cdFx0c3RhcnRfdHJpX3Ntb290aCAgICA9IHN0YXJ0X3RyaV9mbGF0ICAgICsgbGVuX3RyaV9mbGF0ICAgICsgaGFuZGxlUGFkZGluZyggbWQubnRyaV9mbGF0ICogMiApO1xuXHRcdHN0YXJ0X3RyaV9mbGF0X3V2ICAgPSBzdGFydF90cmlfc21vb3RoICArIGxlbl90cmlfc21vb3RoICArIGhhbmRsZVBhZGRpbmcoIG1kLm50cmlfc21vb3RoICogMiApO1xuXHRcdHN0YXJ0X3RyaV9zbW9vdGhfdXYgPSBzdGFydF90cmlfZmxhdF91diArIGxlbl90cmlfZmxhdF91diArIGhhbmRsZVBhZGRpbmcoIG1kLm50cmlfZmxhdF91diAqIDIgKTtcblxuXHRcdHN0YXJ0X3F1YWRfZmxhdCAgICAgPSBzdGFydF90cmlfc21vb3RoX3V2ICsgbGVuX3RyaV9zbW9vdGhfdXYgICsgaGFuZGxlUGFkZGluZyggbWQubnRyaV9zbW9vdGhfdXYgKiAyICk7XG5cdFx0c3RhcnRfcXVhZF9zbW9vdGggICA9IHN0YXJ0X3F1YWRfZmxhdCAgICAgKyBsZW5fcXVhZF9mbGF0XHQgICArIGhhbmRsZVBhZGRpbmcoIG1kLm5xdWFkX2ZsYXQgKiAyICk7XG5cdFx0c3RhcnRfcXVhZF9mbGF0X3V2ICA9IHN0YXJ0X3F1YWRfc21vb3RoICAgKyBsZW5fcXVhZF9zbW9vdGggICAgKyBoYW5kbGVQYWRkaW5nKCBtZC5ucXVhZF9zbW9vdGggKiAyICk7XG5cdFx0c3RhcnRfcXVhZF9zbW9vdGhfdXY9IHN0YXJ0X3F1YWRfZmxhdF91diAgKyBsZW5fcXVhZF9mbGF0X3V2ICAgKyBoYW5kbGVQYWRkaW5nKCBtZC5ucXVhZF9mbGF0X3V2ICogMiApO1xuXG5cdFx0Ly8gaGF2ZSB0byBmaXJzdCBwcm9jZXNzIGZhY2VzIHdpdGggdXZzXG5cdFx0Ly8gc28gdGhhdCBmYWNlIGFuZCB1diBpbmRpY2VzIG1hdGNoXG5cblx0XHRpbml0X3RyaWFuZ2xlc19mbGF0X3V2KCBzdGFydF90cmlfZmxhdF91diApO1xuXHRcdGluaXRfdHJpYW5nbGVzX3Ntb290aF91diggc3RhcnRfdHJpX3Ntb290aF91diApO1xuXG5cdFx0aW5pdF9xdWFkc19mbGF0X3V2KCBzdGFydF9xdWFkX2ZsYXRfdXYgKTtcblx0XHRpbml0X3F1YWRzX3Ntb290aF91diggc3RhcnRfcXVhZF9zbW9vdGhfdXYgKTtcblxuXHRcdC8vIG5vdyB3ZSBjYW4gcHJvY2VzcyB1bnRleHR1cmVkIGZhY2VzXG5cblx0XHRpbml0X3RyaWFuZ2xlc19mbGF0KCBzdGFydF90cmlfZmxhdCApO1xuXHRcdGluaXRfdHJpYW5nbGVzX3Ntb290aCggc3RhcnRfdHJpX3Ntb290aCApO1xuXG5cdFx0aW5pdF9xdWFkc19mbGF0KCBzdGFydF9xdWFkX2ZsYXQgKTtcblx0XHRpbml0X3F1YWRzX3Ntb290aCggc3RhcnRfcXVhZF9zbW9vdGggKTtcblxuXHRcdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xuXHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0XHRpZiAoIFRIUkVFLkxvYWRlci5wcm90b3R5cGUuaGFzTm9ybWFscyggdGhpcyApICkgdGhpcy5jb21wdXRlVGFuZ2VudHMoKTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVBhZGRpbmcoIG4gKSB7XG5cblx0XHRcdHJldHVybiAoIG4gJSA0ICkgPyAoIDQgLSBuICUgNCApIDogMDtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwYXJzZU1ldGFEYXRhKCBkYXRhLCBvZmZzZXQgKSB7XG5cblx0XHRcdHZhciBtZXRhRGF0YSA9IHtcblxuXHRcdFx0XHQnc2lnbmF0dXJlJyAgICAgICAgICAgICAgIDpwYXJzZVN0cmluZyggZGF0YSwgb2Zmc2V0LCAgMTIgKSxcblx0XHRcdFx0J2hlYWRlcl9ieXRlcycgICAgICAgICAgICA6cGFyc2VVQ2hhcjgoIGRhdGEsIG9mZnNldCArIDEyICksXG5cblx0XHRcdFx0J3ZlcnRleF9jb29yZGluYXRlX2J5dGVzJyA6cGFyc2VVQ2hhcjgoIGRhdGEsIG9mZnNldCArIDEzICksXG5cdFx0XHRcdCdub3JtYWxfY29vcmRpbmF0ZV9ieXRlcycgOnBhcnNlVUNoYXI4KCBkYXRhLCBvZmZzZXQgKyAxNCApLFxuXHRcdFx0XHQndXZfY29vcmRpbmF0ZV9ieXRlcycgICAgIDpwYXJzZVVDaGFyOCggZGF0YSwgb2Zmc2V0ICsgMTUgKSxcblxuXHRcdFx0XHQndmVydGV4X2luZGV4X2J5dGVzJyAgICAgIDpwYXJzZVVDaGFyOCggZGF0YSwgb2Zmc2V0ICsgMTYgKSxcblx0XHRcdFx0J25vcm1hbF9pbmRleF9ieXRlcycgICAgICA6cGFyc2VVQ2hhcjgoIGRhdGEsIG9mZnNldCArIDE3ICksXG5cdFx0XHRcdCd1dl9pbmRleF9ieXRlcycgICAgICAgICAgOnBhcnNlVUNoYXI4KCBkYXRhLCBvZmZzZXQgKyAxOCApLFxuXHRcdFx0XHQnbWF0ZXJpYWxfaW5kZXhfYnl0ZXMnICAgIDpwYXJzZVVDaGFyOCggZGF0YSwgb2Zmc2V0ICsgMTkgKSxcblxuXHRcdFx0XHQnbnZlcnRpY2VzJyAgICA6cGFyc2VVSW50MzIoIGRhdGEsIG9mZnNldCArIDIwICksXG5cdFx0XHRcdCdubm9ybWFscycgICAgIDpwYXJzZVVJbnQzMiggZGF0YSwgb2Zmc2V0ICsgMjAgKyA0KjEgKSxcblx0XHRcdFx0J251dnMnICAgICAgICAgOnBhcnNlVUludDMyKCBkYXRhLCBvZmZzZXQgKyAyMCArIDQqMiApLFxuXG5cdFx0XHRcdCdudHJpX2ZsYXQnICAgICAgOnBhcnNlVUludDMyKCBkYXRhLCBvZmZzZXQgKyAyMCArIDQqMyApLFxuXHRcdFx0XHQnbnRyaV9zbW9vdGgnICAgIDpwYXJzZVVJbnQzMiggZGF0YSwgb2Zmc2V0ICsgMjAgKyA0KjQgKSxcblx0XHRcdFx0J250cmlfZmxhdF91dicgICA6cGFyc2VVSW50MzIoIGRhdGEsIG9mZnNldCArIDIwICsgNCo1ICksXG5cdFx0XHRcdCdudHJpX3Ntb290aF91dicgOnBhcnNlVUludDMyKCBkYXRhLCBvZmZzZXQgKyAyMCArIDQqNiApLFxuXG5cdFx0XHRcdCducXVhZF9mbGF0JyAgICAgIDpwYXJzZVVJbnQzMiggZGF0YSwgb2Zmc2V0ICsgMjAgKyA0KjcgKSxcblx0XHRcdFx0J25xdWFkX3Ntb290aCcgICAgOnBhcnNlVUludDMyKCBkYXRhLCBvZmZzZXQgKyAyMCArIDQqOCApLFxuXHRcdFx0XHQnbnF1YWRfZmxhdF91dicgICA6cGFyc2VVSW50MzIoIGRhdGEsIG9mZnNldCArIDIwICsgNCo5ICksXG5cdFx0XHRcdCducXVhZF9zbW9vdGhfdXYnIDpwYXJzZVVJbnQzMiggZGF0YSwgb2Zmc2V0ICsgMjAgKyA0KjEwIClcblxuXHRcdFx0fTtcbi8qXG5cdFx0XHRjb25zb2xlLmxvZyggXCJzaWduYXR1cmU6IFwiICsgbWV0YURhdGEuc2lnbmF0dXJlICk7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBcImhlYWRlcl9ieXRlczogXCIgKyBtZXRhRGF0YS5oZWFkZXJfYnl0ZXMgKTtcblx0XHRcdGNvbnNvbGUubG9nKCBcInZlcnRleF9jb29yZGluYXRlX2J5dGVzOiBcIiArIG1ldGFEYXRhLnZlcnRleF9jb29yZGluYXRlX2J5dGVzICk7XG5cdFx0XHRjb25zb2xlLmxvZyggXCJub3JtYWxfY29vcmRpbmF0ZV9ieXRlczogXCIgKyBtZXRhRGF0YS5ub3JtYWxfY29vcmRpbmF0ZV9ieXRlcyApO1xuXHRcdFx0Y29uc29sZS5sb2coIFwidXZfY29vcmRpbmF0ZV9ieXRlczogXCIgKyBtZXRhRGF0YS51dl9jb29yZGluYXRlX2J5dGVzICk7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBcInZlcnRleF9pbmRleF9ieXRlczogXCIgKyBtZXRhRGF0YS52ZXJ0ZXhfaW5kZXhfYnl0ZXMgKTtcblx0XHRcdGNvbnNvbGUubG9nKCBcIm5vcm1hbF9pbmRleF9ieXRlczogXCIgKyBtZXRhRGF0YS5ub3JtYWxfaW5kZXhfYnl0ZXMgKTtcblx0XHRcdGNvbnNvbGUubG9nKCBcInV2X2luZGV4X2J5dGVzOiBcIiArIG1ldGFEYXRhLnV2X2luZGV4X2J5dGVzICk7XG5cdFx0XHRjb25zb2xlLmxvZyggXCJtYXRlcmlhbF9pbmRleF9ieXRlczogXCIgKyBtZXRhRGF0YS5tYXRlcmlhbF9pbmRleF9ieXRlcyApO1xuXG5cdFx0XHRjb25zb2xlLmxvZyggXCJudmVydGljZXM6IFwiICsgbWV0YURhdGEubnZlcnRpY2VzICk7XG5cdFx0XHRjb25zb2xlLmxvZyggXCJubm9ybWFsczogXCIgKyBtZXRhRGF0YS5ubm9ybWFscyApO1xuXHRcdFx0Y29uc29sZS5sb2coIFwibnV2czogXCIgKyBtZXRhRGF0YS5udXZzICk7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBcIm50cmlfZmxhdDogXCIgKyBtZXRhRGF0YS5udHJpX2ZsYXQgKTtcblx0XHRcdGNvbnNvbGUubG9nKCBcIm50cmlfc21vb3RoOiBcIiArIG1ldGFEYXRhLm50cmlfc21vb3RoICk7XG5cdFx0XHRjb25zb2xlLmxvZyggXCJudHJpX2ZsYXRfdXY6IFwiICsgbWV0YURhdGEubnRyaV9mbGF0X3V2ICk7XG5cdFx0XHRjb25zb2xlLmxvZyggXCJudHJpX3Ntb290aF91djogXCIgKyBtZXRhRGF0YS5udHJpX3Ntb290aF91diApO1xuXG5cdFx0XHRjb25zb2xlLmxvZyggXCJucXVhZF9mbGF0OiBcIiArIG1ldGFEYXRhLm5xdWFkX2ZsYXQgKTtcblx0XHRcdGNvbnNvbGUubG9nKCBcIm5xdWFkX3Ntb290aDogXCIgKyBtZXRhRGF0YS5ucXVhZF9zbW9vdGggKTtcblx0XHRcdGNvbnNvbGUubG9nKCBcIm5xdWFkX2ZsYXRfdXY6IFwiICsgbWV0YURhdGEubnF1YWRfZmxhdF91diApO1xuXHRcdFx0Y29uc29sZS5sb2coIFwibnF1YWRfc21vb3RoX3V2OiBcIiArIG1ldGFEYXRhLm5xdWFkX3Ntb290aF91diApO1xuXG5cdFx0XHR2YXIgdG90YWwgPSBtZXRhRGF0YS5oZWFkZXJfYnl0ZXNcblx0XHRcdFx0XHQgICsgbWV0YURhdGEubnZlcnRpY2VzICogbWV0YURhdGEudmVydGV4X2Nvb3JkaW5hdGVfYnl0ZXMgKiAzXG5cdFx0XHRcdFx0ICArIG1ldGFEYXRhLm5ub3JtYWxzICogbWV0YURhdGEubm9ybWFsX2Nvb3JkaW5hdGVfYnl0ZXMgKiAzXG5cdFx0XHRcdFx0ICArIG1ldGFEYXRhLm51dnMgKiBtZXRhRGF0YS51dl9jb29yZGluYXRlX2J5dGVzICogMlxuXHRcdFx0XHRcdCAgKyBtZXRhRGF0YS5udHJpX2ZsYXQgKiAoIG1ldGFEYXRhLnZlcnRleF9pbmRleF9ieXRlcyozICsgbWV0YURhdGEubWF0ZXJpYWxfaW5kZXhfYnl0ZXMgKVxuXHRcdFx0XHRcdCAgKyBtZXRhRGF0YS5udHJpX3Ntb290aCAqICggbWV0YURhdGEudmVydGV4X2luZGV4X2J5dGVzKjMgKyBtZXRhRGF0YS5tYXRlcmlhbF9pbmRleF9ieXRlcyArIG1ldGFEYXRhLm5vcm1hbF9pbmRleF9ieXRlcyozIClcblx0XHRcdFx0XHQgICsgbWV0YURhdGEubnRyaV9mbGF0X3V2ICogKCBtZXRhRGF0YS52ZXJ0ZXhfaW5kZXhfYnl0ZXMqMyArIG1ldGFEYXRhLm1hdGVyaWFsX2luZGV4X2J5dGVzICsgbWV0YURhdGEudXZfaW5kZXhfYnl0ZXMqMyApXG5cdFx0XHRcdFx0ICArIG1ldGFEYXRhLm50cmlfc21vb3RoX3V2ICogKCBtZXRhRGF0YS52ZXJ0ZXhfaW5kZXhfYnl0ZXMqMyArIG1ldGFEYXRhLm1hdGVyaWFsX2luZGV4X2J5dGVzICsgbWV0YURhdGEubm9ybWFsX2luZGV4X2J5dGVzKjMgKyBtZXRhRGF0YS51dl9pbmRleF9ieXRlcyozIClcblx0XHRcdFx0XHQgICsgbWV0YURhdGEubnF1YWRfZmxhdCAqICggbWV0YURhdGEudmVydGV4X2luZGV4X2J5dGVzKjQgKyBtZXRhRGF0YS5tYXRlcmlhbF9pbmRleF9ieXRlcyApXG5cdFx0XHRcdFx0ICArIG1ldGFEYXRhLm5xdWFkX3Ntb290aCAqICggbWV0YURhdGEudmVydGV4X2luZGV4X2J5dGVzKjQgKyBtZXRhRGF0YS5tYXRlcmlhbF9pbmRleF9ieXRlcyArIG1ldGFEYXRhLm5vcm1hbF9pbmRleF9ieXRlcyo0IClcblx0XHRcdFx0XHQgICsgbWV0YURhdGEubnF1YWRfZmxhdF91diAqICggbWV0YURhdGEudmVydGV4X2luZGV4X2J5dGVzKjQgKyBtZXRhRGF0YS5tYXRlcmlhbF9pbmRleF9ieXRlcyArIG1ldGFEYXRhLnV2X2luZGV4X2J5dGVzKjQgKVxuXHRcdFx0XHRcdCAgKyBtZXRhRGF0YS5ucXVhZF9zbW9vdGhfdXYgKiAoIG1ldGFEYXRhLnZlcnRleF9pbmRleF9ieXRlcyo0ICsgbWV0YURhdGEubWF0ZXJpYWxfaW5kZXhfYnl0ZXMgKyBtZXRhRGF0YS5ub3JtYWxfaW5kZXhfYnl0ZXMqNCArIG1ldGFEYXRhLnV2X2luZGV4X2J5dGVzKjQgKTtcblx0XHRcdGNvbnNvbGUubG9nKCBcInRvdGFsIGJ5dGVzOiBcIiArIHRvdGFsICk7XG4qL1xuXG5cdFx0XHRyZXR1cm4gbWV0YURhdGE7XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VTdHJpbmcoIGRhdGEsIG9mZnNldCwgbGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgY2hhckFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIG9mZnNldCwgbGVuZ3RoICk7XG5cblx0XHRcdHZhciB0ZXh0ID0gXCJcIjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggY2hhckFycmF5WyBvZmZzZXQgKyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dDtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwYXJzZVVDaGFyOCggZGF0YSwgb2Zmc2V0ICkge1xuXG5cdFx0XHR2YXIgY2hhckFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIG9mZnNldCwgMSApO1xuXG5cdFx0XHRyZXR1cm4gY2hhckFycmF5WyAwIF07XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VVSW50MzIoIGRhdGEsIG9mZnNldCApIHtcblxuXHRcdFx0dmFyIGludEFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBkYXRhLCBvZmZzZXQsIDEgKTtcblxuXHRcdFx0cmV0dXJuIGludEFycmF5WyAwIF07XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF92ZXJ0aWNlcyggc3RhcnQgKSB7XG5cblx0XHRcdHZhciBuRWxlbWVudHMgPSBtZC5udmVydGljZXM7XG5cblx0XHRcdHZhciBjb29yZEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggZGF0YSwgc3RhcnQsIG5FbGVtZW50cyAqIDMgKTtcblxuXHRcdFx0dmFyIGksIHgsIHksIHo7XG5cblx0XHRcdGZvciggaSA9IDA7IGkgPCBuRWxlbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0eCA9IGNvb3JkQXJyYXlbIGkgKiAzIF07XG5cdFx0XHRcdHkgPSBjb29yZEFycmF5WyBpICogMyArIDEgXTtcblx0XHRcdFx0eiA9IGNvb3JkQXJyYXlbIGkgKiAzICsgMiBdO1xuXG5cdFx0XHRcdHZlcnRleCggc2NvcGUsIHgsIHksIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbkVsZW1lbnRzICogMyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0X25vcm1hbHMoIHN0YXJ0ICkge1xuXG5cdFx0XHR2YXIgbkVsZW1lbnRzID0gbWQubm5vcm1hbHM7XG5cblx0XHRcdGlmICggbkVsZW1lbnRzICkge1xuXG5cdFx0XHRcdHZhciBub3JtYWxBcnJheSA9IG5ldyBJbnQ4QXJyYXkoIGRhdGEsIHN0YXJ0LCBuRWxlbWVudHMgKiAzICk7XG5cblx0XHRcdFx0dmFyIGksIHgsIHksIHo7XG5cblx0XHRcdFx0Zm9yKCBpID0gMDsgaSA8IG5FbGVtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRcdHggPSBub3JtYWxBcnJheVsgaSAqIDMgXTtcblx0XHRcdFx0XHR5ID0gbm9ybWFsQXJyYXlbIGkgKiAzICsgMSBdO1xuXHRcdFx0XHRcdHogPSBub3JtYWxBcnJheVsgaSAqIDMgKyAyIF07XG5cblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIHgvMTI3LCB5LzEyNywgei8xMjcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5FbGVtZW50cyAqIDMgKiBJbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF91dnMoIHN0YXJ0ICkge1xuXG5cdFx0XHR2YXIgbkVsZW1lbnRzID0gbWQubnV2cztcblxuXHRcdFx0aWYgKCBuRWxlbWVudHMgKSB7XG5cblx0XHRcdFx0dmFyIHV2QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBkYXRhLCBzdGFydCwgbkVsZW1lbnRzICogMiApO1xuXG5cdFx0XHRcdHZhciBpLCB1LCB2O1xuXG5cdFx0XHRcdGZvciggaSA9IDA7IGkgPCBuRWxlbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1ID0gdXZBcnJheVsgaSAqIDIgXTtcblx0XHRcdFx0XHR2ID0gdXZBcnJheVsgaSAqIDIgKyAxIF07XG5cblx0XHRcdFx0XHR1dnMucHVzaCggdSwgdiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbkVsZW1lbnRzICogMiAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0X3V2czMoIG5FbGVtZW50cywgb2Zmc2V0ICkge1xuXG5cdFx0XHR2YXIgaSwgdXZhLCB1dmIsIHV2YywgdTEsIHUyLCB1MywgdjEsIHYyLCB2MztcblxuXHRcdFx0dmFyIHV2SW5kZXhCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoIGRhdGEsIG9mZnNldCwgMyAqIG5FbGVtZW50cyApO1xuXG5cdFx0XHRmb3IoIGkgPSAwOyBpIDwgbkVsZW1lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdHV2YSA9IHV2SW5kZXhCdWZmZXJbIGkgKiAzIF07XG5cdFx0XHRcdHV2YiA9IHV2SW5kZXhCdWZmZXJbIGkgKiAzICsgMSBdO1xuXHRcdFx0XHR1dmMgPSB1dkluZGV4QnVmZmVyWyBpICogMyArIDIgXTtcblxuXHRcdFx0XHR1MSA9IHV2c1sgdXZhKjIgXTtcblx0XHRcdFx0djEgPSB1dnNbIHV2YSoyICsgMSBdO1xuXG5cdFx0XHRcdHUyID0gdXZzWyB1dmIqMiBdO1xuXHRcdFx0XHR2MiA9IHV2c1sgdXZiKjIgKyAxIF07XG5cblx0XHRcdFx0dTMgPSB1dnNbIHV2YyoyIF07XG5cdFx0XHRcdHYzID0gdXZzWyB1dmMqMiArIDEgXTtcblxuXHRcdFx0XHR1djMoIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXSwgdTEsIHYxLCB1MiwgdjIsIHUzLCB2MyApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF91dnM0KCBuRWxlbWVudHMsIG9mZnNldCApIHtcblxuXHRcdFx0dmFyIGksIHV2YSwgdXZiLCB1dmMsIHV2ZCwgdTEsIHUyLCB1MywgdTQsIHYxLCB2MiwgdjMsIHY0O1xuXG5cdFx0XHR2YXIgdXZJbmRleEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSggZGF0YSwgb2Zmc2V0LCA0ICogbkVsZW1lbnRzICk7XG5cblx0XHRcdGZvciggaSA9IDA7IGkgPCBuRWxlbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0dXZhID0gdXZJbmRleEJ1ZmZlclsgaSAqIDQgXTtcblx0XHRcdFx0dXZiID0gdXZJbmRleEJ1ZmZlclsgaSAqIDQgKyAxIF07XG5cdFx0XHRcdHV2YyA9IHV2SW5kZXhCdWZmZXJbIGkgKiA0ICsgMiBdO1xuXHRcdFx0XHR1dmQgPSB1dkluZGV4QnVmZmVyWyBpICogNCArIDMgXTtcblxuXHRcdFx0XHR1MSA9IHV2c1sgdXZhKjIgXTtcblx0XHRcdFx0djEgPSB1dnNbIHV2YSoyICsgMSBdO1xuXG5cdFx0XHRcdHUyID0gdXZzWyB1dmIqMiBdO1xuXHRcdFx0XHR2MiA9IHV2c1sgdXZiKjIgKyAxIF07XG5cblx0XHRcdFx0dTMgPSB1dnNbIHV2YyoyIF07XG5cdFx0XHRcdHYzID0gdXZzWyB1dmMqMiArIDEgXTtcblxuXHRcdFx0XHR1NCA9IHV2c1sgdXZkKjIgXTtcblx0XHRcdFx0djQgPSB1dnNbIHV2ZCoyICsgMSBdO1xuXG5cdFx0XHRcdHV2NCggc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLCB1MSwgdjEsIHUyLCB2MiwgdTMsIHYzLCB1NCwgdjQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXRfZmFjZXMzX2ZsYXQoIG5FbGVtZW50cywgb2Zmc2V0VmVydGljZXMsIG9mZnNldE1hdGVyaWFscyApIHtcblxuXHRcdFx0dmFyIGksIGEsIGIsIGMsIG07XG5cblx0XHRcdHZhciB2ZXJ0ZXhJbmRleEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSggZGF0YSwgb2Zmc2V0VmVydGljZXMsIDMgKiBuRWxlbWVudHMgKTtcblx0XHRcdHZhciBtYXRlcmlhbEluZGV4QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KCBkYXRhLCBvZmZzZXRNYXRlcmlhbHMsIG5FbGVtZW50cyApO1xuXG5cdFx0XHRmb3IoIGkgPSAwOyBpIDwgbkVsZW1lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGEgPSB2ZXJ0ZXhJbmRleEJ1ZmZlclsgaSAqIDMgXTtcblx0XHRcdFx0YiA9IHZlcnRleEluZGV4QnVmZmVyWyBpICogMyArIDEgXTtcblx0XHRcdFx0YyA9IHZlcnRleEluZGV4QnVmZmVyWyBpICogMyArIDIgXTtcblxuXHRcdFx0XHRtID0gbWF0ZXJpYWxJbmRleEJ1ZmZlclsgaSBdO1xuXG5cdFx0XHRcdGYzKCBzY29wZSwgYSwgYiwgYywgbSApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF9mYWNlczRfZmxhdCggbkVsZW1lbnRzLCBvZmZzZXRWZXJ0aWNlcywgb2Zmc2V0TWF0ZXJpYWxzICkge1xuXG5cdFx0XHR2YXIgaSwgYSwgYiwgYywgZCwgbTtcblxuXHRcdFx0dmFyIHZlcnRleEluZGV4QnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KCBkYXRhLCBvZmZzZXRWZXJ0aWNlcywgNCAqIG5FbGVtZW50cyApO1xuXHRcdFx0dmFyIG1hdGVyaWFsSW5kZXhCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoIGRhdGEsIG9mZnNldE1hdGVyaWFscywgbkVsZW1lbnRzICk7XG5cblx0XHRcdGZvciggaSA9IDA7IGkgPCBuRWxlbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0YSA9IHZlcnRleEluZGV4QnVmZmVyWyBpICogNCBdO1xuXHRcdFx0XHRiID0gdmVydGV4SW5kZXhCdWZmZXJbIGkgKiA0ICsgMSBdO1xuXHRcdFx0XHRjID0gdmVydGV4SW5kZXhCdWZmZXJbIGkgKiA0ICsgMiBdO1xuXHRcdFx0XHRkID0gdmVydGV4SW5kZXhCdWZmZXJbIGkgKiA0ICsgMyBdO1xuXG5cdFx0XHRcdG0gPSBtYXRlcmlhbEluZGV4QnVmZmVyWyBpIF07XG5cblx0XHRcdFx0ZjQoIHNjb3BlLCBhLCBiLCBjLCBkLCBtICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0X2ZhY2VzM19zbW9vdGgoIG5FbGVtZW50cywgb2Zmc2V0VmVydGljZXMsIG9mZnNldE5vcm1hbHMsIG9mZnNldE1hdGVyaWFscyApIHtcblxuXHRcdFx0dmFyIGksIGEsIGIsIGMsIG07XG5cdFx0XHR2YXIgbmEsIG5iLCBuYztcblxuXHRcdFx0dmFyIHZlcnRleEluZGV4QnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KCBkYXRhLCBvZmZzZXRWZXJ0aWNlcywgMyAqIG5FbGVtZW50cyApO1xuXHRcdFx0dmFyIG5vcm1hbEluZGV4QnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KCBkYXRhLCBvZmZzZXROb3JtYWxzLCAzICogbkVsZW1lbnRzICk7XG5cdFx0XHR2YXIgbWF0ZXJpYWxJbmRleEJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheSggZGF0YSwgb2Zmc2V0TWF0ZXJpYWxzLCBuRWxlbWVudHMgKTtcblxuXHRcdFx0Zm9yKCBpID0gMDsgaSA8IG5FbGVtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRhID0gdmVydGV4SW5kZXhCdWZmZXJbIGkgKiAzIF07XG5cdFx0XHRcdGIgPSB2ZXJ0ZXhJbmRleEJ1ZmZlclsgaSAqIDMgKyAxIF07XG5cdFx0XHRcdGMgPSB2ZXJ0ZXhJbmRleEJ1ZmZlclsgaSAqIDMgKyAyIF07XG5cblx0XHRcdFx0bmEgPSBub3JtYWxJbmRleEJ1ZmZlclsgaSAqIDMgXTtcblx0XHRcdFx0bmIgPSBub3JtYWxJbmRleEJ1ZmZlclsgaSAqIDMgKyAxIF07XG5cdFx0XHRcdG5jID0gbm9ybWFsSW5kZXhCdWZmZXJbIGkgKiAzICsgMiBdO1xuXG5cdFx0XHRcdG0gPSBtYXRlcmlhbEluZGV4QnVmZmVyWyBpIF07XG5cblx0XHRcdFx0ZjNuKCBzY29wZSwgbm9ybWFscywgYSwgYiwgYywgbSwgbmEsIG5iLCBuYyApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF9mYWNlczRfc21vb3RoKCBuRWxlbWVudHMsIG9mZnNldFZlcnRpY2VzLCBvZmZzZXROb3JtYWxzLCBvZmZzZXRNYXRlcmlhbHMgKSB7XG5cblx0XHRcdHZhciBpLCBhLCBiLCBjLCBkLCBtO1xuXHRcdFx0dmFyIG5hLCBuYiwgbmMsIG5kO1xuXG5cdFx0XHR2YXIgdmVydGV4SW5kZXhCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoIGRhdGEsIG9mZnNldFZlcnRpY2VzLCA0ICogbkVsZW1lbnRzICk7XG5cdFx0XHR2YXIgbm9ybWFsSW5kZXhCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoIGRhdGEsIG9mZnNldE5vcm1hbHMsIDQgKiBuRWxlbWVudHMgKTtcblx0XHRcdHZhciBtYXRlcmlhbEluZGV4QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KCBkYXRhLCBvZmZzZXRNYXRlcmlhbHMsIG5FbGVtZW50cyApO1xuXG5cdFx0XHRmb3IoIGkgPSAwOyBpIDwgbkVsZW1lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGEgPSB2ZXJ0ZXhJbmRleEJ1ZmZlclsgaSAqIDQgXTtcblx0XHRcdFx0YiA9IHZlcnRleEluZGV4QnVmZmVyWyBpICogNCArIDEgXTtcblx0XHRcdFx0YyA9IHZlcnRleEluZGV4QnVmZmVyWyBpICogNCArIDIgXTtcblx0XHRcdFx0ZCA9IHZlcnRleEluZGV4QnVmZmVyWyBpICogNCArIDMgXTtcblxuXHRcdFx0XHRuYSA9IG5vcm1hbEluZGV4QnVmZmVyWyBpICogNCBdO1xuXHRcdFx0XHRuYiA9IG5vcm1hbEluZGV4QnVmZmVyWyBpICogNCArIDEgXTtcblx0XHRcdFx0bmMgPSBub3JtYWxJbmRleEJ1ZmZlclsgaSAqIDQgKyAyIF07XG5cdFx0XHRcdG5kID0gbm9ybWFsSW5kZXhCdWZmZXJbIGkgKiA0ICsgMyBdO1xuXG5cdFx0XHRcdG0gPSBtYXRlcmlhbEluZGV4QnVmZmVyWyBpIF07XG5cblx0XHRcdFx0ZjRuKCBzY29wZSwgbm9ybWFscywgYSwgYiwgYywgZCwgbSwgbmEsIG5iLCBuYywgbmQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXRfdHJpYW5nbGVzX2ZsYXQoIHN0YXJ0ICkge1xuXG5cdFx0XHR2YXIgbkVsZW1lbnRzID0gbWQubnRyaV9mbGF0O1xuXG5cdFx0XHRpZiAoIG5FbGVtZW50cyApIHtcblxuXHRcdFx0XHR2YXIgb2Zmc2V0TWF0ZXJpYWxzID0gc3RhcnQgKyBuRWxlbWVudHMgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDM7XG5cdFx0XHRcdGluaXRfZmFjZXMzX2ZsYXQoIG5FbGVtZW50cywgc3RhcnQsIG9mZnNldE1hdGVyaWFscyApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF90cmlhbmdsZXNfZmxhdF91diggc3RhcnQgKSB7XG5cblx0XHRcdHZhciBuRWxlbWVudHMgPSBtZC5udHJpX2ZsYXRfdXY7XG5cblx0XHRcdGlmICggbkVsZW1lbnRzICkge1xuXG5cdFx0XHRcdHZhciBvZmZzZXRVdnMgPSBzdGFydCArIG5FbGVtZW50cyAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogMztcblx0XHRcdFx0dmFyIG9mZnNldE1hdGVyaWFscyA9IG9mZnNldFV2cyArIG5FbGVtZW50cyAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogMztcblxuXHRcdFx0XHRpbml0X2ZhY2VzM19mbGF0KCBuRWxlbWVudHMsIHN0YXJ0LCBvZmZzZXRNYXRlcmlhbHMgKTtcblx0XHRcdFx0aW5pdF91dnMzKCBuRWxlbWVudHMsIG9mZnNldFV2cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF90cmlhbmdsZXNfc21vb3RoKCBzdGFydCApIHtcblxuXHRcdFx0dmFyIG5FbGVtZW50cyA9IG1kLm50cmlfc21vb3RoO1xuXG5cdFx0XHRpZiAoIG5FbGVtZW50cyApIHtcblxuXHRcdFx0XHR2YXIgb2Zmc2V0Tm9ybWFscyA9IHN0YXJ0ICsgbkVsZW1lbnRzICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiAzO1xuXHRcdFx0XHR2YXIgb2Zmc2V0TWF0ZXJpYWxzID0gb2Zmc2V0Tm9ybWFscyArIG5FbGVtZW50cyAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogMztcblxuXHRcdFx0XHRpbml0X2ZhY2VzM19zbW9vdGgoIG5FbGVtZW50cywgc3RhcnQsIG9mZnNldE5vcm1hbHMsIG9mZnNldE1hdGVyaWFscyApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF90cmlhbmdsZXNfc21vb3RoX3V2KCBzdGFydCApIHtcblxuXHRcdFx0dmFyIG5FbGVtZW50cyA9IG1kLm50cmlfc21vb3RoX3V2O1xuXG5cdFx0XHRpZiAoIG5FbGVtZW50cyApIHtcblxuXHRcdFx0XHR2YXIgb2Zmc2V0Tm9ybWFscyA9IHN0YXJ0ICsgbkVsZW1lbnRzICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiAzO1xuXHRcdFx0XHR2YXIgb2Zmc2V0VXZzID0gb2Zmc2V0Tm9ybWFscyArIG5FbGVtZW50cyAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogMztcblx0XHRcdFx0dmFyIG9mZnNldE1hdGVyaWFscyA9IG9mZnNldFV2cyArIG5FbGVtZW50cyAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogMztcblxuXHRcdFx0XHRpbml0X2ZhY2VzM19zbW9vdGgoIG5FbGVtZW50cywgc3RhcnQsIG9mZnNldE5vcm1hbHMsIG9mZnNldE1hdGVyaWFscyApO1xuXHRcdFx0XHRpbml0X3V2czMoIG5FbGVtZW50cywgb2Zmc2V0VXZzICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0X3F1YWRzX2ZsYXQoIHN0YXJ0ICkge1xuXG5cdFx0XHR2YXIgbkVsZW1lbnRzID0gbWQubnF1YWRfZmxhdDtcblxuXHRcdFx0aWYgKCBuRWxlbWVudHMgKSB7XG5cblx0XHRcdFx0dmFyIG9mZnNldE1hdGVyaWFscyA9IHN0YXJ0ICsgbkVsZW1lbnRzICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiA0O1xuXHRcdFx0XHRpbml0X2ZhY2VzNF9mbGF0KCBuRWxlbWVudHMsIHN0YXJ0LCBvZmZzZXRNYXRlcmlhbHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXRfcXVhZHNfZmxhdF91diggc3RhcnQgKSB7XG5cblx0XHRcdHZhciBuRWxlbWVudHMgPSBtZC5ucXVhZF9mbGF0X3V2O1xuXG5cdFx0XHRpZiAoIG5FbGVtZW50cyApIHtcblxuXHRcdFx0XHR2YXIgb2Zmc2V0VXZzID0gc3RhcnQgKyBuRWxlbWVudHMgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDQ7XG5cdFx0XHRcdHZhciBvZmZzZXRNYXRlcmlhbHMgPSBvZmZzZXRVdnMgKyBuRWxlbWVudHMgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDQ7XG5cblx0XHRcdFx0aW5pdF9mYWNlczRfZmxhdCggbkVsZW1lbnRzLCBzdGFydCwgb2Zmc2V0TWF0ZXJpYWxzICk7XG5cdFx0XHRcdGluaXRfdXZzNCggbkVsZW1lbnRzLCBvZmZzZXRVdnMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXRfcXVhZHNfc21vb3RoKCBzdGFydCApIHtcblxuXHRcdFx0dmFyIG5FbGVtZW50cyA9IG1kLm5xdWFkX3Ntb290aDtcblxuXHRcdFx0aWYgKCBuRWxlbWVudHMgKSB7XG5cblx0XHRcdFx0dmFyIG9mZnNldE5vcm1hbHMgPSBzdGFydCArIG5FbGVtZW50cyAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogNDtcblx0XHRcdFx0dmFyIG9mZnNldE1hdGVyaWFscyA9IG9mZnNldE5vcm1hbHMgKyBuRWxlbWVudHMgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDQ7XG5cblx0XHRcdFx0aW5pdF9mYWNlczRfc21vb3RoKCBuRWxlbWVudHMsIHN0YXJ0LCBvZmZzZXROb3JtYWxzLCBvZmZzZXRNYXRlcmlhbHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXRfcXVhZHNfc21vb3RoX3V2KCBzdGFydCApIHtcblxuXHRcdFx0dmFyIG5FbGVtZW50cyA9IG1kLm5xdWFkX3Ntb290aF91djtcblxuXHRcdFx0aWYgKCBuRWxlbWVudHMgKSB7XG5cblx0XHRcdFx0dmFyIG9mZnNldE5vcm1hbHMgPSBzdGFydCArIG5FbGVtZW50cyAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogNDtcblx0XHRcdFx0dmFyIG9mZnNldFV2cyA9IG9mZnNldE5vcm1hbHMgKyBuRWxlbWVudHMgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDQ7XG5cdFx0XHRcdHZhciBvZmZzZXRNYXRlcmlhbHMgPSBvZmZzZXRVdnMgKyBuRWxlbWVudHMgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDQ7XG5cblx0XHRcdFx0aW5pdF9mYWNlczRfc21vb3RoKCBuRWxlbWVudHMsIHN0YXJ0LCBvZmZzZXROb3JtYWxzLCBvZmZzZXRNYXRlcmlhbHMgKTtcblx0XHRcdFx0aW5pdF91dnM0KCBuRWxlbWVudHMsIG9mZnNldFV2cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gdmVydGV4ICggc2NvcGUsIHgsIHksIHogKSB7XG5cblx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGYzICggc2NvcGUsIGEsIGIsIGMsIG1pICkge1xuXG5cdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCBtaSApICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBmNCAoIHNjb3BlLCBhLCBiLCBjLCBkLCBtaSApIHtcblxuXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlNCggYSwgYiwgYywgZCwgbnVsbCwgbnVsbCwgbWkgKSApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gZjNuICggc2NvcGUsIG5vcm1hbHMsIGEsIGIsIGMsIG1pLCBuYSwgbmIsIG5jICkge1xuXG5cdFx0dmFyIG5heCA9IG5vcm1hbHNbIG5hKjMgICAgIF0sXG5cdFx0XHRuYXkgPSBub3JtYWxzWyBuYSozICsgMSBdLFxuXHRcdFx0bmF6ID0gbm9ybWFsc1sgbmEqMyArIDIgXSxcblxuXHRcdFx0bmJ4ID0gbm9ybWFsc1sgbmIqMyAgICAgXSxcblx0XHRcdG5ieSA9IG5vcm1hbHNbIG5iKjMgKyAxIF0sXG5cdFx0XHRuYnogPSBub3JtYWxzWyBuYiozICsgMiBdLFxuXG5cdFx0XHRuY3ggPSBub3JtYWxzWyBuYyozICAgICBdLFxuXHRcdFx0bmN5ID0gbm9ybWFsc1sgbmMqMyArIDEgXSxcblx0XHRcdG5jeiA9IG5vcm1hbHNbIG5jKjMgKyAyIF07XG5cblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsXG5cdFx0XHRcdFx0XHQgIFtuZXcgVEhSRUUuVmVjdG9yMyggbmF4LCBuYXksIG5heiApLFxuXHRcdFx0XHRcdFx0ICAgbmV3IFRIUkVFLlZlY3RvcjMoIG5ieCwgbmJ5LCBuYnogKSxcblx0XHRcdFx0XHRcdCAgIG5ldyBUSFJFRS5WZWN0b3IzKCBuY3gsIG5jeSwgbmN6ICldLFxuXHRcdFx0XHRcdFx0ICBudWxsLFxuXHRcdFx0XHRcdFx0ICBtaSApICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBmNG4gKCBzY29wZSwgbm9ybWFscywgYSwgYiwgYywgZCwgbWksIG5hLCBuYiwgbmMsIG5kICkge1xuXG5cdFx0dmFyIG5heCA9IG5vcm1hbHNbIG5hKjMgICAgIF0sXG5cdFx0XHRuYXkgPSBub3JtYWxzWyBuYSozICsgMSBdLFxuXHRcdFx0bmF6ID0gbm9ybWFsc1sgbmEqMyArIDIgXSxcblxuXHRcdFx0bmJ4ID0gbm9ybWFsc1sgbmIqMyAgICAgXSxcblx0XHRcdG5ieSA9IG5vcm1hbHNbIG5iKjMgKyAxIF0sXG5cdFx0XHRuYnogPSBub3JtYWxzWyBuYiozICsgMiBdLFxuXG5cdFx0XHRuY3ggPSBub3JtYWxzWyBuYyozICAgICBdLFxuXHRcdFx0bmN5ID0gbm9ybWFsc1sgbmMqMyArIDEgXSxcblx0XHRcdG5jeiA9IG5vcm1hbHNbIG5jKjMgKyAyIF0sXG5cblx0XHRcdG5keCA9IG5vcm1hbHNbIG5kKjMgICAgIF0sXG5cdFx0XHRuZHkgPSBub3JtYWxzWyBuZCozICsgMSBdLFxuXHRcdFx0bmR6ID0gbm9ybWFsc1sgbmQqMyArIDIgXTtcblxuXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlNCggYSwgYiwgYywgZCxcblx0XHRcdFx0XHRcdCAgW25ldyBUSFJFRS5WZWN0b3IzKCBuYXgsIG5heSwgbmF6ICksXG5cdFx0XHRcdFx0XHQgICBuZXcgVEhSRUUuVmVjdG9yMyggbmJ4LCBuYnksIG5ieiApLFxuXHRcdFx0XHRcdFx0ICAgbmV3IFRIUkVFLlZlY3RvcjMoIG5jeCwgbmN5LCBuY3ogKSxcblx0XHRcdFx0XHRcdCAgIG5ldyBUSFJFRS5WZWN0b3IzKCBuZHgsIG5keSwgbmR6ICldLFxuXHRcdFx0XHRcdFx0ICBudWxsLFxuXHRcdFx0XHRcdFx0ICBtaSApICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiB1djMgKCB3aGVyZSwgdTEsIHYxLCB1MiwgdjIsIHUzLCB2MyApIHtcblxuXHRcdHZhciB1diA9IFtdO1xuXHRcdHV2LnB1c2goIG5ldyBUSFJFRS5VViggdTEsIHYxICkgKTtcblx0XHR1di5wdXNoKCBuZXcgVEhSRUUuVVYoIHUyLCB2MiApICk7XG5cdFx0dXYucHVzaCggbmV3IFRIUkVFLlVWKCB1MywgdjMgKSApO1xuXHRcdHdoZXJlLnB1c2goIHV2ICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiB1djQgKCB3aGVyZSwgdTEsIHYxLCB1MiwgdjIsIHUzLCB2MywgdTQsIHY0ICkge1xuXG5cdFx0dmFyIHV2ID0gW107XG5cdFx0dXYucHVzaCggbmV3IFRIUkVFLlVWKCB1MSwgdjEgKSApO1xuXHRcdHV2LnB1c2goIG5ldyBUSFJFRS5VViggdTIsIHYyICkgKTtcblx0XHR1di5wdXNoKCBuZXcgVEhSRUUuVVYoIHUzLCB2MyApICk7XG5cdFx0dXYucHVzaCggbmV3IFRIUkVFLlVWKCB1NCwgdjQgKSApO1xuXHRcdHdoZXJlLnB1c2goIHV2ICk7XG5cblx0fTtcblxuXHRNb2RlbC5wcm90b3R5cGUgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0TW9kZWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kZWw7XG5cblx0Y2FsbGJhY2soIG5ldyBNb2RlbCggdGV4dHVyZVBhdGggKSApO1xuXG59O1xuLyoqXG4gKiBAYXV0aG9yIFRpbSBLbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tLyAvIHRpbSBhdCBmbG9vcnBsYW5uZXIuY29tXG4gKi9cblxuVEhSRUUuQ29sbGFkYUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgQ09MTEFEQSA9IG51bGw7XG5cdHZhciBzY2VuZSA9IG51bGw7XG5cdHZhciBkYWVTY2VuZTtcblxuXHR2YXIgcmVhZHlDYWxsYmFja0Z1bmMgPSBudWxsO1xuXG4gXHR2YXIgc291cmNlcyA9IHt9O1xuXHR2YXIgaW1hZ2VzID0ge307XG5cdHZhciBhbmltYXRpb25zID0ge307XG5cdHZhciBjb250cm9sbGVycyA9IHt9O1xuXHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXHR2YXIgbWF0ZXJpYWxzID0ge307XG5cdHZhciBlZmZlY3RzID0ge307XG5cblx0dmFyIHZpc3VhbFNjZW5lcztcblx0dmFyIGJhc2VVcmw7XG5cdHZhciBtb3JwaHM7XG5cdHZhciBza2lucztcblxuXHR2YXIgZmxpcF91diA9IHRydWU7XG5cdHZhciBwcmVmZXJyZWRTaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHRmdW5jdGlvbiBsb2FkICggdXJsLCByZWFkeUNhbGxiYWNrICkge1xuXG5cdFx0aWYgKCBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudCApIHtcblxuXHRcdFx0dmFyIG5hbWVzcGFjZVVSTCA9IFwiaHR0cDovL3d3dy5jb2xsYWRhLm9yZy8yMDA1LzExL0NPTExBREFTY2hlbWFcIjtcblx0XHRcdHZhciByb290VGFnTmFtZSA9IFwiQ09MTEFEQVwiO1xuXG5cdFx0XHR2YXIgeG1sZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoIG5hbWVzcGFjZVVSTCwgcm9vdFRhZ05hbWUsIG51bGwgKTtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdC8vIGZvcmNlIHJlbG9hZGluZ1xuXHRcdFx0Ly8gKHNob3VsZCBiZSBjb25maWd1cmFibGU/IHNvbWV0aW1lcyBjYWNoaW5nIGlzIGRlc2lyYWJsZSlcblxuXHRcdFx0dXJsICs9IFwiP3JuZD1cIiArIE1hdGgucmFuZG9tKCk7XG5cblx0XHRcdHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdFx0aWYoIHJlcS5vdmVycmlkZU1pbWVUeXBlICkge1xuXG5cdFx0XHRcdC8vIG5lZWQgdGhpcz8geWVzLi4uIGlmIGV4dGVuc2lvbiBpcyBvdGhlciB0aGVuICoueG1sIDotU1xuXG5cdFx0XHRcdHJlcS5vdmVycmlkZU1pbWVUeXBlKCBcInRleHQveG1sXCIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0aWYoIHJlcS5yZWFkeVN0YXRlID09IDQgKSB7XG5cblx0XHRcdFx0XHRpZiggcmVxLnN0YXR1cyA9PSAwIHx8IHJlcS5zdGF0dXMgPT0gMjAwICkge1xuXG5cdFx0XHRcdFx0XHRyZWFkeUNhbGxiYWNrRnVuYyA9IHJlYWR5Q2FsbGJhY2s7XG5cdFx0XHRcdFx0XHRwYXJzZSggcmVxLnJlc3BvbnNlWE1MLCB1bmRlZmluZWQsIHVybCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXEub3BlbiggXCJHRVRcIiwgdXJsLCB0cnVlICk7XG5cdFx0XHRyZXEuc2VuZCggbnVsbCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YWxlcnQoIFwiRG9uJ3Qga25vdyBob3cgdG8gcGFyc2UgWE1MIVwiICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBwYXJzZSAoIGRvYywgY2FsbEJhY2ssIHVybCApIHtcblxuXHRcdENPTExBREEgPSBkb2M7XG5cdFx0Y2FsbEJhY2sgPSBjYWxsQmFjayB8fCByZWFkeUNhbGxiYWNrRnVuYztcblxuXHRcdGlmICggdXJsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG5cdFx0XHRwYXJ0cy5wb3AoKTtcblx0XHRcdGJhc2VVcmwgPSBwYXJ0cy5sZW5ndGggPCAxID8gJycgOiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcblxuXHRcdH1cblxuXHRcdGltYWdlcyA9IHBhcnNlTGliKCBcIi8vZGFlOmxpYnJhcnlfaW1hZ2VzL2RhZTppbWFnZVwiLCBfSW1hZ2UsIFwiaW1hZ2VcIiApO1xuXHRcdG1hdGVyaWFscyA9IHBhcnNlTGliKCBcIi8vZGFlOmxpYnJhcnlfbWF0ZXJpYWxzL2RhZTptYXRlcmlhbFwiLCBNYXRlcmlhbCwgXCJtYXRlcmlhbFwiKSA7XG5cdFx0ZWZmZWN0cyA9IHBhcnNlTGliKCBcIi8vZGFlOmxpYnJhcnlfZWZmZWN0cy9kYWU6ZWZmZWN0XCIsIEVmZmVjdCwgXCJlZmZlY3RcIiApO1xuXHRcdGdlb21ldHJpZXMgPSBwYXJzZUxpYiggXCIvL2RhZTpsaWJyYXJ5X2dlb21ldHJpZXMvZGFlOmdlb21ldHJ5XCIsIEdlb21ldHJ5LCBcImdlb21ldHJ5XCIgKTtcblx0XHRjb250cm9sbGVycyA9IHBhcnNlTGliKCBcIi8vZGFlOmxpYnJhcnlfY29udHJvbGxlcnMvZGFlOmNvbnRyb2xsZXJcIiwgQ29udHJvbGxlciwgXCJjb250cm9sbGVyXCIgKTtcblx0XHRhbmltYXRpb25zID0gcGFyc2VMaWIoIFwiLy9kYWU6bGlicmFyeV9hbmltYXRpb25zL2RhZTphbmltYXRpb25cIiwgQW5pbWF0aW9uLCBcImFuaW1hdGlvblwiICk7XG5cdFx0dmlzdWFsU2NlbmVzID0gcGFyc2VMaWIoIFwiLi8vZGFlOmxpYnJhcnlfdmlzdWFsX3NjZW5lcy9kYWU6dmlzdWFsX3NjZW5lXCIsIFZpc3VhbFNjZW5lLCBcInZpc3VhbF9zY2VuZVwiICk7XG5cblx0XHRtb3JwaHMgPSBbXTtcblx0XHRza2lucyA9IFtdO1xuXG5cdFx0ZGFlU2NlbmUgPSBwYXJzZVNjZW5lKCk7XG5cdFx0c2NlbmUgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRhZVNjZW5lLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0c2NlbmUuYWRkKCBjcmVhdGVTY2VuZUdyYXBoKCBkYWVTY2VuZS5ub2Rlc1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdGNyZWF0ZUFuaW1hdGlvbnMoKTtcblxuXHRcdHZhciByZXN1bHQgPSB7XG5cblx0XHRcdHNjZW5lOiBzY2VuZSxcblx0XHRcdG1vcnBoczogbW9ycGhzLFxuXHRcdFx0c2tpbnM6IHNraW5zLFxuXHRcdFx0ZGFlOiB7XG5cdFx0XHRcdGltYWdlczogaW1hZ2VzLFxuXHRcdFx0XHRtYXRlcmlhbHM6IG1hdGVyaWFscyxcblx0XHRcdFx0ZWZmZWN0czogZWZmZWN0cyxcblx0XHRcdFx0Z2VvbWV0cmllczogZ2VvbWV0cmllcyxcblx0XHRcdFx0Y29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxuXHRcdFx0XHRhbmltYXRpb25zOiBhbmltYXRpb25zLFxuXHRcdFx0XHR2aXN1YWxTY2VuZXM6IHZpc3VhbFNjZW5lcyxcblx0XHRcdFx0c2NlbmU6IGRhZVNjZW5lXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0aWYgKCBjYWxsQmFjayApIHtcblxuXHRcdFx0Y2FsbEJhY2soIHJlc3VsdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldFByZWZlcnJlZFNoYWRpbmcgKCBzaGFkaW5nICkge1xuXG5cdFx0cHJlZmVycmVkU2hhZGluZyA9IHNoYWRpbmc7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBwYXJzZUxpYiAoIHEsIGNsYXNzU3BlYywgcHJlZml4ICkge1xuXG5cdFx0dmFyIGVsZW1lbnRzID0gQ09MTEFEQS5ldmFsdWF0ZShxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRDT0xMQURBLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfbnNSZXNvbHZlcixcblx0XHRcdFx0XHRcdFx0XHRcdFx0WFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG51bGwpIDtcblxuXHRcdHZhciBsaWIgPSB7fTtcblx0XHR2YXIgZWxlbWVudCA9IGVsZW1lbnRzLml0ZXJhdGVOZXh0KCk7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0d2hpbGUgKCBlbGVtZW50ICkge1xuXG5cdFx0XHR2YXIgZGFlRWxlbWVudCA9ICggbmV3IGNsYXNzU3BlYygpICkucGFyc2UoIGVsZW1lbnQgKTtcblx0XHRcdGlmICggZGFlRWxlbWVudC5pZC5sZW5ndGggPT0gMCApIGRhZUVsZW1lbnQuaWQgPSBwcmVmaXggKyAoIGkrKyApO1xuXHRcdFx0bGliWyBkYWVFbGVtZW50LmlkIF0gPSBkYWVFbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzLml0ZXJhdGVOZXh0KCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbGliO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcGFyc2VTY2VuZSAoKSB7XG5cblx0XHR2YXIgc2NlbmVFbGVtZW50ID0gQ09MTEFEQS5ldmFsdWF0ZSggXCIuLy9kYWU6c2NlbmUvZGFlOmluc3RhbmNlX3Zpc3VhbF9zY2VuZVwiLFxuXHRcdFx0Q09MTEFEQSxcblx0XHRcdF9uc1Jlc29sdmVyLFxuXHRcdFx0WFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUsXG5cdFx0XHRudWxsICkuaXRlcmF0ZU5leHQoKTtcblxuXHRcdGlmICggc2NlbmVFbGVtZW50ICkge1xuXG5cdFx0XHR2YXIgdXJsID0gc2NlbmVFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKCAvXiMvLCAnJyApO1xuXHRcdFx0cmV0dXJuIHZpc3VhbFNjZW5lc1sgdXJsIF07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvbnMgKCkge1xuXG5cdFx0Y2FsY0FuaW1hdGlvbkJvdW5kcygpO1xuXG5cdFx0Zm9yICggdmFyIGFuaW1hdGlvbl9pZCBpbiBhbmltYXRpb25zICkge1xuXG5cdFx0XHRjcmVhdGVBbmltYXRpb24oIGFuaW1hdGlvbnNbIGFuaW1hdGlvbl9pZCBdICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVBbmltYXRpb24gKCBhbmltYXRpb24gKSB7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjYWxjQW5pbWF0aW9uQm91bmRzICgpIHtcblxuXHRcdHZhciBzdGFydCA9IDEwMDAwMDA7XG5cdFx0dmFyIGVuZCA9IC1zdGFydDtcblx0XHR2YXIgZnJhbWVzID0gMDtcblxuXHRcdGZvciAoIHZhciBpZCBpbiBhbmltYXRpb25zICkge1xuXG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1sgaWQgXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uLnNhbXBsZXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBzYW1wbGVyID0gYW5pbWF0aW9uLnNhbXBsZXJbIGkgXTtcblx0XHRcdFx0c2FtcGxlci5jcmVhdGUoKTtcblxuXHRcdFx0XHRzdGFydCA9IE1hdGgubWluKCBzdGFydCwgc2FtcGxlci5zdGFydFRpbWUgKTtcblx0XHRcdFx0ZW5kID0gTWF0aC5tYXgoIGVuZCwgc2FtcGxlci5lbmRUaW1lICk7XG5cdFx0XHRcdGZyYW1lcyA9IE1hdGgubWF4KCBmcmFtZXMsIHNhbXBsZXIuaW5wdXQubGVuZ3RoICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7IHN0YXJ0OnN0YXJ0LCBlbmQ6ZW5kLCBmcmFtZXM6ZnJhbWVzIH07XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVNb3JwaCAoIGdlb21ldHJ5LCBjdHJsICkge1xuXG5cdFx0dmFyIG1vcnBoQ3RybCA9IGN0cmwgaW5zdGFuY2VvZiBJbnN0YW5jZUNvbnRyb2xsZXIgPyBjb250cm9sbGVyc1sgY3RybC51cmwgXSA6IGN0cmw7XG5cblx0XHRpZiAoICFtb3JwaEN0cmwgfHwgIW1vcnBoQ3RybC5tb3JwaCApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coXCJjb3VsZCBub3QgZmluZCBtb3JwaCBjb250cm9sbGVyIVwiKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciBtb3JwaCA9IG1vcnBoQ3RybC5tb3JwaDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoLnRhcmdldHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdGFyZ2V0X2lkID0gbW9ycGgudGFyZ2V0c1sgaSBdO1xuXHRcdFx0dmFyIGRhZUdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgdGFyZ2V0X2lkIF07XG5cblx0XHRcdGlmICggIWRhZUdlb21ldHJ5Lm1lc2ggfHxcblx0XHRcdFx0ICFkYWVHZW9tZXRyeS5tZXNoLnByaW1pdGl2ZXMgfHxcblx0XHRcdFx0ICFkYWVHZW9tZXRyeS5tZXNoLnByaW1pdGl2ZXMubGVuZ3RoICkge1xuXHRcdFx0XHQgY29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0YXJnZXQgPSBkYWVHZW9tZXRyeS5tZXNoLnByaW1pdGl2ZXNbIDAgXS5nZW9tZXRyeTtcblxuXHRcdFx0aWYgKCB0YXJnZXQudmVydGljZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzLnB1c2goIHsgbmFtZTogXCJ0YXJnZXRfMVwiLCB2ZXJ0aWNlczogdGFyZ2V0LnZlcnRpY2VzIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzLnB1c2goIHsgbmFtZTogXCJ0YXJnZXRfWlwiLCB2ZXJ0aWNlczogZ2VvbWV0cnkudmVydGljZXMgfSApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlU2tpbiAoIGdlb21ldHJ5LCBjdHJsLCBhcHBseUJpbmRTaGFwZSApIHtcblxuXHRcdHZhciBza2luQ3RybCA9IGNvbnRyb2xsZXJzWyBjdHJsLnVybCBdO1xuXG5cdFx0aWYgKCAhc2tpbkN0cmwgfHwgIXNraW5DdHJsLnNraW4gKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBcImNvdWxkIG5vdCBmaW5kIHNraW4gY29udHJvbGxlciFcIiApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhY3RybC5za2VsZXRvbiB8fCAhY3RybC5za2VsZXRvbi5sZW5ndGggKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBcImNvdWxkIG5vdCBmaW5kIHRoZSBza2VsZXRvbiBmb3IgdGhlIHNraW4hXCIgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciBza2luID0gc2tpbkN0cmwuc2tpbjtcblx0XHR2YXIgc2tlbGV0b24gPSBkYWVTY2VuZS5nZXRDaGlsZEJ5SWQoIGN0cmwuc2tlbGV0b25bIDAgXSApO1xuXHRcdHZhciBoaWVyYXJjaHkgPSBbXTtcblxuXHRcdGFwcGx5QmluZFNoYXBlID0gYXBwbHlCaW5kU2hhcGUgIT09IHVuZGVmaW5lZCA/IGFwcGx5QmluZFNoYXBlIDogdHJ1ZTtcblxuXHRcdHZhciBib25lcyA9IFtdO1xuXHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzID0gW107XG5cdFx0Z2VvbWV0cnkuc2tpbkluZGljZXMgPSBbXTtcblxuXHRcdC8vY3JlYXRlQm9uZXMoIGdlb21ldHJ5LmJvbmVzLCBza2luLCBoaWVyYXJjaHksIHNrZWxldG9uLCBudWxsLCAtMSApO1xuXHRcdC8vY3JlYXRlV2VpZ2h0cyggc2tpbiwgZ2VvbWV0cnkuYm9uZXMsIGdlb21ldHJ5LnNraW5JbmRpY2VzLCBnZW9tZXRyeS5za2luV2VpZ2h0cyApO1xuXG5cdFx0Lypcblx0XHRnZW9tZXRyeS5hbmltYXRpb24gPSB7XG5cdFx0XHRuYW1lOiAndGFrZV8wMDEnLFxuXHRcdFx0ZnBzOiAzMCxcblx0XHRcdGxlbmd0aDogMixcblx0XHRcdEpJVDogdHJ1ZSxcblx0XHRcdGhpZXJhcmNoeTogaGllcmFyY2h5XG5cdFx0fTtcblx0XHQqL1xuXG5cdFx0aWYgKCBhcHBseUJpbmRTaGFwZSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHNraW4uYmluZFNoYXBlTWF0cml4Lm11bHRpcGx5VmVjdG9yMyggZ2VvbWV0cnkudmVydGljZXNbIGkgXS5wb3NpdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXR1cFNrZWxldG9uICggbm9kZSwgYm9uZXMsIGZyYW1lLCBwYXJlbnQgKSB7XG5cblx0XHRub2RlLndvcmxkID0gbm9kZS53b3JsZCB8fCBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdG5vZGUud29ybGQuY29weSggbm9kZS5tYXRyaXggKTtcblxuXHRcdGlmICggbm9kZS5jaGFubmVscyAmJiBub2RlLmNoYW5uZWxzLmxlbmd0aCApIHtcblxuXHRcdFx0dmFyIGNoYW5uZWwgPSBub2RlLmNoYW5uZWxzWyAwIF07XG5cdFx0XHR2YXIgbSA9IGNoYW5uZWwuc2FtcGxlci5vdXRwdXRbIGZyYW1lIF07XG5cblx0XHRcdGlmICggbSBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgKSB7XG5cblx0XHRcdFx0bm9kZS53b3JsZC5jb3B5KCBtICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRub2RlLndvcmxkLm11bHRpcGx5KCBwYXJlbnQsIG5vZGUud29ybGQgKTtcblxuXHRcdH1cblxuXHRcdGJvbmVzLnB1c2goIG5vZGUgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRzZXR1cFNrZWxldG9uKCBub2RlLm5vZGVzWyBpIF0sIGJvbmVzLCBmcmFtZSwgbm9kZS53b3JsZCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0dXBTa2lubmluZ01hdHJpY2VzICggYm9uZXMsIHNraW4gKSB7XG5cblx0XHQvLyBGSVhNRTogdGhpcyBpcyBkdW1iLi4uXG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBib25lID0gYm9uZXNbIGkgXTtcblx0XHRcdHZhciBmb3VuZCA9IC0xO1xuXG5cdFx0XHRpZiAoIGJvbmUudHlwZSAhPSAnSk9JTlQnICkgY29udGludWU7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHNraW4uam9pbnRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRpZiAoIGJvbmUuc2lkID09IHNraW4uam9pbnRzWyBqIF0gKSB7XG5cblx0XHRcdFx0XHRmb3VuZCA9IGo7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZm91bmQgPj0gMCApIHtcblxuXHRcdFx0XHR2YXIgaW52ID0gc2tpbi5pbnZCaW5kTWF0cmljZXNbIGZvdW5kIF07XG5cblx0XHRcdFx0Ym9uZS5pbnZCaW5kTWF0cml4ID0gaW52O1xuXHRcdFx0XHRib25lLnNraW5uaW5nTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRcdFx0Ym9uZS5za2lubmluZ01hdHJpeC5tdWx0aXBseShib25lLndvcmxkLCBpbnYpOyAvLyAoSUJNaSAqIEpNaSlcblxuXHRcdFx0XHRib25lLndlaWdodHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBza2luLndlaWdodHMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBza2luLndlaWdodHNbIGogXS5sZW5ndGg7IGsgKyspIHtcblxuXHRcdFx0XHRcdFx0dmFyIHcgPSBza2luLndlaWdodHNbIGogXVsgayBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHcuam9pbnQgPT0gZm91bmQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ym9uZS53ZWlnaHRzLnB1c2goIHcgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aHJvdyAnQ29sbGFkYUxvYWRlcjogQ291bGQgbm90IGZpbmQgam9pbnQgXFwnJyArIGJvbmUuc2lkICsgJ1xcJy4nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVNraW4gKCBnZW9tZXRyeSwgaW5zdGFuY2VDdHJsLCBmcmFtZSApIHtcblxuXHRcdHZhciBza2luQ29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBpbnN0YW5jZUN0cmwudXJsIF07XG5cblx0XHRmcmFtZSA9IGZyYW1lICE9PSB1bmRlZmluZWQgPyBmcmFtZSA6IDQwO1xuXG5cdFx0aWYgKCAhc2tpbkNvbnRyb2xsZXIgfHwgIXNraW5Db250cm9sbGVyLnNraW4gKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjogQ291bGQgbm90IGZpbmQgc2tpbiBjb250cm9sbGVyLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggIWluc3RhbmNlQ3RybC5za2VsZXRvbiB8fCAhaW5zdGFuY2VDdHJsLnNrZWxldG9uLmxlbmd0aCApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coICdDb2xsYWRhTG9hZGVyOiBDb3VsZCBub3QgZmluZCB0aGUgc2tlbGV0b24gZm9yIHRoZSBza2luLiAnICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgYW5pbWF0aW9uQm91bmRzID0gY2FsY0FuaW1hdGlvbkJvdW5kcygpO1xuXHRcdHZhciBza2VsZXRvbiA9IGRhZVNjZW5lLmdldENoaWxkQnlJZCggaW5zdGFuY2VDdHJsLnNrZWxldG9uWzBdLCB0cnVlICkgfHxcblx0XHRcdFx0XHQgICBkYWVTY2VuZS5nZXRDaGlsZEJ5U2lkKCBpbnN0YW5jZUN0cmwuc2tlbGV0b25bMF0sIHRydWUgKTtcblxuXHRcdHZhciBpLCBqLCB3LCB2aWR4LCB3ZWlnaHQ7XG5cdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBvLCBzO1xuXG5cdFx0Ly8gbW92ZSB2ZXJ0aWNlcyB0byBiaW5kIHNoYXBlXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0c2tpbkNvbnRyb2xsZXIuc2tpbi5iaW5kU2hhcGVNYXRyaXgubXVsdGlwbHlWZWN0b3IzKCBnZW9tZXRyeS52ZXJ0aWNlc1tpXS5wb3NpdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcHJvY2VzcyBhbmltYXRpb24sIG9yIHNpbXBseSBwb3NlIHRoZSByaWcgaWYgbm8gYW5pbWF0aW9uXG5cblx0XHRmb3IgKCBmcmFtZSA9IDA7IGZyYW1lIDwgYW5pbWF0aW9uQm91bmRzLmZyYW1lczsgZnJhbWUgKysgKSB7XG5cblx0XHRcdHZhciBib25lcyA9IFtdO1xuXHRcdFx0dmFyIHNraW5uZWQgPSBbXTtcblxuXHRcdFx0Ly8gemVybyBza2lubmVkIHZlcnRpY2VzXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdFx0c2tpbm5lZC5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMygpICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9jZXNzIHRoZSBmcmFtZSBhbmQgc2V0dXAgdGhlIHJpZyB3aXRoIGEgZnJlc2hcblx0XHRcdC8vIHRyYW5zZm9ybSwgcG9zc2libHkgZnJvbSB0aGUgYm9uZSdzIGFuaW1hdGlvbiBjaGFubmVsKHMpXG5cblx0XHRcdHNldHVwU2tlbGV0b24oIHNrZWxldG9uLCBib25lcywgZnJhbWUgKTtcblx0XHRcdHNldHVwU2tpbm5pbmdNYXRyaWNlcyggYm9uZXMsIHNraW5Db250cm9sbGVyLnNraW4gKTtcblxuXHRcdFx0Ly8gc2tpbiAnbVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGJvbmVzWyBpIF0udHlwZSAhPSAnSk9JTlQnICkgY29udGludWU7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBib25lc1sgaSBdLndlaWdodHMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dyA9IGJvbmVzWyBpIF0ud2VpZ2h0c1sgaiBdO1xuXHRcdFx0XHRcdHZpZHggPSB3LmluZGV4O1xuXHRcdFx0XHRcdHdlaWdodCA9IHcud2VpZ2h0O1xuXG5cdFx0XHRcdFx0byA9IGdlb21ldHJ5LnZlcnRpY2VzW3ZpZHhdO1xuXHRcdFx0XHRcdHMgPSBza2lubmVkW3ZpZHhdO1xuXG5cdFx0XHRcdFx0di54ID0gby5wb3NpdGlvbi54O1xuXHRcdFx0XHRcdHYueSA9IG8ucG9zaXRpb24ueTtcblx0XHRcdFx0XHR2LnogPSBvLnBvc2l0aW9uLno7XG5cblx0XHRcdFx0XHRib25lc1tpXS5za2lubmluZ01hdHJpeC5tdWx0aXBseVZlY3RvcjModik7XG5cblx0XHRcdFx0XHRzLnBvc2l0aW9uLnggKz0gKHYueCAqIHdlaWdodCk7XG5cdFx0XHRcdFx0cy5wb3NpdGlvbi55ICs9ICh2LnkgKiB3ZWlnaHQpO1xuXHRcdFx0XHRcdHMucG9zaXRpb24ueiArPSAodi56ICogd2VpZ2h0KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzLnB1c2goIHsgbmFtZTogXCJ0YXJnZXRfXCIgKyBmcmFtZSwgdmVydGljZXM6IHNraW5uZWQgfSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlU2NlbmVHcmFwaCAoIG5vZGUsIHBhcmVudCApIHtcblxuXHRcdHZhciBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblx0XHR2YXIgc2tpbm5lZCA9IGZhbHNlO1xuXHRcdHZhciBza2luQ29udHJvbGxlcjtcblx0XHR2YXIgbW9ycGhDb250cm9sbGVyO1xuXHRcdHZhciBpLCBqO1xuXG5cdFx0Ly8gRklYTUU6IGNvbnRyb2xsZXJzXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IG5vZGUuY29udHJvbGxlcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBub2RlLmNvbnRyb2xsZXJzWyBpIF0udXJsIF07XG5cblx0XHRcdHN3aXRjaCAoIGNvbnRyb2xsZXIudHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdza2luJzpcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cmllc1sgY29udHJvbGxlci5za2luLnNvdXJjZSBdICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW5zdF9nZW9tID0gbmV3IEluc3RhbmNlR2VvbWV0cnkoKTtcblxuXHRcdFx0XHRcdFx0aW5zdF9nZW9tLnVybCA9IGNvbnRyb2xsZXIuc2tpbi5zb3VyY2U7XG5cdFx0XHRcdFx0XHRpbnN0X2dlb20uaW5zdGFuY2VfbWF0ZXJpYWwgPSBub2RlLmNvbnRyb2xsZXJzWyBpIF0uaW5zdGFuY2VfbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdG5vZGUuZ2VvbWV0cmllcy5wdXNoKCBpbnN0X2dlb20gKTtcblx0XHRcdFx0XHRcdHNraW5uZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0c2tpbkNvbnRyb2xsZXIgPSBub2RlLmNvbnRyb2xsZXJzWyBpIF07XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb250cm9sbGVyc1sgY29udHJvbGxlci5za2luLnNvdXJjZSBdICkge1xuXG5cdFx0XHRcdFx0XHQvLyB1cmdoOiBjb250cm9sbGVyIGNhbiBiZSBjaGFpbmVkXG5cdFx0XHRcdFx0XHQvLyBoYW5kbGUgdGhlIG1vc3QgYmFzaWMgY2FzZS4uLlxuXG5cdFx0XHRcdFx0XHR2YXIgc2Vjb25kID0gY29udHJvbGxlcnNbIGNvbnRyb2xsZXIuc2tpbi5zb3VyY2UgXTtcblx0XHRcdFx0XHRcdG1vcnBoQ29udHJvbGxlciA9IHNlY29uZDtcblx0XHRcdFx0XHQvL1x0c2tpbkNvbnRyb2xsZXIgPSBub2RlLmNvbnRyb2xsZXJzW2ldO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNlY29uZC5tb3JwaCAmJiBnZW9tZXRyaWVzWyBzZWNvbmQubW9ycGguc291cmNlIF0gKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGluc3RfZ2VvbSA9IG5ldyBJbnN0YW5jZUdlb21ldHJ5KCk7XG5cblx0XHRcdFx0XHRcdFx0aW5zdF9nZW9tLnVybCA9IHNlY29uZC5tb3JwaC5zb3VyY2U7XG5cdFx0XHRcdFx0XHRcdGluc3RfZ2VvbS5pbnN0YW5jZV9tYXRlcmlhbCA9IG5vZGUuY29udHJvbGxlcnNbIGkgXS5pbnN0YW5jZV9tYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0XHRub2RlLmdlb21ldHJpZXMucHVzaCggaW5zdF9nZW9tICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21vcnBoJzpcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cmllc1sgY29udHJvbGxlci5tb3JwaC5zb3VyY2UgXSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGluc3RfZ2VvbSA9IG5ldyBJbnN0YW5jZUdlb21ldHJ5KCk7XG5cblx0XHRcdFx0XHRcdGluc3RfZ2VvbS51cmwgPSBjb250cm9sbGVyLm1vcnBoLnNvdXJjZTtcblx0XHRcdFx0XHRcdGluc3RfZ2VvbS5pbnN0YW5jZV9tYXRlcmlhbCA9IG5vZGUuY29udHJvbGxlcnNbIGkgXS5pbnN0YW5jZV9tYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0bm9kZS5nZW9tZXRyaWVzLnB1c2goIGluc3RfZ2VvbSApO1xuXHRcdFx0XHRcdFx0bW9ycGhDb250cm9sbGVyID0gbm9kZS5jb250cm9sbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coICdDb2xsYWRhTG9hZGVyOiBNb3JwaC1jb250cm9sbGVyIHBhcnRpYWxseSBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEZJWE1FOiBtdWx0aS1tYXRlcmlhbCBtZXNoP1xuXHRcdC8vIGdlb21ldHJpZXNcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbm9kZS5nZW9tZXRyaWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGluc3RhbmNlX2dlb21ldHJ5ID0gbm9kZS5nZW9tZXRyaWVzW2ldO1xuXHRcdFx0dmFyIGluc3RhbmNlX21hdGVyaWFscyA9IGluc3RhbmNlX2dlb21ldHJ5Lmluc3RhbmNlX21hdGVyaWFsO1xuXHRcdFx0dmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpbnN0YW5jZV9nZW9tZXRyeS51cmxdO1xuXHRcdFx0dmFyIHVzZWRfbWF0ZXJpYWxzID0ge307XG5cdFx0XHR2YXIgbnVtX21hdGVyaWFscyA9IDA7XG5cdFx0XHR2YXIgZmlyc3RfbWF0ZXJpYWw7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0aWYgKCAhZ2VvbWV0cnkubWVzaCB8fCAhZ2VvbWV0cnkubWVzaC5wcmltaXRpdmVzIClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRpZiAoIG9iai5uYW1lLmxlbmd0aCA9PSAwICkge1xuXG5cdFx0XHRcdFx0b2JqLm5hbWUgPSBnZW9tZXRyeS5pZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY29sbGVjdCB1c2VkIGZ4IGZvciB0aGlzIGdlb21ldHJ5LWluc3RhbmNlXG5cblx0XHRcdFx0aWYgKCBpbnN0YW5jZV9tYXRlcmlhbHMgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IGluc3RhbmNlX21hdGVyaWFscy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBpbnN0X21hdGVyaWFsID0gaW5zdGFuY2VfbWF0ZXJpYWxzW2pdO1xuXHRcdFx0XHRcdFx0dmFyIGVmZmVjdF9pZCA9IG1hdGVyaWFsc1tpbnN0X21hdGVyaWFsLnRhcmdldF0uaW5zdGFuY2VfZWZmZWN0LnVybDtcblx0XHRcdFx0XHRcdHZhciBzaGFkZXIgPSBlZmZlY3RzW2VmZmVjdF9pZF0uc2hhZGVyO1xuXG5cdFx0XHRcdFx0XHRzaGFkZXIubWF0ZXJpYWwub3BhY2l0eSA9ICFzaGFkZXIubWF0ZXJpYWwub3BhY2l0eSA/IDEgOiBzaGFkZXIubWF0ZXJpYWwub3BhY2l0eTtcblx0XHRcdFx0XHRcdHVzZWRfbWF0ZXJpYWxzW2luc3RfbWF0ZXJpYWwuc3ltYm9sXSA9IHNoYWRlci5tYXRlcmlhbDtcblx0XHRcdFx0XHRcdGZpcnN0X21hdGVyaWFsID0gc2hhZGVyLm1hdGVyaWFsO1xuXHRcdFx0XHRcdFx0bnVtX21hdGVyaWFscyArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG1lc2g7XG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IGZpcnN0X21hdGVyaWFsIHx8IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKCB7IGNvbG9yOiAweGRkZGRkZCwgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcgfSApO1xuXHRcdFx0XHR2YXIgZ2VvbSA9IGdlb21ldHJ5Lm1lc2guZ2VvbWV0cnkzanM7XG5cblx0XHRcdFx0aWYgKCBudW1fbWF0ZXJpYWxzID4gMSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoKTtcblxuXHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgZ2VvbS5mYWNlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBmYWNlID0gZ2VvbS5mYWNlc1sgaiBdO1xuXHRcdFx0XHRcdFx0ZmFjZS5tYXRlcmlhbHMgPSBbIHVzZWRfbWF0ZXJpYWxzWyBmYWNlLmRhZU1hdGVyaWFsIF0gXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBza2luQ29udHJvbGxlciAhPT0gdW5kZWZpbmVkKSB7XG5cblx0XHRcdFx0XHRhcHBseVNraW4oIGdlb20sIHNraW5Db250cm9sbGVyICk7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBUSFJFRS5Ta2lubmVkTWVzaCggZ2VvbSwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRtZXNoLnNrZWxldG9uID0gc2tpbkNvbnRyb2xsZXIuc2tlbGV0b247XG5cdFx0XHRcdFx0bWVzaC5za2luQ29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBza2luQ29udHJvbGxlci51cmwgXTtcblx0XHRcdFx0XHRtZXNoLnNraW5JbnN0YW5jZUNvbnRyb2xsZXIgPSBza2luQ29udHJvbGxlcjtcblx0XHRcdFx0XHRtZXNoLm5hbWUgPSAnc2tpbl8nICsgc2tpbnMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0c2tpbnMucHVzaCggbWVzaCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1vcnBoQ29udHJvbGxlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y3JlYXRlTW9ycGgoIGdlb20sIG1vcnBoQ29udHJvbGxlciApO1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbSwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRtZXNoLm5hbWUgPSAnbW9ycGhfJyArIG1vcnBocy5sZW5ndGg7XG5cblx0XHRcdFx0XHRtb3JwaHMucHVzaCggbWVzaCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb20sIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0Ly8gbWVzaC5nZW9tLm5hbWUgPSBnZW9tZXRyeS5pZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bm9kZS5nZW9tZXRyaWVzLmxlbmd0aCA+IDEgPyBvYmouYWRkKCBtZXNoICkgOiBvYmogPSBtZXNoO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRvYmoubmFtZSA9IG5vZGUuaWQgfHwgXCJcIjtcblx0XHRub2RlLm1hdHJpeC5kZWNvbXBvc2UoIG9iai5wb3NpdGlvbiwgb2JqLnJvdGF0aW9uLCBvYmouc2NhbGUgKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbm9kZS5ub2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdG9iai5hZGQoIGNyZWF0ZVNjZW5lR3JhcGgoIG5vZGUubm9kZXNbaV0sIG5vZGUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldEpvaW50SWQoIHNraW4sIGlkICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2tpbi5qb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHNraW4uam9pbnRzWyBpIF0gPT0gaWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldExpYnJhcnlOb2RlKCBpZCApIHtcblxuXHRcdHJldHVybiBDT0xMQURBLmV2YWx1YXRlKFwiLi8vZGFlOmxpYnJhcnlfbm9kZXMvL2RhZTpub2RlW0BpZD0nXCIraWQrXCInXVwiLFxuXHRcdFx0XHRcdFx0XHRcdENPTExBREEsXG5cdFx0XHRcdFx0XHRcdFx0X25zUmVzb2x2ZXIsXG5cdFx0XHRcdFx0XHRcdFx0WFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUsXG5cdFx0XHRcdFx0XHRcdFx0bnVsbCkuaXRlcmF0ZU5leHQoKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldENoYW5uZWxzRm9yTm9kZSAobm9kZSApIHtcblxuXHRcdHZhciBjaGFubmVscyA9IFtdO1xuXHRcdHZhciBzdGFydFRpbWUgPSAxMDAwMDAwO1xuXHRcdHZhciBlbmRUaW1lID0gLTEwMDAwMDA7XG5cblx0XHRmb3IgKCB2YXIgaWQgaW4gYW5pbWF0aW9ucyApIHtcblxuXHRcdFx0dmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaWRdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhbmltYXRpb24uY2hhbm5lbC5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoYW5uZWwgPSBhbmltYXRpb24uY2hhbm5lbFtpXTtcblx0XHRcdFx0dmFyIHNhbXBsZXIgPSBhbmltYXRpb24uc2FtcGxlcltpXTtcblx0XHRcdFx0dmFyIGlkID0gY2hhbm5lbC50YXJnZXQuc3BsaXQoJy8nKVswXTtcblxuXHRcdFx0XHRpZiAoIGlkID09IG5vZGUuaWQgKSB7XG5cblx0XHRcdFx0XHRzYW1wbGVyLmNyZWF0ZSgpO1xuXHRcdFx0XHRcdGNoYW5uZWwuc2FtcGxlciA9IHNhbXBsZXI7XG5cdFx0XHRcdFx0c3RhcnRUaW1lID0gTWF0aC5taW4oc3RhcnRUaW1lLCBzYW1wbGVyLnN0YXJ0VGltZSk7XG5cdFx0XHRcdFx0ZW5kVGltZSA9IE1hdGgubWF4KGVuZFRpbWUsIHNhbXBsZXIuZW5kVGltZSk7XG5cdFx0XHRcdFx0Y2hhbm5lbHMucHVzaChjaGFubmVsKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggY2hhbm5lbHMubGVuZ3RoICkge1xuXG5cdFx0XHRub2RlLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcblx0XHRcdG5vZGUuZW5kVGltZSA9IGVuZFRpbWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2hhbm5lbHM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjYWxjRnJhbWVEdXJhdGlvbiggbm9kZSApIHtcblxuXHRcdHZhciBtaW5UID0gMTAwMDAwMDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlLmNoYW5uZWxzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHNhbXBsZXIgPSBub2RlLmNoYW5uZWxzW2ldLnNhbXBsZXI7XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc2FtcGxlci5pbnB1dC5sZW5ndGggLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciB0MCA9IHNhbXBsZXIuaW5wdXRbIGogXTtcblx0XHRcdFx0dmFyIHQxID0gc2FtcGxlci5pbnB1dFsgaiArIDEgXTtcblx0XHRcdFx0bWluVCA9IE1hdGgubWluKCBtaW5ULCB0MSAtIHQwICk7XG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWluVDtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNhbGNNYXRyaXhBdCggbm9kZSwgdCApIHtcblxuXHRcdHZhciBhbmltYXRlZCA9IHt9O1xuXG5cdFx0dmFyIGksIGo7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IG5vZGUuY2hhbm5lbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hhbm5lbCA9IG5vZGUuY2hhbm5lbHNbIGkgXTtcblx0XHRcdGFuaW1hdGVkWyBjaGFubmVsLnNpZCBdID0gY2hhbm5lbDtcblxuXHRcdH1cblxuXHRcdHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBub2RlLnRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gbm9kZS50cmFuc2Zvcm1zW2ldO1xuXHRcdFx0dmFyIGNoYW5uZWwgPSBhbmltYXRlZFt0cmFuc2Zvcm0uc2lkXTtcblxuXHRcdFx0aWYgKCBjaGFubmVsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIHNhbXBsZXIgPSBjaGFubmVsLnNhbXBsZXI7XG5cdFx0XHRcdHZhciB2YWx1ZTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBzYW1wbGVyLmlucHV0Lmxlbmd0aCAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHNhbXBsZXIuaW5wdXRbaisxXSA+IHQgKSB7XG5cblx0XHRcdFx0XHRcdHZhbHVlID0gc2FtcGxlci5vdXRwdXRbal07XG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKHZhbHVlLmZsYXR0ZW4pXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgKSB7XG5cblx0XHRcdFx0XHRcdG1hdHJpeCA9IG1hdHJpeC5tdWx0aXBseSggbWF0cml4LCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gRklYTUU6IGhhbmRsZSBvdGhlciB0eXBlc1xuXG5cdFx0XHRcdFx0XHRtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkoIG1hdHJpeCwgdHJhbnNmb3JtLm1hdHJpeCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkoIG1hdHJpeCwgdHJhbnNmb3JtLm1hdHJpeCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkoIG1hdHJpeCwgdHJhbnNmb3JtLm1hdHJpeCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0cml4O1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gYmFrZUFuaW1hdGlvbnMgKCBub2RlICkge1xuXG5cdFx0aWYgKCBub2RlLmNoYW5uZWxzICYmIG5vZGUuY2hhbm5lbHMubGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgZnJhbWVEdXJhdGlvbiA9IGNhbGNGcmFtZUR1cmF0aW9uKCBub2RlICk7XG5cdFx0XHR2YXIgdCwgbWF0cml4O1xuXHRcdFx0dmFyIGtleXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdCA9IG5vZGUuc3RhcnRUaW1lOyB0IDwgbm9kZS5lbmRUaW1lOyB0ICs9IGZyYW1lRHVyYXRpb24gKSB7XG5cblx0XHRcdFx0bWF0cml4ID0gY2FsY01hdHJpeEF0KCBub2RlLCB0ICk7XG5cblx0XHRcdFx0Ly9rZXlzLnB1c2goe3RpbWU6IHQsIG1hdDogbWF0cml4LmZsYXR0ZW4oKX0pXG5cblx0XHRcdFx0a2V5cy5wdXNoKHtcblx0XHRcdFx0XHR0aW1lOiB0LFxuXHRcdFx0XHRcdHBvczogW21hdHJpeC5uMTQsIG1hdHJpeC5uMjQsIG1hdHJpeC5uMzRdLFxuXHRcdFx0XHRcdHJvdHE6IFswLCAwLCAwLCAxXSxcblx0XHRcdFx0XHRzY2w6IFsxLDEsMV1cblx0XHRcdFx0fSk7XG5cblx0XHRcdH1cblxuXHRcdFx0bm9kZS5rZXlzID0ga2V5cztcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9JbWFnZSgpIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMuaW5pdF9mcm9tID0gXCJcIjtcblxuXHR9O1xuXG5cdF9JbWFnZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlTmFtZSA9PSAnaW5pdF9mcm9tJyApIHtcblxuXHRcdFx0XHR0aGlzLmluaXRfZnJvbSA9IGNoaWxkLnRleHRDb250ZW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIENvbnRyb2xsZXIoKSB7XG5cblx0XHR0aGlzLmlkID0gXCJcIjtcblx0XHR0aGlzLm5hbWUgPSBcIlwiO1xuXHRcdHRoaXMudHlwZSA9IFwiXCI7XG5cdFx0dGhpcy5za2luID0gbnVsbDtcblx0XHR0aGlzLm1vcnBoID0gbnVsbDtcblxuXHR9O1xuXG5cdENvbnRyb2xsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcblx0XHR0aGlzLnR5cGUgPSBcIm5vbmVcIjtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3NraW4nOlxuXG5cdFx0XHRcdFx0dGhpcy5za2luID0gKG5ldyBTa2luKCkpLnBhcnNlKGNoaWxkKTtcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtb3JwaCc6XG5cblx0XHRcdFx0XHR0aGlzLm1vcnBoID0gKG5ldyBNb3JwaCgpKS5wYXJzZShjaGlsZCk7XG5cdFx0XHRcdFx0dGhpcy50eXBlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gTW9ycGgoKSB7XG5cblx0XHR0aGlzLm1ldGhvZCA9IG51bGw7XG5cdFx0dGhpcy5zb3VyY2UgPSBudWxsO1xuXHRcdHRoaXMudGFyZ2V0cyA9IG51bGw7XG5cdFx0dGhpcy53ZWlnaHRzID0gbnVsbDtcblxuXHR9O1xuXG5cdE1vcnBoLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0dmFyIHNvdXJjZXMgPSB7fTtcblx0XHR2YXIgaW5wdXRzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHR0aGlzLm1ldGhvZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbWV0aG9kJyApO1xuXHRcdHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkucmVwbGFjZSggL14jLywgJycgKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblxuXHRcdFx0XHRcdHZhciBzb3VyY2UgPSAoIG5ldyBTb3VyY2UoKSApLnBhcnNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdHNvdXJjZXNbIHNvdXJjZS5pZCBdID0gc291cmNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RhcmdldHMnOlxuXG5cdFx0XHRcdFx0aW5wdXRzID0gdGhpcy5wYXJzZUlucHV0cyggY2hpbGQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkLm5vZGVOYW1lICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGlucHV0ID0gaW5wdXRzWyBpIF07XG5cdFx0XHR2YXIgc291cmNlID0gc291cmNlc1sgaW5wdXQuc291cmNlIF07XG5cblx0XHRcdHN3aXRjaCAoIGlucHV0LnNlbWFudGljICkge1xuXG5cdFx0XHRcdGNhc2UgJ01PUlBIX1RBUkdFVCc6XG5cblx0XHRcdFx0XHR0aGlzLnRhcmdldHMgPSBzb3VyY2UucmVhZCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01PUlBIX1dFSUdIVCc6XG5cblx0XHRcdFx0XHR0aGlzLndlaWdodHMgPSBzb3VyY2UucmVhZCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdE1vcnBoLnByb3RvdHlwZS5wYXJzZUlucHV0cyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuXHRcdHZhciBpbnB1dHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2lucHV0JzpcblxuXHRcdFx0XHRcdGlucHV0cy5wdXNoKCAobmV3IElucHV0KCkpLnBhcnNlKGNoaWxkKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlucHV0cztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFNraW4oKSB7XG5cblx0XHR0aGlzLnNvdXJjZSA9IFwiXCI7XG5cdFx0dGhpcy5iaW5kU2hhcGVNYXRyaXggPSBudWxsO1xuXHRcdHRoaXMuaW52QmluZE1hdHJpY2VzID0gW107XG5cdFx0dGhpcy5qb2ludHMgPSBbXTtcblx0XHR0aGlzLndlaWdodHMgPSBbXTtcblxuXHR9O1xuXG5cdFNraW4ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHR2YXIgc291cmNlcyA9IHt9O1xuXHRcdHZhciBqb2ludHMsIHdlaWdodHM7XG5cblx0XHR0aGlzLnNvdXJjZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApLnJlcGxhY2UoIC9eIy8sICcnICk7XG5cdFx0dGhpcy5pbnZCaW5kTWF0cmljZXMgPSBbXTtcblx0XHR0aGlzLmpvaW50cyA9IFtdO1xuXHRcdHRoaXMud2VpZ2h0cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2JpbmRfc2hhcGVfbWF0cml4JzpcblxuXHRcdFx0XHRcdHZhciBmID0gX2Zsb2F0cyhjaGlsZC50ZXh0Q29udGVudCk7XG5cdFx0XHRcdFx0dGhpcy5iaW5kU2hhcGVNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdFx0XHRcdHRoaXMuYmluZFNoYXBlTWF0cml4LnNldChcblx0XHRcdFx0XHRcdGZbMF0sIGZbMV0sIGZbMl0sIGZbM10sXG5cdFx0XHRcdFx0XHRmWzRdLCBmWzVdLCBmWzZdLCBmWzddLFxuXHRcdFx0XHRcdFx0Zls4XSwgZls5XSwgZlsxMF0sIGZbMTFdLFxuXHRcdFx0XHRcdFx0ZlsxMl0sIGZbMTNdLCBmWzE0XSwgZlsxNV1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblxuXHRcdFx0XHRcdHZhciBzcmMgPSBuZXcgU291cmNlKCkucGFyc2UoY2hpbGQpO1xuXHRcdFx0XHRcdHNvdXJjZXNbIHNyYy5pZCBdID0gc3JjO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2pvaW50cyc6XG5cblx0XHRcdFx0XHRqb2ludHMgPSBjaGlsZDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2ZXJ0ZXhfd2VpZ2h0cyc6XG5cblx0XHRcdFx0XHR3ZWlnaHRzID0gY2hpbGQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5wYXJzZUpvaW50cyggam9pbnRzLCBzb3VyY2VzICk7XG5cdFx0dGhpcy5wYXJzZVdlaWdodHMoIHdlaWdodHMsIHNvdXJjZXMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0U2tpbi5wcm90b3R5cGUucGFyc2VKb2ludHMgPSBmdW5jdGlvbiAoIGVsZW1lbnQsIHNvdXJjZXMgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdFx0XHR2YXIgaW5wdXQgPSAoIG5ldyBJbnB1dCgpICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnB1dC5zZW1hbnRpYyA9PSAnSk9JTlQnICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmpvaW50cyA9IHNvdXJjZS5yZWFkKCk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBpbnB1dC5zZW1hbnRpYyA9PSAnSU5WX0JJTkRfTUFUUklYJyApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5pbnZCaW5kTWF0cmljZXMgPSBzb3VyY2UucmVhZCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdFNraW4ucHJvdG90eXBlLnBhcnNlV2VpZ2h0cyA9IGZ1bmN0aW9uICggZWxlbWVudCwgc291cmNlcyApIHtcblxuXHRcdHZhciB2LCB2Y291bnQsIGlucHV0cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXG5cdFx0XHRcdFx0aW5wdXRzLnB1c2goICggbmV3IElucHV0KCkgKS5wYXJzZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3YnOlxuXG5cdFx0XHRcdFx0diA9IF9pbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Zjb3VudCc6XG5cblx0XHRcdFx0XHR2Y291bnQgPSBfaW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgaW5kZXggPSAwO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmNvdW50Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG51bUJvbmVzID0gdmNvdW50W2ldO1xuXHRcdFx0dmFyIHZlcnRleF93ZWlnaHRzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG51bUJvbmVzOyBqKysgKSB7XG5cblx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IHt9O1xuXG5cdFx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5wdXQgPSBpbnB1dHNbIGsgXTtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2WyBpbmRleCArIGlucHV0Lm9mZnNldCBdO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0pPSU5UJzpcblxuXHRcdFx0XHRcdFx0XHRpbmZsdWVuY2Uuam9pbnQgPSB2YWx1ZTsvL3RoaXMuam9pbnRzW3ZhbHVlXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1dFSUdIVCc6XG5cblx0XHRcdFx0XHRcdFx0aW5mbHVlbmNlLndlaWdodCA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdLmRhdGFbIHZhbHVlIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmVydGV4X3dlaWdodHMucHVzaCggaW5mbHVlbmNlICk7XG5cdFx0XHRcdGluZGV4ICs9IGlucHV0cy5sZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHZlcnRleF93ZWlnaHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXhfd2VpZ2h0c1sgaiBdLmluZGV4ID0gaTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLndlaWdodHMucHVzaCggdmVydGV4X3dlaWdodHMgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFZpc3VhbFNjZW5lICgpIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMubmFtZSA9IFwiXCI7XG5cdFx0dGhpcy5ub2RlcyA9IFtdO1xuXHRcdHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHR9O1xuXG5cdFZpc3VhbFNjZW5lLnByb3RvdHlwZS5nZXRDaGlsZEJ5SWQgPSBmdW5jdGlvbiggaWQsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZXNbIGkgXS5nZXRDaGlsZEJ5SWQoIGlkLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0aWYgKCBub2RlICkge1xuXG5cdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9O1xuXG5cdFZpc3VhbFNjZW5lLnByb3RvdHlwZS5nZXRDaGlsZEJ5U2lkID0gZnVuY3Rpb24oIHNpZCwgcmVjdXJzaXZlICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBub2RlID0gdGhpcy5ub2Rlc1sgaSBdLmdldENoaWxkQnlTaWQoIHNpZCwgcmVjdXJzaXZlICk7XG5cblx0XHRcdGlmICggbm9kZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fTtcblxuXHRWaXN1YWxTY2VuZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdHRoaXMubmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblx0XHR0aGlzLm5vZGVzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdub2RlJzpcblxuXHRcdFx0XHRcdHRoaXMubm9kZXMucHVzaCggKCBuZXcgTm9kZSgpICkucGFyc2UoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIE5vZGUoKSB7XG5cblx0XHR0aGlzLmlkID0gXCJcIjtcblx0XHR0aGlzLm5hbWUgPSBcIlwiO1xuXHRcdHRoaXMuc2lkID0gXCJcIjtcblx0XHR0aGlzLm5vZGVzID0gW107XG5cdFx0dGhpcy5jb250cm9sbGVycyA9IFtdO1xuXHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuXHRcdHRoaXMuZ2VvbWV0cmllcyA9IFtdO1xuXHRcdHRoaXMuY2hhbm5lbHMgPSBbXTtcblx0XHR0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0fTtcblxuXHROb2RlLnByb3RvdHlwZS5nZXRDaGFubmVsRm9yVHJhbnNmb3JtID0gZnVuY3Rpb24oIHRyYW5zZm9ybVNpZCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG5cdFx0XHR2YXIgcGFydHMgPSBjaGFubmVsLnRhcmdldC5zcGxpdCgnLycpO1xuXHRcdFx0dmFyIGlkID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdHZhciBzaWQgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0dmFyIGRvdFN5bnRheCA9IChzaWQuaW5kZXhPZihcIi5cIikgPj0gMCk7XG5cdFx0XHR2YXIgYXJyU3ludGF4ID0gKHNpZC5pbmRleE9mKFwiKFwiKSA+PSAwKTtcblx0XHRcdHZhciBhcnJJbmRpY2VzO1xuXHRcdFx0dmFyIG1lbWJlcjtcblxuXHRcdFx0aWYgKCBkb3RTeW50YXggKSB7XG5cblx0XHRcdFx0cGFydHMgPSBzaWQuc3BsaXQoXCIuXCIpO1xuXHRcdFx0XHRzaWQgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0XHRtZW1iZXIgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBhcnJTeW50YXggKSB7XG5cblx0XHRcdFx0YXJySW5kaWNlcyA9IHNpZC5zcGxpdChcIihcIik7XG5cdFx0XHRcdHNpZCA9IGFyckluZGljZXMuc2hpZnQoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBhcnJJbmRpY2VzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFyckluZGljZXNbIGogXSA9IHBhcnNlSW50KCBhcnJJbmRpY2VzWyBqIF0ucmVwbGFjZSggL1xcKS8sICcnICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzaWQgPT0gdHJhbnNmb3JtU2lkICkge1xuXG5cdFx0XHRcdGNoYW5uZWwuaW5mbyA9IHsgc2lkOiBzaWQsIGRvdFN5bnRheDogZG90U3ludGF4LCBhcnJTeW50YXg6IGFyclN5bnRheCwgYXJySW5kaWNlczogYXJySW5kaWNlcyB9O1xuXHRcdFx0XHRyZXR1cm4gY2hhbm5lbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fTtcblxuXHROb2RlLnByb3RvdHlwZS5nZXRDaGlsZEJ5SWQgPSBmdW5jdGlvbiAoIGlkLCByZWN1cnNpdmUgKSB7XG5cblx0XHRpZiAoIHRoaXMuaWQgPT0gaWQgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBuID0gdGhpcy5ub2Rlc1sgaSBdLmdldENoaWxkQnlJZCggaWQsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHRcdGlmICggbiApIHtcblxuXHRcdFx0XHRcdHJldHVybiBuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fTtcblxuXHROb2RlLnByb3RvdHlwZS5nZXRDaGlsZEJ5U2lkID0gZnVuY3Rpb24gKCBzaWQsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGlmICggdGhpcy5zaWQgPT0gc2lkICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggcmVjdXJzaXZlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbiA9IHRoaXMubm9kZXNbIGkgXS5nZXRDaGlsZEJ5U2lkKCBzaWQsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHRcdGlmICggbiApIHtcblxuXHRcdFx0XHRcdHJldHVybiBuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH07XG5cblx0Tm9kZS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtQnlTaWQgPSBmdW5jdGlvbiAoIHNpZCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggdGhpcy50cmFuc2Zvcm1zWyBpIF0uc2lkID09IHNpZCApIHJldHVybiB0aGlzLnRyYW5zZm9ybXNbIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH07XG5cblx0Tm9kZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdHZhciB1cmw7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0dGhpcy5zaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc2lkJyk7XG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcblx0XHR0aGlzLnR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXG5cdFx0dGhpcy50eXBlID0gdGhpcy50eXBlID09ICdKT0lOVCcgPyB0aGlzLnR5cGUgOiAnTk9ERSc7XG5cblx0XHR0aGlzLm5vZGVzID0gW107XG5cdFx0dGhpcy50cmFuc2Zvcm1zID0gW107XG5cdFx0dGhpcy5nZW9tZXRyaWVzID0gW107XG5cdFx0dGhpcy5jb250cm9sbGVycyA9IFtdO1xuXHRcdHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ25vZGUnOlxuXG5cdFx0XHRcdFx0dGhpcy5ub2Rlcy5wdXNoKCAoIG5ldyBOb2RlKCkgKS5wYXJzZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2NhbWVyYSc6XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpbnN0YW5jZV9jb250cm9sbGVyJzpcblxuXHRcdFx0XHRcdHRoaXMuY29udHJvbGxlcnMucHVzaCggKCBuZXcgSW5zdGFuY2VDb250cm9sbGVyKCkgKS5wYXJzZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2dlb21ldHJ5JzpcblxuXHRcdFx0XHRcdHRoaXMuZ2VvbWV0cmllcy5wdXNoKCAoIG5ldyBJbnN0YW5jZUdlb21ldHJ5KCkgKS5wYXJzZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2xpZ2h0JzpcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2luc3RhbmNlX25vZGUnOlxuXG5cdFx0XHRcdFx0dXJsID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAndXJsJyApLnJlcGxhY2UoIC9eIy8sICcnICk7XG5cdFx0XHRcdFx0dmFyIGlOb2RlID0gZ2V0TGlicmFyeU5vZGUoIHVybCApO1xuXG5cdFx0XHRcdFx0aWYgKCBpTm9kZSApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5ub2Rlcy5wdXNoKCAoIG5ldyBOb2RlKCkgKS5wYXJzZSggaU5vZGUgKSkgO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRjYXNlICdsb29rYXQnOlxuXHRcdFx0XHRjYXNlICdza2V3JzpcblxuXHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5wdXNoKCAoIG5ldyBUcmFuc2Zvcm0oKSApLnBhcnNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRjb25zb2xlLmxvZyggY2hpbGQubm9kZU5hbWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jaGFubmVscyA9IGdldENoYW5uZWxzRm9yTm9kZSggdGhpcyApO1xuXHRcdGJha2VBbmltYXRpb25zKCB0aGlzICk7XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHROb2RlLnByb3RvdHlwZS51cGRhdGVNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLm1hdHJpeC5pZGVudGl0eSgpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2Zvcm1zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXgubXVsdGlwbHkoIHRoaXMubWF0cml4LCB0aGlzLnRyYW5zZm9ybXNbIGkgXS5tYXRyaXggKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFRyYW5zZm9ybSAoKSB7XG5cblx0XHR0aGlzLnNpZCA9IFwiXCI7XG5cdFx0dGhpcy50eXBlID0gXCJcIjtcblx0XHR0aGlzLmRhdGEgPSBbXTtcblx0XHR0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0fTtcblxuXHRUcmFuc2Zvcm0ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5zaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3NpZCcgKTtcblx0XHR0aGlzLnR5cGUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXHRcdHRoaXMuZGF0YSA9IF9mbG9hdHMoIGVsZW1lbnQudGV4dENvbnRlbnQgKTtcblxuXHRcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdFRyYW5zZm9ybS5wcm90b3R5cGUudXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGFuZ2xlID0gMDtcblxuXHRcdHRoaXMubWF0cml4LmlkZW50aXR5KCk7XG5cblx0XHRzd2l0Y2ggKCB0aGlzLnR5cGUgKSB7XG5cblx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cblx0XHRcdFx0dGhpcy5tYXRyaXguc2V0KFxuXHRcdFx0XHRcdHRoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl0sIHRoaXMuZGF0YVszXSxcblx0XHRcdFx0XHR0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdLCB0aGlzLmRhdGFbN10sXG5cdFx0XHRcdFx0dGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF0sIHRoaXMuZGF0YVsxMV0sXG5cdFx0XHRcdFx0dGhpcy5kYXRhWzEyXSwgdGhpcy5kYXRhWzEzXSwgdGhpcy5kYXRhWzE0XSwgdGhpcy5kYXRhWzE1XVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXG5cdFx0XHRcdHRoaXMubWF0cml4LnNldFRyYW5zbGF0aW9uKHRoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl0pO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAncm90YXRlJzpcblxuXHRcdFx0XHRhbmdsZSA9IHRoaXMuZGF0YVszXSAqIChNYXRoLlBJIC8gMTgwLjApO1xuXHRcdFx0XHR0aGlzLm1hdHJpeC5zZXRSb3RhdGlvbkF4aXMobmV3IFRIUkVFLlZlY3RvcjModGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXSksIGFuZ2xlKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3NjYWxlJzpcblxuXHRcdFx0XHR0aGlzLm1hdHJpeC5zZXRTY2FsZSh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubWF0cml4O1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gSW5zdGFuY2VDb250cm9sbGVyKCkge1xuXG5cdFx0dGhpcy51cmwgPSBcIlwiO1xuXHRcdHRoaXMuc2tlbGV0b24gPSBbXTtcblx0XHR0aGlzLmluc3RhbmNlX21hdGVyaWFsID0gW107XG5cblx0fTtcblxuXHRJbnN0YW5jZUNvbnRyb2xsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy51cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndXJsJykucmVwbGFjZSgvXiMvLCAnJyk7XG5cdFx0dGhpcy5za2VsZXRvbiA9IFtdO1xuXHRcdHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSAhPSAxKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc2tlbGV0b24nOlxuXG5cdFx0XHRcdFx0dGhpcy5za2VsZXRvbi5wdXNoKCBjaGlsZC50ZXh0Q29udGVudC5yZXBsYWNlKC9eIy8sICcnKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2JpbmRfbWF0ZXJpYWwnOlxuXG5cdFx0XHRcdFx0dmFyIGluc3RhbmNlcyA9IENPTExBREEuZXZhbHVhdGUoXCIuLy9kYWU6aW5zdGFuY2VfbWF0ZXJpYWxcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGlsZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfbnNSZXNvbHZlcixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRudWxsKTtcblxuXHRcdFx0XHRcdGlmICggaW5zdGFuY2VzICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXMuaXRlcmF0ZU5leHQoKTtcblxuXHRcdFx0XHRcdFx0d2hpbGUgKCBpbnN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLmluc3RhbmNlX21hdGVyaWFsLnB1c2goKG5ldyBJbnN0YW5jZU1hdGVyaWFsKCkpLnBhcnNlKGluc3RhbmNlKSk7XG5cdFx0XHRcdFx0XHRcdGluc3RhbmNlID0gaW5zdGFuY2VzLml0ZXJhdGVOZXh0KCk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBJbnN0YW5jZU1hdGVyaWFsICgpIHtcblxuXHRcdHRoaXMuc3ltYm9sID0gXCJcIjtcblx0XHR0aGlzLnRhcmdldCA9IFwiXCI7XG5cblx0fTtcblxuXHRJbnN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuc3ltYm9sID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N5bWJvbCcpO1xuXHRcdHRoaXMudGFyZ2V0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpLnJlcGxhY2UoL14jLywgJycpO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gSW5zdGFuY2VHZW9tZXRyeSgpIHtcblxuXHRcdHRoaXMudXJsID0gXCJcIjtcblx0XHR0aGlzLmluc3RhbmNlX21hdGVyaWFsID0gW107XG5cblx0fTtcblxuXHRJbnN0YW5jZUdlb21ldHJ5LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMudXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VybCcpLnJlcGxhY2UoL14jLywgJycpO1xuXHRcdHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVOYW1lID09ICdiaW5kX21hdGVyaWFsJyApIHtcblxuXHRcdFx0XHR2YXIgaW5zdGFuY2VzID0gQ09MTEFEQS5ldmFsdWF0ZShcIi4vL2RhZTppbnN0YW5jZV9tYXRlcmlhbFwiLFxuXHRcdFx0XHRcdGNoaWxkLFxuXHRcdFx0XHRcdF9uc1Jlc29sdmVyLFxuXHRcdFx0XHRcdFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFLFxuXHRcdFx0XHRcdG51bGwpO1xuXG5cdFx0XHRcdGlmICggaW5zdGFuY2VzICkge1xuXG5cdFx0XHRcdFx0dmFyIGluc3RhbmNlID0gaW5zdGFuY2VzLml0ZXJhdGVOZXh0KCk7XG5cblx0XHRcdFx0XHR3aGlsZSAoIGluc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmluc3RhbmNlX21hdGVyaWFsLnB1c2goIChuZXcgSW5zdGFuY2VNYXRlcmlhbCgpKS5wYXJzZShpbnN0YW5jZSkgKTtcblx0XHRcdFx0XHRcdGluc3RhbmNlID0gaW5zdGFuY2VzLml0ZXJhdGVOZXh0KCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEdlb21ldHJ5KCkge1xuXG5cdFx0dGhpcy5pZCA9IFwiXCI7XG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcblxuXHR9O1xuXG5cdEdlb21ldHJ5LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnbWVzaCc6XG5cblx0XHRcdFx0XHR0aGlzLm1lc2ggPSAobmV3IE1lc2godGhpcykpLnBhcnNlKGNoaWxkKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdleHRyYSc6XG5cblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggY2hpbGQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gTWVzaCggZ2VvbWV0cnkgKSB7XG5cblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkuaWQ7XG5cdFx0dGhpcy5wcmltaXRpdmVzID0gW107XG5cdFx0dGhpcy52ZXJ0aWNlcyA9IG51bGw7XG5cdFx0dGhpcy5nZW9tZXRyeTNqcyA9IG51bGw7XG5cblx0fTtcblxuXHRNZXNoLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5wcmltaXRpdmVzID0gW107XG5cblx0XHR2YXIgaSwgajtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3NvdXJjZSc6XG5cblx0XHRcdFx0XHRfc291cmNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3ZlcnRpY2VzJzpcblxuXHRcdFx0XHRcdHRoaXMudmVydGljZXMgPSAoIG5ldyBWZXJ0aWNlcygpICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndHJpYW5nbGVzJzpcblxuXHRcdFx0XHRcdHRoaXMucHJpbWl0aXZlcy5wdXNoKCAoIG5ldyBUcmlhbmdsZXMoKS5wYXJzZSggY2hpbGQgKSApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncG9seWdvbnMnOlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAncG9seWdvbiBob2xlcyBub3QgeWV0IHN1cHBvcnRlZCEnICk7XG5cblx0XHRcdFx0Y2FzZSAncG9seWxpc3QnOlxuXG5cdFx0XHRcdFx0dGhpcy5wcmltaXRpdmVzLnB1c2goICggbmV3IFBvbHlsaXN0KCkucGFyc2UoIGNoaWxkICkgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciB2ZXJ0ZXhfc3RvcmUgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGdldF92ZXJ0ZXggKCB2LCBpbmRleCApICB7XG5cblx0XHRcdHZhciBoYXNoID0gX2hhc2hfdmVjdG9yMyggdi5wb3NpdGlvbiApO1xuXG5cdFx0XHRpZiAoIHZlcnRleF9zdG9yZVsgaGFzaCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmVydGV4X3N0b3JlWyBoYXNoIF0gPSB7IHY6IHYsIGluZGV4OiBpbmRleCB9O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2ZXJ0ZXhfc3RvcmVbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZ2VvbWV0cnkzanMgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuXHRcdHZhciB2ZXJ0ZXhEYXRhID0gc291cmNlc1sgdGhpcy52ZXJ0aWNlcy5pbnB1dFsnUE9TSVRJT04nXS5zb3VyY2UgXS5kYXRhO1xuXG5cdFx0Zm9yICggaSA9IDAsIGogPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGg7IGkgKz0gMywgaiArKyApIHtcblxuXHRcdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydGV4RGF0YVsgaSBdLCB2ZXJ0ZXhEYXRhWyBpICsgMSBdLCB2ZXJ0ZXhEYXRhWyBpICsgMiBdICkgKTtcblx0XHRcdGdldF92ZXJ0ZXgoIHYsIGogKTtcblx0XHRcdHRoaXMuZ2VvbWV0cnkzanMudmVydGljZXMucHVzaCggdiApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLnByaW1pdGl2ZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcHJpbWl0aXZlID0gdGhpcy5wcmltaXRpdmVzWyBpIF07XG5cdFx0XHRwcmltaXRpdmUuc2V0VmVydGljZXMoIHRoaXMudmVydGljZXMgKTtcblx0XHRcdHRoaXMuaGFuZGxlUHJpbWl0aXZlKCBwcmltaXRpdmUsIHRoaXMuZ2VvbWV0cnkzanMsIHZlcnRleF9zdG9yZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZW9tZXRyeTNqcy5jb21wdXRlQ2VudHJvaWRzKCk7XG5cdFx0dGhpcy5nZW9tZXRyeTNqcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHR0aGlzLmdlb21ldHJ5M2pzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cdFx0dGhpcy5nZW9tZXRyeTNqcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0TWVzaC5wcm90b3R5cGUuaGFuZGxlUHJpbWl0aXZlID0gZnVuY3Rpb24oIHByaW1pdGl2ZSwgZ2VvbSwgdmVydGV4X3N0b3JlICkge1xuXG5cdFx0dmFyIGkgPSAwLCBqLCBrLCBwID0gcHJpbWl0aXZlLnAsIGlucHV0cyA9IHByaW1pdGl2ZS5pbnB1dHM7XG5cdFx0dmFyIGlucHV0LCBpbmRleCwgaWR4MzI7XG5cdFx0dmFyIHNvdXJjZSwgbnVtUGFyYW1zO1xuXHRcdHZhciB2Y0luZGV4ID0gMCwgdmNvdW50ID0gMztcblx0XHR2YXIgdGV4dHVyZV9zZXRzID0gW107XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8IGlucHV0cy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdGlucHV0ID0gaW5wdXRzWyBqIF07XG5cblx0XHRcdHN3aXRjaCAoIGlucHV0LnNlbWFudGljICkge1xuXG5cdFx0XHRcdGNhc2UgJ1RFWENPT1JEJzpcblx0XHRcdFx0XHR0ZXh0dXJlX3NldHMucHVzaCggaW5wdXQuc2V0ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHdoaWxlICggaSA8IHAubGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgdnMgPSBbXTtcblx0XHRcdHZhciBucyA9IFtdO1xuXHRcdFx0dmFyIHRzID0ge307XG5cdFx0XHR2YXIgY3MgPSBbXTtcblxuXHRcdFx0aWYgKCBwcmltaXRpdmUudmNvdW50ICkge1xuXG5cdFx0XHRcdHZjb3VudCA9IHByaW1pdGl2ZS52Y291bnRbIHZjSW5kZXggKysgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8IHZjb3VudDsgaiArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRpbnB1dCA9IGlucHV0c1sgayBdO1xuXHRcdFx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xuXG5cdFx0XHRcdFx0aW5kZXggPSBwWyBpICsgKCBqICogaW5wdXRzLmxlbmd0aCApICsgaW5wdXQub2Zmc2V0IF07XG5cdFx0XHRcdFx0bnVtUGFyYW1zID0gc291cmNlLmFjY2Vzc29yLnBhcmFtcy5sZW5ndGg7XG5cdFx0XHRcdFx0aWR4MzIgPSBpbmRleCAqIG51bVBhcmFtcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGlucHV0LnNlbWFudGljICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdWRVJURVgnOlxuXG5cdFx0XHRcdFx0XHRcdHZhciBoYXNoID0gX2hhc2hfdmVjdG9yMyggZ2VvbS52ZXJ0aWNlc1sgaW5kZXggXS5wb3NpdGlvbiApO1xuXHRcdFx0XHRcdFx0XHR2cy5wdXNoKCB2ZXJ0ZXhfc3RvcmVbIGhhc2ggXS5pbmRleCApO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdOT1JNQUwnOlxuXG5cdFx0XHRcdFx0XHRcdG5zLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBzb3VyY2UuZGF0YVsgaWR4MzIgXSwgc291cmNlLmRhdGFbIGlkeDMyICsgMSBdLCBzb3VyY2UuZGF0YVsgaWR4MzIgKyAyIF0gKSApO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdURVhDT09SRCc6XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0c1sgaW5wdXQuc2V0IF0gPT09IHVuZGVmaW5lZCApIHRzWyBpbnB1dC5zZXQgXSA9IFtdO1xuXHRcdFx0XHRcdFx0XHR0c1sgaW5wdXQuc2V0IF0ucHVzaCggbmV3IFRIUkVFLlVWKCBzb3VyY2UuZGF0YVsgaWR4MzIgXSwgc291cmNlLmRhdGFbIGlkeDMyICsgMSBdICkgKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ09MT1InOlxuXG5cdFx0XHRcdFx0XHRcdGNzLnB1c2goIG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQiggc291cmNlLmRhdGFbIGlkeDMyIF0sIHNvdXJjZS5kYXRhWyBpZHgzMiArIDEgXSwgc291cmNlLmRhdGFbIGlkeDMyICsgMiBdICkgKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0dmFyIGZhY2UsIHV2O1xuXG5cdFx0XHRpZiAoIHZjb3VudCA9PSAzICkge1xuXG5cdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIHZzWzBdLCB2c1sxXSwgdnNbMl0sIFsgbnNbMF0sIG5zWzFdLCBuc1syXSBdLCBjcy5sZW5ndGggPyBjcyA6IG5ldyBUSFJFRS5Db2xvcigpICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHZjb3VudCA9PSA0ICkge1xuXG5cdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTQoIHZzWzBdLCB2c1sxXSwgdnNbMl0sIHZzWzNdLCBbIG5zWzBdLCBuc1sxXSwgbnNbMl0sIG5zWzNdIF0sIGNzLmxlbmd0aCA/IGNzIDogbmV3IFRIUkVFLkNvbG9yKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYWNlLmRhZU1hdGVyaWFsID0gcHJpbWl0aXZlLm1hdGVyaWFsO1xuXHRcdFx0Z2VvbS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cblx0XHRcdGZvciAoIGsgPSAwOyBrIDwgdGV4dHVyZV9zZXRzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHR1diA9IHRzWyB0ZXh0dXJlX3NldHNbIGsgXSBdO1xuXHRcdFx0XHRnZW9tLmZhY2VWZXJ0ZXhVdnNbIGsgXS5wdXNoKCBbIHV2WzBdLCB1dlsxXSwgdXZbMl0gXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gaW5wdXRzLmxlbmd0aCAqIHZjb3VudDtcblxuXHRcdH1cblxuXHR9O1xuXG5cblx0ZnVuY3Rpb24gUG9seWxpc3QgKCkge1xuXHR9O1xuXG5cdFBvbHlsaXN0LnByb3RvdHlwZSA9IG5ldyBUcmlhbmdsZXMoKTtcblx0UG9seWxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWxpc3Q7XG5cblx0ZnVuY3Rpb24gVHJpYW5nbGVzKCBmbGlwX3V2ICkge1xuXG5cdFx0dGhpcy5tYXRlcmlhbCA9IFwiXCI7XG5cdFx0dGhpcy5jb3VudCA9IDA7XG5cdFx0dGhpcy5pbnB1dHMgPSBbXTtcblx0XHR0aGlzLnZjb3VudCA9IG51bGw7XG5cdFx0dGhpcy5wID0gW107XG5cdFx0dGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdH07XG5cblx0VHJpYW5nbGVzLnByb3RvdHlwZS5zZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uICggdmVydGljZXMgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggdGhpcy5pbnB1dHNbIGkgXS5zb3VyY2UgPT0gdmVydGljZXMuaWQgKSB7XG5cblx0XHRcdFx0dGhpcy5pbnB1dHNbIGkgXS5zb3VyY2UgPSB2ZXJ0aWNlcy5pbnB1dFsgJ1BPU0lUSU9OJyBdLnNvdXJjZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0VHJpYW5nbGVzLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaW5wdXRzID0gW107XG5cdFx0dGhpcy5tYXRlcmlhbCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbWF0ZXJpYWwnICk7XG5cdFx0dGhpcy5jb3VudCA9IF9hdHRyX2FzX2ludCggZWxlbWVudCwgJ2NvdW50JywgMCApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2lucHV0JzpcblxuXHRcdFx0XHRcdHRoaXMuaW5wdXRzLnB1c2goICggbmV3IElucHV0KCkgKS5wYXJzZSggZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0gKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Zjb3VudCc6XG5cblx0XHRcdFx0XHR0aGlzLnZjb3VudCA9IF9pbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3AnOlxuXG5cdFx0XHRcdFx0dGhpcy5wID0gX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBBY2Nlc3NvcigpIHtcblxuXHRcdHRoaXMuc291cmNlID0gXCJcIjtcblx0XHR0aGlzLmNvdW50ID0gMDtcblx0XHR0aGlzLnN0cmlkZSA9IDA7XG5cdFx0dGhpcy5wYXJhbXMgPSBbXTtcblxuXHR9O1xuXG5cdEFjY2Vzc29yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMucGFyYW1zID0gW107XG5cdFx0dGhpcy5zb3VyY2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKTtcblx0XHR0aGlzLmNvdW50ID0gX2F0dHJfYXNfaW50KCBlbGVtZW50LCAnY291bnQnLCAwICk7XG5cdFx0dGhpcy5zdHJpZGUgPSBfYXR0cl9hc19pbnQoIGVsZW1lbnQsICdzdHJpZGUnLCAwICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlTmFtZSA9PSAncGFyYW0nICkge1xuXG5cdFx0XHRcdHZhciBwYXJhbSA9IHt9O1xuXHRcdFx0XHRwYXJhbVsgJ25hbWUnIF0gPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXHRcdFx0XHRwYXJhbVsgJ3R5cGUnIF0gPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHR0aGlzLnBhcmFtcy5wdXNoKCBwYXJhbSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFZlcnRpY2VzKCkge1xuXG5cdFx0dGhpcy5pbnB1dCA9IHt9O1xuXG5cdH07XG5cblx0VmVydGljZXMucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBlbGVtZW50LmNoaWxkTm9kZXNbaV0ubm9kZU5hbWUgPT0gJ2lucHV0JyApIHtcblxuXHRcdFx0XHR2YXIgaW5wdXQgPSAoIG5ldyBJbnB1dCgpICkucGFyc2UoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdICk7XG5cdFx0XHRcdHRoaXMuaW5wdXRbIGlucHV0LnNlbWFudGljIF0gPSBpbnB1dDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBJbnB1dCAoKSB7XG5cblx0XHR0aGlzLnNlbWFudGljID0gXCJcIjtcblx0XHR0aGlzLm9mZnNldCA9IDA7XG5cdFx0dGhpcy5zb3VyY2UgPSBcIlwiO1xuXHRcdHRoaXMuc2V0ID0gMDtcblxuXHR9O1xuXG5cdElucHV0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuc2VtYW50aWMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc2VtYW50aWMnKTtcblx0XHR0aGlzLnNvdXJjZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzb3VyY2UnKS5yZXBsYWNlKC9eIy8sICcnKTtcblx0XHR0aGlzLnNldCA9IF9hdHRyX2FzX2ludChlbGVtZW50LCAnc2V0JywgLTEpO1xuXHRcdHRoaXMub2Zmc2V0ID0gX2F0dHJfYXNfaW50KGVsZW1lbnQsICdvZmZzZXQnLCAwKTtcblxuXHRcdGlmICggdGhpcy5zZW1hbnRpYyA9PSAnVEVYQ09PUkQnICYmIHRoaXMuc2V0IDwgMCApIHtcblxuXHRcdFx0dGhpcy5zZXQgPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBTb3VyY2UgKCBpZCApIHtcblxuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLnR5cGUgPSBudWxsO1xuXG5cdH07XG5cblx0U291cmNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdib29sX2FycmF5JzpcblxuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IF9ib29scyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdmbG9hdF9hcnJheSc6XG5cblx0XHRcdFx0XHR0aGlzLmRhdGEgPSBfZmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdHRoaXMudHlwZSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2ludF9hcnJheSc6XG5cblx0XHRcdFx0XHR0aGlzLmRhdGEgPSBfaW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdJRFJFRl9hcnJheSc6XG5cdFx0XHRcdGNhc2UgJ05hbWVfYXJyYXknOlxuXG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gX3N0cmluZ3MoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0dGhpcy50eXBlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjaGlsZC5jaGlsZE5vZGVzWyBqIF0ubm9kZU5hbWUgPT0gJ2FjY2Vzc29yJyApIHtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLmFjY2Vzc29yID0gKCBuZXcgQWNjZXNzb3IoKSApLnBhcnNlKCBjaGlsZC5jaGlsZE5vZGVzWyBqIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhjaGlsZC5ub2RlTmFtZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0U291cmNlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0Ly9mb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWNjZXNzb3IucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdHZhciBwYXJhbSA9IHRoaXMuYWNjZXNzb3IucGFyYW1zWyAwIF07XG5cblx0XHRcdC8vY29uc29sZS5sb2cocGFyYW0ubmFtZSArIFwiIFwiICsgcGFyYW0udHlwZSk7XG5cblx0XHRcdHN3aXRjaCAoIHBhcmFtLnR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnSURSRUYnOlxuXHRcdFx0XHRjYXNlICdOYW1lJzogY2FzZSAnbmFtZSc6XG5cdFx0XHRcdGNhc2UgJ2Zsb2F0JzpcblxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmRhdGE7XG5cblx0XHRcdFx0Y2FzZSAnZmxvYXQ0eDQnOlxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdGhpcy5kYXRhLmxlbmd0aDsgaiArPSAxNiApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHMgPSB0aGlzLmRhdGEuc2xpY2UoIGosIGogKyAxNiApO1xuXHRcdFx0XHRcdFx0dmFyIG0gPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdFx0XHRcdFx0bS5zZXQoXG5cdFx0XHRcdFx0XHRcdHNbMF0sIHNbMV0sIHNbMl0sIHNbM10sXG5cdFx0XHRcdFx0XHRcdHNbNF0sIHNbNV0sIHNbNl0sIHNbN10sXG5cdFx0XHRcdFx0XHRcdHNbOF0sIHNbOV0sIHNbMTBdLCBzWzExXSxcblx0XHRcdFx0XHRcdFx0c1sxMl0sIHNbMTNdLCBzWzE0XSwgc1sxNV1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBtICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjogU291cmNlOiBSZWFkIGRvbnQga25vdyBob3cgdG8gcmVhZCAnICsgcGFyYW0udHlwZSArICcuJyApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHQvL31cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBNYXRlcmlhbCAoKSB7XG5cblx0XHR0aGlzLmlkID0gXCJcIjtcblx0XHR0aGlzLm5hbWUgPSBcIlwiO1xuXHRcdHRoaXMuaW5zdGFuY2VfZWZmZWN0ID0gbnVsbDtcblxuXHR9O1xuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdHRoaXMubmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0ubm9kZU5hbWUgPT0gJ2luc3RhbmNlX2VmZmVjdCcgKSB7XG5cblx0XHRcdFx0dGhpcy5pbnN0YW5jZV9lZmZlY3QgPSAoIG5ldyBJbnN0YW5jZUVmZmVjdCgpICkucGFyc2UoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIENvbG9yT3JUZXh0dXJlICgpIHtcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDAgKTtcblx0XHR0aGlzLmNvbG9yLnNldFJHQiggTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSApO1xuXHRcdHRoaXMuY29sb3IuYSA9IDEuMDtcblxuXHRcdHRoaXMudGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy50ZXhjb29yZCA9IG51bGw7XG5cblx0fTtcblxuXHRDb2xvck9yVGV4dHVyZS5wcm90b3R5cGUuaXNDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMudGV4dHVyZSA9PSBudWxsICk7XG5cblx0fTtcblxuXHRDb2xvck9yVGV4dHVyZS5wcm90b3R5cGUuaXNUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuICggdGhpcy50ZXh0dXJlICE9IG51bGwgKTtcblxuXHR9O1xuXG5cdENvbG9yT3JUZXh0dXJlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblxuXHRcdFx0XHRcdHZhciByZ2JhID0gX2Zsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDApO1xuXHRcdFx0XHRcdHRoaXMuY29sb3Iuc2V0UkdCKCByZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdICk7XG5cdFx0XHRcdFx0dGhpcy5jb2xvci5hID0gcmdiYVszXTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0ZXh0dXJlJzpcblxuXHRcdFx0XHRcdHRoaXMudGV4dHVyZSA9IGNoaWxkLmdldEF0dHJpYnV0ZSgndGV4dHVyZScpO1xuXHRcdFx0XHRcdHRoaXMudGV4Y29vcmQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3RleGNvb3JkJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBTaGFkZXIgKCB0eXBlLCBlZmZlY3QgKSB7XG5cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZWZmZWN0ID0gZWZmZWN0O1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXG5cdH07XG5cblx0U2hhZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XG5cdFx0XHRcdGNhc2UgJ2RpZmZ1c2UnOlxuXHRcdFx0XHRjYXNlICdzcGVjdWxhcic6XG5cdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcblxuXHRcdFx0XHRcdHRoaXNbIGNoaWxkLm5vZGVOYW1lIF0gPSAoIG5ldyBDb2xvck9yVGV4dHVyZSgpICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2hpbmluZXNzJzpcblx0XHRcdFx0Y2FzZSAncmVmbGVjdGl2aXR5Jzpcblx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcblxuXHRcdFx0XHRcdHZhciBmID0gZXZhbHVhdGVYUGF0aCggY2hpbGQsIFwiLi8vZGFlOmZsb2F0XCIgKTtcblxuXHRcdFx0XHRcdGlmICggZi5sZW5ndGggPiAwIClcblx0XHRcdFx0XHRcdHRoaXNbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUZsb2F0KCBmWyAwIF0udGV4dENvbnRlbnQgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuY3JlYXRlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRTaGFkZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHByb3BzID0ge307XG5cdFx0dmFyIHRyYW5zcGFyZW50ID0gKCB0aGlzWyd0cmFuc3BhcmVuY3knXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNbJ3RyYW5zcGFyZW5jeSddIDwgMS4wICk7XG5cblx0XHRmb3IgKCB2YXIgcHJvcCBpbiB0aGlzICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBwcm9wICkge1xuXG5cdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XG5cdFx0XHRcdGNhc2UgJ2RpZmZ1c2UnOlxuXHRcdFx0XHRjYXNlICdzcGVjdWxhcic6XG5cblx0XHRcdFx0XHR2YXIgY290ID0gdGhpc1twcm9wXTtcblxuXHRcdFx0XHRcdGlmICggY290IGluc3RhbmNlb2YgQ29sb3JPclRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY290LmlzVGV4dHVyZSgpICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdGhpcy5lZmZlY3Quc2FtcGxlciAmJiB0aGlzLmVmZmVjdC5zdXJmYWNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0aGlzLmVmZmVjdC5zYW1wbGVyLnNvdXJjZSA9PSB0aGlzLmVmZmVjdC5zdXJmYWNlLnNpZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGltYWdlID0gaW1hZ2VzW3RoaXMuZWZmZWN0LnN1cmZhY2UuaW5pdF9mcm9tXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpbWFnZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wc1snbWFwJ10gPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKGJhc2VVcmwgKyBpbWFnZS5pbml0X2Zyb20pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wc1snbWFwJ10ud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHNbJ21hcCddLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzWydtYXAnXS5yZXBlYXQueCA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzWydtYXAnXS5yZXBlYXQueSA9IC0xO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggcHJvcCA9PSAnZGlmZnVzZScgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwcm9wc1sgJ2NvbG9yJyBdID0gY290LmNvbG9yLmdldEhleCgpO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICF0cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHByb3BzWyBwcm9wIF0gPSBjb3QuY29sb3IuZ2V0SGV4KCk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxuXHRcdFx0XHRjYXNlICdyZWZsZWN0aXZpdHknOlxuXG5cdFx0XHRcdFx0cHJvcHNbIHByb3AgXSA9IHRoaXNbIHByb3AgXTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0cmFuc3BhcmVuY3knOlxuXG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0cHJvcHNbICd0cmFuc3BhcmVudCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRwcm9wc1sgJ29wYWNpdHknIF0gPSB0aGlzWyBwcm9wIF07XG5cdFx0XHRcdFx0XHR0cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRwcm9wc1sgJ3NoYWRpbmcnIF0gPSBwcmVmZXJyZWRTaGFkaW5nO1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCggcHJvcHMgKTtcblxuXHRcdHN3aXRjaCAoIHRoaXMudHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnY29uc3RhbnQnOlxuXHRcdFx0Y2FzZSAnbGFtYmVydCc6XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdwaG9uZyc6XG5cdFx0XHRjYXNlICdibGlubic6XG5cblx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0Lypcblx0XHRcdFx0aWYgKCAhdHJhbnNwYXJlbnQgKSB7XG5cblx0XHRcdFx0Ly9cdHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwocHJvcHMpO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ki9cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm1hdGVyaWFsO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gU3VyZmFjZSAoIGVmZmVjdCApIHtcblxuXHRcdHRoaXMuZWZmZWN0ID0gZWZmZWN0O1xuXHRcdHRoaXMuaW5pdF9mcm9tID0gbnVsbDtcblx0XHR0aGlzLmZvcm1hdCA9IG51bGw7XG5cblx0fTtcblxuXHRTdXJmYWNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2luaXRfZnJvbSc6XG5cblx0XHRcdFx0XHR0aGlzLmluaXRfZnJvbSA9IGNoaWxkLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2Zvcm1hdCc6XG5cblx0XHRcdFx0XHR0aGlzLmZvcm1hdCA9IGNoaWxkLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRjb25zb2xlLmxvZyggXCJ1bmhhbmRsZWQgU3VyZmFjZSBwcm9wOiBcIiArIGNoaWxkLm5vZGVOYW1lICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gU2FtcGxlcjJEICggZWZmZWN0ICkge1xuXG5cdFx0dGhpcy5lZmZlY3QgPSBlZmZlY3Q7XG5cdFx0dGhpcy5zb3VyY2UgPSBudWxsO1xuXHRcdHRoaXMud3JhcF9zID0gbnVsbDtcblx0XHR0aGlzLndyYXBfdCA9IG51bGw7XG5cdFx0dGhpcy5taW5maWx0ZXIgPSBudWxsO1xuXHRcdHRoaXMubWFnZmlsdGVyID0gbnVsbDtcblx0XHR0aGlzLm1pcGZpbHRlciA9IG51bGw7XG5cblx0fTtcblxuXHRTYW1wbGVyMkQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblxuXHRcdFx0XHRcdHRoaXMuc291cmNlID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWluZmlsdGVyJzpcblxuXHRcdFx0XHRcdHRoaXMubWluZmlsdGVyID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWFnZmlsdGVyJzpcblxuXHRcdFx0XHRcdHRoaXMubWFnZmlsdGVyID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWlwZmlsdGVyJzpcblxuXHRcdFx0XHRcdHRoaXMubWlwZmlsdGVyID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnd3JhcF9zJzpcblxuXHRcdFx0XHRcdHRoaXMud3JhcF9zID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnd3JhcF90JzpcblxuXHRcdFx0XHRcdHRoaXMud3JhcF90ID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcInVuaGFuZGxlZCBTYW1wbGVyMkQgcHJvcDogXCIgKyBjaGlsZC5ub2RlTmFtZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEVmZmVjdCAoKSB7XG5cblx0XHR0aGlzLmlkID0gXCJcIjtcblx0XHR0aGlzLm5hbWUgPSBcIlwiO1xuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLnN1cmZhY2UgPSBudWxsO1xuXHRcdHRoaXMuc2FtcGxlciA9IG51bGw7XG5cblx0fTtcblxuXHRFZmZlY3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5zaGFkZXIgPT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0fTtcblxuXHRFZmZlY3QucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3Byb2ZpbGVfQ09NTU9OJzpcblxuXHRcdFx0XHRcdHRoaXMucGFyc2VUZWNobmlxdWUoIHRoaXMucGFyc2VQcm9maWxlQ09NTU9OKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRFZmZlY3QucHJvdG90eXBlLnBhcnNlTmV3cGFyYW0gPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR2YXIgc2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzaWQnICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdzdXJmYWNlJzpcblxuXHRcdFx0XHRcdHRoaXMuc3VyZmFjZSA9ICggbmV3IFN1cmZhY2UoIHRoaXMgKSApLnBhcnNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdHRoaXMuc3VyZmFjZS5zaWQgPSBzaWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2FtcGxlcjJEJzpcblxuXHRcdFx0XHRcdHRoaXMuc2FtcGxlciA9ICggbmV3IFNhbXBsZXIyRCggdGhpcyApICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0dGhpcy5zYW1wbGVyLnNpZCA9IHNpZDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdleHRyYSc6XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkLm5vZGVOYW1lICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdEVmZmVjdC5wcm90b3R5cGUucGFyc2VQcm9maWxlQ09NTU9OID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dmFyIHRlY2huaXF1ZTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAncHJvZmlsZV9DT01NT04nOlxuXG5cdFx0XHRcdFx0dGhpcy5wYXJzZVByb2ZpbGVDT01NT04oIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlJzpcblxuXHRcdFx0XHRcdHRlY2huaXF1ZSA9IGNoaWxkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ25ld3BhcmFtJzpcblxuXHRcdFx0XHRcdHRoaXMucGFyc2VOZXdwYXJhbSggY2hpbGQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdleHRyYSc6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGVjaG5pcXVlO1xuXG5cdH07XG5cblx0RWZmZWN0LnByb3RvdHlwZS5wYXJzZVRlY2huaXF1ZT0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2xhbWJlcnQnOlxuXHRcdFx0XHRjYXNlICdibGlubic6XG5cdFx0XHRcdGNhc2UgJ3Bob25nJzpcblxuXHRcdFx0XHRcdHRoaXMuc2hhZGVyID0gKCBuZXcgU2hhZGVyKCBjaGlsZC5ub2RlTmFtZSwgdGhpcyApICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gSW5zdGFuY2VFZmZlY3QgKCkge1xuXG5cdFx0dGhpcy51cmwgPSBcIlwiO1xuXG5cdH07XG5cblx0SW5zdGFuY2VFZmZlY3QucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy51cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKCAvXiMvLCAnJyApO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gQW5pbWF0aW9uKCkge1xuXG5cdFx0dGhpcy5pZCA9IFwiXCI7XG5cdFx0dGhpcy5uYW1lID0gXCJcIjtcblx0XHR0aGlzLnNvdXJjZSA9IHt9O1xuXHRcdHRoaXMuc2FtcGxlciA9IFtdO1xuXHRcdHRoaXMuY2hhbm5lbCA9IFtdO1xuXG5cdH07XG5cblx0QW5pbWF0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdHRoaXMubmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblx0XHR0aGlzLnNvdXJjZSA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdzb3VyY2UnOlxuXG5cdFx0XHRcdFx0dmFyIHNyYyA9ICggbmV3IFNvdXJjZSgpICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0dGhpcy5zb3VyY2VbIHNyYy5pZCBdID0gc3JjO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3NhbXBsZXInOlxuXG5cdFx0XHRcdFx0dGhpcy5zYW1wbGVyLnB1c2goICggbmV3IFNhbXBsZXIoIHRoaXMgKSApLnBhcnNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnY2hhbm5lbCc6XG5cblx0XHRcdFx0XHR0aGlzLmNoYW5uZWwucHVzaCggKCBuZXcgQ2hhbm5lbCggdGhpcyApICkucGFyc2UoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIENoYW5uZWwoIGFuaW1hdGlvbiApIHtcblxuXHRcdHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuXHRcdHRoaXMuc291cmNlID0gXCJcIjtcblx0XHR0aGlzLnRhcmdldCA9IFwiXCI7XG5cdFx0dGhpcy5zaWQgPSBudWxsO1xuXHRcdHRoaXMuZG90U3ludGF4ID0gbnVsbDtcblx0XHR0aGlzLmFyclN5bnRheCA9IG51bGw7XG5cdFx0dGhpcy5hcnJJbmRpY2VzID0gbnVsbDtcblx0XHR0aGlzLm1lbWJlciA9IG51bGw7XG5cblx0fTtcblxuXHRDaGFubmVsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkucmVwbGFjZSggL14jLywgJycgKTtcblx0XHR0aGlzLnRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndGFyZ2V0JyApO1xuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy50YXJnZXQuc3BsaXQoICcvJyApO1xuXG5cdFx0dmFyIGlkID0gcGFydHMuc2hpZnQoKTtcblx0XHR2YXIgc2lkID0gcGFydHMuc2hpZnQoKTtcblxuXHRcdHZhciBkb3RTeW50YXggPSAoIHNpZC5pbmRleE9mKFwiLlwiKSA+PSAwICk7XG5cdFx0dmFyIGFyclN5bnRheCA9ICggc2lkLmluZGV4T2YoXCIoXCIpID49IDAgKTtcblxuXHRcdHZhciBhcnJJbmRpY2VzO1xuXHRcdHZhciBtZW1iZXI7XG5cblx0XHRpZiAoIGRvdFN5bnRheCApIHtcblxuXHRcdFx0cGFydHMgPSBzaWQuc3BsaXQoXCIuXCIpO1xuXHRcdFx0c2lkID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdG1lbWJlciA9IHBhcnRzLnNoaWZ0KCk7XG5cblx0XHR9IGVsc2UgaWYgKCBhcnJTeW50YXggKSB7XG5cblx0XHRcdGFyckluZGljZXMgPSBzaWQuc3BsaXQoXCIoXCIpO1xuXHRcdFx0c2lkID0gYXJySW5kaWNlcy5zaGlmdCgpO1xuXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGFyckluZGljZXMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdGFyckluZGljZXNbal0gPSBwYXJzZUludCggYXJySW5kaWNlc1tqXS5yZXBsYWNlKC9cXCkvLCAnJykgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5zaWQgPSBzaWQ7XG5cdFx0dGhpcy5kb3RTeW50YXggPSBkb3RTeW50YXg7XG5cdFx0dGhpcy5hcnJTeW50YXggPSBhcnJTeW50YXg7XG5cdFx0dGhpcy5hcnJJbmRpY2VzID0gYXJySW5kaWNlcztcblx0XHR0aGlzLm1lbWJlciA9IG1lbWJlcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gU2FtcGxlciAoIGFuaW1hdGlvbiApIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuXHRcdHRoaXMuaW5wdXRzID0gW107XG5cdFx0dGhpcy5pbnB1dCA9IG51bGw7XG5cdFx0dGhpcy5vdXRwdXQgPSBudWxsO1xuXHRcdHRoaXMuaW50ZXJwb2xhdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5zdGFydFRpbWUgPSBudWxsO1xuXHRcdHRoaXMuZW5kVGltZSA9IG51bGw7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IDA7XG5cblx0fTtcblxuXHRTYW1wbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdHRoaXMuaW5wdXRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdFx0XHR0aGlzLmlucHV0cy5wdXNoKCAobmV3IElucHV0KCkpLnBhcnNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRTYW1wbGVyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzWyBpIF07XG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5hbmltYXRpb24uc291cmNlWyBpbnB1dC5zb3VyY2UgXTtcblxuXHRcdFx0c3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XG5cblx0XHRcdFx0Y2FzZSAnSU5QVVQnOlxuXG5cdFx0XHRcdFx0dGhpcy5pbnB1dCA9IHNvdXJjZS5yZWFkKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnT1VUUFVUJzpcblxuXHRcdFx0XHRcdHRoaXMub3V0cHV0ID0gc291cmNlLnJlYWQoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdJTlRFUlBPTEFUSU9OJzpcblxuXHRcdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGlvbiA9IHNvdXJjZS5yZWFkKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSU5fVEFOR0VOVCc6XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdPVVRfVEFOR0VOVCc6XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coaW5wdXQuc2VtYW50aWMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdFx0dGhpcy5lbmRUaW1lID0gMDtcblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblxuXHRcdGlmICggdGhpcy5pbnB1dC5sZW5ndGggKSB7XG5cblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gMTAwMDAwMDAwO1xuXHRcdFx0dGhpcy5lbmRUaW1lID0gLTEwMDAwMDAwMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dC5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbiggdGhpcy5zdGFydFRpbWUsIHRoaXMuaW5wdXRbIGkgXSApO1xuXHRcdFx0XHR0aGlzLmVuZFRpbWUgPSBNYXRoLm1heCggdGhpcy5lbmRUaW1lLCB0aGlzLmlucHV0WyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmR1cmF0aW9uID0gdGhpcy5lbmRUaW1lIC0gdGhpcy5zdGFydFRpbWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBfc291cmNlICggZWxlbWVudCApIHtcblxuXHRcdHZhciBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cblx0XHRpZiAoIHNvdXJjZXNbIGlkIF0gIT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gc291cmNlc1sgaWQgXTtcblxuXHRcdH1cblxuXHRcdHNvdXJjZXNbIGlkIF0gPSAoIG5ldyBTb3VyY2UoaWQgKSkucGFyc2UoIGVsZW1lbnQgKTtcblx0XHRyZXR1cm4gc291cmNlc1sgaWQgXTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9uc1Jlc29sdmVyICggbnNQcmVmaXggKSB7XG5cblx0XHRpZiAoIG5zUHJlZml4ID09IFwiZGFlXCIgKSB7XG5cblx0XHRcdHJldHVybiBcImh0dHA6Ly93d3cuY29sbGFkYS5vcmcvMjAwNS8xMS9DT0xMQURBU2NoZW1hXCI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9ib29scyAoIHN0ciApIHtcblxuXHRcdHZhciByYXcgPSBfc3RyaW5ncyggc3RyICk7XG5cdFx0dmFyIGRhdGEgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGRhdGEucHVzaCggKHJhd1tpXSA9PSAndHJ1ZScgfHwgcmF3W2ldID09ICcxJykgPyB0cnVlIDogZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gX2Zsb2F0cyAoIHN0ciApIHtcblxuXHRcdHZhciByYXcgPSBfc3RyaW5ncyhzdHIpO1xuXHRcdHZhciBkYXRhID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRkYXRhLnB1c2goIHBhcnNlRmxvYXQoIHJhd1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gX2ludHMgKCBzdHIgKSB7XG5cblx0XHR2YXIgcmF3ID0gX3N0cmluZ3MoIHN0ciApO1xuXHRcdHZhciBkYXRhID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRkYXRhLnB1c2goIHBhcnNlSW50KCByYXdbIGkgXSwgMTAgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBfc3RyaW5ncyAoIHN0ciApIHtcblxuXHRcdHJldHVybiBfdHJpbVN0cmluZyggc3RyICkuc3BsaXQoIC9cXHMrLyApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gX3RyaW1TdHJpbmcgKCBzdHIgKSB7XG5cblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIC9eXFxzKy8sIFwiXCIgKS5yZXBsYWNlKCAvXFxzKyQvLCBcIlwiICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBfYXR0cl9hc19mbG9hdCAoIGVsZW1lbnQsIG5hbWUsIGRlZmF1bHRWYWx1ZSApIHtcblxuXHRcdGlmICggZWxlbWVudC5oYXNBdHRyaWJ1dGUoIG5hbWUgKSApIHtcblxuXHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCBuYW1lICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBfYXR0cl9hc19pbnQgKCBlbGVtZW50LCBuYW1lLCBkZWZhdWx0VmFsdWUgKSB7XG5cblx0XHRpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCBuYW1lICkgKSB7XG5cblx0XHRcdHJldHVybiBwYXJzZUludCggZWxlbWVudC5nZXRBdHRyaWJ1dGUoIG5hbWUgKSwgMTApIDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBfYXR0cl9hc19zdHJpbmcgKCBlbGVtZW50LCBuYW1lLCBkZWZhdWx0VmFsdWUgKSB7XG5cblx0XHRpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCBuYW1lICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9mb3JtYXRfZmxvYXQgKCBmLCBudW0gKSB7XG5cblx0XHRpZiAoIGYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIHMgPSAnMC4nO1xuXG5cdFx0XHR3aGlsZSAoIHMubGVuZ3RoIDwgbnVtICsgMiApIHtcblxuXHRcdFx0XHRzICs9ICcwJztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcztcblxuXHRcdH1cblxuXHRcdG51bSA9IG51bSB8fCAyO1xuXG5cdFx0dmFyIHBhcnRzID0gZi50b1N0cmluZygpLnNwbGl0KCAnLicgKTtcblx0XHRwYXJ0c1sgMSBdID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWyAxIF0uc3Vic3RyKCAwLCBudW0gKSA6IFwiMFwiO1xuXG5cdFx0d2hpbGUoIHBhcnRzWyAxIF0ubGVuZ3RoIDwgbnVtICkge1xuXG5cdFx0XHRwYXJ0c1sgMSBdICs9ICcwJztcblxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCAnLicgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9oYXNoX3ZlcnRleCAoIHYsIG4sIHQwLCB0MSwgcHJlY2lzaW9uICkge1xuXG5cdFx0cHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDI7XG5cblx0XHR2YXIgcyA9IHYgaW5zdGFuY2VvZiBUSFJFRS5WZXJ0ZXggPyBfaGFzaF92ZWN0b3IzKCB2LnBvc2l0aW9uLCBwcmVjaXNpb24gKSA6IF9oYXNoX3ZlY3RvcjMoIHYsIHByZWNpc2lvbiApO1xuXG5cdFx0aWYgKCBuID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHMgKz0gJ18wLjAwLDAuMDAsMC4wMCc7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzICs9ICdfJyArIF9oYXNoX3ZlY3RvcjMoIG4sIHByZWNpc2lvbiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0MCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzICs9ICdfMC4wMCwwLjAwJztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHMgKz0gJ18nICsgX2hhc2hfdXYoIHQwLCBwcmVjaXNpb24gKTtcblxuXHRcdH1cblxuXHRcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cyArPSAnXzAuMDAsMC4wMCc7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzICs9ICdfJyArIF9oYXNoX3V2KCB0MSwgcHJlY2lzaW9uICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9oYXNoX3V2ICggdXYsIG51bSApIHtcblxuXHRcdHZhciBzID0gJyc7XG5cblx0XHRzICs9IF9mb3JtYXRfZmxvYXQoIHV2LnUsIG51bSApICsgJywnO1xuXHRcdHMgKz0gX2Zvcm1hdF9mbG9hdCggdXYudiwgbnVtICk7XG5cblx0XHRyZXR1cm4gcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9oYXNoX3ZlY3RvcjMgKCB2ZWMsIG51bSApIHtcblxuXHRcdHZhciBzID0gJyc7XG5cblx0XHRzICs9IF9mb3JtYXRfZmxvYXQoIHZlYy54LCBudW0gKSArICcsJztcblx0XHRzICs9IF9mb3JtYXRfZmxvYXQoIHZlYy55LCBudW0gKSArICcsJztcblx0XHRzICs9IF9mb3JtYXRfZmxvYXQoIHZlYy56LCBudW0gKTtcblxuXHRcdHJldHVybiBzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gZXZhbHVhdGVYUGF0aCAoIG5vZGUsIHF1ZXJ5ICkge1xuXG5cdFx0dmFyIGluc3RhbmNlcyA9IENPTExBREEuZXZhbHVhdGUocXVlcnksXG5cdFx0XHRub2RlLFxuXHRcdFx0X25zUmVzb2x2ZXIsXG5cdFx0XHRYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSxcblx0XHRcdG51bGwpO1xuXG5cdFx0dmFyIGluc3QgPSBpbnN0YW5jZXMuaXRlcmF0ZU5leHQoKTtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHR3aGlsZSAoIGluc3QgKSB7XG5cblx0XHRcdHJlc3VsdC5wdXNoKCBpbnN0ICk7XG5cdFx0XHRpbnN0ID0gaW5zdGFuY2VzLml0ZXJhdGVOZXh0KCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH07XG5cblx0cmV0dXJuIHtcblxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0cGFyc2U6IHBhcnNlLFxuXHRcdHNldFByZWZlcnJlZFNoYWRpbmc6IHNldFByZWZlcnJlZFNoYWRpbmcsXG5cdFx0YXBwbHlTa2luOiBhcHBseVNraW4sXG5cdFx0Z2VvbWV0cmllcyA6IGdlb21ldHJpZXNcblxuXHR9O1xuXG59O1xuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSlNPTkxvYWRlciA9IGZ1bmN0aW9uICggc2hvd1N0YXR1cyApIHtcclxuXHJcblx0VEhSRUUuTG9hZGVyLmNhbGwoIHRoaXMsIHNob3dTdGF0dXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5Mb2FkZXIoKTtcclxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5KU09OTG9hZGVyO1xyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5zdXByID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZTtcclxuXHJcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHR2YXIgd29ya2VyLCBzY29wZSA9IHRoaXM7XHJcblxyXG5cdGlmICggdXJsIGluc3RhbmNlb2YgT2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IEpTT05Mb2FkZXIoIHBhcmFtZXRlcnMgKSBpcyBub3cgSlNPTkxvYWRlciggdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGggKS4nICk7XHJcblxyXG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB1cmw7XHJcblxyXG5cdFx0dXJsID0gcGFyYW1ldGVycy5tb2RlbDtcclxuXHRcdGNhbGxiYWNrID0gcGFyYW1ldGVycy5jYWxsYmFjaztcclxuXHRcdHRleHR1cmVQYXRoID0gcGFyYW1ldGVycy50ZXh0dXJlX3BhdGg7XHJcblxyXG5cdH1cclxuXHJcblx0dGV4dHVyZVBhdGggPSB0ZXh0dXJlUGF0aCA/IHRleHR1cmVQYXRoIDogdGhpcy5leHRyYWN0VXJsYmFzZSggdXJsICksXHJcblxyXG5cdHRoaXMub25Mb2FkU3RhcnQoKTtcclxuXHR0aGlzLmxvYWRBamF4SlNPTiggdGhpcywgdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGggKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkQWpheEpTT04gPSBmdW5jdGlvbiggY29udGV4dCwgdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGgsIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XHJcblxyXG5cdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0dmFyIGxlbmd0aCA9IDA7XHJcblxyXG5cdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09IDQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHhoci5zdGF0dXMgPT0gMjAwIHx8IHhoci5zdGF0dXMgPT0gMCApIHtcclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHJcblx0XHRcdFx0XHR2YXIganNvbk9iamVjdCA9IEpTT04ucGFyc2UoIHhoci5yZXNwb25zZVRleHQgKTtcclxuXHJcblx0XHRcdFx0XHRjb250ZXh0LmNyZWF0ZU1vZGVsKCBqc29uT2JqZWN0LCBjYWxsYmFjaywgdGV4dHVyZVBhdGggKTtcclxuXHRcdFx0XHRcdGNvbnRleHQub25Mb2FkQ29tcGxldGUoKTtcclxuXHJcblx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiREVQUkVDQVRFRDogW1wiICsgdXJsICsgXCJdIHNlZW1zIHRvIGJlIHVzaW5nIG9sZCBtb2RlbCBmb3JtYXRcIiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIkNvdWxkbid0IGxvYWQgW1wiICsgdXJsICsgXCJdIFtcIiArIHhoci5zdGF0dXMgKyBcIl1cIiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09IDMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbGVuZ3RoID09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGVuZ3RoID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtTGVuZ3RoXCIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjYWxsYmFja1Byb2dyZXNzKCB7IHRvdGFsOiBsZW5ndGgsIGxvYWRlZDogeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGggfSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09IDIgKSB7XHJcblxyXG5cdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1MZW5ndGhcIiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0eGhyLm9wZW4oIFwiR0VUXCIsIHVybCwgdHJ1ZSApO1xyXG5cdHhoci5vdmVycmlkZU1pbWVUeXBlKCBcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIiApO1xyXG5cdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvcGxhaW5cIiApO1xyXG5cdHhoci5zZW5kKCBudWxsICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUuY3JlYXRlTW9kZWwgPSBmdW5jdGlvbiAoIGpzb24sIGNhbGxiYWNrLCB0ZXh0dXJlX3BhdGggKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXMsXHJcblx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKSxcclxuXHRzY2FsZSA9ICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgPyAxLjAgLyBqc29uLnNjYWxlIDogMS4wO1xyXG5cclxuXHR0aGlzLmluaXRNYXRlcmlhbHMoIGdlb21ldHJ5LCBqc29uLm1hdGVyaWFscywgdGV4dHVyZV9wYXRoICk7XHJcblxyXG5cdHBhcnNlTW9kZWwoIHNjYWxlICk7XHJcblxyXG5cdHBhcnNlU2tpbigpO1xyXG5cdHBhcnNlTW9ycGhpbmcoIHNjYWxlICk7XHJcblxyXG5cdGdlb21ldHJ5LmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHRnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0aWYgKCB0aGlzLmhhc05vcm1hbHMoIGdlb21ldHJ5ICkgKSBnZW9tZXRyeS5jb21wdXRlVGFuZ2VudHMoKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlTW9kZWwoIHNjYWxlICkge1xyXG5cclxuXHRcdGlmICgganNvbi5tZXRhZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWV0YWRhdGEuZm9ybWF0VmVyc2lvbiA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWV0YWRhdGEuZm9ybWF0VmVyc2lvbiAhPT0gMyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdEZXByZWNhdGVkIGZpbGUgZm9ybWF0LicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpc0JpdFNldCggdmFsdWUsIHBvc2l0aW9uICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgaSwgaiwgZmksXHJcblxyXG5cdFx0b2Zmc2V0LCB6TGVuZ3RoLCBuVmVydGljZXMsXHJcblxyXG5cdFx0Y29sb3JJbmRleCwgbm9ybWFsSW5kZXgsIHV2SW5kZXgsIG1hdGVyaWFsSW5kZXgsXHJcblxyXG5cdFx0dHlwZSxcclxuXHRcdGlzUXVhZCxcclxuXHRcdGhhc01hdGVyaWFsLFxyXG5cdFx0aGFzRmFjZVV2LCBoYXNGYWNlVmVydGV4VXYsXHJcblx0XHRoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxyXG5cdFx0aGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IsXHJcblxyXG5cdFx0dmVydGV4LCBmYWNlLCBjb2xvciwgbm9ybWFsLFxyXG5cclxuXHRcdHV2TGF5ZXIsIHV2cywgdSwgdixcclxuXHJcblx0XHRmYWNlcyA9IGpzb24uZmFjZXMsXHJcblx0XHR2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXHJcblx0XHRub3JtYWxzID0ganNvbi5ub3JtYWxzLFxyXG5cdFx0Y29sb3JzID0ganNvbi5jb2xvcnMsXHJcblxyXG5cdFx0blV2TGF5ZXJzID0gMDtcclxuXHJcblx0XHQvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkrKyApIHtcclxuXHJcblx0XHRcdGlmICgganNvbi51dnNbIGkgXS5sZW5ndGggKSBuVXZMYXllcnMgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpKysgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5mYWNlVXZzWyBpIF0gPSBbXTtcclxuXHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG9mZnNldCA9IDA7XHJcblx0XHR6TGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdHZlcnRleCA9IG5ldyBUSFJFRS5WZXJ0ZXgoKTtcclxuXHJcblx0XHRcdHZlcnRleC5wb3NpdGlvbi54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblx0XHRcdHZlcnRleC5wb3NpdGlvbi55ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblx0XHRcdHZlcnRleC5wb3NpdGlvbi56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0b2Zmc2V0ID0gMDtcclxuXHRcdHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblxyXG5cdFx0XHRpc1F1YWQgICAgICAgICAgXHQ9IGlzQml0U2V0KCB0eXBlLCAwICk7XHJcblx0XHRcdGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xyXG5cdFx0XHRoYXNGYWNlVXYgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDIgKTtcclxuXHRcdFx0aGFzRmFjZVZlcnRleFV2ICAgICA9IGlzQml0U2V0KCB0eXBlLCAzICk7XHJcblx0XHRcdGhhc0ZhY2VOb3JtYWwgICAgICAgPSBpc0JpdFNldCggdHlwZSwgNCApO1xyXG5cdFx0XHRoYXNGYWNlVmVydGV4Tm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDUgKTtcclxuXHRcdFx0aGFzRmFjZUNvbG9yXHQgICAgPSBpc0JpdFNldCggdHlwZSwgNiApO1xyXG5cdFx0XHRoYXNGYWNlVmVydGV4Q29sb3IgID0gaXNCaXRTZXQoIHR5cGUsIDcgKTtcclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJ0eXBlXCIsIHR5cGUsIFwiYml0c1wiLCBpc1F1YWQsIGhhc01hdGVyaWFsLCBoYXNGYWNlVXYsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xyXG5cclxuXHRcdFx0aWYgKCBpc1F1YWQgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTQoKTtcclxuXHJcblx0XHRcdFx0ZmFjZS5hID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5kID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRuVmVydGljZXMgPSA0O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG5cclxuXHRcdFx0XHRmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0blZlcnRpY2VzID0gMztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxyXG5cclxuXHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VVdiApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG5cdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VVdnNbIGkgXVsgZmkgXSA9IG5ldyBUSFJFRS5VViggdSwgdiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR1dnMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IG5WZXJ0aWNlczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcclxuXHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0dXZzWyBqIF0gPSBuZXcgVEhSRUUuVVYoIHUsIHYgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gdXZzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0bm9ybWFsLnggPSBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdO1xyXG5cdFx0XHRcdG5vcm1hbC55ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXTtcclxuXHRcdFx0XHRub3JtYWwueiA9IG5vcm1hbHNbIG5vcm1hbEluZGV4IF07XHJcblxyXG5cdFx0XHRcdGZhY2Uubm9ybWFsID0gbm9ybWFsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5WZXJ0aWNlczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC54ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXTtcclxuXHRcdFx0XHRcdG5vcm1hbC55ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXTtcclxuXHRcdFx0XHRcdG5vcm1hbC56ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0Y29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XHJcblx0XHRcdFx0ZmFjZS5jb2xvciA9IGNvbG9yO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5WZXJ0aWNlczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0Y29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XHJcblx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBjb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XHJcblxyXG5cdFx0dmFyIGksIGwsIHgsIHksIHosIHcsIGEsIGIsIGMsIGQ7XHJcblxyXG5cdFx0aWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdFx0eCA9IGpzb24uc2tpbldlaWdodHNbIGkgICAgIF07XHJcblx0XHRcdFx0eSA9IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF07XHJcblx0XHRcdFx0eiA9IDA7XHJcblx0XHRcdFx0dyA9IDA7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdFx0YSA9IGpzb24uc2tpbkluZGljZXNbIGkgICAgIF07XHJcblx0XHRcdFx0YiA9IGpzb24uc2tpbkluZGljZXNbIGkgKyAxIF07XHJcblx0XHRcdFx0YyA9IDA7XHJcblx0XHRcdFx0ZCA9IDA7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnNraW5JbmRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCBhLCBiLCBjLCBkICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuYm9uZXMgPSBqc29uLmJvbmVzO1xyXG5cdFx0Z2VvbWV0cnkuYW5pbWF0aW9uID0ganNvbi5hbmltYXRpb247XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xyXG5cclxuXHRcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBpLCBsLCB2LCB2bCwgeCwgeSwgeiwgZHN0VmVydGljZXMsIHNyY1ZlcnRpY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xyXG5cdFx0XHRcdHNyY1ZlcnRpY2VzID0ganNvbi5tb3JwaFRhcmdldHMgWyBpIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdGZvciggdiA9IDAsIHZsID0gc3JjVmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gc3JjVmVydGljZXNbIHYgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0eSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XHJcblx0XHRcdFx0XHR6ID0gc3JjVmVydGljZXNbIHYgKyAyIF0gKiBzY2FsZTtcclxuXHJcblx0XHRcdFx0XHRkc3RWZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBpLCBsLCBjLCBjbCwgZHN0Q29sb3JzLCBzcmNDb2xvcnMsIGNvbG9yO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXSA9IHt9O1xyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhDb2xvcnNbIGkgXS5uYW1lO1xyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzID0gW107XHJcblxyXG5cdFx0XHRcdGRzdENvbG9ycyA9IGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzO1xyXG5cdFx0XHRcdHNyY0NvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnMgWyBpIF0uY29sb3JzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBjID0gMCwgY2wgPSBzcmNDb2xvcnMubGVuZ3RoOyBjIDwgY2w7IGMgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmFhMDAgKTtcclxuXHRcdFx0XHRcdGNvbG9yLnNldFJHQiggc3JjQ29sb3JzWyBjIF0sIHNyY0NvbG9yc1sgYyArIDEgXSwgc3JjQ29sb3JzWyBjICsgMiBdICk7XHJcblx0XHRcdFx0XHRkc3RDb2xvcnMucHVzaCggY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Y2FsbGJhY2soIGdlb21ldHJ5ICk7XHJcblxyXG59O1xyXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU2NlbmVMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xuXHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24oKSB7fTtcblx0dGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdHRoaXMuY2FsbGJhY2tTeW5jID0gZnVuY3Rpb24gKCkge307XG5cdHRoaXMuY2FsbGJhY2tQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG59O1xuXG5USFJFRS5TY2VuZUxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TY2VuZUxvYWRlcjtcblxuVEhSRUUuU2NlbmVMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBjYWxsYmFja0ZpbmlzaGVkICkge1xuXG5cdHZhciBjb250ZXh0ID0gdGhpcztcblxuXHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PSA0ICkge1xuXG5cdFx0XHRpZiAoIHhoci5zdGF0dXMgPT0gMjAwIHx8IHhoci5zdGF0dXMgPT0gMCApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB4aHIucmVzcG9uc2VUZXh0ICk7XG5cblx0XHRcdFx0XHRpZiAoIGpzb24ubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1ldGFkYXRhLmZvcm1hdFZlcnNpb24gPT09IHVuZGVmaW5lZCB8fCBqc29uLm1ldGFkYXRhLmZvcm1hdFZlcnNpb24gIT09IDMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdEZXByZWNhdGVkIGZpbGUgZm9ybWF0LicgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRleHQuY3JlYXRlU2NlbmUoIGpzb24sIGNhbGxiYWNrRmluaXNoZWQsIHVybCApO1xuXG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIkRFUFJFQ0FURUQ6IFtcIiArIHVybCArIFwiXSBzZWVtcyB0byBiZSB1c2luZyBvbGQgbW9kZWwgZm9ybWF0XCIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJDb3VsZG4ndCBsb2FkIFtcIiArIHVybCArIFwiXSBbXCIgKyB4aHIuc3RhdHVzICsgXCJdXCIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0eGhyLm9wZW4oIFwiR0VUXCIsIHVybCwgdHJ1ZSApO1xuXHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIgKTtcblx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9wbGFpblwiICk7XG5cdHhoci5zZW5kKCBudWxsICk7XG5cbn07XG5cblRIUkVFLlNjZW5lTG9hZGVyLnByb3RvdHlwZS5jcmVhdGVTY2VuZSA9IGZ1bmN0aW9uICgganNvbiwgY2FsbGJhY2tGaW5pc2hlZCwgdXJsICkge1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dmFyIHVybEJhc2UgPSBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmV4dHJhY3RVcmxiYXNlKCB1cmwgKTtcblxuXHR2YXIgZGcsIGRtLCBkZCwgZGwsIGRjLCBkZiwgZHQsXG5cdFx0ZywgbywgbSwgbCwgZCwgcCwgciwgcSwgcywgYywgdCwgZiwgdHQsIHBwLFxuXHRcdGdlb21ldHJ5LCBtYXRlcmlhbCwgY2FtZXJhLCBmb2csXG5cdFx0dGV4dHVyZSwgaW1hZ2VzLFxuXHRcdG1hdGVyaWFscywgbGlnaHQsXG5cdFx0ZGF0YSwgYmluTG9hZGVyLCBqc29uTG9hZGVyLFxuXHRcdGNvdW50ZXJfbW9kZWxzLCBjb3VudGVyX3RleHR1cmVzLFxuXHRcdHRvdGFsX21vZGVscywgdG90YWxfdGV4dHVyZXMsXG5cdFx0cmVzdWx0O1xuXG5cdGRhdGEgPSBqc29uO1xuXG5cdGJpbkxvYWRlciA9IG5ldyBUSFJFRS5CaW5hcnlMb2FkZXIoKTtcblx0anNvbkxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XG5cblx0Y291bnRlcl9tb2RlbHMgPSAwO1xuXHRjb3VudGVyX3RleHR1cmVzID0gMDtcblxuXHRyZXN1bHQgPSB7XG5cblx0XHRzY2VuZTogbmV3IFRIUkVFLlNjZW5lKCksXG5cdFx0Z2VvbWV0cmllczoge30sXG5cdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHR0ZXh0dXJlczoge30sXG5cdFx0b2JqZWN0czoge30sXG5cdFx0Y2FtZXJhczoge30sXG5cdFx0bGlnaHRzOiB7fSxcblx0XHRmb2dzOiB7fSxcblx0XHR0cmlnZ2Vyczoge30sXG5cdFx0ZW1wdGllczoge31cblxuXHR9O1xuXG5cdC8vIGZpbmQgb3V0IGlmIHRoZXJlIGFyZSBzb21lIGNvbGxpZGVyc1xuXG5cdHZhciBoYXNDb2xsaWRlcnMgPSBmYWxzZTtcblxuXHRmb3IoIGRkIGluIGRhdGEub2JqZWN0cyApIHtcblxuXHRcdG8gPSBkYXRhLm9iamVjdHNbIGRkIF07XG5cblx0XHRpZiAoIG8ubWVzaENvbGxpZGVyICkgIHtcblxuXHRcdFx0aGFzQ29sbGlkZXJzID0gdHJ1ZTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRpZiAoIGhhc0NvbGxpZGVycyApIHtcblxuXHRcdHJlc3VsdC5zY2VuZS5jb2xsaXNpb25zID0gbmV3IFRIUkVFLkNvbGxpc2lvblN5c3RlbSgpO1xuXG5cdH1cblxuXHRpZiAoIGRhdGEudHJhbnNmb3JtICkge1xuXG5cdFx0dmFyIHBvc2l0aW9uID0gZGF0YS50cmFuc2Zvcm0ucG9zaXRpb24sXG5cdFx0XHRyb3RhdGlvbiA9IGRhdGEudHJhbnNmb3JtLnJvdGF0aW9uLFxuXHRcdFx0c2NhbGUgPSBkYXRhLnRyYW5zZm9ybS5zY2FsZTtcblxuXHRcdGlmICggcG9zaXRpb24gKVxuXHRcdFx0cmVzdWx0LnNjZW5lLnBvc2l0aW9uLnNldCggcG9zaXRpb25bIDAgXSwgcG9zaXRpb25bIDEgXSwgcG9zaXRpb24gWyAyIF0gKTtcblxuXHRcdGlmICggcm90YXRpb24gKVxuXHRcdFx0cmVzdWx0LnNjZW5lLnJvdGF0aW9uLnNldCggcm90YXRpb25bIDAgXSwgcm90YXRpb25bIDEgXSwgcm90YXRpb24gWyAyIF0gKTtcblxuXHRcdGlmICggc2NhbGUgKVxuXHRcdFx0cmVzdWx0LnNjZW5lLnNjYWxlLnNldCggc2NhbGVbIDAgXSwgc2NhbGVbIDEgXSwgc2NhbGUgWyAyIF0gKTtcblxuXHRcdGlmICggcG9zaXRpb24gfHwgcm90YXRpb24gfHwgc2NhbGUgKVxuXHRcdFx0cmVzdWx0LnNjZW5lLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRfdXJsKCBzb3VyY2VfdXJsLCB1cmxfdHlwZSApIHtcblxuXHRcdGlmICggdXJsX3R5cGUgPT0gXCJyZWxhdGl2ZVRvSFRNTFwiICkge1xuXG5cdFx0XHRyZXR1cm4gc291cmNlX3VybDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiB1cmxCYXNlICsgXCIvXCIgKyBzb3VyY2VfdXJsO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gaGFuZGxlX29iamVjdHMoKSB7XG5cblx0XHR2YXIgb2JqZWN0O1xuXG5cdFx0Zm9yKCBkZCBpbiBkYXRhLm9iamVjdHMgKSB7XG5cblx0XHRcdGlmICggIXJlc3VsdC5vYmplY3RzWyBkZCBdICkge1xuXG5cdFx0XHRcdG8gPSBkYXRhLm9iamVjdHNbIGRkIF07XG5cblx0XHRcdFx0aWYgKCBvLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRnZW9tZXRyeSA9IHJlc3VsdC5nZW9tZXRyaWVzWyBvLmdlb21ldHJ5IF07XG5cblx0XHRcdFx0XHQvLyBnZW9tZXRyeSBhbHJlYWR5IGxvYWRlZFxuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGhhc05vcm1hbHMgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0Ly8gbm90IGFueW1vcmUgc3VwcG9ydCBmb3IgbXVsdGlwbGUgbWF0ZXJpYWxzXG5cdFx0XHRcdFx0XHQvLyBzaG91bGRuJ3QgcmVhbGx5IGJlIGFycmF5XG5cblx0XHRcdFx0XHRcdGZvciggaSA9IDA7IGkgPCBvLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxzID0gcmVzdWx0Lm1hdGVyaWFsc1sgby5tYXRlcmlhbHNbIGkgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGhhc05vcm1hbHMgPSBtYXRlcmlhbHMgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc05vcm1hbHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cCA9IG8ucG9zaXRpb247XG5cdFx0XHRcdFx0XHRyID0gby5yb3RhdGlvbjtcblx0XHRcdFx0XHRcdHEgPSBvLnF1YXRlcm5pb247XG5cdFx0XHRcdFx0XHRzID0gby5zY2FsZTtcblxuXHRcdFx0XHRcdFx0Ly8gdHVybiBvZmYgcXVhdGVybmlvbnMsIGZvciB0aGUgbW9tZW50XG5cblx0XHRcdFx0XHRcdHEgPSAwO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbHMgPSBuZXcgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCgpO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGRpcnR5IGhhY2sgdG8gaGFuZGxlIG1lc2hlcyB3aXRoIG11bHRpcGxlIG1hdGVyaWFsc1xuXHRcdFx0XHRcdFx0Ly8ganVzdCB1c2UgZmFjZSBtYXRlcmlhbHMgZGVmaW5lZCBpbiBtb2RlbFxuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFscyA9IG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKCk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHMgKTtcblx0XHRcdFx0XHRcdG9iamVjdC5uYW1lID0gZGQ7XG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uc2V0KCBwWzBdLCBwWzFdLCBwWzJdICk7XG5cblx0XHRcdFx0XHRcdGlmICggcSApIHtcblxuXHRcdFx0XHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5zZXQoIHFbMF0sIHFbMV0sIHFbMl0sIHFbM10gKTtcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnVzZVF1YXRlcm5pb24gPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5yb3RhdGlvbi5zZXQoIHJbMF0sIHJbMV0sIHJbMl0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRvYmplY3Quc2NhbGUuc2V0KCBzWzBdLCBzWzFdLCBzWzJdICk7XG5cdFx0XHRcdFx0XHRvYmplY3QudmlzaWJsZSA9IG8udmlzaWJsZTtcblxuXHRcdFx0XHRcdFx0cmVzdWx0LnNjZW5lLmFkZCggb2JqZWN0ICk7XG5cblx0XHRcdFx0XHRcdHJlc3VsdC5vYmplY3RzWyBkZCBdID0gb2JqZWN0O1xuXG5cdFx0XHRcdFx0XHRpZiAoIG8ubWVzaENvbGxpZGVyICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBtZXNoQ29sbGlkZXIgPSBUSFJFRS5Db2xsaXNpb25VdGlscy5NZXNoQ29sbGlkZXJXQm94KCBvYmplY3QgKTtcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnNjZW5lLmNvbGxpc2lvbnMuY29sbGlkZXJzLnB1c2goIG1lc2hDb2xsaWRlciApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggby5jYXN0c1NoYWRvdyApIHtcblxuXHRcdFx0XHRcdFx0XHQvL29iamVjdC52aXNpYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Ly9vYmplY3QubWF0ZXJpYWxzID0gWyBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmYwMDAwIH0gKSBdO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzaGFkb3cgPSBuZXcgVEhSRUUuU2hhZG93Vm9sdW1lKCBnZW9tZXRyeSApXG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5zY2VuZS5hZGQoIHNoYWRvdyApO1xuXG5cdFx0XHRcdFx0XHRcdHNoYWRvdy5wb3NpdGlvbiA9IG9iamVjdC5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdFx0c2hhZG93LnJvdGF0aW9uID0gb2JqZWN0LnJvdGF0aW9uO1xuXHRcdFx0XHRcdFx0XHRzaGFkb3cuc2NhbGUgPSBvYmplY3Quc2NhbGU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBvLnRyaWdnZXIgJiYgby50cmlnZ2VyLnRvTG93ZXJDYXNlKCkgIT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHRyaWdnZXIgPSB7XG5cdFx0XHRcdFx0XHRcdFwidHlwZVwiIFx0XHQ6IG8udHJpZ2dlcixcblx0XHRcdFx0XHRcdFx0XCJvYmplY3RcIlx0OiBvXG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0LnRyaWdnZXJzWyBvYmplY3QubmFtZSBdID0gdHJpZ2dlcjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHB1cmUgT2JqZWN0M0RcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cCA9IG8ucG9zaXRpb247XG5cdFx0XHRcdFx0ciA9IG8ucm90YXRpb247XG5cdFx0XHRcdFx0cSA9IG8ucXVhdGVybmlvbjtcblx0XHRcdFx0XHRzID0gby5zY2FsZTtcblxuXHRcdFx0XHRcdC8vIHR1cm4gb2ZmIHF1YXRlcm5pb25zLCBmb3IgdGhlIG1vbWVudFxuXG5cdFx0XHRcdFx0cSA9IDA7XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblx0XHRcdFx0XHRvYmplY3QubmFtZSA9IGRkO1xuXHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5zZXQoIHBbMF0sIHBbMV0sIHBbMl0gKTtcblxuXHRcdFx0XHRcdGlmICggcSApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LnF1YXRlcm5pb24uc2V0KCBxWzBdLCBxWzFdLCBxWzJdLCBxWzNdICk7XG5cdFx0XHRcdFx0XHRvYmplY3QudXNlUXVhdGVybmlvbiA9IHRydWU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uc2V0KCByWzBdLCByWzFdLCByWzJdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3Quc2NhbGUuc2V0KCBzWzBdLCBzWzFdLCBzWzJdICk7XG5cdFx0XHRcdFx0b2JqZWN0LnZpc2libGUgPSAoIG8udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgPyBvLnZpc2libGUgOiBmYWxzZTtcblxuXHRcdFx0XHRcdHJlc3VsdC5zY2VuZS5hZGQoIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0cmVzdWx0Lm9iamVjdHNbIGRkIF0gPSBvYmplY3Q7XG5cdFx0XHRcdFx0cmVzdWx0LmVtcHRpZXNbIGRkIF0gPSBvYmplY3Q7XG5cblx0XHRcdFx0XHRpZiAoIG8udHJpZ2dlciAmJiBvLnRyaWdnZXIudG9Mb3dlckNhc2UoKSAhPSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHRyaWdnZXIgPSB7XG5cdFx0XHRcdFx0XHRcInR5cGVcIiBcdFx0OiBvLnRyaWdnZXIsXG5cdFx0XHRcdFx0XHRcIm9iamVjdFwiXHQ6IG9cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHJlc3VsdC50cmlnZ2Vyc1sgb2JqZWN0Lm5hbWUgXSA9IHRyaWdnZXI7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBoYW5kbGVfbWVzaCggZ2VvLCBpZCApIHtcblxuXHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBpZCBdID0gZ2VvO1xuXHRcdGhhbmRsZV9vYmplY3RzKCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVfY2FsbGJhY2soIGlkICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBnZW8gKSB7XG5cblx0XHRcdGhhbmRsZV9tZXNoKCBnZW8sIGlkICk7XG5cblx0XHRcdGNvdW50ZXJfbW9kZWxzIC09IDE7XG5cblx0XHRcdHNjb3BlLm9uTG9hZENvbXBsZXRlKCk7XG5cblx0XHRcdGFzeW5jX2NhbGxiYWNrX2dhdGUoKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZV9jYWxsYmFja19lbWJlZCggaWQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGdlbyApIHtcblxuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGlkIF0gPSBnZW87XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBhc3luY19jYWxsYmFja19nYXRlKCkge1xuXG5cdFx0dmFyIHByb2dyZXNzID0ge1xuXG5cdFx0XHR0b3RhbE1vZGVsc1x0XHQ6IHRvdGFsX21vZGVscyxcblx0XHRcdHRvdGFsVGV4dHVyZXNcdDogdG90YWxfdGV4dHVyZXMsXG5cdFx0XHRsb2FkZWRNb2RlbHNcdDogdG90YWxfbW9kZWxzIC0gY291bnRlcl9tb2RlbHMsXG5cdFx0XHRsb2FkZWRUZXh0dXJlc1x0OiB0b3RhbF90ZXh0dXJlcyAtIGNvdW50ZXJfdGV4dHVyZXNcblxuXHRcdH07XG5cblx0XHRzY29wZS5jYWxsYmFja1Byb2dyZXNzKCBwcm9ncmVzcywgcmVzdWx0ICk7XG5cblx0XHRzY29wZS5vbkxvYWRQcm9ncmVzcygpO1xuXG5cdFx0aWYoIGNvdW50ZXJfbW9kZWxzID09IDAgJiYgY291bnRlcl90ZXh0dXJlcyA9PSAwICkge1xuXG5cdFx0XHRjYWxsYmFja0ZpbmlzaGVkKCByZXN1bHQgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHZhciBjYWxsYmFja1RleHR1cmUgPSBmdW5jdGlvbiggaW1hZ2VzICkge1xuXG5cdFx0Y291bnRlcl90ZXh0dXJlcyAtPSAxO1xuXHRcdGFzeW5jX2NhbGxiYWNrX2dhdGUoKTtcblxuXHRcdHNjb3BlLm9uTG9hZENvbXBsZXRlKCk7XG5cblx0fTtcblxuXHQvLyBmaXJzdCBnbyBzeW5jaHJvbm91cyBlbGVtZW50c1xuXG5cdC8vIGNhbWVyYXNcblxuXHRmb3IoIGRjIGluIGRhdGEuY2FtZXJhcyApIHtcblxuXHRcdGMgPSBkYXRhLmNhbWVyYXNbIGRjIF07XG5cblx0XHRpZiAoIGMudHlwZSA9PSBcInBlcnNwZWN0aXZlXCIgKSB7XG5cblx0XHRcdGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggYy5mb3YsIGMuYXNwZWN0LCBjLm5lYXIsIGMuZmFyICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjLnR5cGUgPT0gXCJvcnRob1wiICkge1xuXG5cdFx0XHRjYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCBjLmxlZnQsIGMucmlnaHQsIGMudG9wLCBjLmJvdHRvbSwgYy5uZWFyLCBjLmZhciApO1xuXG5cdFx0fVxuXG5cdFx0cCA9IGMucG9zaXRpb247XG5cdFx0dCA9IGMudGFyZ2V0O1xuXHRcdGNhbWVyYS5wb3NpdGlvbi5zZXQoIHBbMF0sIHBbMV0sIHBbMl0gKTtcblx0XHRjYW1lcmEudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoIHRbMF0sIHRbMV0sIHRbMl0gKTtcblxuXHRcdHJlc3VsdC5jYW1lcmFzWyBkYyBdID0gY2FtZXJhO1xuXG5cdH1cblxuXHQvLyBsaWdodHNcblxuXHR2YXIgaGV4LCBpbnRlbnNpdHk7XG5cblx0Zm9yICggZGwgaW4gZGF0YS5saWdodHMgKSB7XG5cblx0XHRsID0gZGF0YS5saWdodHNbIGRsIF07XG5cblx0XHRoZXggPSAoIGwuY29sb3IgIT09IHVuZGVmaW5lZCApID8gbC5jb2xvciA6IDB4ZmZmZmZmO1xuXHRcdGludGVuc2l0eSA9ICggbC5pbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gbC5pbnRlbnNpdHkgOiAxO1xuXG5cdFx0aWYgKCBsLnR5cGUgPT0gXCJkaXJlY3Rpb25hbFwiICkge1xuXG5cdFx0XHRwID0gbC5kaXJlY3Rpb247XG5cblx0XHRcdGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGhleCwgaW50ZW5zaXR5ICk7XG5cdFx0XHRsaWdodC5wb3NpdGlvbi5zZXQoIHBbMF0sIHBbMV0sIHBbMl0gKTtcblx0XHRcdGxpZ2h0LnBvc2l0aW9uLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fSBlbHNlIGlmICggbC50eXBlID09IFwicG9pbnRcIiApIHtcblxuXHRcdFx0cCA9IGwucG9zaXRpb247XG5cdFx0XHRkID0gbC5kaXN0YW5jZTtcblxuXHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCggaGV4LCBpbnRlbnNpdHksIGQgKTtcblx0XHRcdGxpZ2h0LnBvc2l0aW9uLnNldCggcFswXSwgcFsxXSwgcFsyXSApO1xuXG5cdFx0fSBlbHNlIGlmICggbC50eXBlID09IFwiYW1iaWVudFwiICkge1xuXG5cdFx0XHRsaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoIGhleCApO1xuXG5cdFx0fVxuXG5cdFx0cmVzdWx0LnNjZW5lLmFkZCggbGlnaHQgKTtcblxuXHRcdHJlc3VsdC5saWdodHNbIGRsIF0gPSBsaWdodDtcblxuXHR9XG5cblx0Ly8gZm9nc1xuXG5cdGZvciggZGYgaW4gZGF0YS5mb2dzICkge1xuXG5cdFx0ZiA9IGRhdGEuZm9nc1sgZGYgXTtcblxuXHRcdGlmICggZi50eXBlID09IFwibGluZWFyXCIgKSB7XG5cblx0XHRcdGZvZyA9IG5ldyBUSFJFRS5Gb2coIDB4MDAwMDAwLCBmLm5lYXIsIGYuZmFyICk7XG5cblx0XHR9IGVsc2UgaWYgKCBmLnR5cGUgPT0gXCJleHAyXCIgKSB7XG5cblx0XHRcdGZvZyA9IG5ldyBUSFJFRS5Gb2dFeHAyKCAweDAwMDAwMCwgZi5kZW5zaXR5ICk7XG5cblx0XHR9XG5cblx0XHRjID0gZi5jb2xvcjtcblx0XHRmb2cuY29sb3Iuc2V0UkdCKCBjWzBdLCBjWzFdLCBjWzJdICk7XG5cblx0XHRyZXN1bHQuZm9nc1sgZGYgXSA9IGZvZztcblxuXHR9XG5cblx0Ly8gZGVmYXVsdHNcblxuXHRpZiAoIHJlc3VsdC5jYW1lcmFzICYmIGRhdGEuZGVmYXVsdHMuY2FtZXJhICkge1xuXG5cdFx0cmVzdWx0LmN1cnJlbnRDYW1lcmEgPSByZXN1bHQuY2FtZXJhc1sgZGF0YS5kZWZhdWx0cy5jYW1lcmEgXTtcblxuXHR9XG5cblx0aWYgKCByZXN1bHQuZm9ncyAmJiBkYXRhLmRlZmF1bHRzLmZvZyApIHtcblxuXHRcdHJlc3VsdC5zY2VuZS5mb2cgPSByZXN1bHQuZm9nc1sgZGF0YS5kZWZhdWx0cy5mb2cgXTtcblxuXHR9XG5cblx0YyA9IGRhdGEuZGVmYXVsdHMuYmdjb2xvcjtcblx0cmVzdWx0LmJnQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcblx0cmVzdWx0LmJnQ29sb3Iuc2V0UkdCKCBjWzBdLCBjWzFdLCBjWzJdICk7XG5cblx0cmVzdWx0LmJnQ29sb3JBbHBoYSA9IGRhdGEuZGVmYXVsdHMuYmdhbHBoYTtcblxuXHQvLyBub3cgY29tZSBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMgZWxlbWVudHNcblxuXHQvLyBnZW9tZXRyaWVzXG5cblx0Ly8gY291bnQgaG93IG1hbnkgbW9kZWxzIHdpbGwgYmUgbG9hZGVkIGFzeW5jaHJvbm91c2x5XG5cblx0Zm9yKCBkZyBpbiBkYXRhLmdlb21ldHJpZXMgKSB7XG5cblx0XHRnID0gZGF0YS5nZW9tZXRyaWVzWyBkZyBdO1xuXG5cdFx0aWYgKCBnLnR5cGUgPT0gXCJiaW5fbWVzaFwiIHx8IGcudHlwZSA9PSBcImFzY2lpX21lc2hcIiApIHtcblxuXHRcdFx0Y291bnRlcl9tb2RlbHMgKz0gMTtcblxuXHRcdFx0c2NvcGUub25Mb2FkU3RhcnQoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dG90YWxfbW9kZWxzID0gY291bnRlcl9tb2RlbHM7XG5cblx0Zm9yICggZGcgaW4gZGF0YS5nZW9tZXRyaWVzICkge1xuXG5cdFx0ZyA9IGRhdGEuZ2VvbWV0cmllc1sgZGcgXTtcblxuXHRcdGlmICggZy50eXBlID09IFwiY3ViZVwiICkge1xuXG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoIGcud2lkdGgsIGcuaGVpZ2h0LCBnLmRlcHRoLCBnLnNlZ21lbnRzV2lkdGgsIGcuc2VnbWVudHNIZWlnaHQsIGcuc2VnbWVudHNEZXB0aCwgbnVsbCwgZy5mbGlwcGVkLCBnLnNpZGVzICk7XG5cdFx0XHRyZXN1bHQuZ2VvbWV0cmllc1sgZGcgXSA9IGdlb21ldHJ5O1xuXG5cdFx0fSBlbHNlIGlmICggZy50eXBlID09IFwicGxhbmVcIiApIHtcblxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSggZy53aWR0aCwgZy5oZWlnaHQsIGcuc2VnbWVudHNXaWR0aCwgZy5zZWdtZW50c0hlaWdodCApO1xuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGRnIF0gPSBnZW9tZXRyeTtcblxuXHRcdH0gZWxzZSBpZiAoIGcudHlwZSA9PSBcInNwaGVyZVwiICkge1xuXG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggZy5yYWRpdXMsIGcuc2VnbWVudHNXaWR0aCwgZy5zZWdtZW50c0hlaWdodCApO1xuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGRnIF0gPSBnZW9tZXRyeTtcblxuXHRcdH0gZWxzZSBpZiAoIGcudHlwZSA9PSBcImN5bGluZGVyXCIgKSB7XG5cblx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIGcudG9wUmFkLCBnLmJvdFJhZCwgZy5oZWlnaHQsIGcucmFkU2VncywgZy5oZWlnaHRTZWdzICk7XG5cdFx0XHRyZXN1bHQuZ2VvbWV0cmllc1sgZGcgXSA9IGdlb21ldHJ5O1xuXG5cdFx0fSBlbHNlIGlmICggZy50eXBlID09IFwidG9ydXNcIiApIHtcblxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeSggZy5yYWRpdXMsIGcudHViZSwgZy5zZWdtZW50c1IsIGcuc2VnbWVudHNUICk7XG5cdFx0XHRyZXN1bHQuZ2VvbWV0cmllc1sgZGcgXSA9IGdlb21ldHJ5O1xuXG5cdFx0fSBlbHNlIGlmICggZy50eXBlID09IFwiaWNvc2FoZWRyb25cIiApIHtcblxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggZy5zdWJkaXZpc2lvbnMgKTtcblx0XHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBkZyBdID0gZ2VvbWV0cnk7XG5cblx0XHR9IGVsc2UgaWYgKCBnLnR5cGUgPT0gXCJiaW5fbWVzaFwiICkge1xuXG5cdFx0XHRiaW5Mb2FkZXIubG9hZCggZ2V0X3VybCggZy51cmwsIGRhdGEudXJsQmFzZVR5cGUgKSwgY3JlYXRlX2NhbGxiYWNrKCBkZyApICk7XG5cblx0XHR9IGVsc2UgaWYgKCBnLnR5cGUgPT0gXCJhc2NpaV9tZXNoXCIgKSB7XG5cblx0XHRcdGpzb25Mb2FkZXIubG9hZCggZ2V0X3VybCggZy51cmwsIGRhdGEudXJsQmFzZVR5cGUgKSwgY3JlYXRlX2NhbGxiYWNrKCBkZyApICk7XG5cblx0XHR9IGVsc2UgaWYgKCBnLnR5cGUgPT0gXCJlbWJlZGRlZF9tZXNoXCIgKSB7XG5cblx0XHRcdHZhciBtb2RlbEpzb24gPSBkYXRhLmVtYmVkc1sgZy5pZCBdLFxuXHRcdFx0XHR0ZXh0dXJlX3BhdGggPSBcIlwiO1xuXG5cdFx0XHRpZiAoIG1vZGVsSnNvbiApIHtcblxuXHRcdFx0XHRqc29uTG9hZGVyLmNyZWF0ZU1vZGVsKCBtb2RlbEpzb24sIGNyZWF0ZV9jYWxsYmFja19lbWJlZCggZGcgKSwgdGV4dHVyZV9wYXRoICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gdGV4dHVyZXNcblxuXHQvLyBjb3VudCBob3cgbWFueSB0ZXh0dXJlcyB3aWxsIGJlIGxvYWRlZCBhc3luY2hyb25vdXNseVxuXG5cdGZvciggZHQgaW4gZGF0YS50ZXh0dXJlcyApIHtcblxuXHRcdHR0ID0gZGF0YS50ZXh0dXJlc1sgZHQgXTtcblxuXHRcdGlmKCB0dC51cmwgaW5zdGFuY2VvZiBBcnJheSApIHtcblxuXHRcdFx0Y291bnRlcl90ZXh0dXJlcyArPSB0dC51cmwubGVuZ3RoO1xuXG5cdFx0XHRmb3IoIHZhciBuID0gMDsgbiA8IHR0LnVybC5sZW5ndGg7IG4gKysgKSB7XG5cblx0XHRcdFx0c2NvcGUub25Mb2FkU3RhcnQoKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y291bnRlcl90ZXh0dXJlcyArPSAxO1xuXG5cdFx0XHRzY29wZS5vbkxvYWRTdGFydCgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0b3RhbF90ZXh0dXJlcyA9IGNvdW50ZXJfdGV4dHVyZXM7XG5cblx0Zm9yKCBkdCBpbiBkYXRhLnRleHR1cmVzICkge1xuXG5cdFx0dHQgPSBkYXRhLnRleHR1cmVzWyBkdCBdO1xuXG5cdFx0aWYgKCB0dC5tYXBwaW5nICE9IHVuZGVmaW5lZCAmJiBUSFJFRVsgdHQubWFwcGluZyBdICE9IHVuZGVmaW5lZCAgKSB7XG5cblx0XHRcdHR0Lm1hcHBpbmcgPSBuZXcgVEhSRUVbIHR0Lm1hcHBpbmcgXSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYoIHR0LnVybCBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG5cdFx0XHR2YXIgdXJsX2FycmF5ID0gW107XG5cblx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgdHQudXJsLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR1cmxfYXJyYXlbIGkgXSA9IGdldF91cmwoIHR0LnVybFsgaSBdLCBkYXRhLnVybEJhc2VUeXBlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlKCB1cmxfYXJyYXksIHR0Lm1hcHBpbmcsIGNhbGxiYWNrVGV4dHVyZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGV4dHVyZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoIGdldF91cmwoIHR0LnVybCwgZGF0YS51cmxCYXNlVHlwZSApLCB0dC5tYXBwaW5nLCBjYWxsYmFja1RleHR1cmUgKTtcblxuXHRcdFx0aWYgKCBUSFJFRVsgdHQubWluRmlsdGVyIF0gIT0gdW5kZWZpbmVkIClcblx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRVsgdHQubWluRmlsdGVyIF07XG5cblx0XHRcdGlmICggVEhSRUVbIHR0Lm1hZ0ZpbHRlciBdICE9IHVuZGVmaW5lZCApXG5cdFx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gVEhSRUVbIHR0Lm1hZ0ZpbHRlciBdO1xuXG5cblx0XHRcdGlmICggdHQucmVwZWF0ICkge1xuXG5cdFx0XHRcdHRleHR1cmUucmVwZWF0LnNldCggdHQucmVwZWF0WyAwIF0sIHR0LnJlcGVhdFsgMSBdICk7XG5cblx0XHRcdFx0aWYgKCB0dC5yZXBlYXRbIDAgXSAhPSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0XHRpZiAoIHR0LnJlcGVhdFsgMSBdICE9IDEgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0dC5vZmZzZXQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5vZmZzZXQuc2V0KCB0dC5vZmZzZXRbIDAgXSwgdHQub2Zmc2V0WyAxIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBoYW5kbGUgd3JhcCBhZnRlciByZXBlYXQgc28gdGhhdCBkZWZhdWx0IHJlcGVhdCBjYW4gYmUgb3ZlcnJpZGVuXG5cblx0XHRcdGlmICggdHQud3JhcCApIHtcblxuXHRcdFx0XHR2YXIgd3JhcE1hcCA9IHtcblx0XHRcdFx0XCJyZXBlYXRcIiBcdDogVEhSRUUuUmVwZWF0V3JhcHBpbmcsXG5cdFx0XHRcdFwibWlycm9yXCJcdDogVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB3cmFwTWFwWyB0dC53cmFwWyAwIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwUyA9IHdyYXBNYXBbIHR0LndyYXBbIDAgXSBdO1xuXHRcdFx0XHRpZiAoIHdyYXBNYXBbIHR0LndyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBUID0gd3JhcE1hcFsgdHQud3JhcFsgMSBdIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJlc3VsdC50ZXh0dXJlc1sgZHQgXSA9IHRleHR1cmU7XG5cblx0fVxuXG5cdC8vIG1hdGVyaWFsc1xuXG5cdGZvciAoIGRtIGluIGRhdGEubWF0ZXJpYWxzICkge1xuXG5cdFx0bSA9IGRhdGEubWF0ZXJpYWxzWyBkbSBdO1xuXG5cdFx0Zm9yICggcHAgaW4gbS5wYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRpZiAoIHBwID09IFwiZW52TWFwXCIgfHwgcHAgPT0gXCJtYXBcIiB8fCBwcCA9PSBcImxpZ2h0TWFwXCIgKSB7XG5cblx0XHRcdFx0bS5wYXJhbWV0ZXJzWyBwcCBdID0gcmVzdWx0LnRleHR1cmVzWyBtLnBhcmFtZXRlcnNbIHBwIF0gXTtcblxuXHRcdFx0fSBlbHNlIGlmICggcHAgPT0gXCJzaGFkaW5nXCIgKSB7XG5cblx0XHRcdFx0bS5wYXJhbWV0ZXJzWyBwcCBdID0gKCBtLnBhcmFtZXRlcnNbIHBwIF0gPT0gXCJmbGF0XCIgKSA/IFRIUkVFLkZsYXRTaGFkaW5nIDogVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHRcdFx0fSBlbHNlIGlmICggcHAgPT0gXCJibGVuZGluZ1wiICkge1xuXG5cdFx0XHRcdG0ucGFyYW1ldGVyc1sgcHAgXSA9IFRIUkVFWyBtLnBhcmFtZXRlcnNbIHBwIF0gXSA/IFRIUkVFWyBtLnBhcmFtZXRlcnNbIHBwIF0gXSA6IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwcCA9PSBcImNvbWJpbmVcIiApIHtcblxuXHRcdFx0XHRtLnBhcmFtZXRlcnNbIHBwIF0gPSAoIG0ucGFyYW1ldGVyc1sgcHAgXSA9PSBcIk1peE9wZXJhdGlvblwiICkgPyBUSFJFRS5NaXhPcGVyYXRpb24gOiBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblxuXHRcdFx0fSBlbHNlIGlmICggcHAgPT0gXCJ2ZXJ0ZXhDb2xvcnNcIiApIHtcblxuXHRcdFx0XHRpZiAoIG0ucGFyYW1ldGVyc1sgcHAgXSA9PSBcImZhY2VcIiApIHtcblxuXHRcdFx0XHRcdG0ucGFyYW1ldGVyc1sgcHAgXSA9IFRIUkVFLkZhY2VDb2xvcnM7XG5cblx0XHRcdFx0Ly8gZGVmYXVsdCB0byB2ZXJ0ZXggY29sb3JzIGlmIFwidmVydGV4Q29sb3JzXCIgaXMgYW55dGhpbmcgZWxzZSBmYWNlIGNvbG9ycyBvciAwIC8gbnVsbCAvIGZhbHNlXG5cblx0XHRcdFx0fSBlbHNlIGlmICggbS5wYXJhbWV0ZXJzWyBwcCBdICkgICB7XG5cblx0XHRcdFx0XHRtLnBhcmFtZXRlcnNbIHBwIF0gPSBUSFJFRS5WZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG0ucGFyYW1ldGVycy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgbS5wYXJhbWV0ZXJzLm9wYWNpdHkgPCAxLjAgKSB7XG5cblx0XHRcdG0ucGFyYW1ldGVycy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0ucGFyYW1ldGVycy5ub3JtYWxNYXAgKSB7XG5cblx0XHRcdHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJVdGlscy5saWJbIFwibm9ybWFsXCIgXTtcblx0XHRcdHZhciB1bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG5cdFx0XHR2YXIgZGlmZnVzZSA9IG0ucGFyYW1ldGVycy5jb2xvcjtcblx0XHRcdHZhciBzcGVjdWxhciA9IG0ucGFyYW1ldGVycy5zcGVjdWxhcjtcblx0XHRcdHZhciBhbWJpZW50ID0gbS5wYXJhbWV0ZXJzLmFtYmllbnQ7XG5cdFx0XHR2YXIgc2hpbmluZXNzID0gbS5wYXJhbWV0ZXJzLnNoaW5pbmVzcztcblxuXHRcdFx0dW5pZm9ybXNbIFwidE5vcm1hbFwiIF0udGV4dHVyZSA9IHJlc3VsdC50ZXh0dXJlc1sgbS5wYXJhbWV0ZXJzLm5vcm1hbE1hcCBdO1xuXG5cdFx0XHRpZiAoIG0ucGFyYW1ldGVycy5ub3JtYWxNYXBGYWN0b3IgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXNbIFwidU5vcm1hbFNjYWxlXCIgXS52YWx1ZSA9IG0ucGFyYW1ldGVycy5ub3JtYWxNYXBGYWN0b3I7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtLnBhcmFtZXRlcnMubWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zWyBcInREaWZmdXNlXCIgXS50ZXh0dXJlID0gbS5wYXJhbWV0ZXJzLm1hcDtcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlRGlmZnVzZVwiIF0udmFsdWUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbS5wYXJhbWV0ZXJzLmxpZ2h0TWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zWyBcInRBT1wiIF0udGV4dHVyZSA9IG0ucGFyYW1ldGVycy5saWdodE1hcDtcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlQU9cIiBdLnZhbHVlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG0ucGFyYW1ldGVycy5zcGVjdWxhck1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0U3BlY3VsYXJcIiBdLnRleHR1cmUgPSByZXN1bHQudGV4dHVyZXNbIG0ucGFyYW1ldGVycy5zcGVjdWxhck1hcCBdO1xuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVTcGVjdWxhclwiIF0udmFsdWUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHVuaWZvcm1zWyBcInVEaWZmdXNlQ29sb3JcIiBdLnZhbHVlLnNldEhleCggZGlmZnVzZSApO1xuXHRcdFx0dW5pZm9ybXNbIFwidVNwZWN1bGFyQ29sb3JcIiBdLnZhbHVlLnNldEhleCggc3BlY3VsYXIgKTtcblx0XHRcdHVuaWZvcm1zWyBcInVBbWJpZW50Q29sb3JcIiBdLnZhbHVlLnNldEhleCggYW1iaWVudCApO1xuXG5cdFx0XHR1bmlmb3Jtc1sgXCJ1U2hpbmluZXNzXCIgXS52YWx1ZSA9IHNoaW5pbmVzcztcblxuXHRcdFx0aWYgKCBtLnBhcmFtZXRlcnMub3BhY2l0eSApIHtcblxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ1T3BhY2l0eVwiIF0udmFsdWUgPSBtLnBhcmFtZXRlcnMub3BhY2l0eTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHsgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogdW5pZm9ybXMsIGxpZ2h0czogdHJ1ZSwgZm9nOiB0cnVlIH07XG5cblx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRVsgbS50eXBlIF0oIG0ucGFyYW1ldGVycyApO1xuXG5cdFx0fVxuXG5cdFx0cmVzdWx0Lm1hdGVyaWFsc1sgZG0gXSA9IG1hdGVyaWFsO1xuXG5cdH1cblxuXHQvLyBvYmplY3RzICggc3luY2hyb25vdXMgaW5pdCBvZiBwcm9jZWR1cmFsIHByaW1pdGl2ZXMgKVxuXG5cdGhhbmRsZV9vYmplY3RzKCk7XG5cblx0Ly8gc3luY2hyb25vdXMgY2FsbGJhY2tcblxuXHRzY29wZS5jYWxsYmFja1N5bmMoIHJlc3VsdCApO1xuXG5cdC8vIGp1c3QgaW4gY2FzZSB0aGVyZSBhcmUgbm8gYXN5bmMgZWxlbWVudHM6XG5cdGFzeW5jX2NhbGxiYWNrX2dhdGUoKTtcblxuXG59O1xuLyoqXG4gKiBMb2FkZXIgZm9yIFVURjggZW5jb2RlZCBtb2RlbHMgZ2VuZXJhdGVkIGJ5OlxuICpcdGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1sb2FkZXIvXG4gKlxuICogTGltaXRhdGlvbnM6XG4gKiAgLSBudW1iZXIgb2YgdmVydGljZXMgPCA2NTUzNiAodGhpcyBpcyBhZnRlciBvcHRpbWl6YXRpb25zIGluIGNvbXByZXNzb3IsIGlucHV0IE9CSiBtYXkgaGF2ZSBldmVuIGxlc3MpXG4gKlx0LSBtb2RlbHMgbXVzdCBoYXZlIG5vcm1hbHMgYW5kIHRleHR1cmUgY29vcmRpbmF0ZXNcbiAqICAtIHRleHR1cmUgY29vcmRpbmF0ZXMgbXVzdCBiZSBvbmx5IGZyb20gPDAsMT5cbiAqICAtIG5vIG1hdGVyaWFscyBzdXBwb3J0IHlldFxuICogIC0gbW9kZWxzIGFyZSBzY2FsZWQgYW5kIG9mZnNldCAoY29weSBudW1iZXJzIGZyb20gY29tcHJlc3NvciBhbmQgdXNlIHRoZW0gYXMgcGFyYW1ldGVycyBpbiBVVEY4TG9hZGVyLmxvYWQoKSApXG4gKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Igd29uM2QgLyBodHRwOi8vdHdpdHRlci5jb20vd29uM2RcbiAqL1xuXG5USFJFRS5VVEY4TG9hZGVyID0gZnVuY3Rpb24gKCApIHtcblxufTtcblxuVEhSRUUuVVRGOExvYWRlci5wcm90b3R5cGUgPSBuZXcgVEhSRUUuVVRGOExvYWRlcigpO1xuVEhSRUUuVVRGOExvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5VVEY4TG9hZGVyO1xuXG5cbi8vIExvYWQgVVRGOCBjb21wcmVzc2VkIG1vZGVscyBnZW5lcmF0ZWQgYnkgb2JqY29tcHJlc3Ncbi8vICAtIHBhcmFtZXRlcnNcbi8vXHRcdC0gdXJsIChyZXF1aXJlZClcbi8vXHRcdC0gY2FsbGJhY2sgKHJlcXVpcmVkKVxuLy9cdFx0LSBtZXRhRGF0YSAob3B0aW9uYWwpXG5cblRIUkVFLlVURjhMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBjYWxsYmFjaywgbWV0YURhdGEgKSB7XG5cblx0aWYgKCB1cmwgaW5zdGFuY2VvZiBPYmplY3QgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBVVEY4TG9hZGVyKCBwYXJhbWV0ZXJzICkgaXMgbm93IFVURjhMb2FkZXIoIHVybCwgY2FsbGJhY2ssIG1ldGFEYXRhICkuJyApO1xuXG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB1cmw7XG5cblx0XHR1cmwgPSBwYXJhbWV0ZXJzLm1vZGVsO1xuXHRcdGNhbGxiYWNrID0gcGFyYW1ldGVycy5jYWxsYmFjaztcblx0XHRtZXRhRGF0YSA9IHsgc2NhbGU6IHBhcmFtZXRlcnMuc2NhbGUsIG9mZnNldFg6IHBhcmFtZXRlcnMub2Zmc2V0WCwgb2Zmc2V0WTogcGFyYW1ldGVycy5vZmZzZXRZLCBvZmZzZXRaOiBwYXJhbWV0ZXJzLm9mZnNldFogfTtcblxuXHR9XG5cblx0dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuXHRcdGNhbGxiYWNrUHJvZ3Jlc3MgPSBudWxsLFxuXG5cdFx0c2NhbGUgPSBtZXRhRGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkID8gbWV0YURhdGEuc2NhbGUgOiAxLFxuXHRcdG9mZnNldFggPSBtZXRhRGF0YS5vZmZzZXRYICE9PSB1bmRlZmluZWQgPyBtZXRhRGF0YS5vZmZzZXRYIDogMCxcblx0XHRvZmZzZXRZID0gbWV0YURhdGEub2Zmc2V0WSAhPT0gdW5kZWZpbmVkID8gbWV0YURhdGEub2Zmc2V0WSA6IDAsXG5cdFx0b2Zmc2V0WiA9IG1ldGFEYXRhLm9mZnNldFogIT09IHVuZGVmaW5lZCA/IG1ldGFEYXRhLm9mZnNldFogOiAwO1xuXG5cdHZhciBsZW5ndGggPSAwO1xuXG5cdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT0gNCApIHtcblxuXHRcdFx0aWYgKCB4aHIuc3RhdHVzID09IDIwMCB8fCB4aHIuc3RhdHVzID09IDAgKSB7XG5cblx0XHRcdFx0VEhSRUUuVVRGOExvYWRlci5wcm90b3R5cGUuY3JlYXRlTW9kZWwoIHhoci5yZXNwb25zZVRleHQsIGNhbGxiYWNrLCBzY2FsZSwgb2Zmc2V0WCwgb2Zmc2V0WSwgb2Zmc2V0WiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGFsZXJ0KCBcIkNvdWxkbid0IGxvYWQgW1wiICsgdXJsICsgXCJdIFtcIiArIHhoci5zdGF0dXMgKyBcIl1cIiApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PSAzICkge1xuXG5cdFx0XHRpZiAoIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XG5cblx0XHRcdFx0aWYgKCBsZW5ndGggPT0gMCApIHtcblxuXHRcdFx0XHRcdGxlbmd0aCA9IHhoci5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LUxlbmd0aFwiICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrUHJvZ3Jlc3MoIHsgdG90YWw6IGxlbmd0aCwgbG9hZGVkOiB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aCB9ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09IDIgKSB7XG5cblx0XHRcdGxlbmd0aCA9IHhoci5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LUxlbmd0aFwiICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHhoci5vcGVuKCBcIkdFVFwiLCB1cmwsIHRydWUgKTtcblx0eGhyLnNlbmQoIG51bGwgKTtcblxufTtcblxuLy8gVVRGLTggZGVjb2RlciBmcm9tIHdlYmdsLWxvYWRlclxuLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYmdsLWxvYWRlci9cblxuLy8gQ29weXJpZ2h0IDIwMTEgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3Vcbi8vIG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3Vcbi8vIG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yXG4vLyBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmdcbi8vIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuVEhSRUUuVVRGOExvYWRlci5wcm90b3R5cGUuZGVjb21wcmVzc01lc2ggPSBmdW5jdGlvbiAoIHN0ciApIHtcblxuXHR2YXIgbnVtX3ZlcnRzID0gc3RyLmNoYXJDb2RlQXQoIDAgKTtcblxuXHRpZiAoIG51bV92ZXJ0cyA+PSAweEUwMDAgKSB7XG5cblx0XHRudW1fdmVydHMgLT0gMHgwODAwO1xuXG5cdH1cblxuXHRudW1fdmVydHMgKys7XG5cblx0dmFyIGF0dHJpYnNfb3V0ID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIG51bV92ZXJ0cyApO1xuXG5cdHZhciBvZmZzZXQgPSAxO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XG5cblx0XHR2YXIgcHJldl9hdHRyaWIgPSAwO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbnVtX3ZlcnRzOyArKyBqICkge1xuXG5cdFx0XHR2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCBqICsgb2Zmc2V0ICk7XG5cblx0XHRcdHByZXZfYXR0cmliICs9ICggY29kZSA+PiAxICkgXiAoIC0gKCBjb2RlICYgMSApICk7XG5cblx0XHRcdGF0dHJpYnNfb3V0WyA4ICogaiArIGkgXSA9IHByZXZfYXR0cmliO1xuXG5cdFx0fVxuXG5cdFx0b2Zmc2V0ICs9IG51bV92ZXJ0cztcblxuXHR9XG5cblx0dmFyIG51bV9pbmRpY2VzID0gc3RyLmxlbmd0aCAtIG9mZnNldDtcblxuXHR2YXIgaW5kaWNlc19vdXQgPSBuZXcgVWludDE2QXJyYXkoIG51bV9pbmRpY2VzICk7XG5cblx0dmFyIGluZGV4X2hpZ2hfd2F0ZXJfbWFyayA9IDA7XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbnVtX2luZGljZXM7IGkgKysgKSB7XG5cblx0XHR2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCBpICsgb2Zmc2V0ICk7XG5cblx0XHRpbmRpY2VzX291dFsgaSBdID0gaW5kZXhfaGlnaF93YXRlcl9tYXJrIC0gY29kZTtcblxuXHRcdGlmICggY29kZSA9PSAwICkge1xuXG5cdFx0XHRpbmRleF9oaWdoX3dhdGVyX21hcmsgKys7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBbIGF0dHJpYnNfb3V0LCBpbmRpY2VzX291dCBdO1xuXG59O1xuXG5USFJFRS5VVEY4TG9hZGVyLnByb3RvdHlwZS5jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uICggZGF0YSwgY2FsbGJhY2ssIHNjYWxlLCBvZmZzZXRYLCBvZmZzZXRZLCBvZmZzZXRaICkge1xuXG5cdHZhciBNb2RlbCA9IGZ1bmN0aW9uICggdGV4dHVyZV9wYXRoICkge1xuXG5cdFx0Ly92YXIgcyA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHNjb3BlLm1hdGVyaWFscyA9IFtdO1xuXG5cdFx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dmFyIGJ1ZmZlcnMgPSBUSFJFRS5VVEY4TG9hZGVyLnByb3RvdHlwZS5kZWNvbXByZXNzTWVzaCggZGF0YSApO1xuXG5cdFx0dmFyIG5vcm1hbHMgPSBbXSxcblx0XHRcdHV2cyA9IFtdO1xuXG5cdFx0aW5pdF92ZXJ0aWNlcyggYnVmZmVyc1sgMCBdLCA4LCAwICk7XG5cdFx0aW5pdF91dnMoIGJ1ZmZlcnNbIDAgXSwgOCwgMyApO1xuXHRcdGluaXRfbm9ybWFscyggYnVmZmVyc1sgMCBdLCA4LCA1ICk7XG5cblx0XHRpbml0X2ZhY2VzKCBidWZmZXJzWyAxIF0gKTtcblxuXHRcdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xuXHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdFx0Ly90aGlzLmNvbXB1dGVUYW5nZW50cygpO1xuXG5cdFx0Ly92YXIgZSA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggXCJ1dGY4IGRhdGEgcGFyc2UgdGltZTogXCIgKyAoZS1zKSArIFwiIG1zXCIgKTtcblxuXHRcdGZ1bmN0aW9uIGluaXRfdmVydGljZXMoIGRhdGEsIHN0cmlkZSwgb2Zmc2V0ICkge1xuXG5cdFx0XHR2YXIgaSwgeCwgeSwgeixcblx0XHRcdFx0ZW5kID0gZGF0YS5sZW5ndGg7XG5cblx0XHRcdGZvciggaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSBzdHJpZGUgKSB7XG5cblx0XHRcdFx0eCA9IGRhdGFbIGkgXTtcblx0XHRcdFx0eSA9IGRhdGFbIGkgKyAxIF07XG5cdFx0XHRcdHogPSBkYXRhWyBpICsgMiBdO1xuXG5cdFx0XHRcdC8vIGZpeCBzY2FsZSBhbmQgb2Zmc2V0c1xuXG5cdFx0XHRcdHggPSAoIHggLyAxNjM4MyApICogc2NhbGU7XG5cdFx0XHRcdHkgPSAoIHkgLyAxNjM4MyApICogc2NhbGU7XG5cdFx0XHRcdHogPSAoIHogLyAxNjM4MyApICogc2NhbGU7XG5cblx0XHRcdFx0eCArPSBvZmZzZXRYO1xuXHRcdFx0XHR5ICs9IG9mZnNldFk7XG5cdFx0XHRcdHogKz0gb2Zmc2V0WjtcblxuXHRcdFx0XHR2ZXJ0ZXgoIHNjb3BlLCB4LCB5LCB6ICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0X25vcm1hbHMoIGRhdGEsIHN0cmlkZSwgb2Zmc2V0ICkge1xuXG5cdFx0XHR2YXIgaSwgeCwgeSwgeixcblx0XHRcdFx0ZW5kID0gZGF0YS5sZW5ndGg7XG5cblx0XHRcdGZvciggaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSBzdHJpZGUgKSB7XG5cblx0XHRcdFx0eCA9IGRhdGFbIGkgXTtcblx0XHRcdFx0eSA9IGRhdGFbIGkgKyAxIF07XG5cdFx0XHRcdHogPSBkYXRhWyBpICsgMiBdO1xuXG5cdFx0XHRcdC8vIG5vcm1hbGl6ZSB0byA8LTEsMT5cblxuXHRcdFx0XHR4ID0gKCB4IC0gNTEyICkgLyA1MTE7XG5cdFx0XHRcdHkgPSAoIHkgLSA1MTIgKSAvIDUxMTtcblx0XHRcdFx0eiA9ICggeiAtIDUxMiApIC8gNTExO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggeCwgeSwgeiApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdF91dnMoIGRhdGEsIHN0cmlkZSwgb2Zmc2V0ICkge1xuXG5cdFx0XHR2YXIgaSwgdSwgdixcblx0XHRcdFx0ZW5kID0gZGF0YS5sZW5ndGg7XG5cblx0XHRcdGZvciggaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSBzdHJpZGUgKSB7XG5cblx0XHRcdFx0dSA9IGRhdGFbIGkgXTtcblx0XHRcdFx0diA9IGRhdGFbIGkgKyAxIF07XG5cblx0XHRcdFx0Ly8gbm9ybWFsaXplIHRvIDwwLDE+XG5cblx0XHRcdFx0dSAvPSAxMDIzO1xuXHRcdFx0XHR2IC89IDEwMjM7XG5cblx0XHRcdFx0dXZzLnB1c2goIHUsIDEgLSB2ICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0X2ZhY2VzKCBpbmRpY2VzICkge1xuXG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0YSwgYiwgYyxcblx0XHRcdFx0dTEsIHYxLCB1MiwgdjIsIHUzLCB2Myxcblx0XHRcdFx0bSxcblx0XHRcdFx0ZW5kID0gaW5kaWNlcy5sZW5ndGg7XG5cblx0XHRcdG0gPSAwOyAvLyBhbGwgZmFjZXMgZGVmYXVsdGluZyB0byBtYXRlcmlhbCAwXG5cblx0XHRcdGZvciggaSA9IDA7IGkgPCBlbmQ7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRhID0gaW5kaWNlc1sgaSBdO1xuXHRcdFx0XHRiID0gaW5kaWNlc1sgaSArIDEgXTtcblx0XHRcdFx0YyA9IGluZGljZXNbIGkgKyAyIF07XG5cblx0XHRcdFx0ZjNuKCBzY29wZSwgbm9ybWFscywgYSwgYiwgYywgbSwgYSwgYiwgYyApO1xuXG5cdFx0XHRcdHUxID0gdXZzWyBhICogMiBdO1xuXHRcdFx0XHR2MSA9IHV2c1sgYSAqIDIgKyAxIF07XG5cblx0XHRcdFx0dTIgPSB1dnNbIGIgKiAyIF07XG5cdFx0XHRcdHYyID0gdXZzWyBiICogMiArIDEgXTtcblxuXHRcdFx0XHR1MyA9IHV2c1sgYyAqIDIgXTtcblx0XHRcdFx0djMgPSB1dnNbIGMgKiAyICsgMSBdO1xuXG5cdFx0XHRcdHV2Myggc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLCB1MSwgdjEsIHUyLCB2MiwgdTMsIHYzICk7XG5cblx0XHRcdH1cblxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gdmVydGV4ICggc2NvcGUsIHgsIHksIHogKSB7XG5cblx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGYzbiAoIHNjb3BlLCBub3JtYWxzLCBhLCBiLCBjLCBtaSwgbmEsIG5iLCBuYyApIHtcblxuXHRcdHZhciBtYXRlcmlhbCA9IHNjb3BlLm1hdGVyaWFsc1sgbWkgXSxcblxuXHRcdFx0bmF4ID0gbm9ybWFsc1sgbmEgKiAzICAgICBdLFxuXHRcdFx0bmF5ID0gbm9ybWFsc1sgbmEgKiAzICsgMSBdLFxuXHRcdFx0bmF6ID0gbm9ybWFsc1sgbmEgKiAzICsgMiBdLFxuXG5cdFx0XHRuYnggPSBub3JtYWxzWyBuYiAqIDMgICAgIF0sXG5cdFx0XHRuYnkgPSBub3JtYWxzWyBuYiAqIDMgKyAxIF0sXG5cdFx0XHRuYnogPSBub3JtYWxzWyBuYiAqIDMgKyAyIF0sXG5cblx0XHRcdG5jeCA9IG5vcm1hbHNbIG5jICogMyAgICAgXSxcblx0XHRcdG5jeSA9IG5vcm1hbHNbIG5jICogMyArIDEgXSxcblx0XHRcdG5jeiA9IG5vcm1hbHNbIG5jICogMyArIDIgXTtcblxuXHRcdHZhciBuYSA9IG5ldyBUSFJFRS5WZWN0b3IzKCBuYXgsIG5heSwgbmF6ICksXG5cdFx0XHRuYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCBuYngsIG5ieSwgbmJ6ICksXG5cdFx0XHRuYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCBuY3gsIG5jeSwgbmN6ICk7XG5cblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFsgbmEsIG5iLCBuYyBdLCBudWxsLCBtYXRlcmlhbCApICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiB1djMgKCB3aGVyZSwgdTEsIHYxLCB1MiwgdjIsIHUzLCB2MyApIHtcblxuXHRcdHZhciB1diA9IFtdO1xuXHRcdHV2LnB1c2goIG5ldyBUSFJFRS5VViggdTEsIHYxICkgKTtcblx0XHR1di5wdXNoKCBuZXcgVEhSRUUuVVYoIHUyLCB2MiApICk7XG5cdFx0dXYucHVzaCggbmV3IFRIUkVFLlVWKCB1MywgdjMgKSApO1xuXHRcdHdoZXJlLnB1c2goIHV2ICk7XG5cblx0fTtcblxuXG5cdE1vZGVsLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2RlbDtcblxuXHRjYWxsYmFjayggbmV3IE1vZGVsKCkgKTtcblxufTtcbi8qKlxuICogQGF1dGhvciBzcm91Y2hlcmF5IC8gaHR0cDovL3Nyb3VjaGVyYXkub3JnL1xuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXhlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dmFyIGxpbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRsaW5lR2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlcnRleCgpICk7XG5cdGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVydGV4KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMTAwLCAwICkgKSApO1xuXG5cdHZhciBjb25lR2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgNSwgMjUsIDUsIDEgKTtcblxuXHQvLyB4XG5cblx0dmFyIGxpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3IgOiAweGZmMDAwMCB9ICkgKTtcblx0bGluZS5yb3RhdGlvbi56ID0gLSBNYXRoLlBJIC8gMjtcblx0dGhpcy5hZGQoIGxpbmUgKTtcblxuXHR2YXIgY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBjb25lR2VvbWV0cnksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvciA6IDB4ZmYwMDAwIH0gKSApO1xuXHRjb25lLnBvc2l0aW9uLnggPSAxMDA7XG5cdGNvbmUucm90YXRpb24ueiA9IC0gTWF0aC5QSSAvIDI7XG5cdHRoaXMuYWRkKCBjb25lICk7XG5cblx0Ly8geVxuXG5cdHZhciBsaW5lID0gbmV3IFRIUkVFLkxpbmUoIGxpbmVHZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yIDogMHgwMGZmMDAgfSApICk7XG5cdHRoaXMuYWRkKCBsaW5lICk7XG5cblx0dmFyIGNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3IgOiAweDAwZmYwMCB9ICkgKTtcblx0Y29uZS5wb3NpdGlvbi55ID0gMTAwO1xuXHR0aGlzLmFkZCggY29uZSApO1xuXG5cdC8vIHpcblxuXHR2YXIgbGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvciA6IDB4MDAwMGZmIH0gKSApO1xuXHRsaW5lLnJvdGF0aW9uLnggPSBNYXRoLlBJIC8gMjtcblx0dGhpcy5hZGQoIGxpbmUgKTtcblxuXHR2YXIgY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBjb25lR2VvbWV0cnksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvciA6IDB4MDAwMGZmIH0gKSApO1xuXHRjb25lLnBvc2l0aW9uLnogPSAxMDA7XG5cdGNvbmUucm90YXRpb24ueCA9IE1hdGguUEkgLyAyO1xuXHR0aGlzLmFkZCggY29uZSApO1xuXG59O1xuXG5USFJFRS5BeGVzLnByb3RvdHlwZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuVEhSRUUuQXhlcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BeGVzO1xuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIFBvcnQgb2YgZ3JlZ2dtYW4ncyBUaHJlZUQgdmVyc2lvbiBvZiBtYXJjaGluZyBjdWJlcyB0byBUaHJlZS5qc1xyXG4gKiBodHRwOi8vd2ViZ2xzYW1wbGVzLmdvb2dsZWNvZGUuY29tL2hnL2Jsb2IvYmxvYi5odG1sXHJcbiAqL1xyXG5cclxuLy8gZG8gbm90IGNyYXNoIGlmIHNvbWVib2R5IGluY2x1ZGVzIHRoZSBmaWxlIGluIG9sZGllIGJyb3dzZXJcclxuXHJcblRIUkVFLk1hcmNoaW5nQ3ViZXMgPSBmdW5jdGlvbiAoIHJlc29sdXRpb24sIG1hdGVyaWFscyApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFscyA9IG1hdGVyaWFscyBpbnN0YW5jZW9mIEFycmF5ID8gbWF0ZXJpYWxzIDogWyBtYXRlcmlhbHMgXTtcclxuXHJcblx0Ly8gZnVuY3Rpb25zIGhhdmUgdG8gYmUgb2JqZWN0IHByb3BlcnRpZXNcclxuXHQvLyBwcm90b3R5cGUgZnVuY3Rpb25zIGtpbGwgcGVyZm9ybWFuY2VcclxuXHQvLyAodGVzdGVkIGFuZCBpdCB3YXMgNHggc2xvd2VyICEhISlcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24oIHJlc29sdXRpb24gKSB7XHJcblxyXG5cdFx0Ly8gcGFyYW1ldGVyc1xyXG5cclxuXHRcdHRoaXMuaXNvbGF0aW9uID0gODAuMDtcclxuXHJcblx0XHQvLyBzaXplIG9mIGZpZWxkLCAzMiBpcyBwdXNoaW5nIGl0IGluIEphdmFzY3JpcHQgOilcclxuXHJcblx0XHR0aGlzLnNpemUgPSByZXNvbHV0aW9uO1xyXG5cdFx0dGhpcy5zaXplMiA9IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTtcclxuXHRcdHRoaXMuc2l6ZTMgPSB0aGlzLnNpemUyICogdGhpcy5zaXplO1xyXG5cdFx0dGhpcy5oYWxmc2l6ZSA9IHRoaXMuc2l6ZSAvIDIuMDtcclxuXHJcblx0XHQvLyBkZWx0YXNcclxuXHJcblx0XHR0aGlzLmRlbHRhID0gMi4wIC8gdGhpcy5zaXplO1xyXG5cdFx0dGhpcy55ZCA9IHRoaXMuc2l6ZTtcclxuXHRcdHRoaXMuemQgPSB0aGlzLnNpemUyO1xyXG5cclxuXHRcdHRoaXMuZmllbGQgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLnNpemUzICk7XHJcblx0XHR0aGlzLm5vcm1hbF9jYWNoZSA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuc2l6ZTMgKiAzICk7XHJcblxyXG5cdFx0Ly8gdGVtcCBidWZmZXJzIHVzZWQgaW4gcG9seWdvbml6ZVxyXG5cclxuXHRcdHRoaXMudmxpc3QgPSBuZXcgRmxvYXQzMkFycmF5KCAxMiAqIDMgKTtcclxuXHRcdHRoaXMubmxpc3QgPSBuZXcgRmxvYXQzMkFycmF5KCAxMiAqIDMgKTtcclxuXHJcblx0XHR0aGlzLmZpcnN0RHJhdyA9IHRydWU7XHJcblxyXG5cdFx0Ly8gaW1tZWRpYXRlIHJlbmRlciBtb2RlIHNpbXVsYXRvclxyXG5cclxuXHRcdHRoaXMubWF4Q291bnQgPSA0MDk2OyAvLyBUT0RPOiBmaW5kIHRoZSBmYXN0ZXN0IHNpemUgZm9yIHRoaXMgYnVmZmVyXHJcblx0XHR0aGlzLmNvdW50ID0gMDtcclxuXHRcdHRoaXMuaGFzUG9zID0gZmFsc2U7XHJcblx0XHR0aGlzLmhhc05vcm1hbCA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb25BcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMubWF4Q291bnQgKiAzICk7XHJcblx0XHR0aGlzLm5vcm1hbEFycmF5ICAgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLm1heENvdW50ICogMyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cdC8vIFBvbHlnb25pemF0aW9uXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblx0dGhpcy5sZXJwID0gZnVuY3Rpb24oIGEsIGIsIHQgKSB7IHJldHVybiBhICsgKCBiIC0gYSApICogdDsgfTtcclxuXHJcblx0dGhpcy5WSW50WCA9IGZ1bmN0aW9uKCBxLCBwb3V0LCBub3V0LCBvZmZzZXQsIGlzb2wsIHgsIHksIHosIHZhbHAxLCB2YWxwMiApIHtcclxuXHJcblx0XHR2YXIgbXUgPSAoIGlzb2wgLSB2YWxwMSApIC8gKCB2YWxwMiAtIHZhbHAxICksXHJcblx0XHRuYyA9IHRoaXMubm9ybWFsX2NhY2hlO1xyXG5cclxuXHRcdHBvdXRbIG9mZnNldCBdIFx0ICAgPSB4ICsgbXUgKiB0aGlzLmRlbHRhO1xyXG5cdFx0cG91dFsgb2Zmc2V0ICsgMSBdID0geTtcclxuXHRcdHBvdXRbIG9mZnNldCArIDIgXSA9IHo7XHJcblxyXG5cdFx0bm91dFsgb2Zmc2V0IF0gXHQgICA9IHRoaXMubGVycCggbmNbIHEgXSwgICAgIG5jWyBxICsgMyBdLCBtdSApO1xyXG5cdFx0bm91dFsgb2Zmc2V0ICsgMSBdID0gdGhpcy5sZXJwKCBuY1sgcSArIDEgXSwgbmNbIHEgKyA0IF0sIG11ICk7XHJcblx0XHRub3V0WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmxlcnAoIG5jWyBxICsgMiBdLCBuY1sgcSArIDUgXSwgbXUgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5WSW50WSA9IGZ1bmN0aW9uKCBxLCBwb3V0LCBub3V0LCBvZmZzZXQsIGlzb2wsIHgsIHksIHosIHZhbHAxLCB2YWxwMiApIHtcclxuXHJcblx0XHR2YXIgbXUgPSAoIGlzb2wgLSB2YWxwMSApIC8gKCB2YWxwMiAtIHZhbHAxICksXHJcblx0XHRuYyA9IHRoaXMubm9ybWFsX2NhY2hlO1xyXG5cclxuXHRcdHBvdXRbIG9mZnNldCBdIFx0ICAgPSB4O1xyXG5cdFx0cG91dFsgb2Zmc2V0ICsgMSBdID0geSArIG11ICogdGhpcy5kZWx0YTtcclxuXHRcdHBvdXRbIG9mZnNldCArIDIgXSA9IHo7XHJcblxyXG5cdFx0dmFyIHEyID0gcSArIHRoaXMueWQgKiAzO1xyXG5cclxuXHRcdG5vdXRbIG9mZnNldCBdIFx0ICAgPSB0aGlzLmxlcnAoIG5jWyBxIF0sICAgICBuY1sgcTIgXSwgICAgIG11ICk7XHJcblx0XHRub3V0WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmxlcnAoIG5jWyBxICsgMSBdLCBuY1sgcTIgKyAxIF0sIG11ICk7XHJcblx0XHRub3V0WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmxlcnAoIG5jWyBxICsgMiBdLCBuY1sgcTIgKyAyIF0sIG11ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuVkludFogPSBmdW5jdGlvbiggcSwgcG91dCwgbm91dCwgb2Zmc2V0LCBpc29sLCB4LCB5LCB6LCB2YWxwMSwgdmFscDIgKSB7XHJcblxyXG5cdFx0dmFyIG11ID0gKCBpc29sIC0gdmFscDEgKSAvICggdmFscDIgLSB2YWxwMSApLFxyXG5cdFx0bmMgPSB0aGlzLm5vcm1hbF9jYWNoZTtcclxuXHJcblx0XHRwb3V0WyBvZmZzZXQgXSBcdCAgID0geDtcclxuXHRcdHBvdXRbIG9mZnNldCArIDEgXSA9IHk7XHJcblx0XHRwb3V0WyBvZmZzZXQgKyAyIF0gPSB6ICsgbXUgKiB0aGlzLmRlbHRhO1xyXG5cclxuXHRcdHZhciBxMiA9IHEgKyB0aGlzLnpkICogMztcclxuXHJcblx0XHRub3V0WyBvZmZzZXQgXSBcdCAgID0gdGhpcy5sZXJwKCBuY1sgcSBdLCAgICAgbmNbIHEyIF0sICAgICBtdSApO1xyXG5cdFx0bm91dFsgb2Zmc2V0ICsgMSBdID0gdGhpcy5sZXJwKCBuY1sgcSArIDEgXSwgbmNbIHEyICsgMSBdLCBtdSApO1xyXG5cdFx0bm91dFsgb2Zmc2V0ICsgMiBdID0gdGhpcy5sZXJwKCBuY1sgcSArIDIgXSwgbmNbIHEyICsgMiBdLCBtdSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNvbXBOb3JtID0gZnVuY3Rpb24oIHEgKSB7XHJcblxyXG5cdFx0dmFyIHEzID0gcSAqIDM7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbF9jYWNoZSBbIHEzIF0gPT09IDAuMCApIHtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsX2NhY2hlWyBxMyAgICAgXSA9IHRoaXMuZmllbGRbIHEgLSAxICBdIFx0ICAgIC0gdGhpcy5maWVsZFsgcSArIDEgXTtcclxuXHRcdFx0dGhpcy5ub3JtYWxfY2FjaGVbIHEzICsgMSBdID0gdGhpcy5maWVsZFsgcSAtIHRoaXMueWQgXSAtIHRoaXMuZmllbGRbIHEgKyB0aGlzLnlkIF07XHJcblx0XHRcdHRoaXMubm9ybWFsX2NhY2hlWyBxMyArIDIgXSA9IHRoaXMuZmllbGRbIHEgLSB0aGlzLnpkIF0gLSB0aGlzLmZpZWxkWyBxICsgdGhpcy56ZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgdHJpYW5nbGVzLiBGaWxscyB0cmlhbmdsZXMuXHJcblx0Ly8gKHRoaXMgaXMgd2hlcmUgbW9zdCBvZiB0aW1lIGlzIHNwZW50IC0gaXQncyBpbm5lciB3b3JrIG9mIE8objMpIGxvb3AgKVxyXG5cclxuXHR0aGlzLnBvbHlnb25pemUgPSBmdW5jdGlvbiggZngsIGZ5LCBmeiwgcSwgaXNvbCwgcmVuZGVyX2NhbGxiYWNrICkge1xyXG5cclxuXHRcdC8vIGNhY2hlIGluZGljZXNcclxuXHRcdHZhciBxMSA9IHEgKyAxLFxyXG5cdFx0XHRxeSA9IHEgKyB0aGlzLnlkLFxyXG5cdFx0XHRxeiA9IHEgKyB0aGlzLnpkLFxyXG5cdFx0XHRxMXkgPSBxMSArIHRoaXMueWQsXHJcblx0XHRcdHExeiA9IHExICsgdGhpcy56ZCxcclxuXHRcdFx0cXl6ID0gcSArIHRoaXMueWQgKyB0aGlzLnpkLFxyXG5cdFx0XHRxMXl6ID0gcTEgKyB0aGlzLnlkICsgdGhpcy56ZDtcclxuXHJcblx0XHR2YXIgY3ViZWluZGV4ID0gMCxcclxuXHRcdFx0ZmllbGQwID0gdGhpcy5maWVsZFsgcSBdLFxyXG5cdFx0XHRmaWVsZDEgPSB0aGlzLmZpZWxkWyBxMSBdLFxyXG5cdFx0XHRmaWVsZDIgPSB0aGlzLmZpZWxkWyBxeSBdLFxyXG5cdFx0XHRmaWVsZDMgPSB0aGlzLmZpZWxkWyBxMXkgXSxcclxuXHRcdFx0ZmllbGQ0ID0gdGhpcy5maWVsZFsgcXogXSxcclxuXHRcdFx0ZmllbGQ1ID0gdGhpcy5maWVsZFsgcTF6IF0sXHJcblx0XHRcdGZpZWxkNiA9IHRoaXMuZmllbGRbIHF5eiBdLFxyXG5cdFx0XHRmaWVsZDcgPSB0aGlzLmZpZWxkWyBxMXl6IF07XHJcblxyXG5cdFx0aWYgKCBmaWVsZDAgPCBpc29sICkgY3ViZWluZGV4IHw9IDE7XHJcblx0XHRpZiAoIGZpZWxkMSA8IGlzb2wgKSBjdWJlaW5kZXggfD0gMjtcclxuXHRcdGlmICggZmllbGQyIDwgaXNvbCApIGN1YmVpbmRleCB8PSA4O1xyXG5cdFx0aWYgKCBmaWVsZDMgPCBpc29sICkgY3ViZWluZGV4IHw9IDQ7XHJcblx0XHRpZiAoIGZpZWxkNCA8IGlzb2wgKSBjdWJlaW5kZXggfD0gMTY7XHJcblx0XHRpZiAoIGZpZWxkNSA8IGlzb2wgKSBjdWJlaW5kZXggfD0gMzI7XHJcblx0XHRpZiAoIGZpZWxkNiA8IGlzb2wgKSBjdWJlaW5kZXggfD0gMTI4O1xyXG5cdFx0aWYgKCBmaWVsZDcgPCBpc29sICkgY3ViZWluZGV4IHw9IDY0O1xyXG5cclxuXHRcdC8vIGlmIGN1YmUgaXMgZW50aXJlbHkgaW4vb3V0IG9mIHRoZSBzdXJmYWNlIC0gYmFpbCwgbm90aGluZyB0byBkcmF3XHJcblxyXG5cdFx0dmFyIGJpdHMgPSBUSFJFRS5lZGdlVGFibGVbIGN1YmVpbmRleCBdO1xyXG5cdFx0aWYgKCBiaXRzID09PSAwICkgcmV0dXJuIDA7XHJcblxyXG5cdFx0dmFyIGQgPSB0aGlzLmRlbHRhLFxyXG5cdFx0XHRmeDIgPSBmeCArIGQsXHJcblx0XHRcdGZ5MiA9IGZ5ICsgZCxcclxuXHRcdFx0ZnoyID0gZnogKyBkO1xyXG5cclxuXHRcdC8vIHRvcCBvZiB0aGUgY3ViZVxyXG5cclxuXHRcdGlmICggYml0cyAmIDEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXBOb3JtKCBxICk7XHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHExICk7XHJcblx0XHRcdHRoaXMuVkludFgoIHEgKiAzLCB0aGlzLnZsaXN0LCB0aGlzLm5saXN0LCAwLCBpc29sLCBmeCwgZnksIGZ6LCBmaWVsZDAsIGZpZWxkMSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBiaXRzICYgMiApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHExICk7XHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHExeSApO1xyXG5cdFx0XHR0aGlzLlZJbnRZKCBxMSAqIDMsIHRoaXMudmxpc3QsIHRoaXMubmxpc3QsIDMsIGlzb2wsIGZ4MiwgZnksIGZ6LCBmaWVsZDEsIGZpZWxkMyApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBiaXRzICYgNCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHF5ICk7XHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHExeSApO1xyXG5cdFx0XHR0aGlzLlZJbnRYKCBxeSAqIDMsIHRoaXMudmxpc3QsIHRoaXMubmxpc3QsIDYsIGlzb2wsIGZ4LCBmeTIsIGZ6LCBmaWVsZDIsIGZpZWxkMyApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBiaXRzICYgOCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHEgKTtcclxuXHRcdFx0dGhpcy5jb21wTm9ybSggcXkgKTtcclxuXHRcdFx0dGhpcy5WSW50WSggcSAqIDMsIHRoaXMudmxpc3QsIHRoaXMubmxpc3QsIDksIGlzb2wsIGZ4LCBmeSwgZnosIGZpZWxkMCwgZmllbGQyICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBib3R0b20gb2YgdGhlIGN1YmVcclxuXHJcblx0XHRpZiAoIGJpdHMgJiAxNiApICB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXBOb3JtKCBxeiApO1xyXG5cdFx0XHR0aGlzLmNvbXBOb3JtKCBxMXogKTtcclxuXHRcdFx0dGhpcy5WSW50WCggcXogKiAzLCB0aGlzLnZsaXN0LCB0aGlzLm5saXN0LCAxMiwgaXNvbCwgZngsIGZ5LCBmejIsIGZpZWxkNCwgZmllbGQ1ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoIGJpdHMgJiAzMiApICB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXBOb3JtKCBxMXogKTtcclxuXHRcdFx0dGhpcy5jb21wTm9ybSggcTF5eiApO1xyXG5cdFx0XHR0aGlzLlZJbnRZKCBxMXogKiAzLCAgdGhpcy52bGlzdCwgdGhpcy5ubGlzdCwgMTUsIGlzb2wsIGZ4MiwgZnksIGZ6MiwgZmllbGQ1LCBmaWVsZDcgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggYml0cyAmIDY0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wTm9ybSggcXl6ICk7XHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHExeXogKTtcclxuXHRcdFx0dGhpcy5WSW50WCggcXl6ICogMywgdGhpcy52bGlzdCwgdGhpcy5ubGlzdCwgMTgsIGlzb2wsIGZ4LCBmeTIsIGZ6MiwgZmllbGQ2LCBmaWVsZDcgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggYml0cyAmIDEyOCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHF6ICk7XHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHF5eiApO1xyXG5cdFx0XHR0aGlzLlZJbnRZKCBxeiAqIDMsICB0aGlzLnZsaXN0LCB0aGlzLm5saXN0LCAyMSwgaXNvbCwgZngsIGZ5LCBmejIsIGZpZWxkNCwgZmllbGQ2ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyB2ZXJ0aWNhbCBsaW5lcyBvZiB0aGUgY3ViZVxyXG5cclxuXHRcdGlmICggYml0cyAmIDI1NiApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHEgKTtcclxuXHRcdFx0dGhpcy5jb21wTm9ybSggcXogKTtcclxuXHRcdFx0dGhpcy5WSW50WiggcSAqIDMsIHRoaXMudmxpc3QsIHRoaXMubmxpc3QsIDI0LCBpc29sLCBmeCwgZnksIGZ6LCBmaWVsZDAsIGZpZWxkNCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBiaXRzICYgNTEyICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wTm9ybSggcTEgKTtcclxuXHRcdFx0dGhpcy5jb21wTm9ybSggcTF6ICk7XHJcblx0XHRcdHRoaXMuVkludFooIHExICogMywgIHRoaXMudmxpc3QsIHRoaXMubmxpc3QsIDI3LCBpc29sLCBmeDIsIGZ5LCAgZnosIGZpZWxkMSwgZmllbGQ1ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoIGJpdHMgJiAxMDI0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wTm9ybSggcTF5ICk7XHJcblx0XHRcdHRoaXMuY29tcE5vcm0oIHExeXogKTtcclxuXHRcdFx0dGhpcy5WSW50WiggcTF5ICogMywgdGhpcy52bGlzdCwgdGhpcy5ubGlzdCwgMzAsIGlzb2wsIGZ4MiwgZnkyLCBmeiwgZmllbGQzLCBmaWVsZDcgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggYml0cyAmIDIwNDggKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXBOb3JtKCBxeSApO1xyXG5cdFx0XHR0aGlzLmNvbXBOb3JtKCBxeXogKTtcclxuXHRcdFx0dGhpcy5WSW50WiggcXkgKiAzLCB0aGlzLnZsaXN0LCB0aGlzLm5saXN0LCAzMywgaXNvbCwgZngsICBmeTIsIGZ6LCBmaWVsZDIsIGZpZWxkNiApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Y3ViZWluZGV4IDw8PSA0OyAgLy8gcmUtcHVycG9zZSBjdWJlaW5kZXggaW50byBhbiBvZmZzZXQgaW50byB0cmlUYWJsZVxyXG5cclxuXHRcdHZhciBvMSwgbzIsIG8zLCBudW10cmlzID0gMCwgaSA9IDA7XHJcblxyXG5cdFx0Ly8gaGVyZSBpcyB3aGVyZSB0cmlhbmdsZXMgYXJlIGNyZWF0ZWRcclxuXHJcblx0XHR3aGlsZSAoIFRIUkVFLnRyaVRhYmxlWyBjdWJlaW5kZXggKyBpIF0gIT0gLTEgKSB7XHJcblxyXG5cdFx0XHRvMSA9IGN1YmVpbmRleCArIGk7XHJcblx0XHRcdG8yID0gbzEgKyAxO1xyXG5cdFx0XHRvMyA9IG8xICsgMjtcclxuXHJcblx0XHRcdHRoaXMucG9zbm9ybXRyaXYoIHRoaXMudmxpc3QsIHRoaXMubmxpc3QsXHJcblx0XHRcdFx0XHRcdFx0ICAzICogVEhSRUUudHJpVGFibGVbIG8xIF0sXHJcblx0XHRcdFx0XHRcdFx0ICAzICogVEhSRUUudHJpVGFibGVbIG8yIF0sXHJcblx0XHRcdFx0XHRcdFx0ICAzICogVEhSRUUudHJpVGFibGVbIG8zIF0sXHJcblx0XHRcdFx0XHRcdFx0ICByZW5kZXJfY2FsbGJhY2sgKTtcclxuXHJcblx0XHRcdGkgKz0gMztcclxuXHRcdFx0bnVtdHJpcyArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bXRyaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHQvLyBJbW1lZGlhdGUgcmVuZGVyIG1vZGUgc2ltdWxhdG9yXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuXHR0aGlzLnBvc25vcm10cml2ID0gZnVuY3Rpb24oIHBvcywgbm9ybSwgbzEsIG8yLCBvMywgcmVuZGVyX2NhbGxiYWNrICkge1xyXG5cclxuXHRcdHZhciBjID0gdGhpcy5jb3VudCAqIDM7XHJcblxyXG5cdFx0dGhpcy5wb3NpdGlvbkFycmF5WyBjIF0gPSBwb3NbIG8xIF07XHJcblx0XHR0aGlzLnBvc2l0aW9uQXJyYXlbIGMgKyAxIF0gPSBwb3NbIG8xICsgMSBdO1xyXG5cdFx0dGhpcy5wb3NpdGlvbkFycmF5WyBjICsgMiBdID0gcG9zWyBvMSArIDIgXTtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uQXJyYXlbIGMgKyAzIF0gPSBwb3NbIG8yIF07XHJcblx0XHR0aGlzLnBvc2l0aW9uQXJyYXlbIGMgKyA0IF0gPSBwb3NbIG8yICsgMSBdO1xyXG5cdFx0dGhpcy5wb3NpdGlvbkFycmF5WyBjICsgNSBdID0gcG9zWyBvMiArIDIgXTtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uQXJyYXlbIGMgKyA2IF0gPSBwb3NbIG8zIF07XHJcblx0XHR0aGlzLnBvc2l0aW9uQXJyYXlbIGMgKyA3IF0gPSBwb3NbIG8zICsgMSBdO1xyXG5cdFx0dGhpcy5wb3NpdGlvbkFycmF5WyBjICsgOCBdID0gcG9zWyBvMyArIDIgXTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbEFycmF5WyBjIF0gPSBub3JtWyBvMSBdO1xyXG5cdFx0dGhpcy5ub3JtYWxBcnJheVsgYyArIDEgXSA9IG5vcm1bIG8xICsgMSBdO1xyXG5cdFx0dGhpcy5ub3JtYWxBcnJheVsgYyArIDIgXSA9IG5vcm1bIG8xICsgMiBdO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsQXJyYXlbIGMgKyAzIF0gPSBub3JtWyBvMiBdO1xyXG5cdFx0dGhpcy5ub3JtYWxBcnJheVsgYyArIDQgXSA9IG5vcm1bIG8yICsgMSBdO1xyXG5cdFx0dGhpcy5ub3JtYWxBcnJheVsgYyArIDUgXSA9IG5vcm1bIG8yICsgMiBdO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsQXJyYXlbIGMgKyA2IF0gPSBub3JtWyBvMyBdO1xyXG5cdFx0dGhpcy5ub3JtYWxBcnJheVsgYyArIDcgXSA9IG5vcm1bIG8zICsgMSBdO1xyXG5cdFx0dGhpcy5ub3JtYWxBcnJheVsgYyArIDggXSA9IG5vcm1bIG8zICsgMiBdO1xyXG5cclxuXHRcdHRoaXMuaGFzUG9zID0gdHJ1ZTtcclxuXHRcdHRoaXMuaGFzTm9ybWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmNvdW50ICs9IDM7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNvdW50ID49IHRoaXMubWF4Q291bnQgLSAzICkge1xyXG5cclxuXHRcdFx0cmVuZGVyX2NhbGxiYWNrKCB0aGlzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmJlZ2luID0gZnVuY3Rpb24oICkge1xyXG5cclxuXHRcdHRoaXMuY291bnQgPSAwO1xyXG5cdFx0dGhpcy5oYXNQb3MgPSBmYWxzZTtcclxuXHRcdHRoaXMuaGFzTm9ybWFsID0gZmFsc2U7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5kID0gZnVuY3Rpb24oIHJlbmRlcl9jYWxsYmFjayApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuY291bnQgPT09IDAgKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLmNvdW50ICogMzsgaSA8IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGg7IGkrKyApXHJcblx0XHRcdHRoaXMucG9zaXRpb25BcnJheVsgaSBdID0gMC4wO1xyXG5cclxuXHRcdHJlbmRlcl9jYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblx0Ly8gTWV0YWJhbGxzXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuXHQvLyBBZGRzIGEgcmVjaXByb2NhbCBiYWxsIChuaWNlIGFuZCBibG9iYnkpIHRoYXQsIHRvIGJlIGZhc3QsIGZhZGVzIHRvIHplcm8gYWZ0ZXJcclxuXHQvLyBhIGZpeGVkIGRpc3RhbmNlLCBkZXRlcm1pbmVkIGJ5IHN0cmVuZ3RoIGFuZCBzdWJ0cmFjdC5cclxuXHJcblx0dGhpcy5hZGRCYWxsID0gZnVuY3Rpb24oIGJhbGx4LCBiYWxseSwgYmFsbHosIHN0cmVuZ3RoLCBzdWJ0cmFjdCApIHtcclxuXHJcblx0XHQvLyBMZXQncyBzb2x2ZSB0aGUgZXF1YXRpb24gdG8gZmluZCB0aGUgcmFkaXVzOlxyXG5cdFx0Ly8gMS4wIC8gKDAuMDAwMDAxICsgcmFkaXVzXjIpICogc3RyZW5ndGggLSBzdWJ0cmFjdCA9IDBcclxuXHRcdC8vIHN0cmVuZ3RoIC8gKHJhZGl1c14yKSA9IHN1YnRyYWN0XHJcblx0XHQvLyBzdHJlbmd0aCA9IHN1YnRyYWN0ICogcmFkaXVzXjJcclxuXHRcdC8vIHJhZGl1c14yID0gc3RyZW5ndGggLyBzdWJ0cmFjdFxyXG5cdFx0Ly8gcmFkaXVzID0gc3FydChzdHJlbmd0aCAvIHN1YnRyYWN0KVxyXG5cclxuXHRcdHZhciByYWRpdXMgPSB0aGlzLnNpemUgKiBNYXRoLnNxcnQoIHN0cmVuZ3RoIC8gc3VidHJhY3QgKSxcclxuXHRcdFx0enMgPSBiYWxseiAqIHRoaXMuc2l6ZSxcclxuXHRcdFx0eXMgPSBiYWxseSAqIHRoaXMuc2l6ZSxcclxuXHRcdFx0eHMgPSBiYWxseCAqIHRoaXMuc2l6ZTtcclxuXHJcblx0XHR2YXIgbWluX3ogPSBNYXRoLmZsb29yKCB6cyAtIHJhZGl1cyApOyBpZiAoIG1pbl96IDwgMSApIG1pbl96ID0gMTtcclxuXHRcdHZhciBtYXhfeiA9IE1hdGguZmxvb3IoIHpzICsgcmFkaXVzICk7IGlmICggbWF4X3ogPiB0aGlzLnNpemUgLSAxICkgbWF4X3ogPSB0aGlzLnNpemUgLSAxO1xyXG5cdFx0dmFyIG1pbl95ID0gTWF0aC5mbG9vciggeXMgLSByYWRpdXMgKTsgaWYgKCBtaW5feSA8IDEgKSBtaW5feSA9IDE7XHJcblx0XHR2YXIgbWF4X3kgPSBNYXRoLmZsb29yKCB5cyArIHJhZGl1cyApOyBpZiAoIG1heF95ID4gdGhpcy5zaXplIC0gMSApIG1heF95ID0gdGhpcy5zaXplIC0gMTtcclxuXHRcdHZhciBtaW5feCA9IE1hdGguZmxvb3IoIHhzIC0gcmFkaXVzICk7IGlmICggbWluX3ggPCAxICApIG1pbl94ID0gMTtcclxuXHRcdHZhciBtYXhfeCA9IE1hdGguZmxvb3IoIHhzICsgcmFkaXVzICk7IGlmICggbWF4X3ggPiB0aGlzLnNpemUgLSAxICkgbWF4X3ggPSB0aGlzLnNpemUgLSAxO1xyXG5cclxuXHJcblx0XHQvLyBEb24ndCBwb2x5Z29uaXplIGluIHRoZSBvdXRlciBsYXllciBiZWNhdXNlIG5vcm1hbHMgYXJlbid0XHJcblx0XHQvLyB3ZWxsLWRlZmluZWQgdGhlcmUuXHJcblxyXG5cdFx0dmFyIHgsIHksIHosIHlfb2Zmc2V0LCB6X29mZnNldCwgZngsIGZ5LCBmeiwgZnoyLCBmeTIsIHZhbDtcclxuXHJcblx0XHRmb3IgKCB6ID0gbWluX3o7IHogPCBtYXhfejsgeisrICkge1xyXG5cclxuXHRcdFx0el9vZmZzZXQgPSB0aGlzLnNpemUyICogeixcclxuXHRcdFx0ZnogPSB6IC8gdGhpcy5zaXplIC0gYmFsbHosXHJcblx0XHRcdGZ6MiA9IGZ6ICogZno7XHJcblxyXG5cdFx0XHRmb3IgKCB5ID0gbWluX3k7IHkgPCBtYXhfeTsgeSsrICkge1xyXG5cclxuXHRcdFx0XHR5X29mZnNldCA9IHpfb2Zmc2V0ICsgdGhpcy5zaXplICogeTtcclxuXHRcdFx0XHRmeSA9IHkgLyB0aGlzLnNpemUgLSBiYWxseTtcclxuXHRcdFx0XHRmeTIgPSBmeSAqIGZ5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB4ID0gbWluX3g7IHggPCBtYXhfeDsgeCsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZ4ID0geCAvIHRoaXMuc2l6ZSAtIGJhbGx4O1xyXG5cdFx0XHRcdFx0dmFsID0gc3RyZW5ndGggLyAoIDAuMDAwMDAxICsgZngqZnggKyBmeTIgKyBmejIgKSAtIHN1YnRyYWN0O1xyXG5cdFx0XHRcdFx0aWYgKCB2YWwgPiAwLjAgKSB0aGlzLmZpZWxkWyB5X29mZnNldCArIHggXSArPSB2YWw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuYWRkUGxhbmVYID0gZnVuY3Rpb24oIHN0cmVuZ3RoLCBzdWJ0cmFjdCApIHtcclxuXHJcblx0XHR2YXIgeCwgeSwgeiwgeHgsIHZhbCwgeGRpdiwgY3h5LFxyXG5cclxuXHRcdFx0Ly8gY2FjaGUgYXR0cmlidXRlIGxvb2t1cHNcclxuXHRcdFx0c2l6ZSA9IHRoaXMuc2l6ZSxcclxuXHRcdFx0eWQgPSB0aGlzLnlkLFxyXG5cdFx0XHR6ZCA9IHRoaXMuemQsXHJcblx0XHRcdGZpZWxkID0gdGhpcy5maWVsZCxcclxuXHJcblx0XHRcdGRpc3QgPSBzaXplICogTWF0aC5zcXJ0KCBzdHJlbmd0aCAvIHN1YnRyYWN0ICk7XHJcblxyXG5cdFx0aWYgKCBkaXN0ID4gc2l6ZSApIGRpc3QgPSBzaXplO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDwgZGlzdDsgeCsrICkge1xyXG5cclxuXHRcdFx0eGRpdiA9IHggLyBzaXplO1xyXG5cdFx0XHR4eCA9IHhkaXYgKiB4ZGl2O1xyXG5cdFx0XHR2YWwgPSBzdHJlbmd0aCAvICggMC4wMDAxICsgeHggKSAtIHN1YnRyYWN0O1xyXG5cclxuXHRcdFx0aWYgKCB2YWwgPiAwLjAgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHkgPSAwOyB5IDwgc2l6ZTsgeSsrICkge1xyXG5cclxuXHRcdFx0XHRcdGN4eSA9IHggKyB5ICogeWQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggeiA9IDA7IHogPCBzaXplOyB6KysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmaWVsZFsgemQgKiB6ICsgY3h5IF0gKz0gdmFsO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5hZGRQbGFuZVkgPSBmdW5jdGlvbiggc3RyZW5ndGgsIHN1YnRyYWN0ICkge1xyXG5cclxuXHRcdHZhciB4LCB5LCB6LCB5eSwgdmFsLCB5ZGl2LCBjeSwgY3h5LFxyXG5cclxuXHRcdFx0Ly8gY2FjaGUgYXR0cmlidXRlIGxvb2t1cHNcclxuXHRcdFx0c2l6ZSA9IHRoaXMuc2l6ZSxcclxuXHRcdFx0eWQgPSB0aGlzLnlkLFxyXG5cdFx0XHR6ZCA9IHRoaXMuemQsXHJcblx0XHRcdGZpZWxkID0gdGhpcy5maWVsZCxcclxuXHJcblx0XHRcdGRpc3QgPSBzaXplICogTWF0aC5zcXJ0KCBzdHJlbmd0aCAvIHN1YnRyYWN0ICk7XHJcblxyXG5cdFx0aWYgKCBkaXN0ID4gc2l6ZSApIGRpc3QgPSBzaXplO1xyXG5cclxuXHRcdGZvciAoIHkgPSAwOyB5IDwgZGlzdDsgeSsrICkge1xyXG5cclxuXHRcdFx0eWRpdiA9IHkgLyBzaXplO1xyXG5cdFx0XHR5eSA9IHlkaXYgKiB5ZGl2O1xyXG5cdFx0XHR2YWwgPSBzdHJlbmd0aCAvICggMC4wMDAxICsgeXkgKSAtIHN1YnRyYWN0O1xyXG5cclxuXHRcdFx0aWYgKCB2YWwgPiAwLjAgKSB7XHJcblxyXG5cdFx0XHRcdGN5ID0geSAqIHlkO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHNpemU7IHgrKyApIHtcclxuXHJcblx0XHRcdFx0XHRjeHkgPSBjeSArIHg7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggeiA9IDA7IHogPCBzaXplOyB6KysgKVxyXG5cdFx0XHRcdFx0XHRmaWVsZFsgemQgKiB6ICsgY3h5IF0gKz0gdmFsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmFkZFBsYW5lWiA9IGZ1bmN0aW9uKCBzdHJlbmd0aCwgc3VidHJhY3QgKSB7XHJcblxyXG5cdFx0dmFyIHgsIHksIHosIHp6LCB2YWwsIHpkaXYsIGN6LCBjeXosXHJcblxyXG5cdFx0XHQvLyBjYWNoZSBhdHRyaWJ1dGUgbG9va3Vwc1xyXG5cdFx0XHRzaXplID0gdGhpcy5zaXplLFxyXG5cdFx0XHR5ZCA9IHRoaXMueWQsXHJcblx0XHRcdHpkID0gdGhpcy56ZCxcclxuXHRcdFx0ZmllbGQgPSB0aGlzLmZpZWxkLFxyXG5cclxuXHRcdFx0ZGlzdCA9IHNpemUgKiBNYXRoLnNxcnQoIHN0cmVuZ3RoIC8gc3VidHJhY3QgKTtcclxuXHJcblx0XHRpZiAoIGRpc3QgPiBzaXplICkgZGlzdCA9IHNpemU7XHJcblxyXG5cdFx0Zm9yICggeiA9IDA7IHogPCBkaXN0OyB6KysgKSB7XHJcblxyXG5cdFx0XHR6ZGl2ID0geiAvIHNpemU7XHJcblx0XHRcdHp6ID0gemRpdiAqIHpkaXY7XHJcblx0XHRcdHZhbCA9IHN0cmVuZ3RoIC8gKCAwLjAwMDEgKyB6eiApIC0gc3VidHJhY3Q7XHJcblx0XHRcdGlmICggdmFsID4gMC4wICkge1xyXG5cclxuXHRcdFx0XHRjeiA9IHpkICogejtcclxuXHJcblx0XHRcdFx0Zm9yICggeSA9IDA7IHkgPCBzaXplOyB5KysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjeXogPSBjeiArIHkgKiB5ZDtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHggPSAwOyB4IDwgc2l6ZTsgeCsrIClcclxuXHRcdFx0XHRcdFx0XHRmaWVsZFsgY3l6ICsgeCBdICs9IHZhbDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cdC8vIFVwZGF0ZXNcclxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5cdHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgaTtcclxuXHJcblx0XHQvLyB3aXBlIHRoZSBub3JtYWwgY2FjaGVcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHRoaXMuc2l6ZTM7IGkrKyApIHtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsX2NhY2hlWyBpICogMyBdID0gMC4wO1xyXG5cdFx0XHR0aGlzLmZpZWxkWyBpIF0gPSAwLjA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCByZW5kZXJfY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dGhpcy5iZWdpbigpO1xyXG5cclxuXHRcdC8vIFRyaWFuZ3VsYXRlLiBZZWFoLCB0aGlzIGlzIHNsb3cuXHJcblxyXG5cdFx0dmFyIHEsIHgsIHksIHosIGZ4LCBmeSwgZnosIHlfb2Zmc2V0LCB6X29mZnNldCwgc21pbjIgPSB0aGlzLnNpemUgLSAyO1xyXG5cclxuXHRcdGZvciAoIHogPSAxOyB6IDwgc21pbjI7IHorKyApIHtcclxuXHJcblx0XHRcdHpfb2Zmc2V0ID0gdGhpcy5zaXplMiAqIHo7XHJcblx0XHRcdGZ6ID0gKCB6IC0gdGhpcy5oYWxmc2l6ZSApIC8gdGhpcy5oYWxmc2l6ZTsgLy8rIDFcclxuXHJcblx0XHRcdGZvciAoIHkgPSAxOyB5IDwgc21pbjI7IHkrKyApIHtcclxuXHJcblx0XHRcdFx0eV9vZmZzZXQgPSB6X29mZnNldCArIHRoaXMuc2l6ZSAqIHk7XHJcblx0XHRcdFx0ZnkgPSAoIHkgLSB0aGlzLmhhbGZzaXplICkgLyB0aGlzLmhhbGZzaXplOyAvLysgMVxyXG5cclxuXHRcdFx0XHRmb3IgKCB4ID0gMTsgeCA8IHNtaW4yOyB4KysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZnggPSAoIHggLSB0aGlzLmhhbGZzaXplICkgLyB0aGlzLmhhbGZzaXplOyAvLysgMVxyXG5cdFx0XHRcdFx0cSA9IHlfb2Zmc2V0ICsgeDtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnBvbHlnb25pemUoIGZ4LCBmeSwgZnosIHEsIHRoaXMuaXNvbGF0aW9uLCByZW5kZXJfY2FsbGJhY2sgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmVuZCggcmVuZGVyX2NhbGxiYWNrICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciBzdGFydCA9IDAsIGdlbyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHR2YXIgZ2VvX2NhbGxiYWNrID0gZnVuY3Rpb24oIG9iamVjdCApIHtcclxuXHJcblx0XHRcdHZhciBpLCB4LCB5LCB6LCB2ZXJ0ZXgsIHBvc2l0aW9uLCBub3JtYWwsXHJcblx0XHRcdFx0ZmFjZSwgYSwgYiwgYywgbmEsIG5iLCBuYywgbmZhY2VzO1xyXG5cclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgb2JqZWN0LmNvdW50OyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdGEgPSBpICogMztcclxuXHRcdFx0XHRiID0gYSArIDE7XHJcblx0XHRcdFx0YyA9IGEgKyAyO1xyXG5cclxuXHRcdFx0XHR4ID0gb2JqZWN0LnBvc2l0aW9uQXJyYXlbIGEgXTtcclxuXHRcdFx0XHR5ID0gb2JqZWN0LnBvc2l0aW9uQXJyYXlbIGIgXTtcclxuXHRcdFx0XHR6ID0gb2JqZWN0LnBvc2l0aW9uQXJyYXlbIGMgXTtcclxuXHRcdFx0XHRwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdHggPSBvYmplY3Qubm9ybWFsQXJyYXlbIGEgXTtcclxuXHRcdFx0XHR5ID0gb2JqZWN0Lm5vcm1hbEFycmF5WyBiIF07XHJcblx0XHRcdFx0eiA9IG9iamVjdC5ub3JtYWxBcnJheVsgYyBdO1xyXG5cdFx0XHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICk7XHJcblx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVydGV4KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0XHRnZW8udmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5mYWNlcyA9IG9iamVjdC5jb3VudCAvIDM7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5mYWNlczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRhID0gKCBzdGFydCArIGkgKSAqIDM7XHJcblx0XHRcdFx0YiA9IGEgKyAxO1xyXG5cdFx0XHRcdGMgPSBhICsgMjtcclxuXHJcblx0XHRcdFx0bmEgPSBub3JtYWxzWyBhIF07XHJcblx0XHRcdFx0bmIgPSBub3JtYWxzWyBiIF07XHJcblx0XHRcdFx0bmMgPSBub3JtYWxzWyBjIF07XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFsgbmEsIG5iLCBuYyBdICk7XHJcblxyXG5cdFx0XHRcdGdlby5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGFydCArPSBuZmFjZXM7XHJcblx0XHRcdG9iamVjdC5jb3VudCA9IDA7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnJlbmRlciggZ2VvX2NhbGxiYWNrICk7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coIFwiZ2VuZXJhdGVkIFwiICsgZ2VvLmZhY2VzLmxlbmd0aCArIFwiIHRyaWFuZ2xlc1wiICk7XHJcblxyXG5cdFx0cmV0dXJuIGdlbztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5pbml0KCByZXNvbHV0aW9uICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWFyY2hpbmdDdWJlcy5wcm90b3R5cGUgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuVEhSRUUuTWFyY2hpbmdDdWJlcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NYXJjaGluZ0N1YmVzO1xyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gTWFyY2hpbmcgY3ViZXMgbG9va3VwIHRhYmxlc1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vLyBUaGVzZSB0YWJsZXMgYXJlIHN0cmFpZ2h0IGZyb20gUGF1bCBCb3Vya2UncyBwYWdlOlxyXG4vLyBodHRwOi8vbG9jYWwud2FzcC51d2EuZWR1LmF1L35wYm91cmtlL2dlb21ldHJ5L3BvbHlnb25pc2UvXHJcbi8vIHdobyBpbiB0dXJuIGdvdCB0aGVtIGZyb20gQ29yeSBHZW5lIEJsb3lkLlxyXG5cclxuVEhSRUUuZWRnZVRhYmxlID0gbmV3IEludDMyQXJyYXkoW1xyXG4weDAgICwgMHgxMDksIDB4MjAzLCAweDMwYSwgMHg0MDYsIDB4NTBmLCAweDYwNSwgMHg3MGMsXHJcbjB4ODBjLCAweDkwNSwgMHhhMGYsIDB4YjA2LCAweGMwYSwgMHhkMDMsIDB4ZTA5LCAweGYwMCxcclxuMHgxOTAsIDB4OTkgLCAweDM5MywgMHgyOWEsIDB4NTk2LCAweDQ5ZiwgMHg3OTUsIDB4NjljLFxyXG4weDk5YywgMHg4OTUsIDB4YjlmLCAweGE5NiwgMHhkOWEsIDB4YzkzLCAweGY5OSwgMHhlOTAsXHJcbjB4MjMwLCAweDMzOSwgMHgzMyAsIDB4MTNhLCAweDYzNiwgMHg3M2YsIDB4NDM1LCAweDUzYyxcclxuMHhhM2MsIDB4YjM1LCAweDgzZiwgMHg5MzYsIDB4ZTNhLCAweGYzMywgMHhjMzksIDB4ZDMwLFxyXG4weDNhMCwgMHgyYTksIDB4MWEzLCAweGFhICwgMHg3YTYsIDB4NmFmLCAweDVhNSwgMHg0YWMsXHJcbjB4YmFjLCAweGFhNSwgMHg5YWYsIDB4OGE2LCAweGZhYSwgMHhlYTMsIDB4ZGE5LCAweGNhMCxcclxuMHg0NjAsIDB4NTY5LCAweDY2MywgMHg3NmEsIDB4NjYgLCAweDE2ZiwgMHgyNjUsIDB4MzZjLFxyXG4weGM2YywgMHhkNjUsIDB4ZTZmLCAweGY2NiwgMHg4NmEsIDB4OTYzLCAweGE2OSwgMHhiNjAsXHJcbjB4NWYwLCAweDRmOSwgMHg3ZjMsIDB4NmZhLCAweDFmNiwgMHhmZiAsIDB4M2Y1LCAweDJmYyxcclxuMHhkZmMsIDB4Y2Y1LCAweGZmZiwgMHhlZjYsIDB4OWZhLCAweDhmMywgMHhiZjksIDB4YWYwLFxyXG4weDY1MCwgMHg3NTksIDB4NDUzLCAweDU1YSwgMHgyNTYsIDB4MzVmLCAweDU1ICwgMHgxNWMsXHJcbjB4ZTVjLCAweGY1NSwgMHhjNWYsIDB4ZDU2LCAweGE1YSwgMHhiNTMsIDB4ODU5LCAweDk1MCxcclxuMHg3YzAsIDB4NmM5LCAweDVjMywgMHg0Y2EsIDB4M2M2LCAweDJjZiwgMHgxYzUsIDB4Y2MgLFxyXG4weGZjYywgMHhlYzUsIDB4ZGNmLCAweGNjNiwgMHhiY2EsIDB4YWMzLCAweDljOSwgMHg4YzAsXHJcbjB4OGMwLCAweDljOSwgMHhhYzMsIDB4YmNhLCAweGNjNiwgMHhkY2YsIDB4ZWM1LCAweGZjYyxcclxuMHhjYyAsIDB4MWM1LCAweDJjZiwgMHgzYzYsIDB4NGNhLCAweDVjMywgMHg2YzksIDB4N2MwLFxyXG4weDk1MCwgMHg4NTksIDB4YjUzLCAweGE1YSwgMHhkNTYsIDB4YzVmLCAweGY1NSwgMHhlNWMsXHJcbjB4MTVjLCAweDU1ICwgMHgzNWYsIDB4MjU2LCAweDU1YSwgMHg0NTMsIDB4NzU5LCAweDY1MCxcclxuMHhhZjAsIDB4YmY5LCAweDhmMywgMHg5ZmEsIDB4ZWY2LCAweGZmZiwgMHhjZjUsIDB4ZGZjLFxyXG4weDJmYywgMHgzZjUsIDB4ZmYgLCAweDFmNiwgMHg2ZmEsIDB4N2YzLCAweDRmOSwgMHg1ZjAsXHJcbjB4YjYwLCAweGE2OSwgMHg5NjMsIDB4ODZhLCAweGY2NiwgMHhlNmYsIDB4ZDY1LCAweGM2YyxcclxuMHgzNmMsIDB4MjY1LCAweDE2ZiwgMHg2NiAsIDB4NzZhLCAweDY2MywgMHg1NjksIDB4NDYwLFxyXG4weGNhMCwgMHhkYTksIDB4ZWEzLCAweGZhYSwgMHg4YTYsIDB4OWFmLCAweGFhNSwgMHhiYWMsXHJcbjB4NGFjLCAweDVhNSwgMHg2YWYsIDB4N2E2LCAweGFhICwgMHgxYTMsIDB4MmE5LCAweDNhMCxcclxuMHhkMzAsIDB4YzM5LCAweGYzMywgMHhlM2EsIDB4OTM2LCAweDgzZiwgMHhiMzUsIDB4YTNjLFxyXG4weDUzYywgMHg0MzUsIDB4NzNmLCAweDYzNiwgMHgxM2EsIDB4MzMgLCAweDMzOSwgMHgyMzAsXHJcbjB4ZTkwLCAweGY5OSwgMHhjOTMsIDB4ZDlhLCAweGE5NiwgMHhiOWYsIDB4ODk1LCAweDk5YyxcclxuMHg2OWMsIDB4Nzk1LCAweDQ5ZiwgMHg1OTYsIDB4MjlhLCAweDM5MywgMHg5OSAsIDB4MTkwLFxyXG4weGYwMCwgMHhlMDksIDB4ZDAzLCAweGMwYSwgMHhiMDYsIDB4YTBmLCAweDkwNSwgMHg4MGMsXHJcbjB4NzBjLCAweDYwNSwgMHg1MGYsIDB4NDA2LCAweDMwYSwgMHgyMDMsIDB4MTA5LCAweDBdKVxyXG5cclxuVEhSRUUudHJpVGFibGUgPSBuZXcgSW50MzJBcnJheShbXHJcbi0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCA4LCAzLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgMSwgOSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDgsIDMsIDksIDgsIDEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCAyLCAxMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDgsIDMsIDEsIDIsIDEwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgMiwgMTAsIDAsIDIsIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4yLCA4LCAzLCAyLCAxMCwgOCwgMTAsIDksIDgsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4zLCAxMSwgMiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDExLCAyLCA4LCAxMSwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDksIDAsIDIsIDMsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMSwgMTEsIDIsIDEsIDksIDExLCA5LCA4LCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDEwLCAxLCAxMSwgMTAsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCAxMCwgMSwgMCwgOCwgMTAsIDgsIDExLCAxMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDksIDAsIDMsIDExLCA5LCAxMSwgMTAsIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCA4LCAxMCwgMTAsIDgsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNCwgNywgOCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjQsIDMsIDAsIDcsIDMsIDQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCAxLCA5LCA4LCA0LCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNCwgMSwgOSwgNCwgNywgMSwgNywgMywgMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDIsIDEwLCA4LCA0LCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMywgNCwgNywgMywgMCwgNCwgMSwgMiwgMTAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCAyLCAxMCwgOSwgMCwgMiwgOCwgNCwgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjIsIDEwLCA5LCAyLCA5LCA3LCAyLCA3LCAzLCA3LCA5LCA0LCAtMSwgLTEsIC0xLCAtMSxcclxuOCwgNCwgNywgMywgMTEsIDIsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMSwgNCwgNywgMTEsIDIsIDQsIDIsIDAsIDQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCAwLCAxLCA4LCA0LCA3LCAyLCAzLCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjQsIDcsIDExLCA5LCA0LCAxMSwgOSwgMTEsIDIsIDksIDIsIDEsIC0xLCAtMSwgLTEsIC0xLFxyXG4zLCAxMCwgMSwgMywgMTEsIDEwLCA3LCA4LCA0LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMSwgMTEsIDEwLCAxLCA0LCAxMSwgMSwgMCwgNCwgNywgMTEsIDQsIC0xLCAtMSwgLTEsIC0xLFxyXG40LCA3LCA4LCA5LCAwLCAxMSwgOSwgMTEsIDEwLCAxMSwgMCwgMywgLTEsIC0xLCAtMSwgLTEsXHJcbjQsIDcsIDExLCA0LCAxMSwgOSwgOSwgMTEsIDEwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgNSwgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjksIDUsIDQsIDAsIDgsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCA1LCA0LCAxLCA1LCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOCwgNSwgNCwgOCwgMywgNSwgMywgMSwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDIsIDEwLCA5LCA1LCA0LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMywgMCwgOCwgMSwgMiwgMTAsIDQsIDksIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG41LCAyLCAxMCwgNSwgNCwgMiwgNCwgMCwgMiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjIsIDEwLCA1LCAzLCAyLCA1LCAzLCA1LCA0LCAzLCA0LCA4LCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgNSwgNCwgMiwgMywgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCAxMSwgMiwgMCwgOCwgMTEsIDQsIDksIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCA1LCA0LCAwLCAxLCA1LCAyLCAzLCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjIsIDEsIDUsIDIsIDUsIDgsIDIsIDgsIDExLCA0LCA4LCA1LCAtMSwgLTEsIC0xLCAtMSxcclxuMTAsIDMsIDExLCAxMCwgMSwgMywgOSwgNSwgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjQsIDksIDUsIDAsIDgsIDEsIDgsIDEwLCAxLCA4LCAxMSwgMTAsIC0xLCAtMSwgLTEsIC0xLFxyXG41LCA0LCAwLCA1LCAwLCAxMSwgNSwgMTEsIDEwLCAxMSwgMCwgMywgLTEsIC0xLCAtMSwgLTEsXHJcbjUsIDQsIDgsIDUsIDgsIDEwLCAxMCwgOCwgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCA3LCA4LCA1LCA3LCA5LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgMywgMCwgOSwgNSwgMywgNSwgNywgMywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDcsIDgsIDAsIDEsIDcsIDEsIDUsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCA1LCAzLCAzLCA1LCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgNywgOCwgOSwgNSwgNywgMTAsIDEsIDIsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMCwgMSwgMiwgOSwgNSwgMCwgNSwgMywgMCwgNSwgNywgMywgLTEsIC0xLCAtMSwgLTEsXHJcbjgsIDAsIDIsIDgsIDIsIDUsIDgsIDUsIDcsIDEwLCA1LCAyLCAtMSwgLTEsIC0xLCAtMSxcclxuMiwgMTAsIDUsIDIsIDUsIDMsIDMsIDUsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG43LCA5LCA1LCA3LCA4LCA5LCAzLCAxMSwgMiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjksIDUsIDcsIDksIDcsIDIsIDksIDIsIDAsIDIsIDcsIDExLCAtMSwgLTEsIC0xLCAtMSxcclxuMiwgMywgMTEsIDAsIDEsIDgsIDEsIDcsIDgsIDEsIDUsIDcsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMSwgMiwgMSwgMTEsIDEsIDcsIDcsIDEsIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCA1LCA4LCA4LCA1LCA3LCAxMCwgMSwgMywgMTAsIDMsIDExLCAtMSwgLTEsIC0xLCAtMSxcclxuNSwgNywgMCwgNSwgMCwgOSwgNywgMTEsIDAsIDEsIDAsIDEwLCAxMSwgMTAsIDAsIC0xLFxyXG4xMSwgMTAsIDAsIDExLCAwLCAzLCAxMCwgNSwgMCwgOCwgMCwgNywgNSwgNywgMCwgLTEsXHJcbjExLCAxMCwgNSwgNywgMTEsIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMCwgNiwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDgsIDMsIDUsIDEwLCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgMCwgMSwgNSwgMTAsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCA4LCAzLCAxLCA5LCA4LCA1LCAxMCwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDYsIDUsIDIsIDYsIDEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCA2LCA1LCAxLCAyLCA2LCAzLCAwLCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgNiwgNSwgOSwgMCwgNiwgMCwgMiwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjUsIDksIDgsIDUsIDgsIDIsIDUsIDIsIDYsIDMsIDIsIDgsIC0xLCAtMSwgLTEsIC0xLFxyXG4yLCAzLCAxMSwgMTAsIDYsIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMSwgMCwgOCwgMTEsIDIsIDAsIDEwLCA2LCA1LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgMSwgOSwgMiwgMywgMTEsIDUsIDEwLCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNSwgMTAsIDYsIDEsIDksIDIsIDksIDExLCAyLCA5LCA4LCAxMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjYsIDMsIDExLCA2LCA1LCAzLCA1LCAxLCAzLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgOCwgMTEsIDAsIDExLCA1LCAwLCA1LCAxLCA1LCAxMSwgNiwgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDExLCA2LCAwLCAzLCA2LCAwLCA2LCA1LCAwLCA1LCA5LCAtMSwgLTEsIC0xLCAtMSxcclxuNiwgNSwgOSwgNiwgOSwgMTEsIDExLCA5LCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNSwgMTAsIDYsIDQsIDcsIDgsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG40LCAzLCAwLCA0LCA3LCAzLCA2LCA1LCAxMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDksIDAsIDUsIDEwLCA2LCA4LCA0LCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMTAsIDYsIDUsIDEsIDksIDcsIDEsIDcsIDMsIDcsIDksIDQsIC0xLCAtMSwgLTEsIC0xLFxyXG42LCAxLCAyLCA2LCA1LCAxLCA0LCA3LCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMSwgMiwgNSwgNSwgMiwgNiwgMywgMCwgNCwgMywgNCwgNywgLTEsIC0xLCAtMSwgLTEsXHJcbjgsIDQsIDcsIDksIDAsIDUsIDAsIDYsIDUsIDAsIDIsIDYsIC0xLCAtMSwgLTEsIC0xLFxyXG43LCAzLCA5LCA3LCA5LCA0LCAzLCAyLCA5LCA1LCA5LCA2LCAyLCA2LCA5LCAtMSxcclxuMywgMTEsIDIsIDcsIDgsIDQsIDEwLCA2LCA1LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNSwgMTAsIDYsIDQsIDcsIDIsIDQsIDIsIDAsIDIsIDcsIDExLCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgMSwgOSwgNCwgNywgOCwgMiwgMywgMTEsIDUsIDEwLCA2LCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgMiwgMSwgOSwgMTEsIDIsIDksIDQsIDExLCA3LCAxMSwgNCwgNSwgMTAsIDYsIC0xLFxyXG44LCA0LCA3LCAzLCAxMSwgNSwgMywgNSwgMSwgNSwgMTEsIDYsIC0xLCAtMSwgLTEsIC0xLFxyXG41LCAxLCAxMSwgNSwgMTEsIDYsIDEsIDAsIDExLCA3LCAxMSwgNCwgMCwgNCwgMTEsIC0xLFxyXG4wLCA1LCA5LCAwLCA2LCA1LCAwLCAzLCA2LCAxMSwgNiwgMywgOCwgNCwgNywgLTEsXHJcbjYsIDUsIDksIDYsIDksIDExLCA0LCA3LCA5LCA3LCAxMSwgOSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEwLCA0LCA5LCA2LCA0LCAxMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjQsIDEwLCA2LCA0LCA5LCAxMCwgMCwgOCwgMywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEwLCAwLCAxLCAxMCwgNiwgMCwgNiwgNCwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjgsIDMsIDEsIDgsIDEsIDYsIDgsIDYsIDQsIDYsIDEsIDEwLCAtMSwgLTEsIC0xLCAtMSxcclxuMSwgNCwgOSwgMSwgMiwgNCwgMiwgNiwgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDAsIDgsIDEsIDIsIDksIDIsIDQsIDksIDIsIDYsIDQsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCAyLCA0LCA0LCAyLCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOCwgMywgMiwgOCwgMiwgNCwgNCwgMiwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEwLCA0LCA5LCAxMCwgNiwgNCwgMTEsIDIsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCA4LCAyLCAyLCA4LCAxMSwgNCwgOSwgMTAsIDQsIDEwLCA2LCAtMSwgLTEsIC0xLCAtMSxcclxuMywgMTEsIDIsIDAsIDEsIDYsIDAsIDYsIDQsIDYsIDEsIDEwLCAtMSwgLTEsIC0xLCAtMSxcclxuNiwgNCwgMSwgNiwgMSwgMTAsIDQsIDgsIDEsIDIsIDEsIDExLCA4LCAxMSwgMSwgLTEsXHJcbjksIDYsIDQsIDksIDMsIDYsIDksIDEsIDMsIDExLCA2LCAzLCAtMSwgLTEsIC0xLCAtMSxcclxuOCwgMTEsIDEsIDgsIDEsIDAsIDExLCA2LCAxLCA5LCAxLCA0LCA2LCA0LCAxLCAtMSxcclxuMywgMTEsIDYsIDMsIDYsIDAsIDAsIDYsIDQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG42LCA0LCA4LCAxMSwgNiwgOCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjcsIDEwLCA2LCA3LCA4LCAxMCwgOCwgOSwgMTAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCA3LCAzLCAwLCAxMCwgNywgMCwgOSwgMTAsIDYsIDcsIDEwLCAtMSwgLTEsIC0xLCAtMSxcclxuMTAsIDYsIDcsIDEsIDEwLCA3LCAxLCA3LCA4LCAxLCA4LCAwLCAtMSwgLTEsIC0xLCAtMSxcclxuMTAsIDYsIDcsIDEwLCA3LCAxLCAxLCA3LCAzLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMSwgMiwgNiwgMSwgNiwgOCwgMSwgOCwgOSwgOCwgNiwgNywgLTEsIC0xLCAtMSwgLTEsXHJcbjIsIDYsIDksIDIsIDksIDEsIDYsIDcsIDksIDAsIDksIDMsIDcsIDMsIDksIC0xLFxyXG43LCA4LCAwLCA3LCAwLCA2LCA2LCAwLCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNywgMywgMiwgNiwgNywgMiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjIsIDMsIDExLCAxMCwgNiwgOCwgMTAsIDgsIDksIDgsIDYsIDcsIC0xLCAtMSwgLTEsIC0xLFxyXG4yLCAwLCA3LCAyLCA3LCAxMSwgMCwgOSwgNywgNiwgNywgMTAsIDksIDEwLCA3LCAtMSxcclxuMSwgOCwgMCwgMSwgNywgOCwgMSwgMTAsIDcsIDYsIDcsIDEwLCAyLCAzLCAxMSwgLTEsXHJcbjExLCAyLCAxLCAxMSwgMSwgNywgMTAsIDYsIDEsIDYsIDcsIDEsIC0xLCAtMSwgLTEsIC0xLFxyXG44LCA5LCA2LCA4LCA2LCA3LCA5LCAxLCA2LCAxMSwgNiwgMywgMSwgMywgNiwgLTEsXHJcbjAsIDksIDEsIDExLCA2LCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNywgOCwgMCwgNywgMCwgNiwgMywgMTEsIDAsIDExLCA2LCAwLCAtMSwgLTEsIC0xLCAtMSxcclxuNywgMTEsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG43LCA2LCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDAsIDgsIDExLCA3LCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgMSwgOSwgMTEsIDcsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG44LCAxLCA5LCA4LCAzLCAxLCAxMSwgNywgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEwLCAxLCAyLCA2LCAxMSwgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDIsIDEwLCAzLCAwLCA4LCA2LCAxMSwgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjIsIDksIDAsIDIsIDEwLCA5LCA2LCAxMSwgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjYsIDExLCA3LCAyLCAxMCwgMywgMTAsIDgsIDMsIDEwLCA5LCA4LCAtMSwgLTEsIC0xLCAtMSxcclxuNywgMiwgMywgNiwgMiwgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjcsIDAsIDgsIDcsIDYsIDAsIDYsIDIsIDAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4yLCA3LCA2LCAyLCAzLCA3LCAwLCAxLCA5LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMSwgNiwgMiwgMSwgOCwgNiwgMSwgOSwgOCwgOCwgNywgNiwgLTEsIC0xLCAtMSwgLTEsXHJcbjEwLCA3LCA2LCAxMCwgMSwgNywgMSwgMywgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEwLCA3LCA2LCAxLCA3LCAxMCwgMSwgOCwgNywgMSwgMCwgOCwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDMsIDcsIDAsIDcsIDEwLCAwLCAxMCwgOSwgNiwgMTAsIDcsIC0xLCAtMSwgLTEsIC0xLFxyXG43LCA2LCAxMCwgNywgMTAsIDgsIDgsIDEwLCA5LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNiwgOCwgNCwgMTEsIDgsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4zLCA2LCAxMSwgMywgMCwgNiwgMCwgNCwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjgsIDYsIDExLCA4LCA0LCA2LCA5LCAwLCAxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgNCwgNiwgOSwgNiwgMywgOSwgMywgMSwgMTEsIDMsIDYsIC0xLCAtMSwgLTEsIC0xLFxyXG42LCA4LCA0LCA2LCAxMSwgOCwgMiwgMTAsIDEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCAyLCAxMCwgMywgMCwgMTEsIDAsIDYsIDExLCAwLCA0LCA2LCAtMSwgLTEsIC0xLCAtMSxcclxuNCwgMTEsIDgsIDQsIDYsIDExLCAwLCAyLCA5LCAyLCAxMCwgOSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEwLCA5LCAzLCAxMCwgMywgMiwgOSwgNCwgMywgMTEsIDMsIDYsIDQsIDYsIDMsIC0xLFxyXG44LCAyLCAzLCA4LCA0LCAyLCA0LCA2LCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgNCwgMiwgNCwgNiwgMiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDksIDAsIDIsIDMsIDQsIDIsIDQsIDYsIDQsIDMsIDgsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCA5LCA0LCAxLCA0LCAyLCAyLCA0LCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOCwgMSwgMywgOCwgNiwgMSwgOCwgNCwgNiwgNiwgMTAsIDEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMCwgMSwgMCwgMTAsIDAsIDYsIDYsIDAsIDQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG40LCA2LCAzLCA0LCAzLCA4LCA2LCAxMCwgMywgMCwgMywgOSwgMTAsIDksIDMsIC0xLFxyXG4xMCwgOSwgNCwgNiwgMTAsIDQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG40LCA5LCA1LCA3LCA2LCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDgsIDMsIDQsIDksIDUsIDExLCA3LCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNSwgMCwgMSwgNSwgNCwgMCwgNywgNiwgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMSwgNywgNiwgOCwgMywgNCwgMywgNSwgNCwgMywgMSwgNSwgLTEsIC0xLCAtMSwgLTEsXHJcbjksIDUsIDQsIDEwLCAxLCAyLCA3LCA2LCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjYsIDExLCA3LCAxLCAyLCAxMCwgMCwgOCwgMywgNCwgOSwgNSwgLTEsIC0xLCAtMSwgLTEsXHJcbjcsIDYsIDExLCA1LCA0LCAxMCwgNCwgMiwgMTAsIDQsIDAsIDIsIC0xLCAtMSwgLTEsIC0xLFxyXG4zLCA0LCA4LCAzLCA1LCA0LCAzLCAyLCA1LCAxMCwgNSwgMiwgMTEsIDcsIDYsIC0xLFxyXG43LCAyLCAzLCA3LCA2LCAyLCA1LCA0LCA5LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgNSwgNCwgMCwgOCwgNiwgMCwgNiwgMiwgNiwgOCwgNywgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDYsIDIsIDMsIDcsIDYsIDEsIDUsIDAsIDUsIDQsIDAsIC0xLCAtMSwgLTEsIC0xLFxyXG42LCAyLCA4LCA2LCA4LCA3LCAyLCAxLCA4LCA0LCA4LCA1LCAxLCA1LCA4LCAtMSxcclxuOSwgNSwgNCwgMTAsIDEsIDYsIDEsIDcsIDYsIDEsIDMsIDcsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCA2LCAxMCwgMSwgNywgNiwgMSwgMCwgNywgOCwgNywgMCwgOSwgNSwgNCwgLTEsXHJcbjQsIDAsIDEwLCA0LCAxMCwgNSwgMCwgMywgMTAsIDYsIDEwLCA3LCAzLCA3LCAxMCwgLTEsXHJcbjcsIDYsIDEwLCA3LCAxMCwgOCwgNSwgNCwgMTAsIDQsIDgsIDEwLCAtMSwgLTEsIC0xLCAtMSxcclxuNiwgOSwgNSwgNiwgMTEsIDksIDExLCA4LCA5LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMywgNiwgMTEsIDAsIDYsIDMsIDAsIDUsIDYsIDAsIDksIDUsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCAxMSwgOCwgMCwgNSwgMTEsIDAsIDEsIDUsIDUsIDYsIDExLCAtMSwgLTEsIC0xLCAtMSxcclxuNiwgMTEsIDMsIDYsIDMsIDUsIDUsIDMsIDEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCAyLCAxMCwgOSwgNSwgMTEsIDksIDExLCA4LCAxMSwgNSwgNiwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDExLCAzLCAwLCA2LCAxMSwgMCwgOSwgNiwgNSwgNiwgOSwgMSwgMiwgMTAsIC0xLFxyXG4xMSwgOCwgNSwgMTEsIDUsIDYsIDgsIDAsIDUsIDEwLCA1LCAyLCAwLCAyLCA1LCAtMSxcclxuNiwgMTEsIDMsIDYsIDMsIDUsIDIsIDEwLCAzLCAxMCwgNSwgMywgLTEsIC0xLCAtMSwgLTEsXHJcbjUsIDgsIDksIDUsIDIsIDgsIDUsIDYsIDIsIDMsIDgsIDIsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCA1LCA2LCA5LCA2LCAwLCAwLCA2LCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMSwgNSwgOCwgMSwgOCwgMCwgNSwgNiwgOCwgMywgOCwgMiwgNiwgMiwgOCwgLTEsXHJcbjEsIDUsIDYsIDIsIDEsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCAzLCA2LCAxLCA2LCAxMCwgMywgOCwgNiwgNSwgNiwgOSwgOCwgOSwgNiwgLTEsXHJcbjEwLCAxLCAwLCAxMCwgMCwgNiwgOSwgNSwgMCwgNSwgNiwgMCwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDMsIDgsIDUsIDYsIDEwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMTAsIDUsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMSwgNSwgMTAsIDcsIDUsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMTEsIDUsIDEwLCAxMSwgNywgNSwgOCwgMywgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjUsIDExLCA3LCA1LCAxMCwgMTEsIDEsIDksIDAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xMCwgNywgNSwgMTAsIDExLCA3LCA5LCA4LCAxLCA4LCAzLCAxLCAtMSwgLTEsIC0xLCAtMSxcclxuMTEsIDEsIDIsIDExLCA3LCAxLCA3LCA1LCAxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgOCwgMywgMSwgMiwgNywgMSwgNywgNSwgNywgMiwgMTEsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCA3LCA1LCA5LCAyLCA3LCA5LCAwLCAyLCAyLCAxMSwgNywgLTEsIC0xLCAtMSwgLTEsXHJcbjcsIDUsIDIsIDcsIDIsIDExLCA1LCA5LCAyLCAzLCAyLCA4LCA5LCA4LCAyLCAtMSxcclxuMiwgNSwgMTAsIDIsIDMsIDUsIDMsIDcsIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG44LCAyLCAwLCA4LCA1LCAyLCA4LCA3LCA1LCAxMCwgMiwgNSwgLTEsIC0xLCAtMSwgLTEsXHJcbjksIDAsIDEsIDUsIDEwLCAzLCA1LCAzLCA3LCAzLCAxMCwgMiwgLTEsIC0xLCAtMSwgLTEsXHJcbjksIDgsIDIsIDksIDIsIDEsIDgsIDcsIDIsIDEwLCAyLCA1LCA3LCA1LCAyLCAtMSxcclxuMSwgMywgNSwgMywgNywgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDgsIDcsIDAsIDcsIDEsIDEsIDcsIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCAwLCAzLCA5LCAzLCA1LCA1LCAzLCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgOCwgNywgNSwgOSwgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjUsIDgsIDQsIDUsIDEwLCA4LCAxMCwgMTEsIDgsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG41LCAwLCA0LCA1LCAxMSwgMCwgNSwgMTAsIDExLCAxMSwgMywgMCwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDEsIDksIDgsIDQsIDEwLCA4LCAxMCwgMTEsIDEwLCA0LCA1LCAtMSwgLTEsIC0xLCAtMSxcclxuMTAsIDExLCA0LCAxMCwgNCwgNSwgMTEsIDMsIDQsIDksIDQsIDEsIDMsIDEsIDQsIC0xLFxyXG4yLCA1LCAxLCAyLCA4LCA1LCAyLCAxMSwgOCwgNCwgNSwgOCwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDQsIDExLCAwLCAxMSwgMywgNCwgNSwgMTEsIDIsIDExLCAxLCA1LCAxLCAxMSwgLTEsXHJcbjAsIDIsIDUsIDAsIDUsIDksIDIsIDExLCA1LCA0LCA1LCA4LCAxMSwgOCwgNSwgLTEsXHJcbjksIDQsIDUsIDIsIDExLCAzLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMiwgNSwgMTAsIDMsIDUsIDIsIDMsIDQsIDUsIDMsIDgsIDQsIC0xLCAtMSwgLTEsIC0xLFxyXG41LCAxMCwgMiwgNSwgMiwgNCwgNCwgMiwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDEwLCAyLCAzLCA1LCAxMCwgMywgOCwgNSwgNCwgNSwgOCwgMCwgMSwgOSwgLTEsXHJcbjUsIDEwLCAyLCA1LCAyLCA0LCAxLCA5LCAyLCA5LCA0LCAyLCAtMSwgLTEsIC0xLCAtMSxcclxuOCwgNCwgNSwgOCwgNSwgMywgMywgNSwgMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDQsIDUsIDEsIDAsIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG44LCA0LCA1LCA4LCA1LCAzLCA5LCAwLCA1LCAwLCAzLCA1LCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgNCwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjQsIDExLCA3LCA0LCA5LCAxMSwgOSwgMTAsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgOCwgMywgNCwgOSwgNywgOSwgMTEsIDcsIDksIDEwLCAxMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDEwLCAxMSwgMSwgMTEsIDQsIDEsIDQsIDAsIDcsIDQsIDExLCAtMSwgLTEsIC0xLCAtMSxcclxuMywgMSwgNCwgMywgNCwgOCwgMSwgMTAsIDQsIDcsIDQsIDExLCAxMCwgMTEsIDQsIC0xLFxyXG40LCAxMSwgNywgOSwgMTEsIDQsIDksIDIsIDExLCA5LCAxLCAyLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgNywgNCwgOSwgMTEsIDcsIDksIDEsIDExLCAyLCAxMSwgMSwgMCwgOCwgMywgLTEsXHJcbjExLCA3LCA0LCAxMSwgNCwgMiwgMiwgNCwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjExLCA3LCA0LCAxMSwgNCwgMiwgOCwgMywgNCwgMywgMiwgNCwgLTEsIC0xLCAtMSwgLTEsXHJcbjIsIDksIDEwLCAyLCA3LCA5LCAyLCAzLCA3LCA3LCA0LCA5LCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgMTAsIDcsIDksIDcsIDQsIDEwLCAyLCA3LCA4LCA3LCAwLCAyLCAwLCA3LCAtMSxcclxuMywgNywgMTAsIDMsIDEwLCAyLCA3LCA0LCAxMCwgMSwgMTAsIDAsIDQsIDAsIDEwLCAtMSxcclxuMSwgMTAsIDIsIDgsIDcsIDQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG40LCA5LCAxLCA0LCAxLCA3LCA3LCAxLCAzLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuNCwgOSwgMSwgNCwgMSwgNywgMCwgOCwgMSwgOCwgNywgMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjQsIDAsIDMsIDcsIDQsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG40LCA4LCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuOSwgMTAsIDgsIDEwLCAxMSwgOCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDAsIDksIDMsIDksIDExLCAxMSwgOSwgMTAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCAxLCAxMCwgMCwgMTAsIDgsIDgsIDEwLCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjMsIDEsIDEwLCAxMSwgMywgMTAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4xLCAyLCAxMSwgMSwgMTEsIDksIDksIDExLCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMywgMCwgOSwgMywgOSwgMTEsIDEsIDIsIDksIDIsIDExLCA5LCAtMSwgLTEsIC0xLCAtMSxcclxuMCwgMiwgMTEsIDgsIDAsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMywgMiwgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4yLCAzLCA4LCAyLCA4LCAxMCwgMTAsIDgsIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG45LCAxMCwgMiwgMCwgOSwgMiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjIsIDMsIDgsIDIsIDgsIDEwLCAwLCAxLCA4LCAxLCAxMCwgOCwgLTEsIC0xLCAtMSwgLTEsXHJcbjEsIDEwLCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuMSwgMywgOCwgOSwgMSwgOCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbjAsIDksIDEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4wLCAzLCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcclxuLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdKTtcclxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtYXJrbHVuZGluIC8gaHR0cDovL21hcmstbHVuZGluLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuaWYgKCBUSFJFRS5XZWJHTFJlbmRlcmVyICkge1xuXG5cdFRIUkVFLkFuYWdseXBoV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRcdFRIUkVFLldlYkdMUmVuZGVyZXIuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdFx0dGhpcy5hdXRvVXBkYXRlU2NlbmUgPSBmYWxzZTtcblxuXHRcdHZhciBfdGhpcyA9IHRoaXMsIF9zZXRTaXplID0gdGhpcy5zZXRTaXplLCBfcmVuZGVyID0gdGhpcy5yZW5kZXI7XG5cblx0XHR2YXIgX2NhbWVyYUwgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKSxcblx0XHRcdF9jYW1lcmFSID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cblx0XHR2YXIgZXllUmlnaHQgPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXHRcdFx0ZXllTGVmdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cdFx0XHRmb2NhbExlbmd0aCA9IDEyNSxcblx0XHRcdF9hc3BlY3QsIF9uZWFyLCBfZmFyLCBfZm92O1xuXG5cdFx0X2NhbWVyYUwubWF0cml4QXV0b1VwZGF0ZSA9IF9jYW1lcmFSLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHZhciBfcGFyYW1zID0geyBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWFnRmlsdGVyOiBUSFJFRS5OZWFyZXN0RmlsdGVyLCBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQgfTtcblxuXHRcdHZhciBfcmVuZGVyVGFyZ2V0TCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggNTEyLCA1MTIsIF9wYXJhbXMgKSxcblx0XHRcdF9yZW5kZXJUYXJnZXRSID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCA1MTIsIDUxMiwgX3BhcmFtcyApO1xuXG5cdFx0dmFyIF9jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDUzLCAxLCAxLCAxMDAwMCApO1xuXHRcdF9jYW1lcmEucG9zaXRpb24ueiA9IDI7XG5cblx0XHR2YXIgX21hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cblx0XHRcdFx0XCJtYXBMZWZ0XCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiAwLCB0ZXh0dXJlOiBfcmVuZGVyVGFyZ2V0TCB9LFxuXHRcdFx0XHRcIm1hcFJpZ2h0XCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiAxLCB0ZXh0dXJlOiBfcmVuZGVyVGFyZ2V0UiB9XG5cblx0XHRcdH0sXG5cblx0XHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFwidlV2ID0gdmVjMiggdXYueCwgMS4wIC0gdXYueSApO1wiLFxuXHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFwifVwiXG5cblx0XHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcExlZnQ7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwUmlnaHQ7XCIsXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFwidmVjNCBjb2xvckwsIGNvbG9yUjtcIixcblx0XHRcdFx0XHRcInZlYzIgdXYgPSB2VXY7XCIsXG5cblx0XHRcdFx0XHRcImNvbG9yTCA9IHRleHR1cmUyRCggbWFwTGVmdCwgdXYgKTtcIixcblx0XHRcdFx0XHRcImNvbG9yUiA9IHRleHR1cmUyRCggbWFwUmlnaHQsIHV2ICk7XCIsXG5cblx0XHRcdFx0XHQvLyBodHRwOi8vM2R0di5hdC9Lbm93aG93L0FuYWdseXBoQ29tcGFyaXNvbl9lbi5hc3B4XG5cblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yTC5nICogMC43ICsgY29sb3JMLmIgKiAwLjMsIGNvbG9yUi5nLCBjb2xvclIuYiwgY29sb3JMLmEgKyBjb2xvclIuYSApICogMS4xO1wiLFxuXG5cdFx0XHRcdFwifVwiXG5cblx0XHRcdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0XHR9ICk7XG5cblx0XHR2YXIgX3NjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cdFx0X3NjZW5lLmFkZCggbmV3IFRIUkVFLk1lc2goIG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KCAyLCAyICksIF9tYXRlcmlhbCApICk7XG5cblx0XHRfc2NlbmUuYWRkKCBfY2FtZXJhICk7XG5cblx0XHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRcdF9zZXRTaXplLmNhbGwoIF90aGlzLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdF9yZW5kZXJUYXJnZXRMLndpZHRoID0gd2lkdGg7XG5cdFx0XHRfcmVuZGVyVGFyZ2V0TC5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRcdF9yZW5kZXJUYXJnZXRSLndpZHRoID0gd2lkdGg7XG5cdFx0XHRfcmVuZGVyVGFyZ2V0Ui5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHR9O1xuXG5cdFx0Lypcblx0XHQgKiBSZW5kZXJlciBub3cgdXNlcyBhbiBhc3ltbWV0cmljIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gKGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9taXNjZWxsYW5lb3VzL3N0ZXJlb2dyYXBoaWNzL3N0ZXJlb3JlbmRlci8pLlxuXHRcdCAqIEVhY2ggY2FtZXJhIGlzIG9mZnNldCBieSB0aGUgZXllIHNlcGVyYXRpb24gYW5kIGl0cyBwcm9qZWN0aW9uIG1hdHJpeCBpcyBhbHNvIHNrZXdlZCBhc3ltZXRyaWNhbGx5IGJhY2sgdG8gY29udmVyZ2Ugb24gdGhlIHNhbWVcblx0XHQgKiBwcm9qZWN0aW9uIHBsYW5lLiBBZGRlZCBhIGZvY2FsIGxlbmd0aCBwYXJhbWV0ZXIgdG8sIHRoaXMgaXMgd2hlcmUgdGhlIHBhcmFsbGF4IGlzIGVxdWFsIHRvIDAuXG5cdFx0ICovXG5cblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xuXG5cdFx0XHRzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHR2YXIgaGFzQ2FtZXJhQ2hhbmdlZCA9ICggX2FzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCApIHx8ICggX25lYXIgIT09IGNhbWVyYS5uZWFyICkgfHwgKCBfZmFyICE9PSBjYW1lcmEuZmFyICkgfHwgKCBfZm92ICE9PSBjYW1lcmEuZm92ICk7XG5cblx0XHRcdGlmKCBoYXNDYW1lcmFDaGFuZ2VkICkge1xuXG5cdFx0XHRcdF9hc3BlY3QgPSBjYW1lcmEuYXNwZWN0O1xuXHRcdFx0XHRfbmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0XHRfZmFyID0gY2FtZXJhLmZhcjtcblx0XHRcdFx0X2ZvdiA9IGNhbWVyYS5mb3Y7XG5cblx0XHRcdFx0dmFyIHByb2plY3Rpb25NYXRyaXggPSBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jbG9uZSgpLFxuXHRcdFx0XHRcdGV5ZVNlcCA9IGZvY2FsTGVuZ3RoIC8gMzAgKiAwLjUsXG5cdFx0XHRcdFx0ZXllU2VwT25Qcm9qZWN0aW9uID0gZXllU2VwICogX25lYXIgLyBmb2NhbExlbmd0aCxcblx0XHRcdFx0XHR5bWF4ID0gX25lYXIgKiBNYXRoLnRhbiggX2ZvdiAqIE1hdGguUEkgLyAzNjAgKSxcblx0XHRcdFx0XHR4bWluLCB4bWF4O1xuXG5cdFx0XHRcdC8vIHRyYW5zbGF0ZSB4T2Zmc2V0XG5cblx0XHRcdFx0ZXllUmlnaHQubjE0ID0gZXllU2VwO1xuXHRcdFx0XHRleWVMZWZ0Lm4xNCA9IC1leWVTZXA7XG5cblx0XHRcdFx0Ly8gZm9yIGxlZnQgZXllXG5cblx0XHRcdFx0eG1pbiA9IC15bWF4ICogX2FzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdFx0eG1heCA9IHltYXggKiBfYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xuXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXgubjExID0gMiAqIF9uZWFyIC8gKCB4bWF4IC0geG1pbiApO1xuXHRcdFx0XHRwcm9qZWN0aW9uTWF0cml4Lm4xMyA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcblxuXHRcdFx0XHRfY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0XHQvLyBmb3IgcmlnaHQgZXllXG5cblx0XHRcdFx0eG1pbiA9IC15bWF4ICogX2FzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdFx0eG1heCA9IHltYXggKiBfYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xuXG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXgubjExID0gMiAqIF9uZWFyIC8gKCB4bWF4IC0geG1pbiApO1xuXHRcdFx0XHRwcm9qZWN0aW9uTWF0cml4Lm4xMyA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcblxuXHRcdFx0XHRfY2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfY2FtZXJhTC5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseVNlbGYoIGV5ZUxlZnQgKTtcblx0XHRcdF9jYW1lcmFMLnBvc2l0aW9uLmNvcHkoIGNhbWVyYS5wb3NpdGlvbiApO1xuXHRcdFx0X2NhbWVyYUwubmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0X2NhbWVyYUwuZmFyID0gY2FtZXJhLmZhcjtcblxuXHRcdFx0X3JlbmRlci5jYWxsKCBfdGhpcywgc2NlbmUsIF9jYW1lcmFMLCBfcmVuZGVyVGFyZ2V0TCwgdHJ1ZSApO1xuXG5cdFx0XHRfY2FtZXJhUi5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseVNlbGYoIGV5ZVJpZ2h0ICk7XG5cdFx0XHRfY2FtZXJhUi5wb3NpdGlvbi5jb3B5KCBjYW1lcmEucG9zaXRpb24gKTtcblx0XHRcdF9jYW1lcmFSLm5lYXIgPSBjYW1lcmEubmVhcjtcblx0XHRcdF9jYW1lcmFSLmZhciA9IGNhbWVyYS5mYXI7XG5cblx0XHRcdF9yZW5kZXIuY2FsbCggX3RoaXMsIHNjZW5lLCBfY2FtZXJhUiwgX3JlbmRlclRhcmdldFIsIHRydWUgKTtcblxuXHRcdFx0X3NjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0XHRfcmVuZGVyLmNhbGwoIF90aGlzLCBfc2NlbmUsIF9jYW1lcmEgKTtcblxuXHRcdH07XG5cblx0fTtcblxufTtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5pZiAoIFRIUkVFLldlYkdMUmVuZGVyZXIgKSB7XG5cblx0VEhSRUUuQ3Jvc3NleWVkV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRcdFRIUkVFLldlYkdMUmVuZGVyZXIuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPSBmYWxzZTtcblxuXHRcdHZhciBfdGhpcyA9IHRoaXMsIF9zZXRTaXplID0gdGhpcy5zZXRTaXplLCBfcmVuZGVyID0gdGhpcy5yZW5kZXI7XG5cblx0XHR2YXIgX3dpZHRoLCBfaGVpZ2h0O1xuXG5cdFx0dmFyIF9jYW1lcmFMID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0X2NhbWVyYUwudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKTtcblxuXHRcdHZhciBfY2FtZXJhUiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdF9jYW1lcmFSLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICk7XG5cblx0XHRfdGhpcy5zZXBhcmF0aW9uID0gMTA7XG5cdFx0aWYgKCBwYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnMuc2VwYXJhdGlvbiAhPT0gdW5kZWZpbmVkICkgX3RoaXMuc2VwYXJhdGlvbiA9IHBhcmFtZXRlcnMuc2VwYXJhdGlvbjtcblxuXHRcdHZhciBTQ1JFRU5fV0lEVEggID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFx0dmFyIFNDUkVFTl9IRUlHSFQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdFx0dmFyIEhBTEZfV0lEVEggPSBTQ1JFRU5fV0lEVEggLyAyO1xuXG5cdFx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0XHRfc2V0U2l6ZS5jYWxsKCBfdGhpcywgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRfd2lkdGggPSB3aWR0aC8yO1xuXHRcdFx0X2hlaWdodCA9IGhlaWdodDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xuXG5cdFx0XHR0aGlzLmNsZWFyKCk7XG5cblx0XHRcdF9jYW1lcmFMLmZvdiA9IGNhbWVyYS5mb3Y7XG5cdFx0XHRfY2FtZXJhTC5hc3BlY3QgPSAwLjUgKiBjYW1lcmEuYXNwZWN0O1xuXHRcdFx0X2NhbWVyYUwubmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0X2NhbWVyYUwuZmFyID0gY2FtZXJhLmZhcjtcblx0XHRcdF9jYW1lcmFMLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHRcdFx0X2NhbWVyYUwucG9zaXRpb24uY29weSggY2FtZXJhLnBvc2l0aW9uICk7XG5cdFx0XHRfY2FtZXJhTC50YXJnZXQuY29weSggY2FtZXJhLnRhcmdldCApO1xuXHRcdFx0X2NhbWVyYUwudHJhbnNsYXRlWCggX3RoaXMuc2VwYXJhdGlvbiApO1xuXHRcdFx0X2NhbWVyYUwubG9va0F0KCBfY2FtZXJhTC50YXJnZXQgKTtcblxuXHRcdFx0X2NhbWVyYVIucHJvamVjdGlvbk1hdHJpeCA9IF9jYW1lcmFMLnByb2plY3Rpb25NYXRyaXg7XG5cblx0XHRcdF9jYW1lcmFSLnBvc2l0aW9uLmNvcHkoIGNhbWVyYS5wb3NpdGlvbiApO1xuXHRcdFx0X2NhbWVyYVIudGFyZ2V0LmNvcHkoIGNhbWVyYS50YXJnZXQgKTtcblx0XHRcdF9jYW1lcmFSLnRyYW5zbGF0ZVgoIC0gX3RoaXMuc2VwYXJhdGlvbiApO1xuXHRcdFx0X2NhbWVyYVIubG9va0F0KCBfY2FtZXJhUi50YXJnZXQgKTtcblxuXHRcdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICk7XG5cdFx0XHRfcmVuZGVyLmNhbGwoIF90aGlzLCBzY2VuZSwgX2NhbWVyYUwgKTtcblxuXHRcdFx0dGhpcy5zZXRWaWV3cG9ydCggX3dpZHRoLCAwLCBfd2lkdGgsIF9oZWlnaHQgKTtcblx0XHRcdF9yZW5kZXIuY2FsbCggX3RoaXMsIHNjZW5lLCBfY2FtZXJhUiwgZmFsc2UgKTtcblxuXHRcdH07XG5cblx0fTtcblxufVxuXG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiBUSFJFRSAhPSBcInVuZGVmaW5lZFwiID8gVEhSRUUgOiB3aW5kb3cuVEhSRUUpO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGRlZmluZUV4cG9ydChleCkgeyBtb2R1bGUuZXhwb3J0cyA9IGV4OyB9KTtcblxufSkod2luZG93KSIsInJlcXVpcmUgJy4vbGliL1JlcXVlc3RBbmltYXRpb25GcmFtZSdcbnJlcXVpcmUgJ2pxdWVyeS1tb3VzZXdoZWVsJ1xucmVxdWlyZSAnanF1ZXJ5LWhvdGtleXMnXG5cbiQgPSByZXF1aXJlKCdqcXVlcnknKVxubWluZWNyYWZ0ID0gcmVxdWlyZSgnLi9taW5lY3JhZnQuY29mZmVlJylcbiQobWluZWNyYWZ0KVxuIiwiLyoqXG4gKiBQcm92aWRlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaW4gYSBjcm9zcyBicm93c2VyIHdheS5cbiAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gKi9cblxuaWYgKCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblxuXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKCBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0ZnVuY3Rpb24oIC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrLCAvKiBET01FbGVtZW50IEVsZW1lbnQgKi8gZWxlbWVudCApIHtcblxuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGNhbGxiYWNrLCAxMDAwIC8gNjAgKTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cbn1cbiIsIiMgSW1wb3J0c1xuJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkRldGVjdG9yID0gcmVxdWlyZSAnZGV0ZWN0b3InXG5JbXByb3ZlZE5vaXNlID0gcmVxdWlyZSAnaW1wcm92ZWQtbm9pc2UnXG5cblRIUkVFID0gcmVxdWlyZSAndGhyZWUnXG57T2JqZWN0M0QsIE1hdHJpeDQsIFNjZW5lLCBNZXNoLCBXZWJHTFJlbmRlcmVyLCBQZXJzcGVjdGl2ZUNhbWVyYX0gPSBUSFJFRVxue0N1YmVHZW9tZXRyeSwgUGxhbmVHZW9tZXRyeSwgTWVzaExhbWJlcnRNYXRlcmlhbCwgTWVzaE5vcm1hbE1hdGVyaWFsfSA9IFRIUkVFXG57QW1iaWVudExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0LCBQb2ludExpZ2h0LCBSYXksIFZlY3RvcjMsIFZlY3RvcjJ9ID0gVEhSRUVcbntNZXNoTGFtYmVydE1hdGVyaWFsLCBNZXNoTm9ybWFsTWF0ZXJpYWwsIFByb2plY3Rvcn0gPSBUSFJFRVxue1RleHR1cmUsIFVWTWFwcGluZywgUmVwZWF0V3JhcHBpbmcsIFJlcGVhdFdyYXBwaW5nLCBOZWFyZXN0RmlsdGVyfSA9IFRIUkVFXG57TGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBDbG9ja30gPSBUSFJFRVxuXG57IE1vdXNlRXZlbnQsIENvbnRyb2xzIH0gPSByZXF1aXJlICcuL2NhbWVyYS5jb2ZmZWUnXG5Db2xsaXNpb25VdGlscyA9IHJlcXVpcmUgJy4vY29sbGlzaW9uLmNvZmZlZSdcblxuXG52ZWMgPSAoeCwgeSwgeikgLT4gbmV3IFZlY3RvcjMgeCwgeSwgelxuXG5DdWJlU2l6ZSA9IDUwXG5CbG9ja3MgPSBbXCJjb2JibGVzdG9uZVwiLCBcInBsYW5rXCIsIFwiYnJpY2tcIiwgXCJkaWFtb25kXCIsXG4gICAgXCJnbG93c3RvbmVcIiwgXCJvYnNpZGlhblwiLCBcIndoaXRld29vbFwiLCBcImJsdWV3b29sXCIsIFwicmVkd29vbFwiLCBcIm5ldGhlcnJhY2tcIl1cblxuY2xhc3MgUGxheWVyXG4gICAgd2lkdGg6IEN1YmVTaXplICogMC4zXG4gICAgZGVwdGg6IEN1YmVTaXplICogMC4zXG4gICAgaGVpZ2h0OiBDdWJlU2l6ZSAqIDEuNjNcblxuICAgIGNvbnN0cnVjdG9yOiAtPlxuICAgICAgICBAaGFsZkhlaWdodCA9IEBoZWlnaHQgLyAyXG4gICAgICAgIEBoYWxmV2lkdGggPSBAd2lkdGggLyAyXG4gICAgICAgIEBoYWxmRGVwdGggPSBAZGVwdGggLyAyXG4gICAgICAgIEBwb3MgPSB2ZWMoKVxuICAgICAgICBAZXllc0RlbHRhID0gQGhhbGZIZWlnaHQgKiAwLjlcblxuICAgIGV5ZXNQb3NpdGlvbjogLT5cbiAgICAgICAgcmV0ID0gQHBvcy5jbG9uZSgpXG4gICAgICAgIHJldC55ICs9IEBleWVzRGVsdGFcbiAgICAgICAgcmV0dXJuIHJldFxuXG5cbiAgICBwb3NpdGlvbjogKGF4aXMpIC0+XG4gICAgICAgIHJldHVybiBAcG9zIHVubGVzcyBheGlzP1xuICAgICAgICByZXR1cm4gQHBvc1theGlzXVxuXG4gICAgaW5jUG9zaXRpb246IChheGlzLCB2YWwpIC0+XG4gICAgICAgIEBwb3NbYXhpc10gKz0gdmFsXG4gICAgICAgIHJldHVyblxuXG4gICAgc2V0UG9zaXRpb246IChheGlzLCB2YWwpIC0+XG4gICAgICAgIEBwb3NbYXhpc10gPSB2YWxcbiAgICAgICAgcmV0dXJuXG5cblxuICAgIGNvbGxpZGVzV2l0aEdyb3VuZDogLT4gQHBvc2l0aW9uKCd5JykgPCBAaGFsZkhlaWdodFxuXG4gICAgdmVydGV4OiAodmVydGV4WCwgdmVydGV4WSwgdmVydGV4WikgLT5cbiAgICAgICAgdmVydGV4ID0gQHBvc2l0aW9uKCkuY2xvbmUoKVxuICAgICAgICB2ZXJ0ZXgueCArPSB2ZXJ0ZXhYICogQGhhbGZXaWR0aFxuICAgICAgICB2ZXJ0ZXgueSArPSB2ZXJ0ZXhZICogQGhhbGZIZWlnaHRcbiAgICAgICAgdmVydGV4LnogKz0gdmVydGV4WiAqIEBoYWxmRGVwdGhcbiAgICAgICAgcmV0dXJuIHZlcnRleFxuXG4gICAgYm91bmRpbmdCb3g6IC0+XG4gICAgICAgIHZtaW4gPSBAdmVydGV4KC0xLCAtMSwgLTEpXG4gICAgICAgIHZtYXggPSBAdmVydGV4IDEsIDEsIDFcbiAgICAgICAgcmV0dXJuIHt2bWluOiB2bWluLCB2bWF4OiB2bWF4fVxuXG5cbmNsYXNzIEdyaWRcbiAgICBjb25zdHJ1Y3RvcjogKEBzaXplID0gNSkgLT5cbiAgICAgICAgQG1hdHJpeCA9IFtdXG4gICAgICAgIEBzaXplLnRpbWVzIChpKSA9PlxuICAgICAgICAgICAgQG1hdHJpeFtpXSA9IFtdXG4gICAgICAgICAgICBAc2l6ZS50aW1lcyAoaikgPT5cbiAgICAgICAgICAgICAgICBAbWF0cml4W2ldW2pdID0gW11cblxuICAgIGluc2lkZUdyaWQ6ICh4LCB5LCB6KSAtPiAwIDw9IHggPCBAc2l6ZSBhbmQgMCA8PSB5IDwgQHNpemUgYW5kIDAgPD0geiA8IEBzaXplXG5cbiAgICBnZXQ6ICh4LCB5LCB6KSAtPiBAbWF0cml4W3hdW3ldW3pdXG5cbiAgICBwdXQ6ICh4LCB5LCB6LCB2YWwpIC0+IEBtYXRyaXhbeF1beV1bel0gPSB2YWxcblxuICAgIGdyaWRDb29yZHM6ICh4LCB5LCB6KSAtPlxuICAgICAgICB4ID0gTWF0aC5mbG9vcih4IC8gQ3ViZVNpemUpXG4gICAgICAgIHkgPSBNYXRoLmZsb29yKHkgLyBDdWJlU2l6ZSlcbiAgICAgICAgeiA9IE1hdGguZmxvb3IoeiAvIEN1YmVTaXplKVxuICAgICAgICByZXR1cm4gW3gsIHksIHpdXG5cblxuY2xhc3MgQ29sbGlzaW9uSGVscGVyXG4gICAgY29uc3RydWN0b3I6IChAcGxheWVyLCBAZ3JpZCktPiByZXR1cm5cbiAgICByYWQ6IEN1YmVTaXplXG4gICAgaGFsZlJhZDogQ3ViZVNpemUgLyAyXG5cbiAgICBjb2xsaWRlczogLT5cbiAgICAgICAgcmV0dXJuIHRydWUgaWYgQHBsYXllci5jb2xsaWRlc1dpdGhHcm91bmQoKVxuICAgICAgICByZXR1cm4gdHJ1ZSBpZiBAYmV5b25kQm91bmRzKClcbiAgICAgICAgcGxheWVyQm94ID0gQHBsYXllci5ib3VuZGluZ0JveCgpXG4gICAgICAgIGZvciBjdWJlIGluIEBwb3NzaWJsZUN1YmVzKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlIGlmIEBfY29sbGlkZVdpdGhDdWJlIHBsYXllckJveCwgY3ViZVxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIGJleW9uZEJvdW5kczogLT5cbiAgICAgICAgcCA9IEBwbGF5ZXIucG9zaXRpb24oKVxuICAgICAgICBbeCwgeSwgel0gPSBAZ3JpZC5ncmlkQ29vcmRzIHAueCwgcC55LCBwLnpcbiAgICAgICAgcmV0dXJuIHRydWUgdW5sZXNzIEBncmlkLmluc2lkZUdyaWQgeCwgMCwgelxuXG5cbiAgICBfYWRkVG9Qb3NpdGlvbjogKHBvc2l0aW9uLCB2YWx1ZSkgLT5cbiAgICAgICAgcG9zID0gcG9zaXRpb24uY2xvbmUoKVxuICAgICAgICBwb3MueCArPSB2YWx1ZVxuICAgICAgICBwb3MueSArPSB2YWx1ZVxuICAgICAgICBwb3MueiArPSB2YWx1ZVxuICAgICAgICByZXR1cm4gcG9zXG5cbiAgICBjb2xsaWRlV2l0aEN1YmU6IChjdWJlKSAtPiBAX2NvbGxpZGVXaXRoQ3ViZSBAcGxheWVyLmJvdW5kaW5nQm94KCksIGN1YmVcblxuICAgIF9jb2xsaWRlV2l0aEN1YmU6IChwbGF5ZXJCb3gsIGN1YmUpIC0+XG4gICAgICAgIHZtaW4gPSBAX2FkZFRvUG9zaXRpb24gY3ViZS5wb3NpdGlvbiwgLUBoYWxmUmFkXG4gICAgICAgIHZtYXggPSBAX2FkZFRvUG9zaXRpb24gY3ViZS5wb3NpdGlvbiwgQGhhbGZSYWRcbiAgICAgICAgY3ViZUJveCA9IHt2bWluLCB2bWF4fVxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uVXRpbHMudGVzdEN1YmVDb2xsaXNpb24gcGxheWVyQm94LCBjdWJlQm94XG5cbiAgICBwb3NzaWJsZUN1YmVzOiAtPlxuICAgICAgICBjdWJlcyA9IFtdXG4gICAgICAgIGdyaWQgPSBAZ3JpZFxuICAgICAgICBAd2l0aFJhbmdlICh4LCB5LCB6KSAtPlxuICAgICAgICAgICAgY3ViZSA9IGdyaWQuZ2V0IHgsIHksIHpcbiAgICAgICAgICAgIGN1YmVzLnB1c2ggY3ViZSBpZiBjdWJlP1xuICAgICAgICByZXR1cm4gY3ViZXNcblxuICAgIHdpdGhSYW5nZTogKGZ1bmMpIC0+XG4gICAgICAgIHt2bWluLCB2bWF4fSA9IEBwbGF5ZXIuYm91bmRpbmdCb3goKVxuICAgICAgICBtaW54ID0gQHRvR3JpZCh2bWluLngpXG4gICAgICAgIG1pbnkgPSBAdG9HcmlkKHZtaW4ueSlcbiAgICAgICAgbWlueiA9IEB0b0dyaWQodm1pbi56KVxuXG4gICAgICAgIG1heHggPSBAdG9HcmlkKHZtYXgueCArIEByYWQpXG4gICAgICAgIG1heHkgPSBAdG9HcmlkKHZtYXgueSArIEByYWQpXG4gICAgICAgIG1heHogPSBAdG9HcmlkKHZtYXgueiArIEByYWQpXG4gICAgICAgIHggPSBtaW54XG4gICAgICAgIHdoaWxlIHggPD0gbWF4eFxuICAgICAgICAgICAgeSA9IG1pbnlcbiAgICAgICAgICAgIHdoaWxlIHkgPD0gbWF4eVxuICAgICAgICAgICAgICAgIHogPSBtaW56XG4gICAgICAgICAgICAgICAgd2hpbGUgeiA8PSBtYXh6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgeCwgeSwgelxuICAgICAgICAgICAgICAgICAgICB6KytcbiAgICAgICAgICAgICAgICB5KytcbiAgICAgICAgICAgIHgrK1xuICAgICAgICByZXR1cm5cblxuICAgIHRvR3JpZDogKHZhbCkgLT5cbiAgICAgICAgcmV0ID0gTWF0aC5mbG9vcih2YWwgLyBAcmFkKVxuICAgICAgICByZXR1cm4gMCBpZiByZXQgPCAwXG4gICAgICAgIHJldHVybiBAZ3JpZC5zaXplIC0gMSBpZiByZXQgPiBAZ3JpZC5zaXplIC0gMVxuICAgICAgICByZXR1cm4gcmV0XG5cblxuVGV4dHVyZUhlbHBlciA9XG4gICAgbG9hZFRleHR1cmU6IChwYXRoKSAtPlxuICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpXG4gICAgICAgIGltYWdlLnNyYyA9IHBhdGhcbiAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlLCBuZXcgVVZNYXBwaW5nKCksIENsYW1wVG9FZGdlV3JhcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIE5lYXJlc3RGaWx0ZXIsIExpbmVhck1pcE1hcExpbmVhckZpbHRlcilcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gLT4gdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWVcbiAgICAgICAgbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwobWFwOiB0ZXh0dXJlLCBhbWJpZW50OiAweGJiYmJiYilcblxuXG4gICAgdGlsZVRleHR1cmU6IChwYXRoLCByZXBlYXR4LCByZXBlYXR5KSAtPlxuICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpXG4gICAgICAgIGltYWdlLnNyYyA9IHBhdGhcbiAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlLCBuZXcgVVZNYXBwaW5nKCksIFJlcGVhdFdyYXBwaW5nLFxuICAgICAgICBSZXBlYXRXcmFwcGluZywgTmVhcmVzdEZpbHRlciwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyKVxuICAgICAgICB0ZXh0dXJlLnJlcGVhdC54ID0gcmVwZWF0eFxuICAgICAgICB0ZXh0dXJlLnJlcGVhdC55ID0gcmVwZWF0eVxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAtPiB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbChtYXA6IHRleHR1cmUsIGFtYmllbnQ6IDB4YmJiYmJiKVxuXG5cblxuY2xhc3MgRmxvb3JcbiAgICBjb25zdHJ1Y3RvcjogKHdpZHRoLCBoZWlnaHQpIC0+XG4gICAgICAgIHJlcGVhdFggPSB3aWR0aCAvIEN1YmVTaXplXG4gICAgICAgIHJlcGVhdFkgPSBoZWlnaHQgLyBDdWJlU2l6ZVxuICAgICAgICBtYXRlcmlhbCA9IFRleHR1cmVIZWxwZXIudGlsZVRleHR1cmUoXCIuL3RleHR1cmVzL2JlZHJvY2sucG5nXCIsIHJlcGVhdFgsIHJlcGVhdFkpXG4gICAgICAgIHBsYW5lR2VvID0gbmV3IFBsYW5lR2VvbWV0cnkod2lkdGgsIGhlaWdodCwgMSwgMSlcbiAgICAgICAgcGxhbmUgPSBuZXcgTWVzaChwbGFuZUdlbywgbWF0ZXJpYWwpXG4gICAgICAgIHBsYW5lLnBvc2l0aW9uLnkgPSAtMVxuICAgICAgICBwbGFuZS5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyXG4gICAgICAgIHBsYW5lLm5hbWUgPSAnZmxvb3InXG4gICAgICAgIEBwbGFuZSA9IHBsYW5lXG5cbiAgICBhZGRUb1NjZW5lOiAoc2NlbmUpIC0+IHNjZW5lLmFkZCBAcGxhbmVcblxuXG5jbGFzcyBHYW1lXG4gICAgY29uc3RydWN0b3I6IC0+XG4gICAgICAgIEByYWQgPSBDdWJlU2l6ZVxuICAgICAgICBAd2lkdGggPSB3aW5kb3c/LmlubmVyV2lkdGhcbiAgICAgICAgQGhlaWdodCA9IHdpbmRvdz8uaW5uZXJIZWlnaHRcbiAgICAgICAgQGdlbyA9IEBjcmVhdGVHcmFzc0dlb21ldHJ5KClcbiAgICAgICAgQGN1YmVCbG9ja3MgPSBAY3JlYXRlQmxvY2tzR2VvbWV0cnkoKVxuICAgICAgICBAc2VsZWN0Q3ViZUJsb2NrICdjb2JibGVzdG9uZSdcbiAgICAgICAgQG1vdmUgPSB7eDogMCwgejogMCwgeTogMH1cbiAgICAgICAgQGtleXNEb3duID0ge31cbiAgICAgICAgQGdyaWQgPSBuZXcgR3JpZCgxMDApXG4gICAgICAgIEBvbkdyb3VuZCA9IHRydWVcbiAgICAgICAgQHBhdXNlID0gb2ZmXG4gICAgICAgIEByZW5kZXJlciA9IEBjcmVhdGVSZW5kZXJlcigpXG4gICAgICAgIEBjYW1lcmEgPSBAY3JlYXRlQ2FtZXJhKClcbiAgICAgICAgQGNhbnZhcyA9IEByZW5kZXJlci5kb21FbGVtZW50XG4gICAgICAgIEBjb250cm9scyA9IG5ldyBDb250cm9scyBAY2FtZXJhLCBAY2FudmFzXG4gICAgICAgIEBwbGF5ZXIgPSBuZXcgUGxheWVyKClcbiAgICAgICAgQHNjZW5lID0gbmV3IFNjZW5lKClcbiAgICAgICAgbmV3IEZsb29yKDUwMDAwLCA1MDAwMCkuYWRkVG9TY2VuZSBAc2NlbmVcbiAgICAgICAgQHNjZW5lLmFkZCBAY2FtZXJhXG4gICAgICAgIEBhZGRMaWdodHMgQHNjZW5lXG4gICAgICAgIEBwcm9qZWN0b3IgPSBuZXcgUHJvamVjdG9yKClcbiAgICAgICAgQGNhc3RSYXkgPSBudWxsXG4gICAgICAgIEBtb3ZlZCA9IGZhbHNlXG4gICAgICAgIEB0b0RlbGV0ZSA9IG51bGxcbiAgICAgICAgQGNvbGxpc2lvbkhlbHBlciA9IG5ldyBDb2xsaXNpb25IZWxwZXIoQHBsYXllciwgQGdyaWQpXG4gICAgICAgIEBjbG9jayA9IG5ldyBDbG9jaygpXG4gICAgICAgIEBwb3B1bGF0ZVdvcmxkKClcbiAgICAgICAgQGRlZmluZUNvbnRyb2xzKClcblxuICAgIGNyZWF0ZUJsb2Nrc0dlb21ldHJ5OiAtPlxuICAgICAgICBjdWJlQmxvY2tzID0ge31cbiAgICAgICAgZm9yIGIgaW4gQmxvY2tzXG4gICAgICAgICAgICBjdWJlID0gbmV3IFRIUkVFLkN1YmVHZW9tZXRyeSBAcmFkLCBAcmFkLCBAcmFkLCAxLCAxLCAxLCBAdGV4dHVyZShiKVxuICAgICAgICAgICAgY3ViZUJsb2Nrc1tiXSA9IGN1YmVcbiAgICAgICAgcmV0dXJuIGN1YmVCbG9ja3NcblxuICAgIGNyZWF0ZUdyYXNzR2VvbWV0cnk6IC0+XG4gICAgICAgIFtncmFzc19kaXJ0LCBncmFzcywgZGlydF0gPSBAdGV4dHVyZXMgXCJncmFzc19kaXJ0XCIsIFwiZ3Jhc3NcIiwgXCJkaXJ0XCJcbiAgICAgICAgbWF0ZXJpYWxzID0gW2dyYXNzX2RpcnQsICNyaWdodFxuICAgICAgICAgICAgZ3Jhc3NfZGlydCwgIyBsZWZ0XG4gICAgICAgICAgICBncmFzcywgIyB0b3BcbiAgICAgICAgICAgIGRpcnQsICMgYm90dG9tXG4gICAgICAgICAgICBncmFzc19kaXJ0LCAjIGJhY2tcbiAgICAgICAgICAgIGdyYXNzX2RpcnRdICAjZnJvbnRcbiAgICAgICAgbmV3IFRIUkVFLkN1YmVHZW9tZXRyeSggQHJhZCwgQHJhZCwgQHJhZCwgMSwgMSwgMSwgbWF0ZXJpYWxzKVxuXG4gICAgdGV4dHVyZTogKG5hbWUpIC0+IFRleHR1cmVIZWxwZXIubG9hZFRleHR1cmUgXCIuL3RleHR1cmVzLyN7bmFtZX0ucG5nXCJcblxuICAgIHRleHR1cmVzOiAobmFtZXMuLi4pIC0+IHJldHVybiAoQHRleHR1cmUgbmFtZSBmb3IgbmFtZSBpbiBuYW1lcylcblxuICAgIGdyaWRDb29yZHM6ICh4LCB5LCB6KSAtPiBAZ3JpZC5ncmlkQ29vcmRzIHgsIHksIHpcblxuXG4gICAgaW50b0dyaWQ6ICh4LCB5LCB6LCB2YWwpIC0+XG4gICAgICAgIGFyZ3MgPSBAZ3JpZENvb3Jkcyh4LCB5LCB6KS5jb25jYXQodmFsKVxuICAgICAgICByZXR1cm4gQGdyaWQucHV0IGFyZ3MuLi5cblxuXG4gICAgZ2VuZXJhdGVIZWlnaHQ6IC0+XG4gICAgICAgIHNpemUgPSAxMVxuICAgICAgICBkYXRhID0gW11cbiAgICAgICAgc2l6ZS50aW1lcyAoaSkgLT5cbiAgICAgICAgICAgIGRhdGFbaV0gPSBbXVxuICAgICAgICAgICAgc2l6ZS50aW1lcyAoaikgLT5cbiAgICAgICAgICAgICAgICBkYXRhW2ldW2pdID0gMFxuICAgICAgICBwZXJsaW4gPSBuZXcgSW1wcm92ZWROb2lzZSgpXG4gICAgICAgIHF1YWxpdHkgPSAwLjA1XG4gICAgICAgIHogPSBNYXRoLnJhbmRvbSgpICogMTAwXG4gICAgICAgIDQudGltZXMgKGopIC0+XG4gICAgICAgICAgICBzaXplLnRpbWVzICh4KSAtPlxuICAgICAgICAgICAgICAgIHNpemUudGltZXMgKHkpIC0+XG4gICAgICAgICAgICAgICAgICAgIG5vaXNlID0gcGVybGluLm5vaXNlKHggLyBxdWFsaXR5LCB5IC8gcXVhbGl0eSwgeilcbiAgICAgICAgICAgICAgICAgICAgZGF0YVt4XVt5XSArPSBub2lzZSAqIHF1YWxpdHlcbiAgICAgICAgICAgIHF1YWxpdHkgKj0gNFxuICAgICAgICBkYXRhXG5cblxuICAgIHBvcHVsYXRlV29ybGQ6IC0+XG4gICAgICAgIG1pZGRsZSA9IEBncmlkLnNpemUgLyAyXG4gICAgICAgIGRhdGEgPSBAZ2VuZXJhdGVIZWlnaHQoKVxuICAgICAgICBwbGF5ZXJIZWlnaHQgPSBudWxsXG4gICAgICAgIGZvciBpIGluIFstNS4uNV1cbiAgICAgICAgICAgIGZvciBqIGluIFstNS4uNV1cbiAgICAgICAgICAgICAgICBoZWlnaHQgPShNYXRoLmFicyBNYXRoLmZsb29yKGRhdGFbaSArIDVdW2ogKyA1XSkpICsgMVxuICAgICAgICAgICAgICAgIHBsYXllckhlaWdodCA9IChoZWlnaHQgKyAxKSAqIEN1YmVTaXplIGlmIGkgPT0gMCBhbmQgaiA9PSAwXG4gICAgICAgICAgICAgICAgaGVpZ2h0LnRpbWVzIChrKSA9PiBAY3ViZUF0IG1pZGRsZSArIGkgLCBrLCBtaWRkbGUgKyBqXG4gICAgICAgIG1pZGRsZVBvcyA9IG1pZGRsZSAqIEN1YmVTaXplXG4gICAgICAgIEBwbGF5ZXIucG9zLnNldCBtaWRkbGVQb3MsIHBsYXllckhlaWdodCwgbWlkZGxlUG9zXG5cbiAgICBjdWJlQXQ6ICh4LCB5LCB6LCBnZW8sIHZhbGlkYXRpbmdGdW5jdGlvbikgLT5cbiAgICAgICAgZ2VvIG9yPUBnZW9cbiAgICAgICAgbWVzaCA9IG5ldyBNZXNoKGdlbywgbmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoKSlcbiAgICAgICAgbWVzaC5nZW9tZXRyeS5keW5hbWljID0gZmFsc2VcbiAgICAgICAgaGFsZmN1YmUgPSBDdWJlU2l6ZSAvIDJcbiAgICAgICAgbWVzaC5wb3NpdGlvbi5zZXQgQ3ViZVNpemUgKiB4LCB5ICogQ3ViZVNpemUgKyBoYWxmY3ViZSwgQ3ViZVNpemUgKiB6XG4gICAgICAgIG1lc2gubmFtZSA9IFwiYmxvY2tcIlxuICAgICAgICBpZiB2YWxpZGF0aW5nRnVuY3Rpb24/XG4gICAgICAgICAgICByZXR1cm4gdW5sZXNzIHZhbGlkYXRpbmdGdW5jdGlvbihtZXNoKVxuICAgICAgICBAZ3JpZC5wdXQgeCwgeSwgeiwgbWVzaFxuICAgICAgICBAc2NlbmUuYWRkIG1lc2hcbiAgICAgICAgbWVzaC51cGRhdGVNYXRyaXgoKVxuICAgICAgICBtZXNoLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZVxuICAgICAgICByZXR1cm5cblxuICAgIGNyZWF0ZUNhbWVyYTogLT5cbiAgICAgICAgY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCBAd2lkdGggLyBAaGVpZ2h0LCAxLCAxMDAwMClcbiAgICAgICAgY2FtZXJhLmxvb2tBdCB2ZWMgMCwgMCwgMFxuICAgICAgICBjYW1lcmFcblxuICAgIGNyZWF0ZVJlbmRlcmVyOiAtPlxuICAgICAgICByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKGFudGlhbGlhczogdHJ1ZSlcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSBAd2lkdGgsIEBoZWlnaHRcbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvckhleCgweEJGRDFFNSwgMS4wKVxuICAgICAgICByZW5kZXJlci5jbGVhcigpXG4gICAgICAgICQoJyNjb250YWluZXInKS5hcHBlbmQocmVuZGVyZXIuZG9tRWxlbWVudClcbiAgICAgICAgcmVuZGVyZXJcblxuICAgIGFkZExpZ2h0czogKHNjZW5lKSAtPlxuICAgICAgICBhbWJpZW50TGlnaHQgPSBuZXcgQW1iaWVudExpZ2h0KDB4YWFhYWFhKVxuICAgICAgICBzY2VuZS5hZGQgYW1iaWVudExpZ2h0XG4gICAgICAgIGRpcmVjdGlvbmFsTGlnaHQgPSBuZXcgRGlyZWN0aW9uYWxMaWdodCgweGZmZmZmZiwgMSlcbiAgICAgICAgZGlyZWN0aW9uYWxMaWdodC5wb3NpdGlvbi5zZXQgMSwgMSwgMC41XG4gICAgICAgIGRpcmVjdGlvbmFsTGlnaHQucG9zaXRpb24ubm9ybWFsaXplKClcbiAgICAgICAgc2NlbmUuYWRkIGRpcmVjdGlvbmFsTGlnaHRcblxuICAgIGRlZmluZUNvbnRyb2xzOiAtPlxuICAgICAgICBiaW5kaXQgPSAoa2V5KSA9PlxuICAgICAgICAgICAgJChkb2N1bWVudCkuYmluZCAna2V5ZG93bicsIGtleSwgPT4gQGtleXNEb3duW2tleV0gPSB0cnVlXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5iaW5kICdrZXl1cCcsIGtleSwgPT4gQGtleXNEb3duW2tleV0gPSBmYWxzZVxuICAgICAgICBmb3Iga2V5IGluIFwid2FzZFwiLnNwbGl0KCcnKS5jb25jYXQoJ3NwYWNlJylcbiAgICAgICAgICAgIGJpbmRpdCBrZXlcbiAgICAgICAgJChkb2N1bWVudCkuYmluZCAna2V5ZG93bicsICdwJywgPT4gQHRvZ2dsZVBhdXNlKClcbiAgICAgICAgJChAY2FudmFzKS5tb3VzZWRvd24gKGUpID0+IEBvbk1vdXNlRG93biBlXG4gICAgICAgICQoQGNhbnZhcykubW91c2V1cCAoZSkgPT4gQG9uTW91c2VVcCBlXG4gICAgICAgICQoQGNhbnZhcykubW91c2Vtb3ZlIChlKSA9PiBAb25Nb3VzZU1vdmUgZVxuXG4gICAgdG9nZ2xlUGF1c2U6IC0+XG4gICAgICAgIEBwYXVzZSA9ICFAcGF1c2VcbiAgICAgICAgQGNsb2NrLnN0YXJ0KCkgaWYgQHBhdXNlIGlzIG9mZlxuICAgICAgICByZXR1cm5cblxuICAgIG9uTW91c2VVcDogKGV2ZW50KSAtPlxuICAgICAgICBpZiBub3QgQG1vdmVkIGFuZCBNb3VzZUV2ZW50LmlzTGVmdEJ1dHRvbiBldmVudFxuICAgICAgICAgICAgQHRvRGVsZXRlID0gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV1cbiAgICAgICAgQG1vdmVkID0gZmFsc2VcblxuICAgIG9uTW91c2VNb3ZlOiAoZXZlbnQpIC0+IEBtb3ZlZCA9IHRydWVcblxuICAgIG9uTW91c2VEb3duOiAoZXZlbnQpIC0+XG4gICAgICAgIEBtb3ZlZCA9IGZhbHNlXG4gICAgICAgIHJldHVybiB1bmxlc3MgTW91c2VFdmVudC5pc1JpZ2h0QnV0dG9uIGV2ZW50XG4gICAgICAgIEBjYXN0UmF5ID0gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV1cblxuICAgIGRlbGV0ZUJsb2NrOiAtPlxuICAgICAgICByZXR1cm4gdW5sZXNzIEB0b0RlbGV0ZT9cbiAgICAgICAgW3gsIHldID0gQHRvRGVsZXRlXG4gICAgICAgIHggPSAoeCAvIEB3aWR0aCkgKiAyIC0gMVxuICAgICAgICB5ID0gKC15IC8gQGhlaWdodCkgKiAyICsgMVxuICAgICAgICB2ZWN0b3IgPSB2ZWMgeCwgeSwgMVxuICAgICAgICBAcHJvamVjdG9yLnVucHJvamVjdFZlY3RvciB2ZWN0b3IsIEBjYW1lcmFcbiAgICAgICAgdG9kaXIgPSB2ZWN0b3Iuc3ViU2VsZihAY2FtZXJhLnBvc2l0aW9uKS5ub3JtYWxpemUoKVxuICAgICAgICBAZGVsZXRlQmxvY2tJbkdyaWQgbmV3IFJheSBAY2FtZXJhLnBvc2l0aW9uLCB0b2RpclxuICAgICAgICBAdG9EZWxldGUgPSBudWxsXG4gICAgICAgIHJldHVyblxuXG4gICAgZmluZEJsb2NrOiAocmF5KSAtPlxuICAgICAgICBmb3IgbyBpbiByYXkuaW50ZXJzZWN0U2NlbmUoQHNjZW5lKVxuICAgICAgICAgICAgcmV0dXJuIG8gdW5sZXNzIG8ub2JqZWN0Lm5hbWUgaXMgJ2Zsb29yJ1xuICAgICAgICByZXR1cm4gbnVsbFxuXG5cbiAgICBkZWxldGVCbG9ja0luR3JpZDogKHJheSkgLT5cbiAgICAgICAgdGFyZ2V0ID0gQGZpbmRCbG9jayByYXlcbiAgICAgICAgcmV0dXJuIHVubGVzcyB0YXJnZXQ/XG4gICAgICAgIHJldHVybiB1bmxlc3MgQHdpdGhpbkhhbmREaXN0YW5jZSB0YXJnZXQub2JqZWN0LnBvc2l0aW9uXG4gICAgICAgIG1lc2ggPSB0YXJnZXQub2JqZWN0XG4gICAgICAgIEBzY2VuZS5yZW1vdmUgbWVzaFxuICAgICAgICB7eCwgeSwgen0gPSBtZXNoLnBvc2l0aW9uXG4gICAgICAgIEBpbnRvR3JpZCB4LCB5LCB6LCBudWxsXG4gICAgICAgIHJldHVyblxuXG5cbiAgICBwbGFjZUJsb2NrOiAtPlxuICAgICAgICByZXR1cm4gdW5sZXNzIEBjYXN0UmF5P1xuICAgICAgICBbeCwgeV0gPSBAY2FzdFJheVxuICAgICAgICB4ID0gKHggLyBAd2lkdGgpICogMiAtIDFcbiAgICAgICAgeSA9ICgteSAvIEBoZWlnaHQpICogMiArIDFcbiAgICAgICAgdmVjdG9yID0gdmVjIHgsIHksIDFcbiAgICAgICAgQHByb2plY3Rvci51bnByb2plY3RWZWN0b3IgdmVjdG9yLCBAY2FtZXJhXG4gICAgICAgIHRvZGlyID0gdmVjdG9yLnN1YlNlbGYoQGNhbWVyYS5wb3NpdGlvbikubm9ybWFsaXplKClcbiAgICAgICAgQHBsYWNlQmxvY2tJbkdyaWQgbmV3IFJheSBAY2FtZXJhLnBvc2l0aW9uLCB0b2RpclxuICAgICAgICBAY2FzdFJheSA9IG51bGxcbiAgICAgICAgcmV0dXJuXG5cbiAgICBnZXRBZGphY2VudEN1YmVQb3NpdGlvbjogKHRhcmdldCkgLT5cbiAgICAgICAgbm9ybWFsID0gdGFyZ2V0LmZhY2Uubm9ybWFsLmNsb25lKClcbiAgICAgICAgcCA9IHRhcmdldC5vYmplY3QucG9zaXRpb24uY2xvbmUoKS5hZGRTZWxmIG5vcm1hbC5tdWx0aXBseVNjYWxhcihDdWJlU2l6ZSlcbiAgICAgICAgcmV0dXJuIHBcblxuICAgIGFkZEhhbGZDdWJlOiAocCkgLT5cbiAgICAgICAgcC55ICs9IEN1YmVTaXplIC8gMlxuICAgICAgICBwLnogKz0gQ3ViZVNpemUgLyAyXG4gICAgICAgIHAueCArPSBDdWJlU2l6ZSAvIDJcbiAgICAgICAgcmV0dXJuIHBcblxuICAgIGdldEN1YmVPbkZsb29yUG9zaXRpb246IChyYXkpIC0+XG4gICAgICAgIHJldHVybiBudWxsIGlmIHJheS5kaXJlY3Rpb24ueSA+PSAwXG4gICAgICAgIHJldCA9IHZlYygpXG4gICAgICAgIG8gPSByYXkub3JpZ2luXG4gICAgICAgIHYgPSByYXkuZGlyZWN0aW9uXG4gICAgICAgIHQgPSAoLW8ueSkgLyB2LnlcbiAgICAgICAgcmV0LnkgPSAwXG4gICAgICAgIHJldC54ID0gby54ICsgdCAqIHYueFxuICAgICAgICByZXQueiA9IG8ueiArIHQgKiB2LnpcbiAgICAgICAgcmV0dXJuIEBhZGRIYWxmQ3ViZSByZXRcblxuICAgIHNlbGVjdEN1YmVCbG9jazogKG5hbWUpIC0+XG4gICAgICAgIEBjdXJyZW50Q3ViZSA9IEBjdWJlQmxvY2tzW25hbWVdXG5cbiAgICBnZXROZXdDdWJlUG9zaXRpb246IChyYXkpIC0+XG4gICAgICAgIHRhcmdldCA9IEBmaW5kQmxvY2sgcmF5XG4gICAgICAgIHJldHVybiBAZ2V0Q3ViZU9uRmxvb3JQb3NpdGlvbiByYXkgdW5sZXNzIHRhcmdldD9cbiAgICAgICAgcmV0dXJuIEBnZXRBZGphY2VudEN1YmVQb3NpdGlvbiB0YXJnZXRcblxuICAgIGNyZWF0ZUN1YmVBdDogKHgsIHksIHopIC0+XG4gICAgICAgIEBjdWJlQXQgeCwgeSwgeiwgQGN1cnJlbnRDdWJlLCAoY3ViZSkgPT4gbm90IEBjb2xsaXNpb25IZWxwZXIuY29sbGlkZVdpdGhDdWJlIGN1YmVcblxuICAgIGhhbmRMZW5ndGg6IDdcblxuICAgIHdpdGhpbkhhbmREaXN0YW5jZTogKHBvcykgLT5cbiAgICAgICAgZGlzdCA9IHBvcy5kaXN0YW5jZVRvIEBwbGF5ZXIucG9zaXRpb24oKVxuICAgICAgICByZXR1cm4gZGlzdCA8PSBDdWJlU2l6ZSAqIEBoYW5kTGVuZ3RoXG5cbiAgICBwbGFjZUJsb2NrSW5HcmlkOiAocmF5KSAtPlxuICAgICAgICBwID0gQGdldE5ld0N1YmVQb3NpdGlvbiByYXlcbiAgICAgICAgcmV0dXJuIHVubGVzcyBwP1xuICAgICAgICBncmlkUG9zID0gQGdyaWRDb29yZHMgcC54LCBwLnksIHAuelxuICAgICAgICBbeCwgeSwgel0gPSBncmlkUG9zXG4gICAgICAgIHJldHVybiB1bmxlc3MgQHdpdGhpbkhhbmREaXN0YW5jZSBwXG4gICAgICAgIHJldHVybiB1bmxlc3MgQGdyaWQuaW5zaWRlR3JpZCB4LCB5LCB6XG4gICAgICAgIHJldHVybiBpZiBAZ3JpZC5nZXQoeCwgeSwgeik/XG4gICAgICAgIEBjcmVhdGVDdWJlQXQgeCwgeSwgelxuICAgICAgICByZXR1cm5cblxuXG4gICAgY29sbGlkZXM6IC0+IEBjb2xsaXNpb25IZWxwZXIuY29sbGlkZXMoKVxuXG4gICAgc3RhcnQ6IC0+XG4gICAgICAgIGFuaW1hdGUgPSA9PlxuICAgICAgICAgICAgQHRpY2soKSB1bmxlc3MgQHBhdXNlXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5pbWF0ZSwgQHJlbmRlcmVyLmRvbUVsZW1lbnRcbiAgICAgICAgYW5pbWF0ZSgpXG5cbiAgICBheGVzOiBbJ3gnLCAneScsICd6J11cbiAgICBpdGVyYXRpb25Db3VudDogMTBcblxuICAgIG1vdmVDdWJlOiAoc3BlZWRSYXRpbykgLT5cbiAgICAgICAgQGRlZmluZU1vdmUoKVxuICAgICAgICBpdGVyYXRpb25Db3VudCA9IE1hdGgucm91bmQoQGl0ZXJhdGlvbkNvdW50ICogc3BlZWRSYXRpbylcbiAgICAgICAgd2hpbGUgaXRlcmF0aW9uQ291bnQtLSA+IDBcbiAgICAgICAgICAgIEBhcHBseUdyYXZpdHkoKVxuICAgICAgICAgICAgZm9yIGF4aXMgaW4gQGF4ZXMgd2hlbiBAbW92ZVtheGlzXSBpc250IDBcbiAgICAgICAgICAgICAgICBvcmlnaW5hbHBvcyA9IEBwbGF5ZXIucG9zaXRpb24oYXhpcylcbiAgICAgICAgICAgICAgICBAcGxheWVyLmluY1Bvc2l0aW9uIGF4aXMsIEBtb3ZlW2F4aXNdXG4gICAgICAgICAgICAgICAgaWYgQGNvbGxpZGVzKClcbiAgICAgICAgICAgICAgICAgICAgQHBsYXllci5zZXRQb3NpdGlvbiBheGlzLCBvcmlnaW5hbHBvc1xuICAgICAgICAgICAgICAgICAgICBAb25Hcm91bmQgPSB0cnVlIGlmIGF4aXMgaXMgJ3knIGFuZCBAbW92ZS55IDwgMFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgYXhpcyBpcyAneScgYW5kIEBtb3ZlLnkgPD0gMFxuICAgICAgICAgICAgICAgICAgICBAb25Hcm91bmQgPSBmYWxzZVxuICAgICAgICByZXR1cm5cblxuXG4gICAgcGxheWVyS2V5czpcbiAgICAgICAgdzogJ3orJ1xuICAgICAgICBzOiAnei0nXG4gICAgICAgIGE6ICd4KydcbiAgICAgICAgZDogJ3gtJ1xuXG4gICAgc2hvdWxkSnVtcDogLT4gQGtleXNEb3duLnNwYWNlIGFuZCBAb25Hcm91bmRcblxuICAgIGRlZmluZU1vdmU6IC0+XG4gICAgICAgIGJhc2VWZWwgPSAuNFxuICAgICAgICBqdW1wU3BlZWQgPSAuOFxuICAgICAgICBAbW92ZS54ID0gMFxuICAgICAgICBAbW92ZS56ID0gMFxuICAgICAgICBmb3Iga2V5LCBhY3Rpb24gb2YgQHBsYXllcktleXNcbiAgICAgICAgICAgIFtheGlzLCBvcGVyYXRpb25dID0gYWN0aW9uXG4gICAgICAgICAgICB2ZWwgPSBpZiBvcGVyYXRpb24gaXMgJy0nIHRoZW4gLWJhc2VWZWwgZWxzZSBiYXNlVmVsXG4gICAgICAgICAgICBAbW92ZVtheGlzXSArPSB2ZWwgaWYgQGtleXNEb3duW2tleV1cbiAgICAgICAgaWYgQHNob3VsZEp1bXAoKVxuICAgICAgICAgICAgQG9uR3JvdW5kID0gZmFsc2VcbiAgICAgICAgICAgIEBtb3ZlLnkgPSBqdW1wU3BlZWRcbiAgICAgICAgQGdhcmFudGVlWFlOb3JtKClcbiAgICAgICAgQHByb2plY3RNb3ZlT25DYW1lcmEoKVxuICAgICAgICByZXR1cm5cblxuICAgIGdhcmFudGVlWFlOb3JtOiAtPlxuICAgICAgICBpZiBAbW92ZS54ICE9IDAgYW5kIEBtb3ZlLnogIT0gMFxuICAgICAgICAgICAgcmF0aW8gPSBNYXRoLmNvcyhNYXRoLlBJIC8gNClcbiAgICAgICAgICAgIEBtb3ZlLnggKj0gcmF0aW9cbiAgICAgICAgICAgIEBtb3ZlLnogKj0gcmF0aW9cbiAgICAgICAgcmV0dXJuXG5cbiAgICBwcm9qZWN0TW92ZU9uQ2FtZXJhOiAtPlxuICAgICAgICB7eCwgen0gPSBAY29udHJvbHMudmlld0RpcmVjdGlvbigpXG4gICAgICAgIGZyb250RGlyID0gbmV3IFZlY3RvcjIoeCwgeikubm9ybWFsaXplKClcbiAgICAgICAgcmlnaHREaXIgPSBuZXcgVmVjdG9yMihmcm9udERpci55LCAtZnJvbnREaXIueClcbiAgICAgICAgZnJvbnREaXIubXVsdGlwbHlTY2FsYXIgQG1vdmUuelxuICAgICAgICByaWdodERpci5tdWx0aXBseVNjYWxhciBAbW92ZS54XG4gICAgICAgIEBtb3ZlLnggPSBmcm9udERpci54ICsgcmlnaHREaXIueFxuICAgICAgICBAbW92ZS56ID0gZnJvbnREaXIueSArIHJpZ2h0RGlyLnlcblxuXG4gICAgYXBwbHlHcmF2aXR5OiAtPiBAbW92ZS55IC09IC4wMDUgdW5sZXNzIEBtb3ZlLnkgPCAtMVxuXG4gICAgc2V0Q2FtZXJhRXllczogLT5cbiAgICAgICAgcG9zID0gQHBsYXllci5leWVzUG9zaXRpb24oKVxuICAgICAgICBAY29udHJvbHMubW92ZSBwb3NcbiAgICAgICAgZXllc0RlbHRhID0gQGNvbnRyb2xzLnZpZXdEaXJlY3Rpb24oKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigyMClcbiAgICAgICAgZXllc0RlbHRhLnkgPSAwXG4gICAgICAgIHBvcy5zdWJTZWxmIGV5ZXNEZWx0YVxuICAgICAgICByZXR1cm5cblxuICAgIGlkZWFsU3BlZWQ6IDEgLyA2MFxuXG4gICAgdGljazogLT5cbiAgICAgICAgc3BlZWRSYXRpbyA9IEBjbG9jay5nZXREZWx0YSgpIC8gQGlkZWFsU3BlZWRcbiAgICAgICAgQHBsYWNlQmxvY2soKVxuICAgICAgICBAZGVsZXRlQmxvY2soKVxuICAgICAgICBAbW92ZUN1YmUgc3BlZWRSYXRpb1xuICAgICAgICBAcmVuZGVyZXIuY2xlYXIoKVxuICAgICAgICBAY29udHJvbHMudXBkYXRlKClcbiAgICAgICAgQHNldENhbWVyYUV5ZXMoKVxuICAgICAgICBAcmVuZGVyZXIucmVuZGVyIEBzY2VuZSwgQGNhbWVyYVxuICAgICAgICByZXR1cm5cblxuY2xhc3MgQmxvY2tTZWxlY3Rpb25cbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lKSAtPlxuICAgICAgICBAY3VycmVudCA9IFwiY29iYmxlc3RvbmVcIlxuXG4gICAgYmxvY2tJbWc6IChuYW1lKSAtPlxuICAgICAgICBcIjxpbWcgd2lkdGg9JzMyJyBoZWlnaHQ9JzMyJyBzcmM9Jy4vdGV4dHVyZXMvI3tuYW1lfWljb24ucG5nJyBpZD0nI3tuYW1lfScvPlwiXG5cbiAgICBtb3VzZWRvd246IChlKSAtPlxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgZS50YXJnZXQgPT0gQFxuICAgICAgICBAc2VsZWN0IGUudGFyZ2V0LmlkXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgbW91c2V3aGVlbDogKGRlbHRhKSAtPlxuICAgICAgICBkaWYgPSAoaWYgZGVsdGEgPj0gMCB0aGVuIDEgZWxzZSAtMSlcbiAgICAgICAgaW5kZXggPSAoQmxvY2tzLmluZGV4T2YoQGN1cnJlbnQpIC0gZGlmKS5tb2QoQmxvY2tzLmxlbmd0aClcbiAgICAgICAgQHNlbGVjdCBCbG9ja3NbaW5kZXhdXG5cbiAgICBsaWd0aFVwOiAodGFyZ2V0KSAtPiBAX3NldE9wYWNpdHkgdGFyZ2V0LCAwLjhcbiAgICBsaWdodE9mZjogICh0YXJnZXQpIC0+IEBfc2V0T3BhY2l0eSB0YXJnZXQsIDFcblxuICAgIHNlbGVjdDogKG5hbWUpIC0+XG4gICAgICAgIHJldHVybiBpZiBAY3VycmVudCBpcyBuYW1lXG4gICAgICAgIEBnYW1lLnNlbGVjdEN1YmVCbG9jayBuYW1lXG4gICAgICAgIEBsaWd0aFVwIG5hbWVcbiAgICAgICAgQGxpZ2h0T2ZmIEBjdXJyZW50XG4gICAgICAgIEBjdXJyZW50ID0gbmFtZVxuXG4gICAgX3NldE9wYWNpdHk6ICh0YXJnZXQsIHZhbCkgLT4gJChcIiNcIiArIHRhcmdldCkuY3NzKG9wYWNpdHk6IHZhbClcblxuICAgIGluc2VydDogLT5cbiAgICAgICAgYmxvY2tMaXN0ID0gKEBibG9ja0ltZyhiKSBmb3IgYiBpbiBCbG9ja3MpXG4gICAgICAgIGRvbUVsZW1lbnQgPSAkKFwiI2Jsb2Nrc1wiKVxuICAgICAgICBkb21FbGVtZW50LmFwcGVuZCBibG9ja0xpc3Quam9pbignJylcbiAgICAgICAgQGxpZ3RoVXAgQGN1cnJlbnRcbiAgICAgICAgZG9tRWxlbWVudC5tb3VzZWRvd24gKGUpID0+IEBtb3VzZWRvd24gZVxuICAgICAgICAkKGRvY3VtZW50KS5tb3VzZXdoZWVsIChlLCBkZWx0YSkgPT4gQG1vdXNld2hlZWwgZGVsdGFcbiAgICAgICAgZG9tRWxlbWVudC5zaG93KClcblxuY2xhc3MgSW5zdHJ1Y3Rpb25zXG4gICAgY29uc3RydWN0b3I6IChAY2FsbGJhY2spIC0+XG4gICAgICAgIEBkb21FbGVtZW50ID0gJCgnI2luc3RydWN0aW9ucycpXG5cbiAgICBpbnN0cnVjdGlvbnM6XG4gICAgICAgIGxlZnRjbGljazogXCJSZW1vdmUgYmxvY2tcIlxuICAgICAgICByaWdodGNsaWNrOiBcIkFkZCBibG9ja1wiXG4gICAgICAgIGRyYWc6IFwiRHJhZyB3aXRoIHRoZSBsZWZ0IG1vdXNlIGNsaWNrZWQgdG8gbW92ZSB0aGUgY2FtZXJhXCJcbiAgICAgICAgcGF1c2U6IFwiUGF1c2UvVW5wYXVzZVwiXG4gICAgICAgIHNwYWNlOiBcIkp1bXBcIlxuICAgICAgICB3YXNkOiBcIldBU0Qga2V5cyB0byBtb3ZlXCJcbiAgICAgICAgc2Nyb2xsOiBcIlNjcm9sbCB0byBjaGFuZ2Ugc2VsZWN0ZWQgYmxvY2tcIlxuXG4gICAgaW50cnVjdGlvbnNCb2R5OiAtPlxuICAgICAgICBAZG9tRWxlbWVudC5hcHBlbmQgXCI8ZGl2IGlkPSdpbnN0cnVjdGlvbnNDb250ZW50Jz5cbiAgICAgICAgPGgxPkNsaWNrIHRvIHN0YXJ0PC9oMT5cbiAgICAgICAgPHRhYmxlPiN7QGxpbmVzKCl9PC90YWJsZT5cbiAgICAgICAgPC9kaXY+XCJcbiAgICAgICAgJChcIiNpbnN0cnVjdGlvbnNDb250ZW50XCIpLm1vdXNlZG93biA9PlxuICAgICAgICAgICAgQGRvbUVsZW1lbnQuaGlkZSgpXG4gICAgICAgICAgICBAY2FsbGJhY2soKVxuICAgICAgICByZXR1cm5cblxuICAgIHJpYmJvbjogLT5cbiAgICAgICAgJzxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vdGhsb3JlbnovV2ViR0xDcmFmdFwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAgICA8aW1nIHN0eWxlPVwicG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3JkZXI6IDA7XCJcbiAgICAgICAgc3JjPVwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZ2l0aHViL3JpYmJvbnMvZm9ya21lX3JpZ2h0X2RhcmtibHVlXzEyMTYyMS5wbmdcIlxuICAgICAgICBhbHQ9XCJGb3JrIG1lIG9uIEdpdEh1YlwiPjwvYT4nXG5cbiAgICBpbnNlcnQ6IC0+XG4gICAgICAgIEBzZXRCb2RlcigpXG4gICAgICAgIEBpbnRydWN0aW9uc0JvZHkoKVxuICAgICAgICBtaW5lY3JhZnQgPSBcIjxhIGhyZWY9J2h0dHA6Ly93d3cubWluZWNyYWZ0Lm5ldC8nIHRhcmdldD0nX2JsYW5rJz5NaW5lY3JhZnQ8L2E+XCJcbiAgICAgICAgbGVnYWwgPSBcIjxkaXY+Tm90IGFmZmlsaWF0ZWQgd2l0aCBNb2phbmcuICN7bWluZWNyYWZ0fSBpcyBhIHRyYWRlbWFyayBvZiBNb2phbmc8L2Rpdj5cIlxuICAgICAgICBobmltYWdlID0gJzxpbWcgY2xhc3M9XCJhbGlnbm5vbmVcIiB0aXRsZT1cImhhY2tlciBuZXdzXCIgc3JjPVwiaHR0cDovLzEuZ3JhdmF0YXIuY29tL2JsYXZhdGFyLzk2Yzg0OWIwM2FlZmFmN2VmOWQzMDE1ODc1NGYwMDE5P3M9MjBcIiBhbHQ9XCJcIiB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIiAvPidcbiAgICAgICAgaG5saW5rID0gXCI8ZGl2PkNvbW1lbnQgb24gICN7aG5pbWFnZX0gPGEgaHJlZj0naHR0cDovL25ld3MueWNvbWJpbmF0b3IuY29tL2l0ZW0/aWQ9MzM3NjYyMCcgIHRhcmdldD0nX2JsYW5rJz5IYWNrZXIgTmV3czwvYT48L2Rpdj5cIlxuICAgICAgICBicm93c2VyaWZpZWQgPSBcIjxkaXY+PHA+PHNwYW4gc3R5bGU9J2ZvbnRXZWlnaHQ6IGJvbGQnPk5vdGU6PC9zcGFuPiBUaGlzIGlzIHRoZSBicm93c2VyaWZpZWQgdmVyc2lvbiB3aXRoIHByZXNlcnZlZCBzb3VyY2VtYXBzLjwvcD48cD5DbGljayBBbHQtQ21kLUogdG8gZGVidWcgdGhlIG9yaWdpbmFsIENvZmZlZVNjcmlwdC48L3A+PHA+KG5lZWRzIHNvdXJjZW1hcHMgZW5hYmxlZCBpbiB5b3VyIGJyb3dzZXIpPC9wPjwvZGl2PlwiXG4gICAgICAgIEBkb21FbGVtZW50LmFwcGVuZCBsZWdhbCArIGhubGluayArIGJyb3dzZXJpZmllZCArIEByaWJib24oKVxuICAgICAgICBAZG9tRWxlbWVudC5zaG93KClcblxuICAgIGxpbmVzOiAtPlxuICAgICAgICByZXQgPSAoQGxpbmUoaW5zdCkgZm9yIGluc3Qgb2YgQGluc3RydWN0aW9ucylcbiAgICAgICAgcmV0LmpvaW4oJyAnKVxuXG4gICAgbGluZTogKG5hbWUpIC0+XG4gICAgICAgIGluc3QgPSBAaW5zdHJ1Y3Rpb25zW25hbWVdXG4gICAgICAgIFwiPHRyPjx0ZCBjbGFzcz0naW1hZ2UnPiN7QGltZyhuYW1lKX08L3RkPlxuICAgICAgICA8dGQgY2xhc3M9J2xhYmVsJz4je2luc3R9PC90ZD48L3RyPlwiXG5cbiAgICBzZXRCb2RlcjogLT5cbiAgICAgICAgZm9yIHByZWZpeCBpbiBbJy13ZWJraXQtJywgJy1tb3otJywgJy1vLScsICctbXMtJywgJyddXG4gICAgICAgICAgICBAZG9tRWxlbWVudC5jc3MgcHJlZml4ICsgJ2JvcmRlci1yYWRpdXMnLCAnMTBweCdcbiAgICAgICAgcmV0dXJuXG5cbiAgICBpbWc6IChuYW1lKSAtPiBcIjxpbWcgc3JjPScuL2luc3RydWN0aW9ucy8je25hbWV9LnBuZycvPlwiXG5cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gLT5cbiAgICBjb25zb2xlLmxvZyAnaW5pdGlhbGl6aW5nIG1pbmVjcmFmdCdcbiAgICAkKFwiI2Jsb2Nrc1wiKS5oaWRlKClcbiAgICAkKCcjaW5zdHJ1Y3Rpb25zJykuaGlkZSgpXG4gICAgJChkb2N1bWVudCkuYmluZCBcImNvbnRleHRtZW51XCIsIC0+IGZhbHNlXG4gICAgcmV0dXJuIERldGVjdG9yLmFkZEdldFdlYkdMTWVzc2FnZSgpIHVubGVzcyBEZXRlY3Rvci53ZWJnbFxuICAgIHN0YXJ0R2FtZSA9IC0+XG4gICAgICAgIGdhbWUgPSBuZXcgR2FtZSgpXG4gICAgICAgIG5ldyBCbG9ja1NlbGVjdGlvbihnYW1lKS5pbnNlcnQoKVxuICAgICAgICBnYW1lLnN0YXJ0KClcbiAgICBuZXcgSW5zdHJ1Y3Rpb25zKHN0YXJ0R2FtZSkuaW5zZXJ0KClcbiIsIkNvbGxpc2lvblV0aWxzID1cbiAgICAjIFRoZSB0d28gaW50ZXJ2YWxzIGFyZSBbczEsIGYxXSBhbmQgW3MyLCBmMl1cbiAgICB0ZXN0SW50ZXJ2YWxDb2xsaXNpb246IChzMSwgZjEsIHMyLCBmMikgLT4gIShzMiA+IGYxIHx8IHMxID4gZjIpXG5cbiAgICAjQ3ViZXMgYXJlIG9iamVjdHMgd2l0aCB2bWF4LCB2bWluICh0aGUgdmVydGljZXMgd2l0aCBncmVhdGVzdC9zbWFsbGVzdCB2YWx1ZXMpXG4gICAgI3Byb3BlcnRpZXMuIEFzc3VtZXMgdW5yb3RhdGVkIGN1YmVzLlxuICAgIHRlc3RDdWJlQ29sbGlzaW9uOiAoY3ViZTEsIGN1YmUyKSAtPlxuICAgICAgICBmY29sID0gQ29sbGlzaW9uVXRpbHMudGVzdEludGVydmFsQ29sbGlzaW9uXG4gICAgICAgIGZvciBheGlzIGluIFsneCcsICd5JywgJ3onXVxuICAgICAgICAgICAgY29sbGlkZXMgPSBmY29sIGN1YmUxLnZtaW5bYXhpc10sIGN1YmUxLnZtYXhbYXhpc11cbiAgICAgICAgICAgICwgY3ViZTIudm1pbltheGlzXSwgY3ViZTIudm1heFtheGlzXVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyBjb2xsaWRlc1xuICAgICAgICByZXR1cm4gdHJ1ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvblV0aWxzXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xuVEhSRUUgPSByZXF1aXJlICd0aHJlZSdcbnsgYXNzb2MgfSA9IHJlcXVpcmUgJy4vY29yZUV4dGVuc2lvbnMuY29mZmVlJ1xuXG5Nb3VzZUV2ZW50ID1cbiAgICBpc0xlZnRCdXR0b246IChldmVudCkgLT4gZXZlbnQud2hpY2ggPT0gMVxuICAgIGlzUmlnaHRCdXR0b246IChldmVudCkgLT4gZXZlbnQud2hpY2ggPT0gM1xuXG4gICAgaXNMZWZ0QnV0dG9uRG93bjogKGV2ZW50KSAtPiBldmVudC5idXR0b24gPT0gMCBhbmQgQGlzTGVmdEJ1dHRvbiBldmVudFxuXG5jbGFzcyBDb250cm9sc1xuICAgIGNvbnN0cnVjdG9yOiAob2JqZWN0LCBkb21FbGVtZW50KSAtPlxuICAgICAgICBAb2JqZWN0ID0gb2JqZWN0XG4gICAgICAgIEB0YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMyAwLCAwLCAwXG4gICAgICAgIEBkb21FbGVtZW50ID0gZG9tRWxlbWVudCBvciBkb2N1bWVudFxuICAgICAgICBAbG9va1NwZWVkID0gMC4yMFxuICAgICAgICBAbW91c2VYID0gMFxuICAgICAgICBAbW91c2VZID0gMFxuICAgICAgICBAbGF0ID0gMFxuICAgICAgICBAbG9uID0gMFxuICAgICAgICBAbW91c2VEcmFnT24gPSBmYWxzZVxuICAgICAgICBAYW5jaG9yeCA9IG51bGxcbiAgICAgICAgQGFuY2hvcnkgPSBudWxsXG4gICAgICAgIEBkZWZpbmVCaW5kaW5ncygpXG5cbiAgICBkZWZpbmVCaW5kaW5nczogLT5cbiAgICAgICAgJChAZG9tRWxlbWVudCkubW91c2Vtb3ZlIChlKSA9PiBAb25Nb3VzZU1vdmUgZVxuICAgICAgICAkKEBkb21FbGVtZW50KS5tb3VzZWRvd24gKGUpID0+IEBvbk1vdXNlRG93biBlXG4gICAgICAgICQoQGRvbUVsZW1lbnQpLm1vdXNldXAgKGUpID0+IEBvbk1vdXNlVXAgZVxuICAgICAgICAkKEBkb21FbGVtZW50KS5tb3VzZWVudGVyIChlKSA9PiBAb25Nb3VzZXJFbnRlciBlXG5cbiAgICBvbk1vdXNlckVudGVyOiAoZXZlbnQpIC0+XG4gICAgICAgIEBvbk1vdXNlVXAoZXZlbnQpIHVubGVzcyBNb3VzZUV2ZW50LmlzTGVmdEJ1dHRvbkRvd24gZXZlbnRcblxuICAgIG9uTW91c2VEb3duOiAoZXZlbnQpIC0+XG4gICAgICAgIHJldHVybiB1bmxlc3MgTW91c2VFdmVudC5pc0xlZnRCdXR0b24gZXZlbnRcbiAgICAgICAgQGRvbUVsZW1lbnQuZm9jdXMoKSBpZiBAZG9tRWxlbWVudCBpc250IGRvY3VtZW50XG4gICAgICAgIEBhbmNob3J4ID0gZXZlbnQucGFnZVhcbiAgICAgICAgQGFuY2hvcnkgPSBldmVudC5wYWdlWVxuICAgICAgICBAc2V0TW91c2UgZXZlbnRcbiAgICAgICAgQG1vdXNlRHJhZ09uID0gdHJ1ZVxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIG9uTW91c2VVcDogKGV2ZW50KSAtPlxuICAgICAgICBAbW91c2VEcmFnT24gPSBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIHNldE1vdXNlOiAoZXZlbnQpIC0+XG4gICAgICAgIEBtb3VzZVggPSBldmVudC5wYWdlWFxuICAgICAgICBAbW91c2VZID0gZXZlbnQucGFnZVlcblxuICAgIG9uTW91c2VNb3ZlOiAoZXZlbnQpIC0+XG4gICAgICAgIHJldHVybiB1bmxlc3MgQG1vdXNlRHJhZ09uXG4gICAgICAgIEBzZXRNb3VzZSBldmVudFxuICAgICAgICByZXR1cm5cblxuICAgIGhhbGZDaXJjbGU6ICBNYXRoLlBJIC8gMTgwXG5cbiAgICB2aWV3RGlyZWN0aW9uOiAtPiBAdGFyZ2V0LmNsb25lKCkuc3ViU2VsZihAb2JqZWN0LnBvc2l0aW9uKVxuXG4gICAgbW92ZTogKG5ld1Bvc2l0aW9uKSAtPlxuICAgICAgICBAb2JqZWN0LnBvc2l0aW9uID0gbmV3UG9zaXRpb25cbiAgICAgICAgQHVwZGF0ZUxvb2soKVxuXG4gICAgdXBkYXRlTG9vazogLT5cbiAgICAgICAge3NpbiwgY29zfSA9IE1hdGhcbiAgICAgICAgcGhpID0gKDkwIC0gQGxhdCkgKiBAaGFsZkNpcmNsZVxuICAgICAgICB0aGV0YSA9IEBsb24gKiBAaGFsZkNpcmNsZVxuICAgICAgICBwID0gQG9iamVjdC5wb3NpdGlvblxuICAgICAgICBhc3NvYyBAdGFyZ2V0LFxuICAgICAgICAgICAgeDogcC54ICsgMTAwICogc2luKHBoaSkgKiBjb3ModGhldGEpXG4gICAgICAgICAgICB5OiBwLnkgKyAxMDAgKiBjb3MocGhpKVxuICAgICAgICAgICAgejogcC56ICsgMTAwICogc2luKHBoaSkgKiBzaW4odGhldGEpXG4gICAgICAgIEBvYmplY3QubG9va0F0IEB0YXJnZXRcbiAgICAgICAgcmV0dXJuXG5cbiAgICB1cGRhdGU6IC0+XG4gICAgICAgIHJldHVybiB1bmxlc3MgQG1vdXNlRHJhZ09uXG4gICAgICAgIHJldHVybiBpZiBAbW91c2VYIGlzIEBhbmNob3J4IGFuZCBAbW91c2VZIGlzIEBhbmNob3J5XG4gICAgICAgIHttYXgsIG1pbn0gPSBNYXRoXG4gICAgICAgIEBsb24gKz0gKEBtb3VzZVggLSBAYW5jaG9yeCkgKiBAbG9va1NwZWVkXG4gICAgICAgIEBsYXQgLT0gKEBtb3VzZVkgLSBAYW5jaG9yeSkgKiBAbG9va1NwZWVkXG4gICAgICAgIEBhbmNob3J4ID0gQG1vdXNlWFxuICAgICAgICBAYW5jaG9yeSA9IEBtb3VzZVlcbiAgICAgICAgQGxhdCA9IG1heCgtODUsIG1pbig4NSwgQGxhdCkpXG4gICAgICAgIEB1cGRhdGVMb29rKClcbiAgICAgICAgcmV0dXJuXG5cbiN3aW5kb3cuTW91c2VFdmVudCA9IE1vdXNlRXZlbnRcbiN3aW5kb3cuQ29udHJvbHMgPSBDb250cm9sc1xuXG5leHBvcnRzLk1vdXNlRXZlbnQgPSBNb3VzZUV2ZW50XG5leHBvcnRzLkNvbnRyb2xzID0gQ29udHJvbHNcbiIsInsgcGF0Y2ggfSA9IHJlcXVpcmUgJy4vbGliL3JiY29mZmVlLmNvZmZlZSdcblxucGF0Y2ggTnVtYmVyLFxuICAgIG1vZDogKGFyZykgLT5cbiAgICAgICAgcmV0dXJuIEAgJSBhcmcgaWYgQCA+PSAwXG4gICAgICAgIHJldHVybiAoQCArIGFyZykgJSBhcmdcblxuICAgIGRpdjogKGFyZykgLT4gcmV0dXJuIE1hdGguZmxvb3IoQCAvIGFyZylcblxuXG4gICAgdGltZXM6IChmbikgLT5cbiAgICAgICAgaSA9IDBcbiAgICAgICAgd2hpbGUgaSA8IEBcbiAgICAgICAgICAgIGZuKGkrKylcblxuICAgIHRvUmFkaWFuczogLT4gKEAgKiBNYXRoLlBJKSAvIDE4MFxuXG4gICAgdG9EZWdyZWVzOiAtPiAgKEAgKiAxODApIC8gTWF0aC5QSVxuXG5cbmV4cG9ydHMuYXNzb2MgPSAobywgaSkgLT5cbiAgICAob1trXSA9IHYpIGZvciBrLCB2IG9mIGlcbiAgICByZXR1cm4gb1xuIiwiIyBSdWJ5aXNtcyBpbiBjb2ZmZXNjcmlwdFxucHV0cyA9IGV4cG9ydHMucHV0cyA9IChhcmdzLi4uKSAtPlxuICAgIHJldHVybiB1bmxlc3MgQFtcImNvbnNvbGVcIl1cbiAgICBmb3IgYXJnIGluIGFyZ3NcbiAgICAgICAgY29uc29sZS5sb2coYXJnKVxuICAgIHJldHVyblxucmFpc2UgPSBleHBvcnRzLnJhaXNlID0gKG1lc3NhZ2UpIC0+IHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuYWJzdHJhY3RfbWV0aG9kID0gZXhwb3J0cy5hYnN0cmFjdF9tZXRob2QgPSAtPiByYWlzZSBcIlN1YmNsYXNzIHJlc3BvbnNhYmlsaXR5XCJcbmFic3RyYWN0X3Byb3BlcnR5ID0gZXhwb3J0cy5hYnN0cmFjdF9wcm9wZXJ0eSA9IC0+IHJhaXNlIFwiQWJzdHJhY3QgcHJvcGVydHlcIlxuXG4jIFJldHVybnMgYSBzaGFsb3cgY2xvbmUgb2YgYW4gb2JqZWN0XG5jbG9uZSA9IGV4cG9ydHMuY2xvbmUgPSAob2JqKSAtPlxuICAgIHJldHVybiBvYmogdW5sZXNzIG9iaj9cbiAgICByZXQgPSB7fVxuICAgIGZvciBrLCB2IG9mIG9ialxuICAgICAgICByZXRba10gPSB2XG4gICAgcmV0dXJuIHJldFxuXG5cbmVxID0gZXhwb3J0cy5lcSA9ICh4LCB5KSAtPiByZXR1cm4gYHggPT0geWBcblxuIyBEZWZpbmUgYSBtZXRob2QgY2FsbGVkIG1ldGhvZE5hbWUsIHdpdGggYm9keSBmdW5jIG9uIHRoZSBjbGFzcyBnaXZlblxuZGVmaW5lID0gZXhwb3J0cy5kZWZpbmUgPSAoY2xhcywgbWV0aG9kTmFtZSwgZnVuYykgLT4gY2xhcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jXG5cbiMgRGVmaW5lIGFsbCBtZXRob2RzIG9uIHRoZSBjbGFzIGZvciBlYWNoIGssIHYgaW4gb2JqXG5wYXRjaCA9IGV4cG9ydHMucGF0Y2ggPSAoY2xhcywgbWl4ZWQpIC0+XG4gICAgKGRlZmluZSBjbGFzLCBuYW1lLCBtZXRob2QpIGZvciBuYW1lLCBtZXRob2Qgb2YgbWl4ZWRcbiAgICByZXR1cm5cblxuXG5pc0Fic3RyYWN0ID0gZXhwb3J0cy5pc0Fic3RyYWN0ID0gKG0pIC0+IG0gPT0gYWJzdHJhY3RfbWV0aG9kIG9yIG0gPT0gYWJzdHJhY3RfcHJvcGVydHlcblxuI2FkZHMgYWxsIGF0cmlidXRlcyBvZiBtaXhlZCBpbnRvIGNsYXMuIEZvciBhY3R1YWwgY2xhc3NlcywgaXQgaXMgdGhlIG1peGluIHNlbWFudGljc1xuI1dpbGwgbm90IG92ZXJyaWRlIGV4aXN0aW5nIG1ldGhvZCB3aXRoIGFic3RyYWN0IG1ldGhvZHMgb2YgdGhlIG1peHhlZCBjbGFzcy5cbm1peGluV2l0aCA9IGV4cG9ydHMubWl4aW5XaXRoID0gKGNsYXMsIG1peGVkKSAtPlxuICAgIGZvciBuYW1lLCBtIG9mIG1peGVkXG4gICAgICAgIHVubGVzcyBpc0Fic3RyYWN0KG0pIG9yXG4gICAgICAgIChjbGFzLnByb3RvdHlwZVtuYW1lXT8gYW5kIG5vdCBpc0Fic3RyYWN0KGNsYXMucHJvdG90eXBlW25hbWVdKSlcbiAgICAgICAgICAgIGRlZmluZSBjbGFzLCBuYW1lLCBtXG4gICAgcmV0dXJuXG5cbiMgTGlrZSBtaXhpbldpdGgsIGJ1dCBhY2NlcHRzIG1hbnkgdHJhaXRzLlxubWl4aW4gPSBleHBvcnRzLm1peGluID0gKGNsYXMsIHRyYWl0cy4uLikgLT5cbiAgICBmb3IgdHJhaXQgaW4gdHJhaXRzXG4gICAgICAgIG1peGluV2l0aCBjbGFzLCB0cmFpdFxuICAgIHJldHVyblxuXG4jIHJldHVybiB0aGUgaW5zdGFuY2UgbWV0aG9kcyBvZiBhIGNsYXNzLlxubWV0aG9kcyA9IGV4cG9ydHMubWV0aG9kcyA9IChjbGFzKSAtPlxuICAgIHJldCA9IChjIGZvciBjIG9mIGNsYXMucHJvdG90eXBlKVxuICAgIHJldHVybiByZXQgdW5sZXNzIGNsYXMuX19zdXBlcl9fXG4gICAgcmV0LmNvbmNhdCBtZXRob2RzIGNsYXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yXG5cbiMgcmV0dXJuIHRoZSBpbnN0YW5jZSBtZXRob2RzIG9mIGEgY2xhc3MuIE9ubHkgY29tcHV0ZSBpZiBmdW5jIG9mIHRoZSBzdXBlcmNsYXNzIGlzIHRydWUuXG5tZXRob2RzV2hpbGUgPSBleHBvcnRzLm1ldGhvZHNXaGlsZSA9IChjbGFzLCBmdW5jKSAtPlxuICAgIHJldHVybiBbXSB1bmxlc3MgZnVuYyhjbGFzKVxuICAgIHJldCA9IChjIGZvciBjIG9mIGNsYXMucHJvdG90eXBlKVxuICAgIHJldHVybiByZXQgdW5sZXNzIGNsYXMuX19zdXBlcl9fXG4gICAgcmV0LmNvbmNhdCBtZXRob2RzV2hpbGUgY2xhcy5fX3N1cGVyX18uY29uc3RydWN0b3IsIGZ1bmNcblxuIyByZXR1cm4gdGhlIGluc3RhbmNlIG1ldGhvZHMgb2YgYSBjbGFzcyBvZiBhbiBpbnN0YW5jZVxubWV0aG9kc09mSW5zdGFuY2UgPSBleHBvcnRzLm1ldGhvZHNPZkluc3RhbmNlID0gKGluc3RhbmNlKSAtPiBtZXRob2RzIGluc3RhbmNlLmNvbnN0cnVjdG9yXG5cbiMgTGlrZSBtZXRob2RzVW50aWwsIGJ1dCB3b3JrcyBvbiBhbiBpbnN0YW5jZVxubWV0aG9kc09mSW5zdGFuY2VXaGlsZSA9IGV4cG9ydHMubWV0aG9kc09mSW5zdGFuY2VXaGlsZSA9IChpbnN0YW5jZSwgZnVuYykgLT4gbWV0aG9kc1doaWxlIGluc3RhbmNlLmNvbnN0cnVjdG9yLCBmdW5jXG4iXX0=
;